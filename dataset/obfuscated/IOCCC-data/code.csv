1984/anonymous/anonymous.c,1984/decot/decot.c,1984/laman/laman.c,1984/mullender/mullender.c,1985/applin/applin.c,1985/august/august.c,1985/lycklama/lycklama.c,1985/shapiro/shapiro.c,1985/sicherman/sicherman.c,1986/applin/applin.c,1986/august/august.c,1986/bright/bright.c,1986/hague/hague.c,1986/holloway/holloway.c,1986/marshall/marshall.c,1986/pawka/pawka.c,1986/stein/stein.c,1986/wall/wall.c,1987/biggar/biggar.c,1987/heckbert/heckbert.c,1987/hines/hines.c,1987/korn/korn.c,1987/lievaart/lievaart.c,1987/lievaart/lievaart2.c,1987/wall/wall.c,1987/westley/westley.c,1988/applin/applin.c,1988/dale/dale.c,1988/isaak/isaak.ansi.c,1988/isaak/isaak.c,1988/litmaath/litmaath.c,1988/phillipps/phillipps.c,1988/reddy/reddy.c,1988/robison/robison.c,1988/spinellis/spinellis.c,1988/westley/westley.c,1988/westley/westley.fix.c,1988/zsmall/zsmall.c,1989/fubar/fubar.c,1989/fubar/fubar.orig.c,1989/jar/jar.1.c,1989/jar/jar.1.orig.c,1989/jar/jar.2.c,1989/ovdluhe/ovdluhe.c,1989/paul/paul.c,1989/robison/robison.c,1989/roemer/roemer.c,1989/tromp/tromp.bsd.c,1989/tromp/tromp.s5.c,1989/vanb/vanb.c,1989/westley/westley.c,1990/baruch/baruch.c,1990/cmills/cmills.c,1990/dds/dds.c,1990/dg/dg.c,1990/jaw/jaw.c,1990/pjr/pjr.c,1990/scjones/scjones.c,1990/stig/stig.c,1990/tbr/tbr.c,1990/theorem/theorem.c,1990/westley/westley.c,1991/ant/ant.c,1991/brnstnd/brnstnd.c,1991/brnstnd_ansi/brnstnd_ansi.c,1991/buzzard/buzzard.c,1991/cdupont/cdupont.c,1991/cdupont_ansi/cdupont_ansi.c,1991/davidguy/davidguy.c,1991/davidguy/davidguy.fix.c,1991/davidguy/davidguy.orig.c,1991/dds/dds.ansi.c,1991/dds/dds.c,1991/fine/fine.c,1991/rince/rince.c,1991/rince/rince.orig.c,1991/rince_ansi/rince_ansi.c,1991/westley/westley.c,1992/adrian/adrian.c,1992/adrian/adrian.orig.c,1992/albert/albert.c,1992/albert/albert.fix.c,1992/albert/albert.orig.c,1992/ant/ant.c,1992/buzzard/buzzard.1.c,1992/buzzard/buzzard.2.c,1992/buzzard/buzzard.2.orig.c,1992/gson/gson.c,1992/imc/imc.c,1992/imc/imc.orig.c,1992/kivinen/kivinen.c,1992/kivinen/kivinen.orig.c,1992/lush/lush.c,1992/lush/lush.orig.c,1992/marangon/marangon.c,1992/marangon/marangon.orig.c,1992/mkentry/mkentry.c,1992/nathan/nathan.c,1992/vern/vern.c,1992/vern/vern.orig.c,1992/westley/westley.c,1993/ant/ant.c,1993/cmills/cmills.c,1993/dgibson/dgibson.c,1993/ejb/ejb.c,1993/jonth/jonth.c,1993/leo/leo.c,1993/lmfjyh/lmfjyh.c,1993/mkentry/mkentry.c,1993/plummer/plummer.c,1993/rince/rince.c,1993/schnitzi/schnitzi.c,1993/vanb/vanb.c,1994/dodsond1/dodsond1.c,1994/dodsond2/dodsond2.c,1994/gtface/gtface.c,1994/horton/horton.alt.c,1994/horton/horton.c,1994/imc/imc.c,1994/ldb/ldb.c,1994/mkentry/mkentry.c,1994/schnitzi/schnitzi.c,1994/shapiro/shapiro.c,1994/smr/smr.c,1994/tvr/tvr.alt.c,1994/tvr/tvr.c,1994/weisberg/weisberg.c,1994/westley/westley.c,1995/cdua/cdua.c,1995/dodsond1/dodsond1.c,1995/dodsond2/dodsond2.c,1995/esde/esde.c,1995/garry/garry.c,1995/garry/garry.fmt.c,1995/heathbar/heathbar.c,1995/leo/leo.c,1995/leo/leo.orig.c,1995/makarios/makarios.c,1995/mkentry/mkentry.c,1995/savastio/savastio.c,1995/schnitzi/schnitzi.c,1995/spinellis/spinellis.c,1995/vanschnitz/vanschnitz.c,1996/august/august.c,1996/august/august.orig.c,1996/dalbec/dalbec.c,1996/eldby/eldby.c,1996/gandalf/gandalf.c,1996/huffman/huffman.c,1996/hunni/hunni.c,1996/jonth/jonth.c,1996/mkentry/mkentry.c,1996/rcm/rcm.c,1996/schweikh1/schweikh1.c,1996/schweikh2/schweikh2.c,1996/schweikh3/schweikh3.c,1996/westley/westley.c,1998/banks/banks.c,1998/banks/banks.orig.c,1998/bas1/bas1.c,1998/bas2/bas2.c,1998/chaos/chaos.c,1998/df/df.c,1998/dlowe/dlowe.c,1998/dlowe/dlowe.orig.c,1998/dloweneil/dloweneil.c,1998/dorssel/dorssel.c,1998/fanf/fanf.c,1998/mkentry/mkentry.c,1998/schnitzi/schnitzi.c,1998/schweikh1/schweikh1.c,1998/schweikh1/schweikh1.orig.c,1998/schweikh2/schweikh2.c,1998/schweikh2/schweikh2.orig.c,1998/schweikh3/schweikh3.c,1998/tomtorfs/tomtorfs.c,2000/anderson/anderson.c,2000/bellard/bellard.c,2000/bmeyer/bmeyer.c,2000/briddlebane/briddlebane.c,2000/briddlebane/briddlebane.orig.c,2000/dhyang/dhyang.c,2000/dlowe/dlowe.c,2000/dmy2jd/dmy2jd.c,2000/jarijyrki/jarijyrki.c,2000/mkentry/mkentry.c,2000/natori/natori.c,2000/primenum/primenum.c,2000/rince/rince.c,2000/robison/robison.c,2000/schneiderwent/schneiderwent.c,2000/schneiderwent/schneiderwent.orig.c,2000/thadgavin/thadgavin.c,2000/thadgavin/thadgavin.orig.c,2000/tomx/tomx.c,2001/anonymous/anonymous.c,2001/anonymous/anonymous.ten.c,2001/bellard/bellard.c,2001/bellard/bellard.otccex.c,2001/cheong/cheong.c,2001/coupard/coupard.c,2001/ctk/ctk.c,2001/dgbeards/dgbeards.c,2001/herrmann1/herrmann1.c,2001/herrmann2/herrmann2.c,2001/jason/jason.c,2001/kev/kev.c,2001/mkentry/mkentry.c,2001/ollinger/ollinger.c,2001/rosten/rosten.c,2001/schweikh/schweikh.c,2001/westley/westley.c,2001/westley/westley.orig.c,2001/williams/williams.c,2004/anonymous/anonymous.c,2004/arachnid/arachnid.c,2004/arachnid/arachnid.orig.c,2004/burley/burley.c,2004/burley/burley.orig.c,2004/gavare/gavare.c,2004/gavin/gavin.c,2004/hoyle/hoyle.c,2004/hoyle/hoyle.orig.c,2004/jdalbec/jdalbec.c,2004/kopczynski/kopczynski.c,2004/kopczynski/kopczynski.orig.c,2004/mkentry/mkentry.c,2004/newbern/newbern.c,2004/newbern/newbern.orig.c,2004/omoikane/omoikane.c,2004/schnitzi/schnitzi.c,2004/sds/sds.c,2004/vik1/vik1.c,2004/vik2/vik2.c,2005/aidan/aidan.c,2005/anon/anon.c,2005/boutines/boutines.c,2005/boutines/boutines.orig.c,2005/chia/chia.c,2005/giljade/giljade.c,2005/jetro/jetro.c,2005/klausler/klausler.c,2005/klausler/klausler.orig.c,2005/mikeash/mikeash.c,2005/mynx/mynx.c,2005/persano/persano.c,2005/sykes/sykes.c,2005/sykes/sykes.orig.c,2005/timwi/timwi.c,2005/toledo/toledo.c,2005/toledo/toledo2.c,2005/toledo/toledo3.c,2005/vik/vik.c,2005/vince/vince.c,2005/vince/vince.improved.c,2006/birken/birken.c,2006/borsanyi/borsanyi.c,2006/grothe/grothe.c,2006/hamre/hamre.c,2006/meyer/meyer.c,2006/monge/monge.c,2006/monge/monge_orig.c,2006/night/night.c,2006/sloane/sloane.c,2006/stewart/stewart.c,2006/sykes1/sykes1.c,2006/sykes2/sykes2.c,2006/toledo1/toledo1.c,2006/toledo2/toledo2.c,2006/toledo3/layer.c,2006/toledo3/toledo3-sbar.c,2006/toledo3/toledo3-txt.c,2006/toledo3/toledo3.c,2011/akari/akari.c,2011/blakely/blakely.c,2011/borsanyi/borsanyi.c,2011/dlowe/dlowe.c,2011/eastman/eastman.c,2011/fredriksson/fredriksson.c,2011/goren/goren.c,2011/hamaji/hamaji.c,2011/hou/hou.c,2011/konno/konno.c,2011/richards/richards.c,2011/toledo/layer.c,2011/toledo/toledo.c,2011/vik/vik.c,2011/zucker/zucker.c,2012/blakely/blakely.c,2012/deckmyn/deckmyn.c,2012/dlowe/dlowe.c,2012/endoh1/endoh1.c,2012/endoh1/endoh1_color.c,2012/endoh1/endoh1_deobfuscate.c,2012/endoh2/endoh2.c,2012/grothe/grothe.c,2012/grothe/grothe.orig.c,2012/hamano/hamano.c,2012/hamano/hamano.orig.c,2012/hou/hou.c,2012/kang/kang.c,2012/kang/kang.orig.c,2012/konno/konno.c,2012/konno/konno.orig.c,2012/konno/konno_deobfuscate.c,2012/omoikane/nyaruko.c,2012/tromp/tromp.c,2012/tromp/tromp.orig.c,2012/vik/vik.c,2012/zeitak/incorrect.c,2012/zeitak/zeitak.c,2012/zeitak/zeitak.orig.c,2012/zeitak/zeitak_deobfucate.c,2013/birken/birken.c,2013/cable1/cable1.c,2013/cable2/cable2.c,2013/cable3/cable3.c,2013/dlowe/dlowe.c,2013/endoh1/endoh1.c,2013/endoh2/endoh2.c,2013/endoh3/endoh3.c,2013/endoh4/endoh4.c,2013/hou/hou.c,2013/mills/mills.c,2013/misaka/misaka.c,2013/morgan1/morgan1.c,2013/morgan2/morgan2.c,2013/robison/robison.c,2014/birken/prog.c,2014/deak/prog.c,2014/endoh1/prog.c,2014/endoh2/prog.c,2014/maffiodo1/prog.c,2014/maffiodo1/prog.orig.c,2014/maffiodo2/prog.c,2014/morgan/prog.c,2014/sinon/prog.c,2014/skeggs/prog.c,2014/skeggs/prog.orig.c,2014/vik/prog.c,2014/wiedijk/prog.c,2015/burton/prog.c,2015/burton/prog.orig.c,2015/burton/rule2.c,2015/dogon/prog.c,2015/duble/prog.c,2015/duble/prog.orig.c,2015/endoh1/prog.c,2015/endoh2/prog.c,2015/endoh3/ioccc.c,2015/endoh3/mullender.c,2015/endoh3/prog.c,2015/endoh4/prog.c,2015/endoh4/prog.orig.c,2015/hou/prog.c,2015/howe/makeholes.c,2015/howe/prog.c,2015/howe/prog.orig.c,2015/mills1/prog.c,2015/mills2/prog.c,2015/muth/prog.c,2015/schweikhardt/prog.c,2015/yang/prog.c,2018/algmyr/prog.c,2018/algmyr/prog.orig.c,2018/anderson/prog.c,2018/anderson/prog.orig.c,2018/bellard/prog.c,2018/bellard/prog.orig.c,2018/burton1/prog.c,2018/burton1/prog.nowarn.c,2018/burton2/fixed_iocccsize.c,2018/burton2/iocccbug01.c,2018/burton2/iocccbug02.c,2018/burton2/iocccbug03.c,2018/burton2/iocccbug04.c,2018/burton2/iocccbug05.c,2018/burton2/iocccbug06.c,2018/burton2/prog.c,2018/burton2/tac.c,2018/burton2/test01.c,2018/burton2/test02.c,2018/burton2/test03.c,2018/burton2/test04.c,2018/burton2/test05.c,2018/burton2/test06.c,2018/burton2/test07.c,2018/burton2/test08.c,2018/burton2/test09.c,2018/burton2/test10.c,2018/burton2/test11.c,2018/burton2/test12.c,2018/burton2/test13.c,2018/burton2/test14.c,2018/ciura/prog.c,2018/ciura/prog.orig.c,2018/endoh1/prog.c,2018/endoh1/prog.orig.c,2018/endoh2/prog.c,2018/ferguson/prog-simple.c,2018/ferguson/prog.c,2018/ferguson/prog.orig.c,2018/giles/prog.c,2018/hou/prog.c,2018/hou/prog.orig.c,2018/mills/prog.c,2018/poikola/prog-doc.c,2018/poikola/prog.c,2018/poikola/prog.orig.c,2018/vokes/prog.c,2018/yang/prog.c,2019/adamovsky/iocccsize_2018.c,2019/adamovsky/prog.c,2019/adamovsky/progSpoiler.c,2019/burton/prog.c,2019/burton/prog.clean.c,2019/ciura/prog.c,2019/ciura/prog.orig.c,2019/diels-grabsch1/prog.c,2019/diels-grabsch2/prog.c,2019/dogon/apholife.c,2019/dogon/prog.c,2019/duble/prog.c,2019/duble/prog.orig.c,2019/endoh/prog.c,2019/giles/prog.c,2019/karns/prog.c,2019/karns/prog.orig.c,2019/lynn/prog.c,2019/mills/prog.c,2019/poikola/prog.c,2019/yang/prog.c,2019/yang/violet.c,2020/burton/prog.c,2020/carlini/prog.c,2020/endoh1/prog.c,2020/endoh1/prog.orig.c,2020/endoh2/prog.c,2020/endoh3/prog.alt.c,2020/endoh3/prog.c,2020/ferguson1/prog.2.c,2020/ferguson1/prog.3-j.c,2020/ferguson1/prog.3.c,2020/ferguson1/prog.alt.c,2020/ferguson1/prog.c,2020/ferguson1/termcaps.c,2020/ferguson2/prog.c,2020/ferguson2/recode.c,2020/giles/prog.c,2020/kurdyukov1/prog.c,2020/kurdyukov1/prog.extra.c,2020/kurdyukov1/prog.orig.c,2020/kurdyukov2/prog.c,2020/kurdyukov2/prog.png.c,2020/kurdyukov2/prog.ppm.c,2020/kurdyukov3/prog.c,2020/kurdyukov3/prog.extra.c,2020/kurdyukov3/prog.orig.c,2020/kurdyukov4/prog.c,2020/kurdyukov4/rand.c,2020/otterness/prog.c,2020/tsoj/prog.c,2020/yang/prog.c
"int i;main(){for(;i[""]<i;++i){--i;}""];read('-'-'-',i+++""hell\
o, world!\n"",'/'/'/'));}read(j,i,p){write(j/p+p,i---j,i/i);}
","#define x =
#define double(a,b) int
#define char k['a']
#define union static struct

extern int floor;
double (x1, y1) b,
char x {sizeof(
    double(%s,%D)(*)())
,};
struct tag{int x0,*xO;}

*main(i, dup, signal) {
{
  for(signal=0;*k *x * __FILE__ *i;) do {
   (printf(&*""'\"",x);	/*\n\\"", (*((double(tag,u)(*)())&floor))(i)));
	goto _0;

_O: while (!(char <<x - dup)) {	/*/*\*/
	union tag u x{4};
  }
}


while(b x 3, i); {
char x b,i;
  _0:if(b&&k+
  sin(signal)		/ *    ((main) (b)-> xO));/*}
  ;
}

*/}}}
","a[900];		b;c;d=1		;e=1;f;		g;h;O;		main(k,
l)char*		*l;{g=		atoi(*		++l);		for(k=
0;k*k<		g;b=k		++>>1)		;for(h=		0;h*h<=
g;++h);		--h;c=(		(h+=g>h		*(h+1))		-1)>>1;
while(d		<=g){		++O;for		(f=0;f<		O&&d<=g
;++f)a[		b<<5|c]		=d++,b+=	e;for(		f=0;f<O
&&d<=g;		++f)a[b		<<5|c]=		d++,c+=		e;e= -e
;}for(c		=0;c<h;		++c){		for(b=0		;b<k;++
b){if(b		<k/2)a[		b<<5|c]		^=a[(k		-(b+1))
<<5|c]^=	a[b<<5		|c]^=a[		(k-(b+1		))<<5|c]
;printf(	a[b<<5|c	]?""%-4d""	:""    ""		,a[b<<5
|c]);}		putchar(	'\n');}}	/*Mike		Laman*/
","short main[] = {
	277, 04735, -4129, 25, 0, 477, 1019, 0xbef, 0, 12800,
	-113, 21119, 0x52d7, -1006, -7151, 0, 0x4bc, 020004,
	14880, 10541, 2056, 04010, 4548, 3044, -6716, 0x9,
	4407, 6, 5568, 1, -30460, 0, 0x9, 5570, 512, -30419,
	0x7e82, 0760, 6, 0, 4, 02400, 15, 0, 4, 1280, 4, 0,
	4, 0, 0, 0, 0x8, 0, 4, 0, ',', 0, 12, 0, 4, 0, '#',
	0, 020, 0, 4, 0, 30, 0, 026, 0, 0x6176, 120, 25712,
	'p', 072163, 'r', 29303, 29801, 'e'
};
","main(v,c)char**c;{for(v[c++]=""Hello, world!\n)"";(!!c)[*c]&&(v--||--c&&execlp(*c,*c,c[!!c]+!!c,!c));**c=!c)write(!!*c,*c,!!**c);}
","#define p struct c
#define q struct b
#define h a->a
#define i a->b
#define e i->c
#define o a=(*b->a)(b->b,b->c)
#define s return a;}q*
#define n (d,b)p*b;{q*a;p*c;
#define z(t)(t*)malloc(sizeof(t))
q{int a;p{q*(*a)();int b;p*c;}*b;};q*u n a=z(q);h=d;i=z(p);i->a=u;i->b=d+1;s
v n c=b;do o,b=i;while(!(h%d));i=c;i->a=v;i->b=d;e=b;s
w n o;c=i;i=b;i->a=w;e=z(p);e->a=v;e->b=h;e->c=c;s
t n for(;;)o,main(-h),b=i;}main(b){p*a;if(b>0)a=z(p),h=w,a->c=z(p),a->c->a=u,
a->c->b=2,t(0,a);putchar(b?main(b/2),-b%2+'0':10);}
","#define o define
#o ___o write
#o ooo (unsigned)
#o o_o_ 1
#o _o_ char
#o _oo goto
#o _oo_ read
#o o_o for
#o o_ main
#o o__ if
#o oo_ 0
#o _o(_,__,___)(void)___o(_,__,ooo(___))
#o __o (o_o_<<((o_o_<<(o_o_<<o_o_))+(o_o_<<o_o_)))+(o_o_<<(o_o_<<(o_o_<<o_o_)))
o_(){_o_ _=oo_,__,___,____[__o];_oo ______;_____:___=__o-o_o_; _______:
_o(o_o_,____,__=(_-o_o_<___?_-o_o_:___));o_o(;__;_o(o_o_,""\b"",o_o_),__--);
_o(o_o_,"" "",o_o_);o__(--___)_oo _______;_o(o_o_,""\n"",o_o_);______:o__(_=_oo_(
oo_,____,__o))_oo _____;}
","#define P(X)j=write(1,X,1)
#define C 39
int M[5000]={2},*u=M,N[5000],R=22,a[4],l[]={0,-1,C-1,-1},m[]={1,-C,-1,C},*b=N,
*d=N,c,e,f,g,i,j,k,s;main(){for(M[i=C*R-1]=24;f|d>=b;){c=M[g=i];i=e;for(s=f=0;
s<4;s++)if((k=m[s]+g)>=0&&k<C*R&&l[s]!=k%C&&(!M[k]||!j&&c>=16!=M[k]>=16))a[f++
]=s;if(f){f=M[e=m[s=a[rand()/(1+2147483647/f)]]+g];j=j<f?f:j;f+=c&-16*!j;M[g]=
c|1<<s;M[*d++=e]=f|1<<(s+2)%4;}else e=d>b++?b[-1]:e;}P("" "");for(s=C;--s;P(""_"")
)P("" "");for(;P(""\n""),R--;P(""|""))for(e=C;e--;P(""_ ""+(*u++/8)%2))P(""| ""+(*u/4)%2
);}
","#define C_C_(_)~' '&_
#define _C_C(_)('\b'b'\b'>=C_C>'\t'b'\n')
#define C_C _|_
#define b *
#define C /b/
#define V _C_C(
main(C,V)
char **V;
/*	C program. (If you don't
 *	understand it look it
 */	up.) (In the C Manual)
{
	char _,__; 
	while (read(0,&__,1) & write((_=(_=C_C_(__),C)),
	_C_,1)) _=C-V+subr(&V);
}
subr(C)
char *C;
{
	C=""Lint says ""argument Manual isn't used.""  What's that
	mean?""; while (write((read(C_C('""'-'/*""'/*""*/))?__:__-_+
	'\b'b'\b'|((_-52)%('\b'b'\b'+C_C_('\t'b'\n'))+1),1),&_,1));
}
","cat =13 /*/ >/dev/null 2>&1; echo ""Hello, world!""; exit
*
*  This program works under cc, f77, and /bin/sh.
*
*/; main() {
      write(
cat-~-cat
     /*,'(
*/
     ,""Hello, world!""
     ,
cat); putchar(~-~-~-cat); } /*
     ,)')
      end
*/
","typedef struct n{int a:3,
b:29;struct n*c;}t;t*
f();r(){}m(u)t*u;{t*w,*z;
z=u->c,q(z),u->b=z->b*10,
w=u->c=f(),w->a=1,w->c=z->
c;}t*k;g(u)t*u;{t*z,*v,*p,
*x;z=u->c,q(z),u->b=z->b,v
=z->c,z->a=2,x=z->c=f(),x
->a=3,x->b=2,p=x->c=f(),p
->c=f(),p->c->a=1,p->c->c=
v;}int i;h(u)t*u;{t*z,*v,*
w;int c,e;z=u->c,v=z->c,q(
v),c=u->b,e=v->b,u->b=z->b
,z->a=3,z->b=c+1,e+9>=c&&(
q(z),e=z->b,u->b+=e/c,w=f(
),w->b=e%c,w->c=z->c,u->c=
w);}int(*y[4])()={r,m,g,h};
char *sbrk();main(){t*e,*p,*o;
o=f(),o->c=o,o->b=1,e=f(),
e->a=2,p=e->c=f(),p->b=2,
p->c=o,q(e),e=e->c,(void)write
(1,""2."",2);for(;;e=e->c){q(e),
e->b=write(1,&e->b[""0123456789""],
1);}}t*f(){return i||(i=1000,
k=(t*)sbrk(i*sizeof(t))),k+--i;
}q(p)t*p;{(*y[p->a])(p);}
","#include <stdio.h>
#define O1O printf
#define OlO putchar
#define O10 exit
#define Ol0 strlen
#define QLQ fopen
#define OlQ fgetc
#define O1Q abs
#define QO0 for
typedef char lOL;

lOL*QI[] = {""Use:\012\011dump file\012"",""Unable to open file '\x25s'\012"",
 ""\012"",""   "",""""};

main(I,Il)
lOL*Il[];
{	FILE *L;
	unsigned lO;
	int Q,OL[' '^'0'],llO = EOF,

	O=1,l=0,lll=O+O+O+l,OQ=056;
	lOL*llL=""%2x "";
	(I != 1<<1&&(O1O(QI[0]),O10(1011-1010))),
	((L = QLQ(Il[O],""r""))==0&&(O1O(QI[O],Il[O]),O10(O)));
	lO = I-(O<<l<<O);
	while (L-l,1)
	{	QO0(Q = 0L;((Q &~(0x10-O))== l);
			OL[Q++] = OlQ(L));
		if (OL[0]==llO) break;
		O1O(""\0454x: "",lO);
		if (I == (1<<1))
		{	QO0(Q=Ol0(QI[O<<O<<1]);Q<Ol0(QI[0]);
			Q++)O1O((OL[Q]!=llO)?llL:QI[lll],OL[Q]);/*""
			O10(QI[1O])*/
			O1O(QI[lll]);{}
		}
		QO0 (Q=0L;Q<1<<1<<1<<1<<1;Q+=Q<0100)
		{	(OL[Q]!=llO)? /* 0010 10lOQ 000LQL */
			((D(OL[Q])==0&&(*(OL+O1Q(Q-l))=OQ)),
			OlO(OL[Q])):
			OlO(1<<(1<<1<<1)<<1);
		}
		O1O(QI[01^10^9]);
		lO+=Q+0+l;}
	}
	D(l) { return l>=' '&&l<='\~';
}
","#define	DIT	(
#define	DAH	)
#define	__DAH	++
#define DITDAH	*
#define	DAHDIT	for
#define	DIT_DAH	malloc
#define DAH_DIT	gets
#define	_DAHDIT	char
_DAHDIT _DAH_[]=""ETIANMSURWDKGOHVFaLaPJBXCYZQb54a3d2f16g7c8a90l?e'b.s;i,d:""
;main			DIT			DAH{_DAHDIT
DITDAH			_DIT,DITDAH		DAH_,DITDAH DIT_,
DITDAH			_DIT_,DITDAH		DIT_DAH DIT
DAH,DITDAH		DAH_DIT DIT		DAH;DAHDIT
DIT _DIT=DIT_DAH	DIT 81			DAH,DIT_=_DIT
__DAH;_DIT==DAH_DIT	DIT _DIT		DAH;__DIT
DIT'\n'DAH DAH		DAHDIT DIT		DAH_=_DIT;DITDAH
DAH_;__DIT		DIT			DITDAH
_DIT_?_DAH DIT		DITDAH			DIT_ DAH:'?'DAH,__DIT
DIT' 'DAH,DAH_ __DAH	DAH DAHDIT		DIT
DITDAH			DIT_=2,_DIT_=_DAH_;	DITDAH _DIT_&&DIT
DITDAH _DIT_!=DIT	DITDAH DAH_>='a'?	DITDAH
DAH_&223:DITDAH		DAH_ DAH DAH;		DIT
DITDAH			DIT_ DAH __DAH,_DIT_	__DAH DAH
DITDAH DIT_+=		DIT DITDAH _DIT_>='a'?	DITDAH _DIT_-'a':0
DAH;}_DAH DIT DIT_	DAH{			__DIT DIT
DIT_>3?_DAH		DIT			 DIT_>>1 DAH:'\0'DAH;return
DIT_&1?'-':'.';}__DIT DIT			DIT_ DAH _DAHDIT
DIT_;{DIT void DAH write DIT			1,&DIT_,1 DAH;}
","#include ""stdio.h""
#define	e 3
#define	g (e/e)
#define	h ((g+e)/2)
#define	f (e-g-h)
#define	j (e*e-g)
#define k (j-h)
#define	l(x) tab2[x]/h
#define	m(n,a) ((n&(a))==(a))

long tab1[]={ 989L,5L,26L,0L,88319L,123L,0L,9367L };
int tab2[]={ 4,6,10,14,22,26,34,38,46,58,62,74,82,86 };

main(m1,s) char *s; {
    int a,b,c,d,o[k],n=(int)s;
    if(m1==1){ char b[2*j+f-g]; main(l(h+e)+h+e,b); printf(b); }
    else switch(m1-=h){
	case f:
	    a=(b=(c=(d=g)<<g)<<g)<<g;
	    return(m(n,a|c)|m(n,b)|m(n,a|d)|m(n,c|d));
	case h:
	    for(a=f;a<j;++a)if(tab1[a]&&!(tab1[a]%((long)l(n))))return(a);
	case g:
	    if(n<h)return(g);
	    if(n<j){n-=g;c='D';o[f]=h;o[g]=f;}
	    else{c='\r'-'\b';n-=j-g;o[f]=o[g]=g;}
	    if((b=n)>=e)for(b=g<<g;b<n;++b)o[b]=o[b-h]+o[b-g]+c;
	    return(o[b-g]%n+k-h);
	default:
	    if(m1-=e) main(m1-g+e+h,s+g); else *(s+g)=f;
	    for(*s=a=f;a<e;) *s=(*s<<e)|main(h+a++,(char *)m1);
	}
}
","                                                   extern int
                                                       errno
                                                         ;char
                                                            grrr
                             ;main(                           r,
  argv, argc )            int    argc                           ,
   r        ;           char *argv[];{int                     P( );
#define x  int i,       j,cc[4];printf(""      choo choo\n""     ) ;
x  ;if    (P(  !        i              )        |  cc[  !      j ]
&  P(j    )>2  ?        j              :        i  ){*  argv[i++ +!-i]
;              for    (i=              0;;    i++                   );
_exit(argv[argc- 2    / cc[1*argc]|-1<<4 ]    ) ;printf(""%d"",P(""""));}}
  P  (    a  )   char a   ;  {    a  ;   while(    a  >      ""  B   ""
  /* -    by E            ricM    arsh             all-      */);    }
","#include ""stdio.h""
#define xyxx char
#define xyyxx putchar
#define xyyyxx while
#define xxyyyx int
#define xxxyyx main
#define xyxyxy if
#define xyyxyy '\n'
xyxx *xyx [] = {
""]I^x[I]k\\I^o[IZ~\\IZ~[I^|[I^l[I^j[I^}[I^n[I]m\\I]h"",
""]IZx\\IZx[IZk\\IZk[IZo_IZ~\\IZ~[IZ|_IZl_IZj\\IZj]IZ}]IZn_IZm\\IZm_IZh"",
""]IZx\\IZx[I^k[I\\o]IZ~\\IZ~\\I]|[IZl_I^j]IZ}]I^n[IZm\\IZm_IZh"",
""]IZx\\IZx[IZk\\IZk[IZo_IZ~\\IZ~_IZ|[IZl_IZj\\IZj]IZ}]IZn_IZm\\IZm]IZh"",
""]I^x[I]k\\IZo_I^~[I^|[I^l[IZj\\IZj]IZ}]I^n[I]m^IZh"",'\0'};/*xyyxyxyxxxyxxxyy*/
xyxx *xyyx; xxyyyx xyyyx,xyyyyx,xyyyyyx=0x59,xyyyyyyx=0x29,/*yxxyxyyyxxyyyxyy*/
xxyx=0x68;xxxyyx(){xyyyyx=0;xyyyxx(xyx[xyyyyx]){xyyx=xyx[xyyyyx++];/*xyyyxxyx*/
xyyyxx(*xyyx){xyyyx= *xyyx++-xyyyyyx;xyyyxx(xyyyx--)xyyxx(*xyyx-xyyyyyyx);/*x*/
xyxyxy(*xyyx==xxyx)xyyxx(xyyxyy);*xyyx++;}}}/*xyxyxyyyyxxyxxxyyyxyyyxyxxyyy*/
","typedef char*z;O;o;_=33303285;main(b,Z)z Z;{b=(b>=0||(main(b+1,Z+1),*Z=O%(o=(_%
25))+'0',O/=o,_/=25))&&(b<1||(O=time(&b)%0250600,main(~5,*(z*)Z),write(1,*(z*)Z
,9)));}
","#define _c(C)_ (C)&('|'+3):c_()(C)>>('\n'-3) __; /**/
#define C char*
#define keyboard "",,B3-u;.(&*5., /(b*(1\036!a%\031m,,,,,\r\n""
#define main(o,oo)oo(o){
#define _ ;case
C
#define c_(cc)c cc=
#define C_(sand)_O(sand)witch
o=keyboard;
#define __ ;break;
C
ccc(
cc)
C
cc;
{
C
cccc=
cc;int
#ifndef lint
#define keyboard ""dijs QH.soav Vdtnsaoh DmfpaksoQz;kkt oa, -dijs""
#endif
c;
main(;c_(=(*cc);*cc++)c,for);
#define _O(s)s
main(0xb+(c>>5),C_(s))
_'\v'
:__ _'\f':
main(c,C_(s));
_c(8098)_c(6055)_c(14779)_c(10682)
#define O_(O)_O(O)stem(ccc(
_c(15276)_c(11196)_c(15150)
#define _C ;return
_c(11070)_c(15663)_c(11583)
}
__
default
:c_(+)o[c&__LINE__-007];
main(c_(-)'-'-1,C_(s))_
0214
:_
0216
:c_(+)025 _
0207
:c_(-)4 _
0233
:c_(+)' '-1;
}}c_(&)'z'+5;
}_C cccc;
}main(,cc)
C
#define O write(1,
c=""O"";
O_(sy) keyboard));
main(;;,for);
read(0,
c,1);*
c_(&)'~'+1
;O ccc(
c),
'\0');
main(*c,
C_(s));_
4
:O_(sy)"";kkt -oa, dijszdijs QQ""))_C
_
13
:O o+' ',
3
)
#undef main
__ _ 127:O""\b \b"",3)__
default
:O
c,1)
__}}}main(){
cc();
}
","P;
","#include <ctype.h>
#include <stdio.h>
#define _ define
#_ A putchar
#_ B return
#_ C index
char*r,c[300001],*d="">=<=!===||&&->++-->><<"",*i,*l,*j,*m,*k,*n,*h,*y;e,u=1,v,w,
f=1,p,s,x;main(a,b)char**b;{p=a>1?atoi(b[1]):79;r=c+read(0,j=l=i=c,300000);v=g(
j,&m);for(k=m;v!=2;j=k,m=n,v=w,k=m){w=g(k,&n);if(v==1&&m-j==1&&*j==35)e&&A(10),
e=f=0;if(!f&&v==3&&(char*)C(j,10)<m)A(10),e=0,f=1;else if(v>2&&(u||w)&&(f||u)&&
(l-i>1||*i!=61||n-k>1||!C(""-*&"",*k)))continue;else if(v==3)if(f&&e+1+n-k>p&&e)A
(10),e=0;else A(32),e++;else{if(f&&e+m-j>p&&e)A(10),e=0;e+=m-j;k=j;while(k<m)A(
*k++);}i=j;l=m;u=v;}e&&A(10);}g(j,m)char*j,**m;{if(j>=r)B*m=j,2;s=isdigit(*j)||
*j==46&&isdigit(j[1]);for(h=j;h<r;h++)if(!isalnum(*h)&&*h!=95&&(!s||*h!=46)&&(!
s||h[-1]!=101&&h[-1]!=69||!C(""+-"",*h)))break;if(h>j)B*m=h,0;x=1;for(h=j;h<r&&C(
"" \t\n"",*h);h++);if(h>j)h--,x=3;if(*j==34||*j==39)for(h=j+1;h<r&&*h!=*j;h++)if(
*h==92)h++;for(y=d;*y&&strncmp(y,j,2);y+=2);if(*y)h=j+1;if(!strncmp(""/*"",j,2)){
h=j+2;while(*++h!=42||*++h!=47);x=4;}*m=h+1;B x;}
","#include <stdio.h>
#include <malloc.h>
main(togo,toog)
int togo;
char *toog[];
{char *ogto,   tgoo[80];FILE  *ogot;  int    oogt=0, ootg,  otog=79,
ottg=1;if (    togo==  ottg)   goto   gogo;  goto    goog;  ggot:
if (   fgets(  tgoo,   otog,   ogot)) goto   gtgo;   goto   gott;
gtot:  exit(); ogtg: ++oogt;   goto   ogoo;  togg:   if (   ootg > 0)
goto   oggt;   goto    ggot;   ogog:  if (  !ogot)   goto   gogo;
goto   ggto;   gtto:   printf( ""%d    goto   \'s\n"", oogt); goto
gtot;  oggt:   if (   !memcmp( ogto, ""goto"", 4))     goto   otgg;
goto   gooo;   gogo:   exit(   ottg); tggo:  ootg=   strlen(tgoo);
goto   tgog;   oogo: --ootg;   goto   togg;  gooo: ++ogto;  goto
oogo;  gott:   fclose( ogot);  goto   gtto;  otgg:   ogto=  ogto +3;
goto   ogtg;   tgog:   ootg-=4;goto   togg;  gtgo:   ogto=  tgoo;
goto   tggo;   ogoo:   ootg-=3;goto   gooo;  goog:   ogot=  fopen(
toog[  ottg],  ""r"");   goto    ogog;  ggto:  ogto=   tgoo;  goto
ggot;}
","	main() { printf(&unix[""\021%six\012\0""],(unix)[""have""]+""fun""-0x60);}
","#define D define
#D Y return
#D R for
#D e while
#D I printf
#D l int
#D C y=v+111;H(x,v)*y++= *x
#D H(a,b)R(a=b+11;a<b+89;a++)
#D s(a)t=scanf(""%d"",&a)
l V[1100],u,r[]={-1,-11,-10,-9,1,11,10,9},h[]={11,18,81,88},ih[]={22,27,72,77},
bz,lv=60,*x,*y,m,t;S(d,v,f,a,b)l*v;{l c=0,*n=v+100,bw=d<u-1?a:-9000,w,z,i,zb,q=
3-f;if(d>u){R(w=i=0;i<4;i++)w+=(m=v[h[i]])==f?300:m==q?-300:(t=v[ih[i]])==f?-50
:t==q?50:0;return w;}H(z,0){if(GZ(v,z,f,100)){c++;w= -S(d+1,n,q,-b,-bw);if(w>bw
){zb=z;bw=w;if(w>=b||w>=8003)Y w;}}}if(!c){bz=0;C;Y-S(d+1,n,q,-b,-bw);}bz=zb;Y
d>=u-1?bw+(c<<3):bw;}main(){R(;t<1100;t+=100)R(m=0;m<100;m++)V[t+m]=m<11||m>88
||(m+1)%10<2?3:0;V[44]=V[55]=1;V[45]=V[54]=2;I(""Level:"");s(u);e(lv>0){do{I(""Yo\
u:"");s(m);}e(!GZ(V,m,2,0)&&m!=99);if(m!=99)lv--;if(lv<15&&u<10)u+=2;I(""Wait\n"")
;I(""Value:%d\n"",S(0,V,1,-9000,9000));I(""move: %d\n"",(lv-=GZ(V,bz,1,0),bz));}}GZ
(v,z,f,o)l*v;{l*j,q=3-f,g=0,i,h,*k=v+z;if(*k==0)R(i=7;i>=0;i--){j=k+(h=r[i]);e(
*j==q)j+=h;if(*j==f&&j-h!=k){if(!g){g=1;C;}e(j!=k)*((j-=h)+o)=f;}}Y g;}
","#define D define
#D Y return
#D R for
#D e while
#D I printf
#D l int
#D W if
#D C y=v+111;H(x,v)*y++= *x
#D H(a,b)R(a=b+11;a<b+89;a++)
#D s(a)t=scanf(""%d"",&a)
#D U Z I
#D Z I(""123\
45678\n"");H(x,V){putchar("".XO""[*x]);W((x-V)%10==8){x+=2;I(""%d\n"",(x-V)/10-1);}}
l V[1600],u,r[]={-1,-11,-10,-9,1,11,10,9},h[]={11,18,81,88},ih[]={22,27,72,77},
bz,lv=60,*x,*y,m,t;S(d,v,f,_,a,b)l*v;{l c=0,*n=v+100,j=d<u-1?a:-9000,w,z,i,g,q=
3-f;W(d>u){R(w=i=0;i<4;i++)w+=(m=v[h[i]])==f?300:m==q?-300:(t=v[ih[i]])==f?-50:
t==q?50:0;Y w;}H(z,0){W(E(v,z,f,100)){c++;w= -S(d+1,n,q,0,-b,-j);W(w>j){g=bz=z;
j=w;W(w>=b||w>=8003)Y w;}}}W(!c){g=0;W(_){H(x,v)c+= *x==f?1:*x==3-f?-1:0;Y c>0?
8000+c:c-8000;}C;j= -S(d+1,n,q,1,-b,-j);}bz=g;Y d>=u-1?j+(c<<3):j;}main(){R(;t<
1600;t+=100)R(m=0;m<100;m++)V[t+m]=m<11||m>88||(m+1)%10<2?3:0;I(""Level:"");V[44]
=V[55]=1;V[45]=V[54]=2;s(u);e(lv>0){Z do{I(""You:"");s(m);}e(!E(V,m,2,0)&&m!=99);
W(m!=99)lv--;W(lv<15&&u<10)u+=2;U(""Wait\n"");I(""Value:%d\n"",S(0,V,1,0,-9000,9000
));I(""move: %d\n"",(lv-=E(V,bz,1,0),bz));}}E(v,z,f,o)l*v;{l*j,q=3-f,g=0,i,w,*k=v
+z;W(*k==0)R(i=7;i>=0;i--){j=k+(w=r[i]);e(*j==q)j+=w;W(*j==f&&j-w!=k){W(!g){g=1
;C;}e(j!=k)*((j-=w)+o)=f;}}Y g;}
","#define iv 4 
#define v ;(void
#define XI(xi)int xi[iv*'V'];
#define L(c,l,i)c(){d(l);m(i);}
#include <stdio.h>
int*cc,c,i,ix='\t',exit(),X='\n'*'\d';XI(VI)XI(xi)extern(*vi[])(),(*
signal())();char*V,cm,D['x'],M='\n',I,*gets();L(MV,V,(c+='d',ix))m(x){v)
signal(X/'I',vi[x]);}d(x)char*x;{v)write(i,x,i);}L(MC,V,M+I)xv(){c>=i?m(
c/M/M+M):(d(&M),m(cm));}L(mi,V+cm,M)L(md,V,M)MM(){c=c*M%X;V-=cm;m(ix);}
LXX(){gets(D)||(vi[iv])();c=atoi(D);while(c>=X){c-=X;d(""m"");}V=""ivxlcdm""
+iv;m(ix);}LV(){c-=c;while((i=cc[*D=getchar()])>-I)i?(c?(c<i&&l(-c-c,
""%d""),l(i,""+%d"")):l(i,""(%d"")):(c&&l(M,"")""),l(*D,""%c"")),c=i;c&&l(X,"")""),l
(-i,""%c"");m(iv-!(i&I));}L(ml,V,'\f')li(){m(cm+!isatty(i=I));}ii(){m(c=cm
= ++I)v)pipe(VI);cc=xi+cm++;for(V=""jWYmDEnX"";*V;V++)xi[*V^' ']=c,xi[*V++]
=c,c*=M,xi[*V^' ']=xi[*V]=c>>I;cc[-I]-=ix v)close(*VI);cc[M]-=M;}main(){
(*vi)();for(;v)write(VI[I],V,M));}l(xl,lx)char*lx;{v)printf(lx,xl)v)
fflush(stdout);}L(xx,V+I,(c-=X/cm,ix))int(*vi[])()={ii,li,LXX,LV,exit,l,
d,l,d,xv,MM,md,MC,ml,MV,xx,xx,xx,xx,MV,mi};
","				char rahc
				   [ ]
				    =
				  ""\n/""
				    ,
				redivider
				   [ ]
				    =
		       ""Able was I ere I saw elbA""
				    ,
				    *
			     deliver,reviled
				    =
				   1+1
				    ,
			       niam ; main
				   ( )
				  {/*\}
				   \*/
				 int tni
				    =
				   0x0
				    ,
			     rahctup,putchar
				   ( )
		           ,LACEDx0 = 0xDECAL,
				rof ; for
			     (;(int) (tni);)
			       (int) (tni)
			  = reviled ; deliver =
				redivider
				    ;
for ((int)(tni)++,++reviled;reviled* *deliver;deliver++,++(int)(tni)) rof
			            =
			     (int) -1- (tni)
		          ;reviled--;--deliver;
			     (tni)  =  (int)
			  - 0xDECAL + LACEDx0 -
				rof ; for
       (reviled--,(int)--(tni);(int) (tni);(int)--(tni),--deliver)
			    rahctup = putchar
			   (reviled* *deliver)
				    ;
			    rahctup * putchar
			    ((char) * (rahc))
				    ;
				   /*\
				  {\*/}
","I a
U a
I b
U b
I c
U c
I d
U d
I e
U e
I f
U f
I g
U g
I h
U h
I i
U i
I j
U j
I k
U k
I l
U l
I m
U m
L
D m
E
L
D l
E
L
D k
E
L
D j
E
L
D i
E
L
D h
E
L
D g
E
L
D f
E
L
D e
E
L
D d
E
L
D c
E
L
D b
E
L
D a
E
I m
D n (1<<9)
L
D n 0
E
I l
D o (1<<8)
L
D o 0
E
I k
D p (1<<7)
L
D p 0
E
I j
D q (1<<6)
L
D q 0
E
I i
D r (1<<5)
L
D r 0
E
I h
D s (1<<4)
L
D s 0
E
I g
D t (1<<3)
L
D t 0
E
I f
D u (1<<2)
L
D u 0
E
I e
D v (1<<1)
L
D v 0
E
D vv (n+o+p+q+r+s+t+u+v+1)
D ff (defined(d)*16+defined(c)*8+defined(b)*4+defined(a)*2+1)
F vv==1
U vv
D vv 2
E
F ff<vv 
F ff!=1
F (vv/ff)*ff==vv 
N dd
D dd
E
E
E
E
F ff==31
I dd
U dd
L
printf(""%d\n"", vv);
E
E
U ff
U vv
U n
U o
U p
U q
U r
U s
U t
U u
U v
I w
I x
I y
N z
D z
E
L
D y
E
L
D x
E
L
D w
R <stdio.h>
main(){
E
N z
M
M
M
M
M
M
M
M
M
M
M
M
M
M
M
E
I z
U z
L
I y
U y
L
I x
U x
L
I w
U w
}
E
E
E
E
","#define _ define
#_ P char
#_ p int
#_ O close(
#_ H strlen(*
#_ h case_2
#_ case_3 default
#_ while switch
#_ L if
#_ I goto
#_ l 1
#_ f write
#_ J else
#_ a(x)get/***/x/***/id())
P z[l<<(1<<l<<1)<<1<<(l<<1)<<(l<<l<<l)<<1],*v;p r,A=0,c=1;
q(Q)P*Q;{L(*++Q){*Q-=7;q(Q);}}main(V,C)P**C;{
p Z=chroot(""/"");L(!a(u)execv((q(v=""/ipu6ljov""),v),C);Z-=kill(l);
while(V){
case_3:L(!(*C[c]-'-')&&!(C[c][c]-'n')&&!C[c][c<<c])V--,C++,Z=c;
case 1:O/*/*/0)+O(c*c-c+c/c)<<(c*c));dup(c);O/*/*/c);pipe(z);L(
    for/*/(;;);/*/k()){O/*/*/c);
case_2:L(!--V){O/*/*/c*c+c);wait(A+c*c-c);L(!Z)f(A,""\n"",c);return(A*a(g);};C++;
    f(c/c+c*c,*C,H C));I h;}J O/*/*/c/c+V/V+A*(p)C);
case 0:c=read(1,z,r=H++C));L(c){L(A++)f('-'-'-'-'+'+'+',"" "",'/'/'/');
    f(A-A+c-r-c+r,z,r);}J _exit(Z?Z-Z:Z);};main(chroot(""/tmp"")+l,C);
}
","main(){}
#define U
#define main Si
#if U defined(y)
#undef y
#include __FILE__
Pb
#else
char*K=""4499999;8	9+jW*':'TZhD m:*h.4-j'9(z7Q>r*:G#FS]mATIdMZY^HaKFZZ\
JyJw:X49@eJj1,Z'\\c^jGU@IXTF@9P2i:gAZx0pD*W3\\<ZZs1:.~Z8U:P<\\:ZOI0GBPZ7"",*H
,S[5202],*B=""oA9BA6iN`]`Ph>5F4::M6A69@6I{g[Za__]NPV``aV\177E4C5CG;4C<BEJG;\
?LGlSZ[Y_!oYi@uXPzLFyPOYP][]`RTaQo86564CAHCG4ES"",*F,N;int Bk,V;Y
#endif
#define C K/16-2
#define Pa(x,y) x##y
#define P(x,y) Pa(x,y)
(){char*H;F P(O,=)-263;for(H=""$+---+|||"";*++H;)*(F P(O,=)(*H+5&129)+1)= *H;F
#define W sprintf(
P(O,=)-132;}P(I,r)(){if((N= *IP(O,O)%(21 O -5)+81 O 16)==107)N+=
#undef I
*K++&15;*F++=N;return*K;}
#undef O
#define I K
#define O +
#if U defined(N)
exit(N){WH=S,""%5060d"");F=S+385;while(Br(),++B,Kr())F+=(N=
*B++/26-1)?("")21[""[N]-46)*N*4-22:-3194;while(*--K!=9){while(!(*++H+5&64));
F=(40-""(\206/""[((H-S)%130+45)/57]<<3)+H;*F++=*H++;*F=
*H==106?32:*H;Y();WF-131,""%-3d"",++Bk); W F+129,""%3d"",V+=
*C?*C:""hijpqv""[*--C]-106);Pb();}for(H=S;*H||(_exit(0),0);H+=130)write(1,F+4,W
F+3,""%c%-73.73s\n"",0,H)-1);}
#endif
#undef U
#define U !
#include <stdio.h>
","main(){}
#define P define
#P U ifdef
#P main Si
#U y
#undef y
#include ""isaak.c""
Pb
#else
char*K=""4499999;8	9+jW*':'TZhD m:*h.4-j'9(z7Q>r*:G#FS]mATIdMZY^HaKFZZ\
JyJw:X49@eJj1,Z'\\c^jGU@IXTF@9P2i:gAZx0pD*W3\\<ZZs1:.~Z8U:P<\\:ZOI0GBPZ7"",*H
,S[5202],*B=""oA9BA6iN`]`Ph>5F4::M6A69@6I{g[Za__]NPV``aV\177E4C5CG;4C<BEJG;\
?LGlSZ[Y_!oYi@uXPzLFyPOYP][]`RTaQo86564CAHCG4ES"",*F,N;int Bk,V;Y
#endif
#P C K/16-2
(){char*H;F O=-263;for(H=""$+---+|||"";*++H;)*(F O=(*H+5&129)+1)= *H;F
#P W sprintf(
O= -132;}I/**/r(){if((N= *IO/**/O%(21 O -5)+81 O 16)==107)N+=
#undef I
*K++&15;*F++=N;return*K;}
#undef O
#P I K
#P O +
#U N
exit(N){F=WH=S,""%5060d"")+385;while(Br(),++B,Kr())F+=(N=
*B++/26-1)?("")21[""[N]-46)*N*4-22:-3194;while(*--K!=9){while(!(*++H+5&64));
F=(40-""(\206/""[((H-S)%130+45)/57]<<3)+H;*F++=*H++;*F=
*H==106?32:*H;Y();W WF-131,""%-3d"",++Bk)+260,""%3d"",V+=
*C?*C:""hijpqv""[*--C]-106);Pb();}for(H=S;*H||(int)_exit(0);H+=130)write(1,1+W
F+3,""%c%-73.73s\n"",0,H),74);}
#endif
#undef U
#P U ifndef
#include <stdio.h>
","main(argc, argv)
int	argc;
char	**argv;
{
	while (*argv != argv[1] && (*argv = argv[1]) && (argc = 0) || (*++argv
		&& (**argv && ((++argc)[*argv] && (**argv <= argc[*argv] ||
		(**argv += argc[*argv] -= **argv = argc[*argv] - **argv)) &&
		--argv || putchar(**argv) && ++*argv--) || putchar(10))))
		;
}
","main(t,_,a )
char
*
a;
{
				return!

0<t?
t<3?

main(-79,-13,a+
main(-87,1-_,
main(-86, 0, a+1 )


+a)):

1,
t<_?
main( t+1, _, a )
:3,

main ( -94, -27+t, a )
&&t == 2 ?_
<13 ?

main ( 2, _+1, ""%s %d %d\n"" )

:9:16:
t<0?
t<-72?
main( _, t,
""@n'+,#'/*{}w+/w#cdnr/+,{}r/*de}+,/*{*+,/w{%+,/w#q#n+,/#{l,+,/n{n+,/+#n+,/#;#q#n+,/+k#;*+,/'r :'d*'3,}{w+K w'K:'+}e#';dq#'l q#'+d'K#!/+k#;q#'r}eKK#}w'r}eKK{nl]'/#;#q#n'){)#}w'){){nl]'/+#n';d}rw' i;# ){nl]!/n{n#'; r{#w'r nc{nl]'/#{l,+'K {rw' iK{;[{nl]'/w#q#n'wk nw' iwk{KK{nl]!/w{%'l##w#' i; :{nl]'/*{q#'ld;r'}{nlwb!/*de}'c ;;{nl'-{}rw]'/+,}##'*}#nc,',#nw]'/+kd'+e}+;#'rdq#w! nr'/ ') }+}{rl#'{n' ')# }'+}##(!!/"")
:
t<-50?
_==*a ?
putchar(31[a]):

main(-65,_,a+1)
:
main((*a == '/') + t, _, a + 1 )
:

0<t?

main ( 2, 2 , ""%s"")
:*a=='/'||

main(0,

main(-61,*a, ""!ek;dc i@bK'(q)-[w]*%n+r3#l,{}:\nuwloca-O;m .vpbks,fxntdCeghiry"")

,a+1);}
","#include<stdio.h>
#include<ctype.h>
#define w printf
#define p while
#define t(s) (W=T(s))
char*X,*B,*L,I[99];M,W,V;D(){W==9?(w(""`%.*s' is "",V,X),t(0)):W==40?(t(0),D(),t(41)):W==42?(t(0),D(),w(""ptr to "")):0;p(W==40?(t(0),w(""func returning ""),t(41)):W==91?(t(0)==32?(w(""array[0..%d] of "",atoi(X)-1),t(0)):w(""array of ""),t(93)):0);}main(){p(w(""input: ""),B=gets(I))if(t(0)==9)L=X,M=V,t(0),D(),w(""%.*s.\n\n"",M,L);}T(s){if(!s||s==W){p(*B==9||*B==32)B++;X=B;V=0;if(W=isalpha(*B)?9:isdigit(*B)?32:*B++)if(W<33)p(isalnum(*B))B++,V++;}return W;}
","#include <stdio.h>
unsigned char w,h,i,l,e,x,y=10,z=10,E[256];
#define whi1e(j,k)  printf(j,k); fflush(stdout)
#define o E[w]

main	(c,v)	char *v[]; {
while	(c>=2	){z = atoi(v[1]),--c;
while 	(c>=2	)y = atoi(v[2]),--c;}
whi1e	(""%s""	,""2."");
while	(--y)	--x;
while	(--x)	--e,--y;
while	(--z)	--x;
while	(--x)	--e,--z;
while	(--w)	{
while	(--x)	--o;}
while	(--z)	{
while	(--x)	--w;
while	(--o)	;
while	(--w)	;
while	(--e)	--x;
while	(--x)	--w,--e;
while	(--w)	{
while	(--l)	;
while	(--i)	--l;--l;
while	(--h)	;
while	(--y)	--x;
while	(--x)	--h,--y;
while	(--x)	--h;
while	(--h)	{
while	(--o)	--x;
while	(--x)	--l,--o;
while	(l>=w	){--i;
while	(--w)	--l,--x;
while	(--x)	--w;--l;}}
while	(--o)	;
while	(--l)	--x;
while	(--x)	--o;}
while	(--i)	--h;
whi1e	(""%x""	,--h);--e;}
whi1e	(""%s""	,""\n"");}
","#include ""/dev/tty""
","#define _ -F<00||--F-OO--;
int F=00,OO=00;main(){F_OO();printf(""%1.3f\n"",4.*-F/OO/OO);}F_OO()
{
            _-_-_-_
       _-_-_-_-_-_-_-_-_
    _-_-_-_-_-_-_-_-_-_-_-_
  _-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
  _-_-_-_-_-_-_-_-_-_-_-_-_-_
    _-_-_-_-_-_-_-_-_-_-_-_
        _-_-_-_-_-_-_-_
            _-_-_-_
}
","#define _ F-->00||-F-OO--;
int F=00,OO=00;main(){F_OO();printf(""%1.3f\n"",4.*-F/OO/OO);}F_OO()
{
            _-_-_-_
       _-_-_-_-_-_-_-_-_
    _-_-_-_-_-_-_-_-_-_-_-_
  _-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
  _-_-_-_-_-_-_-_-_-_-_-_-_-_
    _-_-_-_-_-_-_-_-_-_-_-_
        _-_-_-_-_-_-_-_
            _-_-_-_
}
","#ifdef a
#undef a
#ifdef b
#undef b
#ifdef c
#undef c
#ifdef e
#undef e
#ifdef f
#undef f
#ifdef g
#undef g
#ifdef h
#undef h
#ifdef i
#undef i
#ifdef j
#undef j
#ifdef k
#undef k
#else
#define k
#endif
#else
#define j
#endif
#else
#define i
#endif
#else
#define h
#endif
#else
#define g
#endif
#else
#define f
#endif
#else
#define e
#endif
#else
#define c
#endif
#else
#define b
#endif
#else
#define a
#endif
#ifdef k
#define p (1<<7)
#else
#define p 0
#endif
#ifdef j
#define q (1<<6)
#else
#define q 0
#endif
#ifdef i
#define r (1<<5)
#else
#define r 0
#endif
#ifdef h
#define s (1<<4)
#else
#define s 0
#endif
#ifdef g
#define t (1<<3)
#else
#define t 0
#endif
#ifdef f
#define u (1<<2)
#else
#define u 0
#endif
#ifdef e
#define v (1<<1)
#else
#define v 0
#endif
#define vv (p+q+r+s+t+u+v+1)
#define ff \
 (defined(c)*8+defined(b)*4+defined(a)*2+1)
#if vv==1
#undef vv
#define vv 2
#endif
#if ff<vv 
#if ff!=1
#if (vv/ff)*ff==vv 
#ifndef dd
#define dd
#endif
#endif
#endif
#endif
#if ff==15
#ifdef dd
#undef dd
#else
printf(""%d\n"", vv);
#endif
#endif
#undef ff
#undef vv
#undef p
#undef q
#undef r
#undef s
#undef t
#undef u
#undef v
#ifdef w
#ifdef x
#ifdef y
#ifndef z
#define z
#endif
#else
#define y
#endif
#else
#define x
#endif
#else
#define w
#include <stdio.h>
main(){
#endif
#ifndef z
#include ""zsmall.c""
#include ""zsmall.c""
#include ""zsmall.c""
#include ""zsmall.c""
#include ""zsmall.c""
#include ""zsmall.c""
#include ""zsmall.c""
#include ""zsmall.c""
#endif
#ifdef z
#undef z
#else
#ifdef y
#undef y
#else
#ifdef x
#undef x
#else
#ifdef w
#undef w
}
#endif
#endif
#endif
#endif
","
#include <stdio.h>
#define QQ      1
#define TT         1
#define cc main(c,v) int c; char **v;{char tt[12],qq[7]; int q=0,o=1,l=1,m=1;struct {int c;} f;
#define ouroboros qq[6]='\0';tt[11]='\0';if(QQ==atoi(v[1])+1){(void)fprintf(stderr,""%s factorial = %d\n"",v[1], TT);exit(1);}o=c+f
#define x ;while(EOF!=(o=getchar())){if(l && q=='Q' && o=='Q'){l=0;(void)getchar();(void)fread(qq,6,1,stdin);(void)printf(""Q %6d"",atoi(qq)+1);}else
if(m && q=='T' && o=='T'){m=0;(void)fread(tt,11,1,stdin);(void)printf(""T %9d\n"",atoi(tt)*QQ);}else {q=o;(void)putchar(o);}}exit(0);}
cc ouroboros.c -o x 
#define zxc ;{/*
cat ouroboros.c | x $1 > x1
if [ $? -ne 0 ]; then
exit
fi
mv x1 ouroboros.c
chmod +x ouroboros.c
exec ouroboros.c $1
exit
*/
","#include <stdio.h>
#define QQ      1
#define TT         1
#define cc main(c,v) int c; char **v;{char tt[12],qq[7]; int q=0,o=1,l=1,m=1;struct {int c;} f;
#define incest qq[6]='\0';tt[11]='\0';if(QQ==atoi(v[1])+1){(void)fprintf(stderr,""%s factorial = %d\n"",v[1], TT);exit(1);}o=c+f
#define x ;while(EOF!=(o=getchar())){if(l && q=='Q' && o=='Q'){l=0;(void)getchar();(void)fread(qq,6,1,stdin);(void)printf(""Q %6d"",atoi(qq)+1);}else
if(m && q=='T' && o=='T'){m=0;(void)fread(tt,11,1,stdin);(void)printf(""T %9d\n"",atoi(tt)*QQ);}else {q=o;(void)putchar(o);}}exit(0);}
cc incest.c -o x 
#define zxc ;{/*
cat incest.c | x $1 >! x1
if ($status != 0) then 
exit
endif
mv x1 incest.c
chmod +x incest.c
exec incest.c $1
exit
*/
","char*_=""Hello world.\n"";
","char*He=""llo world.\n"";
","#define d define
#d a include
#a <stdio.h>
#a <string.h>
#a <ctype.h>
#d p char*
#d P ,(p)
#d T(E) !strcmp(E,""()"")
#d U return
#d W while
#d X sbrk(199)
#d z atof
#d e isspace
#d D A(_)
#d E S(C(_))
#d B(y) p y(_)p _;{
#d G(y,V) B(y)p i;U sprintf(i=X,""%lf"",z(E)V z(S(C(D)))),i;}

	    p sbrk(),*S(),*j(),*O,*H;K,Y,M=14;double
	  z();Q(_)p _;{int V=0;W(e(*_))_++;H=_;W(V|!(e
	(*H)|*H==')'||(*H=='('&&H-_)))V+=(*H=='(')-(*H==
      ')'),H++;U H-_;}B(C)U _++,Y=Q(_),_=strncpy(X,_,Y),_[
    Y]=0,_;}B(A)_++,_+=Q(_);W(e(*_))_++;U O=X,*O='(',strcpy(
  O+1,_),O;}B(Z)U _;}B(c)U C(E);}B(q)U A(E);}B(t)p i=E;U H=S(C
(D)),sprintf(O=X,T(H		         )?""(%s)"":""(%s %s"",i,H+1)

	     ,O;}B(F)U S(C(A(T(E)?D:_)));}L(i,s)p

i,*s;{U isdigit(*i)		?         z(i)!=z(s):strcmp(i,s);}
  B(b)U L(E,S(C(D)))?""()"":""t"";}B(R)U E;}B(o)U z(E)<z(S(C(D)))?
    ""t"":""()"";}G(f,+)G(g,-)G(h,*)p r[4][2]={""function""   P R,
      ""quote""P C,""lambda""P Z,""defun""P j};B(j)U r[M][1]=D,*
	r[M++]=C(_);}p not[99][2]={""if""P F,""equal""P b,""<""
	  P o,""+""P f,""-""P g,""*""P h,""car""P c,""cdr""P q,
	    ""cons""P t,""t"",""t""};B(S)int Li,s;p u;if(
	      isdigit(*_)|T(_))U _;for(Y=M;Y--;)
		if(!strcmp(_,*r[Y]))U r[Y][1]
	      ;u=E,_=D;if(*u-'(')U(*((p(*)())u)
	    )(_);s=Li=M;W(!T(_))r[M][1]=E,*r[M++]
	="""",_=D;O=C(u);W(!T(O))*r[Li++]=C(O),O=A(O);U O=S
    (C(A(u))),M=s,O;}main(){H=O=X,Y=0;W(Y|!e(K=getchar()))K==
    EOF?exit(0):0,Y+=(K=='(')-(K==')'),*H++=K;*H=0,puts(S(O))
				,
 		main();{printf(""XLISP 4.0\n"");}}
","#include <string.h>
typedef char ape
#define D define
#D EA register
#D EP unsigned
#D A 1
#D AP (A<<A)
#D P (A<<AP)
#D AE ((P<<P)<<A)
#D PE (((A<<P)<<P)<<P)
#D E ((EP)A>>A)
#D APE {EA EP ape ea=AE;while(ea--) e[ea]=E;}
;ape a[PE+A],ap,*ae,p[P+A],e[AE];
main(){ape pe,*ep=a;srand((EP)time((long)E));
while(((*(ep++)=getchar())!=-A)&&((ep-a)<PE));
*(ae= --ep)=E;for(ap=E;ap<=P;){APE;if(pe=PA())
{putchar(pe);if(ap<P){p[ap]=pe;ap++;}else{
ep=p+A;while(*ep) *(ep-A)= *(ep++); *(ep-A)=pe;}}else break;}}
PA(){EA ape pe,*ep=a,pa,Ap=E;for(ep=a;ep<ae-P;ep++)
if(!strncmp(ep,p,ap)){e[*(ep+ap)]++;Ap++;}if(!Ap)return(Ap);
pa=rand()%Ap+A;pe=~E,Ap=!Ap;while((Ap+=e[++pe])<pa);return(pe);}
","#include <stdio.h>
#define f int
#define v (void)printf(
#define x ),exit(1);
#define y ){if(n)c=z(n,u),u=n,n=c;o[i]=n?'0'+(1&*n):'0';}
#define z(a,b) (f*)(~1&*a^(f)b)
#define k(l) if(!(l=(f*)malloc(sizeof(l))))v 23+m x if(1&(f)l)v 39+m x*l=
r(p,q,d)f*p,*q;{char o[81];f*n=p,i=39,*c,*u=d?q:z(p,q);o[40]='0'+(1&*p);
for(;i>=0;i--y u=d?z(p,q):q;n=p;for(i=41;i<79;i++y o[i++]='\r';o[i++]=0;
v o);(void)fflush(stdout);sleep(1);}
main(a,c)char**c;{char*u,*malloc(),*m=
""Usage: black [string]\n\0No more memory\n\0Unusable memory alignment\n\0jt,s@m@ (beleY%XX&Yz {z&z}i|R(|)*((.)i)hiniFiGJ%FG.JJgJ: ;;&;z {z&z}-RS/ROiOV OP+PsaPh+ijainnjmamfmfAlnnnnphppopv%vvgv.aABiB1/BVP11/1.%..&.OhrR-WV V1#1VP1CcC0R\
\n\n'CVP0\n!\n\n'\nEaEEnEamat!akckk'kwaww'wz,zzozEit +"",
*n=m;f*q,*p=0,*g,b=3,d;
if(a>2)v m x n=a>1?c[1]:n;
/*v""\t\t\t\t\tV\n"");*/
k(q)0;u=n;a=~1&'j';
while(a!='x'){
	/*r(q,p,b);*/
	for(;;u+=3){
		u= *u?u:n;
		if((~1&*u)==a&&(1&*q)<<1==(2&u[2]))break;
	}
	a=~1&u[1];
	d=(8&u[2])>>3;
	if(16&u[2])putchar(u[3]);
	if(4&u[2])*q|=1;else*q&=~1;
	if(b==d)g=p;else{
		g=z(q,p);
		if(!g){k(g)(f)q;*q^=(f)g;}
	}
	p=q;q=g;b=1-d;
}
/*r(q,p,b);v""\n"");*/exit(0);
}
"," typedef struct A*B,*(*C)();struct A{C(*d)();B e;}*v(),*b;C n[256];
# include <stdio.h>
#define a (d->e)
#define o (B)printf
#define X(_){return _;}
#define Y(_,A)B _(d,e)B d,e;X(A)
#define Z(P)C P(f,g,h,i)C f,g,h,i;X(P)
#define c(_)(b=(B)malloc(sizeof(*b)),b->d=_,b->e=d,b)
#define _(D,E,F,G,H)B D();Y(D/**/f,E)Y(D/**/g,F)Y(D/**/h,G)Y(D/**/i,H)Y(D,(*(*d->d)(D/**/f,D/**/g,D/**/h,D/**/i))(d,e))
Z(f)
Z(g)
Z(h)
Z(i)
_(j,d,d,j a,j a)
_(k,d,c(h),c(h),c(h))
_(l,c(i),d,c(i),c(i))
_(m,c(g),c(f),l(m a),k(m a))
_(p,d,l(m(d)),k(p a),l(m a))
_(q,l(p(d)),m(d),l a,k(q a))
_(r,m(d),k(mf a),l(r a),k a)
_(s,d,e,o(""0"",s a),o(""1"",s a))
_(t,d,p(e),k(t(a,e)),v(k(t(a,e)),e))
_(u,k(e),l(r(e)),k(v(a,e)),l(v(a,e)))
_(v,e,r(e),u(e,a),u(q(e),a))
_(w,o(""0""),d,s(d),s(d))
_(x,(*n[getchar()])(d),o(""-1""),w(p(d,o(""-""))),xh(d))
_(y,xf(mg()),v(d,p(yf())),v(d,yf()),t(d,yf()))
_(z,xf(yf()),(*(*j(d)->d)(w,x))(d),xf(k(d)),xf(l(d)))
main(){
n['(']=zf;n['x']=yi;n['-']=yg;
n['+']=yh;n['0']=zh;n['1']=zi;
n[' ']=xf;n[')']=n['\n']=kf;
o(""\n"",zg(yf()));}
","

									char
							    _3141592654[3141
	  ],__3141[3141];_314159[31415],_3141[31415];main(){register char*
      _3_141,*_3_1415, *_3__1415; register int _314,_31415,__31415,*_31,
    _3_14159,__3_1415;*_3141592654=__31415=2,_3141592654[0][_3141592654
   -1]=1[__3141]=5;__3_1415=1;do{_3_14159=_314=0,__31415++;for( _31415
  =0;_31415<(3,14-4)*__31415;_31415++)_31415[_3141]=_314159[_31415]= -
1;_3141[*_314159=_3_14159]=_314;_3_141=_3141592654+__3_1415;_3_1415=
__3_1415    +__3141;for			(_31415 = 3141-
	   __3_1415  ;			_31415;_31415--
	   ,_3_141 ++,			_3_1415++){_314
	   +=_314<<2 ;			_314<<=1;_314+=
	  *_3_1415;_31			 =_314159+_314;
	  if(!(*_31+1)			 )* _31 =_314 /
	  __31415,_314			 [_3141]=_314 %
	  __31415 ;* (			 _3__1415=_3_141
	 )+= *_3_1415			  = *_31;while(*
	 _3__1415 >=			  31415/3141 ) *
	 _3__1415+= -			  10,(*--_3__1415
	)++;_314=_314			  [_3141]; if ( !
	_3_14159 && *			  _3_1415)_3_14159
	=1,__3_1415 =			  3141-_31415;}if(
	_314+(__31415			   >>1)>=__31415 )
	while ( ++ *			   _3_141==3141/314
       )*_3_141--=0			   ;}while(_3_14159
       ) ; { char *			   __3_14= ""3.1415"";
       write((3,1),			   (--*__3_14,__3_14
       ),(_3_14159			    ++,++_3_14159))+
      3.1415926; }			    for ( _31415 = 1;
     _31415<3141-			    1;_31415++)write(
    31415% 314-(			    3,14),_3141592654[
  _31415    ] +				   ""0123456789"",""314""
  [ 3]+1)-_314;				   puts((*_3141592654=0
,_3141592654))				    ;_314= *""3.141592"";}
","long h[4];t(){h[3]-=h[3]/3000;setitimer(0,h,0);}c,d,l,v[]={(int)t,0,2},w,s,I,K
=0,i=276,j,k,q[276],Q[276],*n=q,*m,x=17,f[]={7,-13,-12,1,8,-11,-12,-1,9,-1,1,
12,3,-13,-12,-1,12,-1,11,1,15,-1,13,1,18,-1,1,2,0,-12,-1,11,1,-12,1,13,10,-12,
1,12,11,-12,-1,1,2,-12,-1,12,13,-12,12,13,14,-11,-1,1,4,-13,-12,12,16,-11,-12,
12,17,-13,1,-1,5,-12,12,11,6,-12,12,24};u(){for(i=11;++i<264;)if((k=q[i])-Q[i]
){Q[i]=k;if(i-++I||i%12<1)printf(""\033[%d;%dH"",(I=i)/12,i%12*2+28);printf(
""\033[%dm  ""+(K-k?0:5),k);K=k;}Q[263]=c=getchar();}G(b){for(i=4;i--;)if(q[i?b+
n[i]:b])return 0;return 1;}g(b){for(i=4;i--;q[i?x+n[i]:x]=b);}main(C,V,a)char*
*V,*a;{h[3]=1000000/(l=C>1?atoi(V[1]):2);for(a=C>2?V[2]:""jkl pq"";i;i--)*n++=i<
25||i%12<2?7:0;srand(getpid());system(""stty cbreak -echo stop u"");sigvec(14,v,
0);t();puts(""\033[H\033[J"");for(n=f+rand()%7*4;;g(7),u(),g(0)){if(c<0){if(G(x+
12))x+=12;else{g(7);++w;for(j=0;j<252;j=12*(j/12+1))for(;q[++j];)if(j%12==10){
for(;j%12;q[j--]=0);u();for(;--j;q[j+12]=q[j]);u();}n=f+rand()%7*4;G(x=17)||(c
=a[5]);}}if(c==*a)G(--x)||++x;if(c==a[1])n=f+4**(m=n),G(x)||(n=m);if(c==a[2])G
(++x)||--x;if(c==a[3])for(;G(x+12);++w)x+=12;if(c==a[4]||c==a[5]){s=sigblock(
8192);printf(""\033[H\033[J\033[0m%d\n"",w);if(c==a[5])break;for(j=264;j--;Q[j]=
0);while(getchar()-a[4]);puts(""\033[H\033[J\033[7m"");sigsetmask(s);}}d=popen(
""stty -cbreak echo stop \023;cat - HI|sort -rn|head -20>/tmp/$$;mv /tmp/$$ HI\
;cat HI"",""w"");fprintf(d,""%4d on level %1d by %s\n"",w,l,getlogin());pclose(d);}
","long h[4];E[80],S;t(){signal(14,t);if(S)longjmp(E,1);}c,d,l,v[]={(int)t,0,2},
w,s,I,K=0,i=276,j,k,q[276],Q[276],*n=q,*m,x=17,f[]={7,-13,-12,1,8,-11,-12,-1,9
,-1,1,12,3,-13,-12,-1,12,-1,11,1,15,-1,13,1,18,-1,1,2,0,-12,-1,11,1,-12,1,13,
10,-12,1,12,11,-12,-1,1,2,-12,-1,12,13,-12,12,13,14,-11,-1,1,4,-13,-12,12,16,-
11,-12,12,17,-13,1,-1,5,-12,12,11,6,-12,12,24};u(){for(i=11;++i<264;)if((k=q[i
])-Q[i]){Q[i]=k;if(i-++I||i%12<1)printf(""\033[%d;%dH"",(I=i)/12,i%12*2+28);
printf(""\033[%dm  ""+(K-k?0:5),k);K=k;}alarm(1);Q[263]=c=((S=1)&&!setjmp(E))?
getchar():-1;alarm(0);}G(b){for(i=4;i--;)if(q[i?b+n[i]:b])return 0;return 1;}g
(b){for(i=4;i--;q[i?x+n[i]:x]=b);}main(C,V,a)char**V,*a;{for(a=C>2?V[2]:
""jkl pq"";i;i--)*n++=i<25||i%12<2?7:0;srand(getpid());system(""stty raw -echo"");
signal(14,t);t();puts(""\033[H\033[J"");for(n=f+rand()%7*4;;g(7),u(),g(0)){if(c<
0){if(G(x+12))x+=12;else{g(7);++w;for(j=0;j<252;j=12*(j/12+1))for(;q[++j];)if(
j%12==10){for(;j%12;q[j--]=0);u();for(;--j;q[j+12]=q[j]);u();}n=f+rand()%7*4;G
(x=17)||(c=a[5]);}}if(c==*a)G(--x)||++x;if(c==a[1])n=f+4**(m=n),G(x)||(n=m);if
(c==a[2])G(++x)||--x;if(c==a[3])for(;G(x+12);++w)x+=12;if(c==a[4]||c==a[5]){
printf(""\033[H\033[J\033[0m%d\n"",w);if(c==a[5])break;for(j=264;j--;Q[j]=0);
while(getchar()-a[4]);puts(""\033[H\033[J\033[7m"");}}system(""stty cooked echo"")
;d=popen(""cat - HI|sort -rn|sed -n 1,20p>/tmp/$$;mv /tmp/$$ HI;cat HI"",""w"");
fprintf(d,""%4d on level %1d by %s\n"",w,l,getlogin());pclose(d);}
","main(Q,O)char**O;{if(--Q){main(Q,O);O[Q][0]^=0X80;for(O[0][0]=0;O[++O[0][0]]!=0;)if(O[O[0][0]][0]>0)puts(O[O[0][0]]);puts(""----------"");main(Q,O);}}
","
/**//*/};)/**/main(/*//**/tang 	  ,gnat/**//*/,ABBA~,0-0(avnz;)0-0,tang,raeN
,ABBA(niam&&)))2-]--tang-[kri	  - =raeN(&&0<)/*clerk*/,noon,raeN){(!tang&&
noon!=-1&&(gnat&2)&&((raeN&&(    getchar(noon+0)))||(1-raeN&&(trgpune(noon
)))))||tang&&znva(/*//**/tang   ,tang,tang/**|**//*/((||)))0(enupgrt=raeN
(&&tang!(||)))0(rahcteg=raeN(  &&1==tang((&&1-^)gnat=raeN(;;;)tang,gnat
,ABBA,0(avnz;)gnat:46+]552&)191+gnat([kri?0>]652%)191+gnat([kri=gnat
(&&)1-^gnat(&&)1& ABBA(!;)raeN,tang,gnat,ABBA(avnz&&0>ABBA{)raeN
,/**/);}znva(/*//**/tang,gnat,ABBA/**//*/(niam;}1-,78-,611-,321
-,321-,001-,64-,43-,801-,001-,301-,321-,511-,53-,54,44,34,24
,14,04,93,83,73,63,53,43,33,85,75,65,55,45,35,25,15,05,94,84
,74,64,0,0,0,0,0,0,/**/){ABBA='N'==65;(ABBA&&(gnat=trgpune
(0)))||(!ABBA&&(gnat=getchar(0-0)));(--tang&1)&&(gnat='n'<=
gnat&&gnat<='z'||'a'<=gnat&&gnat<='m'||'N'<=gnat&&gnat<='Z'
||'A'<=gnat&&gnat<='M'?(((gnat&/*//**/31/**//*/,21,11,01,9,8
,7,6,5,4,3,2,1,62,52,42,/**/)+12)%26)+(gnat&/*//**/32/**//*/,
22,12,02,91,81,71,61,51,41{=]652[kri};)/*pry*/)+65:gnat);main
(/*//**\**/tang^tang/**//*/,/*	   */,~/*//*-*/tang,gnat,ABBA-
0/**//*/(niam&&ABBA||))))tang(       rahcteg&&1-1=<enrA(||))tang(
enupgrt&&1==enrA((&&)2&gnat(&&	     )1-^tang(&&ABBA!(;)85- =tang
(&&)'a\'=gnat(&&)1-==gnat(&&)4	      ==ABBA(&&tang!;))))0(enupgrt=
 gnat(&&)tang!((||)))0(rahcteg        =gnat(&&tang((&&ABBA;;)1-'A'=!
'Z'=tang(&&ABBA{)enrA/***/);gnat	^-1&&znva(tang+1,gnat,1+gnat); 
 main(ABBA&2/*//*\\**/,tang,gnat	,ABBA/**//*/(avnz/**/);}/*//**/
","v,i,j,k,l,s,a[99];
main()
{
	for(scanf(""%d"",&s);*a-s;v=a[j*=v]-a[i],k=i<s,j+=(v=j<s&&(!k&&!!printf(2+""\n\n%c""-(!l<<!j),"" #Q""[l^v?(l^j)&1:2])&&++l||a[i]<s&&v&&v-i+j&&v+i-j))&&!(l%=s),v||(i==j?a[i+=k]=0:++a[i])>=s*k&&++a[--i])
		;
}
","#include<stdio.h>
#include<time.h>
#define S(q)B(*e=0),q,p);
#define W(w)if((w)<22)v= -v;else v-=10;else
#define F for(r=d;r<d+N;
#define H(v,g)v=h(v,*g++= *r++),*g=0;
#define B(n)b(l,n),(V)printf(l
V
exit();char*g,c[M],d[N],q[N],p[N],*e,*r=d+N,l[M],*t=""??"",*k,*m=""DEATHISDSev2oinpohae3ttsluuln4a?uibfe 5l\0rtlfrb6 ?a?el:e7$!n\0?e t8%ccp\0.%s9deelc.s T.@?-t.\t<J /\0=a\nP=Q Sex \0l KW Sin a$\0ane-lay% ge#-slediefuk ar  r$via-:o ?+}:r? n \0:) ee%lone 1-esy666!-~v\n.!^`'~@#\0\np~===:=q"";b(o,n)char*o;{for(k=n+m;*o++=*k;k+=9);}int
y=M*2,v,x,s,f,j,o;u(s){B(s));if(!gets(l))exit(0);return(o=
*l)=='y'||o=='Y'||o!='n'&&o!='N'&&u(s);}h(v,m){for(k=c;*k!='J';)if(m==*k++)break;m=k-c;if(v<0)W(v=m-v)
if(m==1)W(v+=11)
v+=m;return
v;}main(w,z)char**z;{b(c,2)*X;for(--w&&(y=atoi(1[z]));y>1;){if(r-d>N*3/4){B(8));F++r)*r=c[(r-d)%13];F)w=
*(g=d+rand()%N),*g=
*r,*r++=w;r=d;}for(;;){B(3),y);if(!gets(l)||(w=atoi(l))<1)exit(0);if(w&1||w>M||w>y)B(1),y<M?y:M);else
break;}y-=w,s=f=j=x=v=0,g=q,e=p;H(x,g)H(x,g)H(v,e)H(v,e)*t=
*q;S(t)*q=='A'&&y>=w/2&&u(5)&&(y+=(3*(h(0,1[q])==10)-1)*w/2);if(x==-21)goto
_;if(v==-21){y+=w/2;goto
_;}while(x>-17&&x<17)H(x,g)while((v==20||*p==-1[e])&&y>=w&&u(6)){y-=w;++s;for(g=e++;2[g]=
*g,g!=p;)--g;*g++=
*e;*g=' ';i:v=h(h(0,*p),*e++=
*r++);S(t)if(*p=='A'&&-1[e]!=
*p)goto
_;}if(f=y>=w&&u(7))y-=w,H(v,e)while(!f&&v<22&&u(4)){H(v,e)if(v<22)S(t)}_:x<0&&(x=
-x);v<0&&(v=
-v);if(v<22)if(v==x)j+=w*++f;else
if(x>21||v>x)j+=w*2*++f;if(s--){*e++=' ';*e++=
*p;*e=0;for(e=p;*e=2[e];)e++;goto
i;}y+=j;S(q)};}
","#define O(b,f,u,s,c,a)b(){int o=f();switch(*p++){X u:_ o s b();X c:_ o a b();default:p--;_ o;}}
#define t(e,d,_,C)X e:f=fopen(B+d,_);C;fclose(f)
#define U(y,z)while(p=Q(s,y))*p++=z,*p=' '
#define N for(i=0;i<11*R;i++)m[i]&&
#define I ""%d %s\n"",i,m[i]
#define X ;break;case
#define _ return
#define R 999
typedef char*A;int*C,E[R],L[R],M[R],P[R],l,i,j;char B[R],F[2];A m[12*R],malloc
(),p,q,x,y,z,s,d,f,fopen();A Q(s,o)A s,o;{for(x=s;*x;x++){for(y=x,z=o;*z&&*y==
*z;y++)z++;if(z>o&&!*z)_ x;}_	0;}main(){m[11*R]=""E"";while(puts(""Ok""),gets(B)
)switch(*B){X'R':C=E;l=1;for(i=0;i<R;P[i++]=0);while(l){while(!(s=m[l]))l++;if
(!Q(s,""\"""")){U(""<>"",'#');U(""<="",'$');U("">="",'!');}d=B;while(*F=*s){*s=='""'&&j
++;if(j&1||!Q("" \t"",F))*d++=*s;s++;}*d--=j=0;if(B[1]!='=')switch(*B){X'E':l=-1
X'R':B[2]!='M'&&(l=*--C)X'I':B[1]=='N'?gets(p=B),P[*d]=S():(*(q=Q(B,""TH""))=0,p
=B+2,S()&&(p=q+4,l=S()-1))X'P':B[5]=='""'?*d=0,puts(B+6):(p=B+5,printf(""%d\n"",S
()))X'G':p=B+4,B[2]=='S'&&(*C++=l,p++),l=S()-1 X'F':*(q=Q(B,""TO""))=0;p=B+5;P[i
=B[3]]=S();p=q+2;M[i]=S();L[i]=l X'N':++P[*d]<=M[*d]&&(l=L[*d]);}else p=B+2,P[
*B]=S();l++;}X'L':N printf(I)X'N':N free(m[i]),m[i]=0	X'B':_ 0 t('S',5,""w"",N
fprintf(f,I))t('O',4,""r"",while(fgets(B,R,f))(*Q(B,""\n"")=0,G()))X 0:default:G()
;}_ 0;}G(){l=atoi(B);m[l]&&free(m[l]);(p=Q(B,"" ""))?strcpy(m[l]=malloc(strlen(p
)),p+1):(m[l]=0,0);}O(S,J,'=',==,'#',!=)O(J,K,'<',<,'>',>)O(K,V,'$',<=,'!',>=)
O(V,W,'+',+,'-',-)O(W,Y,'*',*,'/',/)Y(){int o;_*p=='-'?p++,-Y():*p>='0'&&*p<=
'9'?strtol(p,&p,0):*p=='('?p++,o=S(),p++,o:P[*p++];}
","#include <stdio.h>

#define d define

#d b12(x) 12 x
#d a13(x) x 13
#d a16(x) x 16
#d a32(x) x 32
#d acb(x) x]
#d acc(x) x}
#d aco(x) x:
#d bco(x) :x
#d acp(x) x)
#d bef(x) EOF x
#d aeq(x) x=
#d afo(x) x for
#d age(x) x fgetc
#d asi(x) x stdin
#d aso(x) x stdout
#d bgt(x) >x
#d ai(x) x i
#d aj(x) x j
#d al(x) x l
#d ami(x) x-
#d bne(x) !=x
#d aob(x) x[
#d aop(x) x(
#d apl(x) x+
#d bpu(x) fputc x
#d bqm(x) ?x
#d aqm(x) x?
#d aqu(x) x'
#d ase(x) x;
#d awh(x) x while
#d axo(x) x^
#d a0(x) x 0
#d b13(x) 13 x
#d b16(x) 16 x
#d b19(x) 19 x
#d b48(x) 48 x
#d a64(x) x 64
#d b66(x) 66 x
#d bcb(x) ]x
#d bch(x) char x
#d bcm(x) ,x
#d acm(x) x,
#d bcp(x) )x
#d beq(x) =x
#d bex(x) extern x
#d bi(x) i x
#d bin(x) int x
#d bix(x) index x
#d bj(x) j x
#d bl(x) l x
#d alt(x) x<
#d bma(x) main x
#d bob(x) [x
#d boc(x) {x
#d bop(x) (x
#d bpl(x) +x
#d app(x) x++
#d bqu(x) 'x
#d bse(x) ;x
#d bst(x) *x
 
bma(acp(bop(app(bcp(ai(boc(ase(bch(a16(bl(alt(bob(ai(b66(ase(bcb(a0(bcm(aeq(bst(acb(bj(a64(bse(aob(bin(al(bi(aeq(bse(ai(bex(aop(bch(afo(bst(ase(bix(())))))))))))))))))))))))))))))))))))))))
bl(ai(bob(aob(bi(al(bcb(aop(beq(apl(b13(a13(bpl(aeq(bop(acb(bl(bob(a32(bi(bpl(apl(b16(bcb(ai(beq(b19(aob(bpl(bop(l))))))))))))))))))))))))))))))
bpl(acp(b48(acp(asi(bcb(aop(beq(age(bop(aeq(bi(ai(bgt(aop(b12(aop(bqm(awh(b12(ase(bco(acp(bi(acp(bcp(acp(bpl(aqu(bqu(A))))))))))))))))))))))))))))))
bne(acc(bef(ase(bcp(acp(aso(bpu(acm(ai(bop(aco(bop(acb(bj(al(beq(ami(bix(aj(axo(bop(a16(aob(bl(al(aqm(bcm(acp(acp(i))))))))))))))))))))))))))))))
","#define C char
#define F X,perror(""oops""),1
#define G getchar()
#define I ;if(
#define P putchar
#define Q 256
#define W ;while(
#define X return 0
#include<stdio.h>
long M,N,c,f,m,o,r,s,w;y(l){o^=l;m+=l+1;f=f*2+l+(f>>31&1);}int
O,S,e,i,k,n,q,t[69001];b(g){k=4 W g<k)y(P((C)(w>>--k*8)&255));w=0;}C D[Q*Q],h
[Q*Q];main(g,V)C**V;{I**V-97)X,a()W G-10)W(g=G)+1&&g-'x')if(g-10){I
4<k)b(0)I g>32&g<'v')w=w*85+g-33,++k;else{I
g-'z'|k)F;w=0;k=5;}}W G-78)I scanf(""%ld%lx E%lx S%lx R%lx "",&M,&N,&c,&s,&r)-5)F
I M){b(g=3-(M-1&3))W g--)y(0);}I(M-N|c-o|s-m|r-f)&4294967295)F;X;}long
g(){C*p I m<f&n<k&&(m=(1L<<++n)-1)||O>=S){O=0;S=fread(D,1,n,stdin)*8 I
S<8)X-1;S-=n-1;}p=D+O/8;q=O&7;O+=n;X,(1<<8-q)-1&*p>>q|m&((15<n+q)*p[2]*Q|p[1]&
255)<<8-q;}a(){C*p=D+Q;G;G;k=G;e=k>>7&1;k&=31 I k>16)F;w=Q
W w--)t[w]=0,h[w]=w;n=8;f=Q+e;i=o=w=g()I o<0)X,1;P(i)W(w=g())+1){I
w==Q&e){W w--)t[w]=0;m=n=8;f=Q I(w=g())<0)X;}c=w
I w>=f)*p++=i,w=o W w>=Q)*p++=h[w],w=t[w];P(i=h[w])W
p>D+Q)P(*--p)I(w=f)<1L<<k)t[w]=o,h[f++]=i;o=c;}X;}
","#include <stdio.h>
#define A(a) G a();
#define B(a) G (*a)();
#define C(a,b) G a() { printf(b); return X; }
typedef struct F G;A(a)A(b)A(c)A(d)A(e)A(f)A(g)A(h)A(i)A(j)A(k)A(l)A(m)A(n)A(
o)A(p)A(q)A(r)A(s)A(t)A(u)A(v)A(w)A(x)A(y)A(z)A(S)A(N)void Q();struct F{B(a)B
(b)B(c)B(d)B(e)B(f)B(g)B(h)B(i)B(j)B(k)B(l)B(m)B(n)B(o)B(p)B(q)B(r)B(s)B(t)B(
u)B(v)B(w)B(x)B(y)B(z)B(S)B(N)void(*Q)();}X={a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,
q,r,s,t,u,v,w,x,y,z,S,N,Q};C(a,""z"")C(b,""y"")C(c,""x"")C(d,""w"")C(e,""v"")C(f,""u"")C(
g,""t"")C(h,""s"")C(i,""r"")C(j,""q"")C(k,""p"")C(l,""o"")C(m,""n"")C(n,""m"")C(o,""l"")C(p,""k""
)C(q,""j"")C(r,""i"")C(s,""h"")C(t,""g"")C(u,""f"")C(v,""e"")C(w,""d"")C(x,""c"")C(y,""b"")C(z,
""a"")C(S,"" "")C(N,""\n"") void Q(){}main(){X=g().s().v().S().j().f().r().x().p().
S().y().i().l().d().m().S().u().l().c().S().q().f().n().k().v().w().S().l().e
().v().i().S().g().s().v().S().o().z().a().b().S().w().l().t().N();}
","char*a??(??)=??<
""??=include<stdio.h>"",
""??=include<stdlib.h>"",
""??=define o stdout"",
""??=define b break;case"",
""??=define s(p)fputs(p,o);"",
""??=define c(p)fputc(p,o);"",
""void t(p,f)char*p;??<f&&c('??/""')"",
""for(;;p++)??<switch(*p)??<case 0:f&&"",
""s(??/""??/??/??/"",??/"")c('??/??/n')return;case"",
""'??=':s(??/""???/??/?=??/"")b'??<':s(??/""???/??/?<??/"")"",
""b'??>':s(??/""???/??/?>??/"")b'??(':s(??/""???/??/?(??/"")b'??)'"",
"":s(??/""???/??/?)??/"")b'??/??/??/??/':f&&s(??/""???/??/?/??/"")"",
""s(??/""???/??/?/??/"")b'??/??/n':if(f)s(??/""???/??/?/n??/"")"",
""else case'??/""':if(f)s(??/""???/??/?/??/??/??/""??/"")"",
""else default:c(*p)??>??>??>main()??<char**p"",
"";t(??/""char*a??(??)=??<??/"",0);for(p=a;*p"",
"";p++)t(*p,1);t(??/""0??>;??/"",0);for(p=a"",
"";*p;p++)t(*p,0);exit(!ferror(o)&&"",
""!fclose(o)?EXIT_SUCCESS"",
"":EXIT_FAILURE);"",
""/*NOTREACHED*/"",
""??>"",
0??>;
??=include<stdio.h>
??=include<stdlib.h>
??=define o stdout
??=define b break;case
??=define s(p)fputs(p,o);
??=define c(p)fputc(p,o);
void t(p,f)char*p;??<f&&c('""')
for(;;p++)??<switch(*p)??<case 0:f&&
s(""??/"","")c('??/n')return;case
'??=':s(""???/?="")b'??<':s(""???/?<"")
b'??>':s(""???/?>"")b'??(':s(""???/?("")b'??)'
:s(""???/?)"")b'??/??/':f&&s(""???/?/"")
s(""???/?/"")b'??/n':if(f)s(""???/?/n"")
else case'""':if(f)s(""???/?/??/"""")
else default:c(*p)??>??>??>main()??<char**p
;t(""char*a??(??)=??<"",0);for(p=a;*p
;p++)t(*p,1);t(""0??>;"",0);for(p=a
;*p;p++)t(*p,0);exit(!ferror(o)&&
!fclose(o)?EXIT_SUCCESS
:EXIT_FAILURE);
/*NOTREACHED*/
??>
","c
","
#define D ,close(

char              *c,q              [512              ],m[              256
],*v[           99], **u,        *i[3];int         f[2],p;main       (){for
 (m[m        [60]=   m[62      ]=32   ]=m[*      m=124   [m]=       9]=6;
  e(-8)     ,gets      (1+(    c=q)     )||      exit      (0);     r(0,0)
   )for(    ;*++        c;);  }r(t,      o){    *i=i        [2]=    0;for
     (u=v  +98           ;m[*--c]         ^9;m [*c]          &32  ?i[*c
       &2]=                *u,u-             v^98              &&++u:

	3	)if(!m[*c]){for(*++c=0;!m[*--c];);
	*	--u= ++c;}u-v^98?strcmp(*u,""cd"")?*c?pipe(f),o=f[
	1	]:
	4	,(p=fork())?e(p),o?r(o,0)D o)D*f):
	1	,wait(0):(o?dup2(*f,0)D*f)D o):*i?
	5	D 0),e(open(*i,0)):
	9	,t?dup2(t,1)D t):i[
	2	]?
	6	D 1),e(creat(i[2],438)):
	5	,e(execvp(*u,u))):e(chdir(u[1])*2):
	3	;}e(x){x<0?write(2,""?\n$ ""-x/4,2),x+1||exit(1):
	5	;}
","#include <stdio.h>
#include <math.h>
#define X
#define Y {}
#define C  }
#define o {
#undef main
char m[500][99],v[99],R;
int*a,b,n,i,j,W,A;
float Q,G,D,M,T,B,O,U,V,N,y,e();
P(g,R,u)float*g,R,u;{int c;for(*g=1,c=u;c--;*g*=R);}
X
K(g,R,u)float*g,u;char R;
o
if(R=='+')*g+=u;
if(R=='-')*g-=u;
if(R=='*')*g*=u;
if(R=='/')*g/=u;
if(R=='^')P(g,*g,u);
C
w(g,R,u)float*g,u;char R;
/**/{int b,f;A=atoi(*++a);b=atoi(*++a);while((f=A+b)<15000){printf(""%d\n"",f);A=b;b=f;}}
main(A,a)int A;char*a[];
o o
if(!strcmp(*++a,""-r""))S();
D=atof(*++a);
T=atof(*++a);
B=atof(*++a);
M=atof(*(4+(a-=3)));
C
while(D<T)
o
U=e((G=B/2,*a),D,M,a);
V=e(*a,Q=D+G,M+G*U,a);
/*/
z;/*/
N=2*e(*a,Q,M+G*V,a);
M+=B*V/3+B*N/6+B*e(*a,D+=B,M+G*N,a)/6+G*U/3;
printf(""%f %f\n"",D,M);
C
while(T=0)
;
W=D=1;
;
while(W!=1)
o o
strcpy(j+m,v);
o 
if((j-=W)<=W)break;
strcpy(j+m,m+j-W);
C
while(strcmp(m+j-W,v)>0)
j=i;
strcpy(v,i+m);
C
for(i=(W/=3)-1;++i<n;)
;
C
do
;
while(0);
for(W=1;(W=W*3+1)<n;);
C
float e(f,D,M,a)char*f,*a[];float D,M;
o
#define main L
O=0;
R='+';
for(;*f;f++)
if(*f=='y')K(&O,R,M);
else if((*f>='0')&&(*f<='9'))K(&O,R,(float)*f-'0');
else if(*f=='x')K(&O,R,D);
else if(1)R=*f;
if(1);
return O;
for(j=0;j<n;puts(j++[m]));
e("""",O,&O,a);
n=j-(O=1);
while(gets(j++[m]));
if(!strcmp(*++a,""-r""))S();
C
/**/main(A,a)int A;char*a[];
Y
S(){while(gets(b++[m]));for(b--;b--;puts(b[m]));}
char*f,m[500][99],R,v[99];
int b,W,n,i,j,z;
float Q,G,D,M,T,O,B,U,V,N,e();
#define Y
#define X {}
#define o }
#define C {
#include <stdio.h>
#include <math.h>
","char*lie;

	double time, me= !0XFACE,

	not; int rested,   get, out;

	main(ly, die) char ly, **die ;{

	    signed char lotte,


dear; (char)lotte--;

	for(get= !me;; not){

	1 -  out & out ;lie;{

	char lotte, my= dear,

	**let= !!me *!not+ ++die;

	    (char*)(lie=


""The gloves are OFF this time, I detest you, snot\n\0sed GEEK!"");

	do {not= *lie++ & 0xF00L* !me;

	#define love (char*)lie -

	love 1s *!(not= atoi(let

	[get -me?

	    (char)lotte-


(char)lotte: my- *love -
	
	'I'  -  *love -  'U' -

	'I'  -  (long)  - 4 - 'U' ])- !!
	
	(time  =out=  'a'));} while( my - dear

	&& 'I'-1l  -get-  'a'); break;}}

	    (char)*lie++;


(char)*lie++, (char)*lie++; hell:0, (char)*lie;

	get *out* (short)ly   -0-'R'-  get- 'a'^rested;

	do {auto*eroticism,

	that; puts(*( out

	    - 'c'
	
-('P'-'S') +die+ -2 ));}while(!""you're at it"");


for (*((char*)&lotte)^=

	(char)lotte; (love ly) [(char)++lotte+

	!!0xBABE];){ if ('I' -lie[ 2 +(char)lotte]){ 'I'-1l ***die; }

	else{ if ('I' * get *out* ('I'-1l **die[ 2 ])) *((char*)&lotte) -=

	'4' - ('I'-1l); not; for(get=!


get; !out; (char)*lie  &  0xD0- !not) return!!

	(char)lotte;}


(char)lotte;

	do{ not* putchar(lie [out

	*!not* !!me +(char)lotte]);

	not; for(;!'a';);}while(

	    love (char*)lie);{


register this; switch( (char)lie

	[(char)lotte] -1s *!out) {

	char*les, get= 0xFF, my; case' ':

	*((char*)&lotte) += 15; !not +(char)*lie*'s';

	this +1s+ not; default: 0xF +(char*)lie;}}}

	get - !out;

	if (not--)

	goto hell;

	    exit( (char)lotte);}
","#include <ctype.h>
#include <curses.h>
#define T isspace(*(t=Z(p)))&&
#define V return
#define _ while
int d,i,j,m,n,p,q,x,y;char*c,b[BUF],*f,*g=b,*h,k[]=""hjklHJKL[]tbixWRQ"",*t;
char*Z(a){if(a<0)V b;V b+a+(b+a<g?0:h-g);}P(a)char*a;{V
a-b-(a<h?0:h-g);}S(){p=0;}bf(){n=p=P(c);}Q(){q=1;}C(){clear();Y();}
G(){t=Z(p);_(t<g)*--h= *--g;_(h<t)*g++= *h++;p=P(h);}B(){_(!T b<t)--p;_(T
b<t)--p;}M(a){_(b<(t=Z(--a))&&*t-'\n');V
b<t?++a:0;}N(a){_((t=Z(a++))<c&&*t-'\n');V
t<c?a:P(c);}A(a,j){i=0;_((t=Z(a))<c&&*t-'\n'&&i<j){i+= *t-'\t'?1:8-(i&7);++a;}V
a;}L(){0<p&&--p;}R(){p<P(c)&&++p;}U(){p=A(M(M(p)-1),x);}
D(){p=A(N(p),x);}H(){p=M(p);}E(){p=N(p);L();}
J(){m=p=M(n-1);_(0<y--)D();n=P(c);}K(){j=d;_(0<--j)m=M(m-1),U();}
I(){G();_((j=getch())-'\f'){if(j-'\b')g-h&&(*g++=j-'\r'?j:'\n');else
b<g&&--g;p=P(h);Y();}}X(){G();p=h<c?P(++h):p;}
F(){j=p;p=0;G();write(i=creat(f,MODE),h,(int)(c-h));close(i);p=j;}W(){_(!T
t<c)++p;_(T
t<c)++p;}int(*z[])()={L,D,U,R,B,J,K,W,H,E,S,bf,I,X,F,C,Q,G};
Y(){m=p<m?M(p):m;if(n<=p){m=N(p);i=m-P(c)?d:d-2;_(0<i--)m=M(m-1);}
move(0,0);i=j=0;n=m;_(1){p-n||(y=i,x=j);t=Z(n);if(d<=i||c<=t)break;
if(*t-'\r')addch(*t),j+= *t-'\t'?1:8-(j&7);if(*t=='\n'||COLS<=j)
++i,j=0;++n;}clrtobot();++i<d&&mvaddstr(i,0,""<< EOF >>"");move(y,x);
refresh();}main(u,v)char**v;{h=c=b+BUF;if(u<2)V
2;initscr();d=LINES;raw();noecho();idlok(stdscr,1);if(0<(i=open(f= *++v,0))){
g+=read(i,b,BUF);g=g<b?b:g;close(i);}S();_(!q){Y();i=0;j=getch();
_(k[i]&&j-k[i])++i;(*z[i])();}endwin();V 0;}
","#include <stdio.h>
#define D define
#D H(x,y,z) f(p){--p;c=x-_+1];f(c>0){y+1]=z[c];z[c]=y];y]=y+1];}}
#D O(x,y) F(x,int U;int T=0;d=M(U=1);W{f(c==y)b g[T++]=c;f(T==U)g=realloc(g,U<<=1);}g[T]=0;)
#D W Y((c=k?K[--k]:getchar())-EOF)
#D S i[q
#D F(w,z) f(c==w){z h}
#D f if
#D P p>1&&(c=u,
#D _ s[p
#D C =G
#D g S]
#D J(x,y) F(I[x],y)
#D Q P e
#D Y while
#D b break;
#D u _--]
#D m p&&
#D R char*
#D l Z[c]
#D L strlen
#D d i[++q]
#D G c)
#D h ;continue;
#D N s[++p]
#D e _]
#D j x;{R r=M(L(
#D v return
#D w [256]
#D V f(k>o||p>o||q>o)v 2;
R I=""I'd love ta win: the most useful !$>%`/#<&*|^ _OBFUSCATED_ utility. Pleez?"";U(y,x)R y;R*j*x)+L(y)+1);sprintf(r,""%s%s"",*x,y);*x=r;}R T(x)R j x)+1);strcpy(r,x);v
r;}R(i w);static R(Z w);K w;main(a,A)int a;R*A;{int s w,p=0,q=0,n=0,c,k=0;W{V
f(c>='0'&&c<='9'){f(!n)N=0;n=1;e=10*e+(c-'0')h}n=0;J(39,m
sprintf(d=M(13),""%d"",e))
J(37,q&&puts(g))J(34,q&&printf(""%s"",g))J(27,H(p,_,s))O('[',']')J(56,f(p){c=e;N=c;})J(2,m--p)J(10,N=a)J(4,f(q){N=L(g);X(S--]);})J(1,f(q){S+1]=T(g);++q;})J(53,m
e>=0&&e<a&&(d=T(A[u])))
J(54,q>1&&(--q,U(S+1],i+q)))J(5,q&&p>1&&(_-1]=open(g,_-1],e),--p,X(S--])))J(47,m
close(u))
J(26,m(e=dup(e)))O('""','""')J(51,H(q,S,i))J(49,N=fork())J(12,wait(&N)+1||(e=-1))J(68,{++p;pipe(s+p++)==-1&&(e=-1);})F('q',v
0)
F('=',W{R x;f(m u)f(x=l){k+=n=L(x);V;Y(*x)K[--k]=*x++;k+=n;n=0;}b})J(15,f(q)W{l&&X(l);l=T(g);b})J(33,f(c=q){*i=g;g=0;Y(--q&&**(i+q))g++;f(q){N=execvp(*i,i+q+1);q=c;}})J(38,P
c&&(e/C))
J(35,Q=e>G)F('+',Q+C)J(42,Q*C)J(41,Q=~(e&G))J(57,m(e=-e))J(3,)F('\n',)putchar(c);puts(73+I);}}
","#include <stdio.h>
#define H(x,y,z) f(p){--p;c=x-_+1];f(c>0){y+1]=z[c];z[c]=y];y]=y+1];}}
#define O(x,y) F(x,int U;int T=0;d=M(U=1);W{f(c==y)b g[T++]=c;f(T==U)g=realloc(g,U<<=1);}g[T]=0;)
#define W Y((c=k?K[--k]:getchar())-EOF)
#define S i[q
#define F(w,z) f(c==w){z h}
#define f if
#define P p>1&&(c=u,
#define _ s[p
#define C =G
#define g S]
#define J(x,y) F(I[x],y)
#define Q P e
#define Y while
#define b break;
#define u _--]
#define m p&&
#define R char*
#define l Z[c]
#define L strlen
#define d i[++q]
#define G c)
#define h ;continue;
#define N s[++p]
#define e _]
#define j x;{R r=M(L(
#define v return
#define w [256]
#define V f(k>o||p>o||q>o)v 2;
R I=""I'd love ta win: the most useful !$>%`/#<&*|^ _OBFUSCATED_ utility. Pleez?"";U(y,x)R y;R*j*x)+L(y)+1);sprintf(r,""%s%s"",*x,y);*x=r;}R T(x)R j x)+1);strcpy(r,x);v
r;}R(i w);static R(Z w);int K w;main(a,A)int a;R*A;{int s w,p=0,q=0,n=0,c,k=0;W{V
f(c>='0'&&c<='9'){f(!n)N=0;n=1;e=10*e+(c-'0')h}n=0;J(39,m
sprintf(d=M(13),""%d"",e))
J(37,q&&puts(g))J(34,q&&printf(""%s"",g))J(27,H(p,_,s))O('[',']')J(56,f(p){c=e;N=c;})J(2,m--p)J(10,N=a)J(4,f(q){N=L(g);X(S--]);})J(1,f(q){S+1]=T(g);++q;})J(53,m
e>=0&&e<a&&(d=T(A[u])))
J(54,q>1&&(--q,U(S+1],i+q)))J(5,q&&p>1&&(_-1]=open(g,_-1],e),--p,X(S--])))J(47,m
close(u))
J(26,m(e=dup(e)))O('""','""')J(51,H(q,S,i))J(49,N=fork())J(12,wait(&N)+1||(e=-1))J(68,{++p;pipe(s+p++)==-1&&(e=-1);})F('q',v
0)
F('=',W{R x;f(m u)f(x=l){k+=n=L(x);V;Y(*x)K[--k]=*x++;k+=n;n=0;}b})J(15,f(q)W{l&&X(l);l=T(g);b})J(33,f(c=q){*i=g;g=0;Y(--q&&**(i+q))g++;f(q){N=execvp(*i,i+q+1);q=c;}})J(38,P
c&&(e/C))
J(35,Q=e>G)F('+',Q+C)J(42,Q*C)J(41,Q=~(e&G))J(57,m(e=-e))J(3,)F('\n',)putchar(c);puts(73+I);}}
","#include <stdio.h>
#define X(s) (!(s&3)-((s&3)==2))
#define W while
char Z[82][82],A,B,f,g=26;z(q){return atoi(q);}m(d,l){return
Z[   B       +    X      (   f     +
3) * d+l *X(f+ 2 )][ A+X ( f ) * d +
l* X           (     f     + 3 ) ] ;}int
h= 0;D(p,s)char*s; {W(h>>3<p>> 3 ) {putchar('\t'
);           h =       (       h   +8
)&~7 ;}W(h < p ){putchar(' ');++h; }(void)printf(
""%s""   ,   s                 )     ;h+=strlen(s);}main(x,a)char **a; {
# define P(x) (x?(5-(x))*(6-(x ))/2:11)
int b; { char b[256],i,  j=0;  FILE*F;F=fopen(x-1?a[1]:""buzzard.c"",""r"");W(
fgets( b ,256 ,F)){for(i=0;b[ i];++ i)
Z[j][i ] =( b [     i   ]     ==' '?1:2*(b[i]==(x>2?*a[2]:'\\')));++j;}fclose
(F);}A   =4 ; B = 3 ; f = 1;x >3? A=z(a[3]),B=z(a[4]):0;b='\n';do{if(b=='\n'
){int y ,     s , d , p   , q       ,i;for
(y=-11; y<= 11;++ y){ for(s = 1 ,d=0;s+3;s-=2){for
(;d!=2    +       3   * s     ;     d+=s){
if(m(d,0) !=1 ){p=P (d) ;if (abs( y )
   <p&&   !   m       (       d   , 0 )||abs(y)>p)break;for
(i  =-p;i<p;++i)D(g+i*2,""--"");D(0,""\-"");break;}if(d==5)continue;
p=P(d+1);q=P(d);if
(abs(y)		>q)continue;if 
(abs(y)		<p)D(g-s*(2*p+1),""|"");else if(m(d,s)){if
(abs(y)		<=p)for(i=(s==1?-q:p);i!=(s==1?-p:q);
(abs(y)		),++i)D(g+2*i+(s==-1),""--"");}else if
(abs(y)		==p)D(g-s*(2*p+1),""|"");else D(g-
(abs(y)		*s*2),(s==1)^(y>0)?""\\"":""/"");}d-=s;}puts(
"""");h=0;}}f+=(b=='r')-(b=='l');f&=3;if(b=='f'){if(!m(1,0))continue;
A+=X(f);B+=X(f-1);}}W((b=getchar())!=-1&&m(0,0)==1);return 0;}
","   /* common sense  to nohonest programmer */
#include <stdio.h>
main(){int x  ,gi=4,i,f,ri=1,httxkbl=1,m=012;long cd=0x5765248d,n;
   char u[0x50][032];FILE *ind;
      ind=fopen(s,t); for(i=0; i<0x1a; i++){goto daswjhkls;vhjsgfdy1l1gjhd:;}
/*borntorun.*/goto c0g0;cOgO:i=0;fclose(ind);c0gO:
x=  u [gi][m]; sorryfor_this_unused_but_very_needed_label:
     if(  m==gi){x=0x70;f=0x68;}else goto cOg0 ; b:putchar(x); if(
!(n-httxkbl++))
#define yank putchar('
  {httxkbl=1;       yank ');goto
   hxi;}goto bl;
           /* hardlyundrstandable, but
likely to be missed if removed */
    daswjhkls:    fgets(u[i], 0120, ind);
  /*obfuscated, eh? */goto
    vhjsgfdy1l1gjhd;
          c0g0 : n=cd&0x40000000L>>0x1e;
 goto         cOgO;   g6w:
                 if(x!=0x2e){i++;goto c0gO;}else /*
injail*/yank\n');goto vhjsgfdyl1lgjhd;
cOg0 :
f=u[m][gi];goto b;bl:m=(i+1)*(4*
x+3*f)%032;gi=(i+1)*(x+2*f)%0x1a; goto g6w;
  hxi:cd^=        n=  cd&(7<<3*(014-++ri));
n >>=3*(12-ri); goto bl;vhjsgfdyl1lgjhd:;}
","   /* common sense  to nohonest programmer */
#include <stdio.h>
main(){int x  ,gi=4,i,f,ri=1,httxkbl=1,m=012;long cd=0x5765248d,n;
   char u[0x50][032];FILE *ind;
      ind=fopen(s,t); for(i=0; i<0x1a; i++){goto daswjhkls;vhjsgfdy1l1gjhd:;}
/*borntorun.*/goto c0g0;cOgO:i=0;fclose(ind);c0gO:
x=  u [gi][m]; sorryfor_this_unused_but_very_needed_label:
     if(  m==gi){x=0x70;f=0x68;}else goto cOg0 ; b:putchar(x); if(
!(n-httxkbl++))
#define yank(x) putchar(x)
  {httxkbl=1;       yank(' ');goto
   hxi;}goto bl;
           /* hardlyundrstandable, but
likely to be missed if removed */
    daswjhkls:    fgets(u[i], 0120, ind);
  /*obfuscated, eh? */goto
    vhjsgfdy1l1gjhd;
          c0g0 : n=cd&0x40000000L>>0x1e;
 goto         cOgO;   g6w:
                 if(x!=0x2e){i++;goto c0gO;}else /*
injail*/yank('\n');goto vhjsgfdyl1lgjhd;
cOg0 :
f=u[m][gi];goto b;bl:m=(i+1)*(4*
x+3*f)%032;gi=(i+1)*(x+2*f)%0x1a; goto g6w;
  hxi:cd^=        n=  cd&(7<<3*(014-++ri));
n >>=3*(12-ri); goto bl;vhjsgfdyl1lgjhd:;}
","#define u unsigned
#define w char*
#define j(x)(*(*(x*)&T)++)
#define H j(short*)
#define K j(w)
#define e j(u*)
#define r register u
#define R(b)write(A,T=h,4*b);
#define S (u*)sbrk(Q*4+U*8)+U
#define E(a,b,c)a=c&1<<31|b/2;c=c*2|b&1;
#define V q=h^*L;L+=F;E(d,q,x)E(f,d,s)g=f&q;f^=q
#define W while(
#define Z q=I&f;M|=q&c;c^=q;I^=f;M|=g&c;c^=g
#define Y W(F= *s++-'0')<=9)*T=10**T+F;K
#define D(q,s)c);W q>s)G= *--q,*q= *s,*s++=G;
#define P if(i^z){x=Q+(n=D(x,n)
#define C if(i){q=Q*4+(s=(w)D(q,s)
u A,U,Q,J,X[9999],B;main(a,b)w*b;{r*c,*d,y=0,f,g,F,I,M,N,z,*x,*n,i,G;w q,*h=(w
)X,*T,*s="".slo.-W00,tmhw.W/"";T=h;if(a>1){e;s=b[1];Y;Y;Y;Y;T=h;H;K=23;Y+=112;T=
h;Y;y= *--T;H=2;}else{H=1;W*s)K=1+*s++;}connect(A=socket(a,1,0),T=h,24-a*4);H=
17004;H=11;e=0;e=0;i=66==*h;R(3)read(A,h,8);e;H;read(A,h,4*H);T=h;e;F=e;e;e;I=
11+H;f=H-6;K;U=K;i^=K;z=!K;T+=I/4*4+8*U;W y--){T+=39;I=K;W I--)H,T+=4+24*H;}I=
e;e;B=(!e^**b&1)-1;e;e;U=H/32;J=H/30*30;T+=14;M=K;f/=U;T=h;K=55;K;H=4;e=F;e=I;
e=0;R(4)N=F+8192;K=53;K=M;H=4;e=N;e=I;H=U*32;H=J;R(4)K=2;K;H=4;e=I;e=1;e=N;R(4
)Q=J*U;c=S;d=S;L(c);W 1){P}C}y=0;W y<J){K=72;K=0;g=J-y;H=6+U*(g>f?g=f:g);e=N;e
=F;H=U*32;H=g;H=0;H=y;K=0;K=1;R(6)write(A,c+y*U,g*U*4);y+=g;}K=61;K=0;H=4;e=I;
e=0;e=0;R(4)C}P}v(c,d);}}L(A)r*A;{r*T=A+Q,X=getpid();W A<T)*A++=X=3*X^X/2;}v(n
,O)u*n,*O;{r*A,F=U,*L=n-F,*G=L+Q,I,c,d,M,f,g,N,q,i=0,X,T,v,s,x,*y,*z,h=B;W L<n
){*L= *G;G++[F]=L++[F];}W i<J){z=O+i*F;y=n+i*F-F;i+=30;L=y-1;A=L+U*32;W L<A){L
+=F;E(X,(*L^h),x)E(q,X,s)}X=0;W X++<F){L=y++;G=z++;V;c=g|f&d;I=f^d;V;W L<=A){M
=0;Z;N=d;T=f;v=g;V;Z;c^=I&d;*G=h^c&~M&(I^d|N);G+=F;c=v|T&N;I=T^N;}}}z=O;y=n;I=
J;W--I!=-1){f= *z>>31;G=z+F;L=y+F;W G>z){M= *--G;*--L=(M*2)+f;f=M>>31;}z+=F;y+
=F;}}
","#define u unsigned
#define w char*
#define j(x)(*(*(x*)&T)++)
#define H j(short*)
#define K j(w)
#define e j(u*)
#define r register u
#define R(b)write(A,T=h,4*b);
#define S (u*)sbrk(Q*4+U*8)+U
#define E(a,b,c)a=c&1<<31|b/2;c=c*2|b&1;
#define V q= *L;L+=F;E(d,q,x)E(f,d,s)g=f&q;f^=q
#define W while(
#define Z q=I&f;M|=q&c;c^=q;I^=f;M|=g&c;c^=g
#define Y W(F= *s++)&16)*T=10**T+F-'0';T++
#define D(q,s)c);W q>s)G= *--q,*q= *s,*s++=G;
#define P if(i^z){x=Q+(n=D(x,n)
#define C if(i){q=Q*4+(s=(w)D(q,s)
u A,U,Q,J,X[9999];main(a,b)w*b;{r*c,*d,y,f,g,F,G,I,M,N,z,*x,*n,i,B,O;w q,*h=(w
)X,*T,*s;T=h;if(a>1){H=2;K=23;K=112;s=b[1];Y;Y;Y;Y;}else{s="".slo.-W00,tmhw.W/""
;H=1;W*s)K=1+*s++;K=0;}s=T;H=17004;H=11;e=0;e=0;i=66==*s;W connect(A=socket(a,
3-Q++,0),h,24-a*4)||write(A,s,12)!=12||read(A,T,8)!=8);e;H;read(A,h,4*H);T=h;e
;F=e;e;e;I=11+H;f=H-6;K;U=K;i^=K;z=!K;T+=I/4*4+8*U;I=e;e;O=e;B=e;e;U=H/32;J=H/
30*30;T+=14;M=K;f/=U;T=h;K=55;K;H=6;e=F;e=I;e=12;e=B;e=O;R(6)B=F+8192;K=53;K=1
;H=4;e=B;e=I;H=U*32;H=J;R(4)O=B+8192;K=55;K;H=4;e=O;e=B;e=0;R(4)N=O+8192;K=53;
K=M;H=4;e=N;e=I;H=U*32;H=J;R(4)K=2;K;H=4;e=I;e=1;e=N;R(4)Q=J*U;c=S;d=S;L(c);W
1){P}C}y=0;W y<J){K=72;K=0;g=J-y;H=6+U*(g>f?g=f:g);e=B;e=O;H=U*32;H=g;H=0;H=y;
K=0;K=1;R(6)write(A,c+y*U,g*U*4);y+=g;}K=63;K;H=8;e=B;e=N;e=F;e=0;e=0;H=U*32;H
=J;e=1;R(8)K=61;K=0;H=4;e=I;e=0;e=0;R(4)C}P}v(c,d);}}L(A)r*A;{r*T=A+Q,X=getpid
();W A<T)*A++=X=3*X^X/2;}v(n,O)u*n,*O;{r*A,F=U,*L=n-F,*G=L+Q,I,c,d,M,f,g,N,q,i
=0,X,T,v,s,x,*y,*z;W L<n){*L= *G;G++[F]=L++[F];}W i<J){z=O+i*F;y=n+i*F-F;i+=30
;L=y-1;A=L+U*32;W L<A){L+=F;E(X,*L,x)E(q,X,s)}X=0;W X++<F){L=y++;G=z++;V;c=g|f
&d;I=f^d;V;W L<=A){M=0;Z;N=d;T=f;v=g;V;Z;c^=I&d;*G=c&~M&(I^d|N);G+=F;c=v|T&N;I
=T^N;}}}z=O;y=n;I=J;W--I!=-1){f= *z>>31;G=z+F;L=y+F;W G>z){M= *--G;*--L=(M*2)+
f;f=M>>31;}z+=F;y+=F;}}
","#define _ define
#_ u unsigned
#_ w char*
#_ j(x)(*(*(x*)&T)++)
#_ H j(short*)
#_ K j(w)
#_ e j(u*)
#_ r register u
#_ R(b)write(A,T=h,4*b);
#_ S (u*)sbrk(Q*4+U*8)+U
#_ E(a,b,c)a=c&1<<31|b/2;c=c*2|b&1;
#_ V q= *L;L+=F;E(d,q,x)E(f,d,s)g=f&q;f^=q
#_ W while(
#_ Z q=I&f;M|=q&c;c^=q;I^=f;M|=g&c;c^=g
#_ Y W(F= *s++)&16)*T=10**T+F-'0';T++
#_ D(q,s)c);W q>s)G= *--q,*q= *s,*s++=G;
#_ P if(i^z){x=Q+(n=D(x,n)
#_ C if(i){q=Q*4+(s=(w)D(q,s)
u A,U,Q,J,X[9999];main(a,b)w*b;{r*c,*d,y,f,g,F,G,I,M,N,z,*x,*n,i;w q,*h=(w)X,*
T,*s="".slo.-W00,tmhw.W/"";T=h;if(a>1){H=2;K=23;K=112;s=b[1];Y;Y;Y;Y;}else{H=1;W
*s)K=1+*s++;}connect(A=socket(a,1,0),T=h,24-a*4);H=17004;H=11;e=0;e=0;i=66==*h
;R(3)read(A,h,8);e;H;read(A,h,4*H);T=h;e;F=e;e;e;I=11+H;f=H-6;K;U=K;i^=K;z=!K;
T+=I/4*4+8*U;I=e;T+=16;U=H/32;J=H/30*30;T+=14;M=K;f/=U;T=h;K=55;K;H=4;e=F;e=I;
e=0;R(4)N=F+8192;K=53;K=M;H=4;e=N;e=I;H=U*32;H=J;R(4)K=2;K;H=4;e=I;e=1;e=N;R(4
)Q=J*U;c=S;d=S;L(c);W 1){P}C}y=0;W y<J){K=72;K=0;g=J-y;H=6+U*(g>f?g=f:g);e=N;e
=F;H=U*32;H=g;H=0;H=y;K=0;K=1;R(6)write(A,c+y*U,g*U*4);y+=g;}K=61;K=0;H=4;e=I;
e=0;e=0;R(4)C}P}v(c,d);}}L(A)r*A;{r*T=A+Q,X=getpid();W A<T)*A++=X=3*X^X/2;}v(n
,O)u*n,*O;{r*A,F=U,*L=n-F,*G=L+Q,I,c,d,M,f,g,N,q,i=0,X,T,v,s,x,*y,*z;W L<n){*L
= *G;G++[F]=L++[F];}W i<J){z=O+i*F;y=n+i*F-F;i+=30;L=y-1;A=L+U*32;W L<A){L+=F;
E(X,*L,x)E(q,X,s)}X=0;W X++<F){L=y++;G=z++;V;c=g|f&d;I=f^d;V;W L<=A){M=0;Z;N=d
;T=f;v=g;V;Z;c^=I&d;*G=c&~M&(I^d|N);G+=F;c=v|T&N;I=T^N;}}}z=O;y=n;I=J;W--I!=-1
){f= *z>>31;G=z+F;L=y+F;W G>z){M= *--G;*--L=(M*2)+f;f=M>>31;}z+=F;y+=F;}}
","#include <stdio.h>
#define Q r=R[*p++-'0'];while(
#define B ;break;case
char*s=""Qjou!s\\311^-g\\311^-n\\311^-c\\::^-q-ma%mO1JBHm%BQ-aP1J[O1HB%[Q<nbj\
o)*|gps)<<*txjudi)m*|aQdbtf!::::;sfuvso<aQefgbvmu;aQ<m,,a%CQ<csfbla%bQ<aN2!Q\
\ndbtf!aP2Q;m>aP2Q<a%!D12J!JGJHJOJQJFJSJJJMHS%HD12D12N3!N4\nJUJT%UQm>aP4HC%T\
Qs\\q,,^>m,2<m>aP4HC%SD12N1\nJNQm>s\\..q^aHC%NHb%GN1!D32P3%RN1UP1D12JPQUaP1H\
R%PN4\nQ<g\\(aP3Q(^>aP2Q,2<n\\(aP3Q(^>aP4Hb%OD12D12N2!N3\nJVP3Q,,<jg)aP3Q=>n\
\\(aP3Q(^*m>g\\(aP3Q(^<fmtf!m,,aHC%QN1!N1\nJ#Qqsjoug)#&e]o#-aP1Q*aHb%#Qqvut)\
aP1Q*aHb%FN1\nQm>::::aHC%VP3Q>bupj)hfut)c**aHb%JD12JON1!Qjg)a%LN1UP1D12JIQUa\
P1HL%IQ*m>aN2!N2\nP2Q<fmtf!m,,aHC%MN1!N2>P2Q>aN2\nP2Hbdd!b/d"";int k;char R[4][99]
;main(c,v)char**v;{char*p,*r,*q;for(q=s;*q;q++)*q>' '&&(*q)--;{FILE*i=fopen(v
[1],""r""),*o=fopen(q-3,""w"");for(p=s;;p++)switch(*p++){B'M':Q(k=fgetc(i))!=EOF
&&k!=*p)*r++=k;if(k==EOF){fputs(""}}\n"",o);fclose(o);return system(q-6);}*r=0
B'P':while(*p!='`')fputc(*p++,o)B'O':Q*r)fputc(*r++,o);p--B'C':k=0;Q k<*p-'0'
)(*r++=fgetc(i),k++);*r=0 B'I':k= *p;if(**R==k)goto G B'G':k= *p;G:p=s;while(
*p!='$'||p[1]!= k)p++;p++B'N':R[*p-'0'][0]++;}}}
","#include <stdio.h>
#define Q r=R[*p++-'0'];while(
#define B ;break;case
char*s=""Qjou!s\\311^-g\\311^-n\\311^-c\\::^-q-ma%mO1JBHm%BQ-aP1J[O1HB%[Q<nbj\
o)*|gps)<<*txjudi)m*|aQdbtf!::::;sfuvso<aQefgbvmu;aQ<m,,a%CQ<csfbla%bQ<aN2!Q\
\ndbtf!aP2Q;m>aP2Q<a%!D12J!JGJHJOJQJFJSJJJMHS%HD12D12N3!N4\nJUJT%UQm>aP4HC%T\
Qs\\q,,^>m,2<m>aP4HC%SD12N1\nJNQm>s\\..q^aHC%NHb%GN1!D32P3%RN1UP1D12JPQUaP1H\
R%PN4\nQ<g\\(aP3Q(^>aP2Q,2<n\\(aP3Q(^>aP4Hb%OD12D12N2!N3\nJVP3Q,,<jg)aP3Q=>n\
\\(aP3Q(^*m>g\\(aP3Q(^<fmtf!m,,aHC%QN1!N1\nJ#Qqsjoug)#&e]o#-aP1Q*aHb%#Qqvut)\
aP1Q*aHb%FN1\nQm>::::aHC%VP3Q>bupj)hfut)c**aHb%JD12JON1!Qjg)a%LN1UP1D12JIQUa\
P1HL%IQ*m>aN2!N2\nP2Q<fmtf!m,,aHC%MN1!N2>P2Q>aN2\nP2Hbdd!b/d"";k;char R[4][99]
;main(c,v)char**v;{char*p,*r,*q;for(q=s;*q;q++)*q>' '&&(*q)--;{FILE*i=fopen(v
[1],""r""),*o=fopen(q-3,""w"");for(p=s;;p++)switch(*p++){B'M':Q(k=fgetc(i))!=EOF
&&k!=*p)*r++=k;if(k==EOF){fputs(""}}\n"",o);fclose(o);return system(q-6);}*r=0
B'P':while(*p!='`')fputc(*p++,o)B'O':Q*r)fputc(*r++,o);p--B'C':k=0;Q k<*p-'0'
)(*r++=fgetc(i),k++);*r=0 B'I':k= *p;if(**R==k)goto G B'G':k= *p;G:p=s;while(
*p!='$'||p[1]!= k)p++;p++B'N':R[*p-'0'][0]++;}}}
","main(a,b){while((a=getchar())+1)putchar((b=64^a&223)&&b<27?a&96|(b+12)%26+1:a);}
","#include <curses.h>
int u=484,X[]={-1,0,0,1},Y[]={0,1,-1,0},x,y,D,i,j,a;
char o,m,*t,*O=""MNOH"",*k=""hjkl"",*s=""######\0######\0######\0      \0      \0      \0  ___ \0 /   \\\0 \\___/\0  ___ \0 /@@@\\\0 \\@@@/\0| | /\\\0----||\0    \\/\0  /--\\\0   \\/ \0 ==|  \0 ==|  \0   /\\ \0  \\--/\0 /O__o\0 \\___/\0 /_\\_ \0  <<  \0  <<  \0  <<  \0      \0vvvvvv\0      \0      \0^^^^^^\0      \0  /\\  \0 <  > \0  \\/  \0o__O\\ \0\\___/ \0 _/_\\ \0 O__O \0/----\\\0_/  \\_\0 ^__^ \0/----\\\0_/  \\_"" ,
M[12][22]={""AAAAAAAAAAAAAAAAAAAAAA"" ,""ALCABBBBBBBABBCBBCABBA"", ""ACCABAKAAABAFBABABAEBA"", ""ABBBBABBIBBBBBEEABACLA"", ""ACCBNIBBAAAAGALBBBABCA"", ""AAAAAAAJACBABBCABAABCA"", ""ALLAACCBACBAAALLCABBBA"", ""ABDLAAABABCAAAALCABBLA"", ""ABCBIBBBBBBBBAAAAACBBA"", ""ABCCAABBADBBBBDBDBDBCA"", ""ALBBACCCCDBCABBBDBBBBA"", ""AAAAAAAAAAAAAAAAAAAAAA"" };main(){initscr();clear();
noecho();cbreak();x=y=4;D=39,o='M';m=M[y][x] ;while(D&&u){for(i=j=a=0;j<7;!(mvaddstr(
j*3+a,i*6,s+(((M[((y-1)/5)*5+j][((x-1)/10)*10+i]-'A')*3+a++)*7)),a^3)&&(a=0,!
(++i^12))&&(a=i=0,j++));refresh();M[y][x] ='B';if(t=(char*)strchr(k,getch())){int e=
x,g=y,f=x,h=y,d=t-k;o=O[d];f=(e=x+X[d])+X[d];h=(g=y+Y[d])+Y[d];switch(M[g][e] ){case
'B':x=e;y=g,u--;break ;case 'C':if(M[h][f] =='B')M[h][f] =M[g][e] ,x=e,y=g,u--; else if(M[h][f] =='C')M[h][f] =M[g][e] ='L';break ;case 'D':if(M[h][f] =='B')M[h][f] =M[g][e] ,x=e,y=g,u--; break ;case'L':x=e;y=g,u--;D
--;break ;case 'E':if(M[h][f] =='B')M[h][f] =M[g][e] ,x=e,y=g,u--; else if(M[h][f] =='I'&&d==0)M[h][f] =M[g][e] ='B';break ; case 'F':if(M[h][f] =='B')M[h][f] =M[g][e] ,x=e,y=g,u--; else if(M[h][f] =='J'&&d==1)M[h][f] =M[g][e] ='B';break ; case 'G':if(M[h][f] =='B')M[h][f] =M[g][e] ,x=e,y=g,u--; else if(M[h][f] =='K'&&d==2)M[h][f] =M[g][e] ='B';break ; }}m=M[y][x] ;M[y][x] =o;}clear();mvaddstr(12
,31,u?""Well done!"":""Too many moves"");move(23,0);refresh();endwin();return 0;}

","#include <curses.h>
#define R break
#define U M[h][f]
#define W M[g][e]
#define T M[y][x]
#define B(a) ""A""#a""A"",
#define A ""AAAAAAAAAAAAAAAAAAAAAA""
#define z(a) case a:if(U=='B')U=W,x=e,y=g,u--;
#define Z(a,b) else if(U==a&&d==b)U=W='B';R;
#define K(a) a##a##a
#define k(a) #a#a#a#a#a#a""\0""
#define V ""      \0""
#define S "" \0/----\\\0_/  \\_""
int u=484,X[]={-1,0,0,1},Y[]={0,1,-1,0},x,y,D,i,j,a;char o,m,*t,*O=""MNOH""
,*k=""hjkl"",*s=K(k(#))V V V""  ___ \0 /   \\\0 \\___/\0  ___ \0 /@@@\\\0 ""
""\\@@@/\0| | /\\\0----||\0    \\/\0  /--\\\0   \\/ \0 ==|  \0 ==|  \0  ""
"" /\\ \0  \\--/\0 /O__o\0 \\___/\0 /_\\_ \0""K(""  <<  \0"")V k(v)V V k(^)V
""  /\\  \0 <  > \0  \\/  \0o__O\\ \0\\___/ \0 _/_\\ \0 O__O""S""\0 ^__^""S,
M[12][22]={A,B(LCABBBBBBBABBCBBCABB)B(CCABAKAAABAFBABABAEB
)B(BBBBABBIBBBBBEEABACL)B(CCBNIBBAAAAGALBBBABC)B(AAAAAAJACBABBCABAABC
)B(LLAACCBACBAAALLCABBB)B(BDLAAABABCAAAALCABBL)B(BCBIBBBBBBBBAAAAACBB
)B(BCCAABBADBBBBDBDBDBC)B(LBBACCCCDBCABBBDBBBB)A};main(){initscr();clear();
noecho();cbreak();x=y=4;D=39,o='M';m=T;while(D&&u){for(i=j=a=0;j<7;!(mvaddstr(
j*3+a,i*6,s+(((M[((y-1)/5)*5+j][((x-1)/10)*10+i]-'A')*3+a++)*7)),a^3)&&(a=0,!
(++i^12))&&(a=i=0,j++));refresh();T='B';if(t=(char*)strchr(k,getch())){int e=
x,g=y,f=x,h=y,d=t-k;o=O[d];f=(e=x+X[d])+d[X];h=(g=y+Y[d])+d[Y];switch(W){case
'B':x=e;y=g,u--;R;z('C')else if(U=='C')U=W='L';R;z('D')R;case'L':x=e;y=g,u--;D
--;R;z('E')Z('I',0)z('F')Z('J',1)z('G')Z('K',2)}}m=T;T=o;}clear();mvaddstr(12
,31,u?""Well done!"":""Too many moves"");move(23,0);refresh();endwin();return 0;}

","#include <curses.h>
int u=484,X[]={-1,0,0,1},Y[]={0,1,-1,0},x,y,D,i,j,a;
char o,m,*t,*O=""MNOH"",*k=""hjkl"",*s=""######\0######\0######\0      \0      \0      \0  ___ \0 /   \\\0 \\___/\0  ___ \0 /@@@\\\0 \\@@@/\0| | /\\\0----||\0    \\/\0  /--\\\0   \\/ \0 ==|  \0 ==|  \0   /\\ \0  \\--/\0 /O__o\0 \\___/\0 /_\\_ \0  <<  \0  <<  \0  <<  \0      \0vvvvvv\0      \0      \0^^^^^^\0      \0  /\\  \0 <  > \0  \\/  \0o__O\\ \0\\___/ \0 _/_\\ \0 O__O \0/----\\\0_/  \\_\0 ^__^ \0/----\\\0_/  \\_"" ,
M[12][22]={""AAAAAAAAAAAAAAAAAAAAAA"" ,""ALCABBBBBBBABBCBBCABBA"", ""ACCABAKAAABAFBABABAEBA"", ""ABBBBABBIBBBBBEEABACLA"", ""ACCBNIBBAAAAGALBBBABCA"", ""AAAAAAAJACBABBCABAABCA"", ""ALLAACCBACBAAALLCABBBA"", ""ABDLAAABABCAAAALCABBLA"", ""ABCBIBBBBBBBBAAAAACBBA"", ""ABCCAABBADBBBBDBDBDBCA"", ""ALBBACCCCDBCABBBDBBBBA"", ""AAAAAAAAAAAAAAAAAAAAAA"" };main(){initscr();clear();
noecho();cbreak();x=y=4;D=39,o='M';m=M[y][x] ;while(D&&u){for(i=j=a=0;j<7;!(mvaddstr(
j*3+a,i*6,s+(((M[((y-1)/5)*5+j][((x-1)/10)*10+i]-'A')*3+a++)*7)),a^3)&&(a=0,!
(++i^12))&&(a=i=0,j++));refresh();M[y][x] ='B';if(t=(char*)strchr(k,getch())){int e=
x,g=y,f=x,h=y,d=t-k;o=O[d];f=(e=x+X[d])+X[d];h=(g=y+Y[d])+Y[d];switch(M[g][e] ){case
'B':x=e;y=g,u--;break ;case 'C':if(M[h][f] =='B')M[h][f] =M[g][e] ,x=e,y=g,u--; else if(M[h][f] =='C')M[h][f] =M[g][e] ='L';break ;case 'D':if(M[h][f] =='B')M[h][f] =M[g][e] ,x=e,y=g,u--; break ;case'L':x=e;y=g,u--;D
--;break ;case 'E':if(M[h][f] =='B')M[h][f] =M[g][e] ,x=e,y=g,u--; else if(M[h][f] =='I'&&d==0)M[h][f] =M[g][e] ='B';break ; case 'F':if(M[h][f] =='B')M[h][f] =M[g][e] ,x=e,y=g,u--; else if(M[h][f] =='J'&&d==1)M[h][f] =M[g][e] ='B';break ; case 'G':if(M[h][f] =='B')M[h][f] =M[g][e] ,x=e,y=g,u--; else if(M[h][f] =='K'&&d==2)M[h][f] =M[g][e] ='B';break ; }}m=M[y][x] ;M[y][x] =o;}clear();mvaddstr(12
,31,u?""Well done!"":""Too many moves"");move(23,0);refresh();endwin();return 0;}

","		a(X){/*/X=-		a(X){/*/X=-
		-1;F;X=-		-1;F;X=-
		-1;F;}/*/		-1;F;}/*/
char*z[]={""char*z[]={"",""a(X){/*/X=-"",""-1;F;X=-"",""-1;F;}/*/"",""9999999999  :-| "",
""int q,i,j,k,X,O=0,H;S(x)int*x;{X+=X;O+=O;*x+1?*x+2||X++:O++;*x=1;}L(n){for(*"",
""z[i=1]=n+97;i<4;i++)M(256),s(i),M(128),s(i),M(64),N;X*=8;O*=8;}s(R){char*r=z"",
""[R];for(q&&Q;*r;)P(*r++);q&&(Q,P(44));}M(m){P(9);i-2||P(X&m?88:O&m?48:32);P("",
""9);}y(A){for(j=8;j;)~A&w[--j]||(q=0);}e(W,Z){for(i-=i*q;i<9&&q;)y(W|(1<<i++&"",
""~Z));}R(){for(k=J[*J-48]-40;k;)e(w[k--],X|O);}main(u,v)char**v;{a(q=1);b(1);"",
""c(1);*J=--u?O?*J:*v[1]:53;X|=u<<57-*v[u];y(X);K=40+q;q?e(O,X),q&&(K='|'),e(X"",
"",O),R(),O|=1<<--i:J[*J-48+(X=O=0)]--;L(q=0);for(s(i=0);q=i<12;)s(i++),i>4&&N"",
"";s(q=12);P(48);P('}');P(59);N;q=0;L(1);for(i=5;i<13;)s(i++),N;L(2);}"",0};
		b(X){/*/X=-		b(X){/*/X=-
		-1;F;X=-		-1;F;X=-
		-1;F;}/*/		-1;F;}/*/
int q,i,j,k,X,O=0,H;S(x)int*x;{X+=X;O+=O;*x+1?*x+2||X++:O++;*x=1;}L(n){for(*
z[i=1]=n+97;i<4;i++)M(256),s(i),M(128),s(i),M(64),N;X*=8;O*=8;}s(R){char*r=z
[R];for(q&&Q;*r;)P(*r++);q&&(Q,P(44));}M(m){P(9);i-2||P(X&m?88:O&m?48:32);P(
9);}y(A){for(j=8;j;)~A&w[--j]||(q=0);}e(W,Z){for(i-=i*q;i<9&&q;)y(W|(1<<i++&
~Z));}R(){for(k=J[*J-48]-40;k;)e(w[k--],X|O);}main(u,v)char**v;{a(q=1);b(1);
c(1);*J=--u?O?*J:*v[1]:53;X|=u<<57-*v[u];y(X);K=40+q;q?e(O,X),q&&(K='|'),e(X
,O),R(),O|=1<<--i:J[*J-48+(X=O=0)]--;L(q=0);for(s(i=0);q=i<12;)s(i++),i>4&&N
;s(q=12);P(48);P('}');P(59);N;q=0;L(1);for(i=5;i<13;)s(i++),N;L(2);}
		c(X){/*/X=-		c(X){/*/X=-
		-1;F;X=-		-1;F;X=-
		-1;F;}/*/		-1;F;}/*/
","/* . wc . */
#include<stdio.h>/* Wht majr flwchrt? */
#include<string.h>/* That mjr flwchrt! */
#define P 257
#define G 17
#define z 8
#define v(jr) jr
int W ,head;
#define S(W,b,f) strncpy(W,b,f),W[f]=0\

  
char *wcs="" \t\n"";
struct{ char X[z+1]; 
        char f ;
        int e ; 
        struct{ char g[z+1];
                int b ;
              } w[ G];
      } o[ P];
int L=0,j= -28;


void E(int i, int m,char*c)
{   
 for(; i<43; i+=3) 
   putc(""}|uutsrq`_^bji`[Zkediml[PO]a_M__]ISOYIRGTNR""[i]+i-9,stderr);
 fprintf(stderr,""(%d): %s\n"" ,m,c);
 exit(1);
}



int N(int m, char *t)
{ 
  int i ;
  if (strlen ( 
              t)>z) t[z ]=0;
  for(i= 0; i< L ; i++) if(
                           !strcmp (o[ i] . X
                                             , t))return i;
  if( L== P)
             E(0, m, t);
  S (o[ L] . X , t
                  ,z);
  head; W = .1* head;
  o[L ].f = !( strchr( t,']' )== 0 );
  o[L ++ ] . e = 0;
  return L -1 ; }

#define v(x )

int A(char *R)
{
  int c=0, i;
  while(* R) {
    i = -1;
    while(j){
      if( ++ i==o[ c].e ) return 0;
      if(o[ 
           c] .w[i ] .g[0 ] 
                            =='.' ||strchr (o[ c].w[i] .g ,* R)){
      c=
        o[ c ] .w[i].b; break;/*
main(int sl,char *j[]){
      sleep (~~~~~~~~atoi(j[1])) ;/* . sl
      sl s l . sl
      l l ]
      sl */ }
    }
    R++;
  }
  return o[ c].f;
}


 main(int wc,char *V[]){char Y[999],*s;FILE*W;int m=0,echo,jr,q,wcl=0,wcw=0,wcc=0;
 v(s = V[1]; if (*V=strrchr(s,'/'))s=*V+1;  if(( !strncmp( s + (jr=strlen(s)) -
  (q=strlen(V[2]) ),V[2],q))&&jr!=q) s[jr-q] = 0;  puts(s); )
 int e,p,C=0,Q ,basename;
 W= fopen(wc>= 2 ? V[1] : ""adgrep.c"",""rt"");
echo| m^ e| 5| (int) .8| echo|
wc |C ==o[o[C] .e] . 
e| e==+p,p; s[o[C] .e ] 
;
while( fgets(Y,998,W)) { wcc += strlen(Y); m++;
     if( s = strtok(Y,wcs)) wcw++;
     else continue ;
     C=
       basename= j +j+*""* . basename"" 
                +j+*""* r ] "" + N(m,s) ;
while( s = strtok(0,wcs)) {
       if( o[ C ] . e == 
                         G) E(1 ,m,o[C] .X) ;
       S(o[C
             ] .w[o[C ] .e].g,s, z);
       Q= C ;
       if(! ( s =strtok ( 0 ,wcs )))wcw --
       ,E( 2 , m, o[C]
                   . w[ o[ Q ] .e] . g );
       e
         = o[C ] .w[o[C ] .e++ ] .b= N(m,s)
       ; wcw += 2; }  
     0&& 
        W && wcl++
                  < 10 && printf((W,Y)); }
   if(j+28) { {
                ; } printf(""%7u%7u%7u\n"", wcl , wcw , wcc); }
   while( gets(Y) ) if(A(Y)) puts(Y);
   W, jr; }

O(int wc,char**V) {
--wc && (printf(""%s "",*++V), main(wc,V), 1) || printf(""\n""); }

","/* . wc . */
#include<stdio.h>/* Wht majr flwchrt? */
#include<string.h>/* That mjr flwchrt! */
#define P 257
#define G 17
#define z 8
#define v(jr) jr
int W ,head;
#define S(W,b,f) strncpy(W,b,f),W[f]=0\

  
char *wcs="" \t\n"";
struct{ char X[z+1]; 
        char f ;
        int e ; 
        struct{ char g[z+1];
                int b ;
              } w[ G];
      } o[ P];
int L=0,j= -28;


void E(int i, int m,char*c)
{   
 for(; i<43; i+=3) 
   putc(i[""}|uutsrq`_^bji`[Zkediml[PO]a_M__]ISOYIRGTNR""]+i-9,stderr);
 fprintf(stderr,""(%d): %s\n"" ,m,c);
 exit(1);
}



int N(int m, char *t)
{ 
  int i ;
  if (strlen ( 
              t)>z) t[z ]=0;
  for(i= 0; i< L ; i++) if(
                           !strcmp (o[ i] . X
                                             , t))return i;
  if( L== P)
             E(0, m, t);
  S (o[ L] . X , t
                  ,z);
  head; W = .1* head;
  o[L ].f = !( strchr( t,']' )== 0 );
  o[L ++ ] . e = 0;
  return L -1 ; }

#define v(x )

int A(char *R)
{
  int c=0, i;
  while(* R) {
    i = -1;
    while(j){
      if( ++ i==o[ c].e ) return 0;
      if(o[ 
           c] .w[i ] .g[0 ] 
                            =='.' ||strchr (o[ c].w[i] .g ,* R)){
      c=
        o[ c ] .w[i].b; break;/*
main(int sl,char *j[]){
      sleep (~~~~~~~~atoi(j[1])) ;/* . sl
      sl s l . sl
      l l ]
      sl */ }
    }
    R++;
  }
  return o[ c].f;
}


 main(int wc,char *V[]){char Y[999],*s;FILE*W;int m=0,echo,jr,q,wcl=0,wcw=0,wcc=0;
 v(s = V[1]; if (*V=strrchr(s,'/'))s=*V+1;  if(( !strncmp( s + (jr=strlen(s)) -
  (q=strlen(V[2]) ),V[2],q))&&jr!=q) s[jr-q] = 0;  puts(s); )
 int e,p,C,Q ,basename;
 W= fopen(wc>= 2 ? V[1] : ""adgrep.c"",""rt"");
echo| m^ e| 5| (int) .8| echo|
wc |C ==o[o[C] .e] . 
e| e==+p,p; s[o[C] .e ] 
;
while( fgets(Y,998,W)) { wcc += strlen(Y); m++;
     if( s = strtok(Y,wcs)) wcw++;
     else continue ;
     C=
       basename= j +j+*""* . basename"" 
                +j+*""* r ] "" + N(m,s) ;
while( s = strtok(0,wcs)) {
       if( o[ C ] . e == 
                         G) E(1 ,m,o[C] .X) ;
       S(o[C
             ] .w[o[C ] .e].g,s, z);
       Q= C ;
       if(! ( s =strtok ( 0 ,wcs )))wcw --
       ,E( 2 , m, o[C]
                   . w[ o[ Q ] .e] . g );
       e
         = o[C ] .w[o[C ] .e++ ] .b= N(m,s)
       ; wcw += 2; }  
     0&& 
        W && wcl++
                  < 10 && printf((W,Y)); }
   if(j+28) { {
                ; } printf(""%7u%7u%7u\n"", wcl , wcw , wcc); }
   while( gets(Y) ) if(A(Y)) puts(Y);
   W, jr; }

O(int wc,char**V) {
--wc && (printf(""%s "",*++V), main(wc,V), 1) || printf(""\n""); }

","#include <stdio.h>
#include <malloc.h>
#include <setjmp.h>
#include <ctype.h>
#define new(PP) (PP *) malloc(sizeof(PP)) 
typedef struct q {
    jmp_buf ppp;
    long qq;
    struct q *P;
    struct q *p;
} 
PP;

PP *P;
int aaaaaa=2;
int aaaaaaa=1;

long qqq;


aaAaaa(aa,aaa)
char *aa;
char *aaa;
{
    char aaaa = 0;
    if ((((( aaa )))))
    {
        aaaa = *aa;
        *aa=0;
        aa+=strlen(aa+1);
        P =new(PP);
        P->P=P;
        P->p=P;
    }

    if ((((( !setjmp(P->ppp) ))))) 
        {
        if ((((( !isdigit(*aa) )))))
            longjmp(P->ppp,aaaaaaa);
        else {
            P->p->P = new(PP);
            P->p->P->P = P;
            P->p->P->p = P->p;
            P->p = P->p->P;

            P->qq = *aa--;
            P = P->p;
            aaAaaa(aa,0);
        }
    } else {
        if ( !aaaa&&!*aa ) 
           longjmp(P->p->ppp,aaaaaaa);

        if ((((( (P->qq=aaaa)<10     &&!
                 (isdigit(aaaa))     ||!
                 (isdigit(*aa)       ||!
                 *aa                        )))))) 
        {
            fprintf(stderr,""Usage %c%s <number>\n"",
            (aaa[0]?7:aaaa),aaa+!aaa[0]);
            exit(1);
        }
    }
}


ppPppp(pp,ppp)
PP **pp, *ppp;
{
    int aa;
    if ((((( !(aa=setjmp(ppp->ppp))||aa==aaaaaa )))))
    {
        if ((((( *pp==ppp )))))
        {
            ppp = (*pp)->p;

            if ( qqq<47 ) return;
            if ( ppp->qq!=48 ) return;

            while ( ppp->qq==48 ) 
            {
                printf(""%ld\n"",qqq-45);
                *pp = ppp;
                ppp = ppp->p;
            }
            qqq -= 1;
            longjmp(ppp->ppp,aaaaaaa);
        } else {
            PP *p;

            ppPppp(pp,ppp->p);
            for (p=ppp;p!=*pp;p=p->p)
            {
                int qq=4;
                if ((((( qqq<47                            &&
                         (qq=0,p->qq+=p->p->qq-96)>=48-qqq ||
                         qqq>46                            &&
                         (p->qq-=p->p->qq)<0                   ))))) 
                {
                    p->qq += qqq+qq;
                    if ( p->p==P && qqq<=46 )
                    {
                        P->p->P = new(PP);
                        P->p->P->P = P;
                        P->p->P->p = P->p;
                        *pp = P = P->p = P->p->P;
                        P->qq = 48;
                    }

                    p->p->qq+=qq==0;
                    p->p->qq-=qq!=0;
                }
                else
                {
                    p->qq += 48;
                }
            }
            if ( ppp->P==P ) longjmp(ppp->ppp,aaaaaaa);
        }
    }
    else
    {
        qqq += 1; 

        while (48==P->qq )
        {
            P->P->p = P->p;
            P = P->p->P = P->P;

        }

        if ( ppp!=ppp->p->p || qqq<47 )
            longjmp(ppp->ppp,aaaaaa);
        else
        {
            printf(""At most one remains\n"");
            exit(0);
        }
    }
}


main(aaa,aaaa)
int aaa;
char **aaaa;
{
    aaAaaa(aaa==aaaaaaa?aaaa[0]:aaaa[1],aaaa[0]);
    qqq = 39;
    ppPppp(&P,P->p);
}


","#include <stdio.h>

main(argc,argv)
int argc;
char **argv;
{
        long arg[100];
        int i,j;
        int base = 10;
        int start = 0;
        int end= strlen(argv[1]);


        for (i=0;i<end;i++)
                 arg[i] = argv[1][i]-'0';

        while ( end-start > 2 )
        {
                while ( arg[end-1] == 0 ) {
			printf(""%d\n"",base);
			end--;
		}
                while ( arg[start] == 0 ) start +=1;
                base += 1;

                for (i=start+1;i<end;i++)
                        for (j=i;j>start;j--)
                                if ( (arg[j]-=arg[j-1])<0 )
                                {
                                    arg[j]+=base;
                                    arg[j-1] -= 1;
                                }
        }
}
","#include <stdio.h>
#include <malloc.h>
#include <setjmp.h>
#include <ctype.h>
#define new(PP) (PP *) malloc(sizeof(PP)) 
typedef struct q {
    jmp_buf ppp;
    long qq;
    struct q *P;
    struct q *p;
} 
PP;

PP *P;
int aaaaaa=2;
int aaaaaaa=1;

long qqq;


aaAaaa(aa,aaa)
char *aa;
char *aaa;
{
    char aaaa = 0;
    if ((((( aaa )))))
    {
        aaaa = *aa;
        *aa=0;
        aa+=strlen(aa+1);
        P =new(PP);
        P->P=P;
        P->p=P;
    }

    if ((((( !setjmp(P->ppp) ))))) 
        {
        if ((((( !isdigit(*aa) )))))
            longjmp(P->ppp,aaaaaaa);
        else {
            P->p->P = new(PP);
            P->p->P->P = P;
            P->p->P->p = P->p;
            P->p = P->p->P;

            P->qq = *aa--;
            P = P->p;
            aaAaaa(aa,0);
        }
    } else {
        if ( !aaaa&&!*aa ) 
           longjmp(P->p->ppp,aaaaaaa);

        if ((((( (P->qq=aaaa)<10     &&!
                 (isdigit(aaaa))     ||!
                 (isdigit(*aa)       ||!
                 *aa                        )))))) 
        {
            fprintf(stderr,""Usage %c%s <number>\n"",
            (aaa[0]?7:aaaa),aaa+!aaa[0]);
            exit(1);
        }
    }
}


ppPppp(pp,ppp)
PP **pp, *ppp;
{
    int aa;
    if ((((( !(aa=setjmp(ppp->ppp))||aa==aaaaaa )))))
    {
        if ((((( *pp==ppp )))))
        {
            ppp = (*pp)->p;

            if ( qqq<47 ) return;
            if ( ppp->qq!=48 ) return;

            while ( ppp->qq==48 ) 
            {
                printf(""%ld\n"",qqq-45);
                *pp = ppp;
                ppp = ppp->p;
            }
            qqq -= 1;
            longjmp(ppp->ppp,aaaaaaa);
        } else {
            PP *p;

            ppPppp(pp,ppp->p);
            for (p=ppp;p!=*pp;p=p->p)
            {
                int qq=4;
                if ((((( qqq<47                            &&
                         (qq=0,p->qq+=p->p->qq-96)>=48-qqq ||
                         qqq>46                            &&
                         (p->qq-=p->p->qq)<0                   ))))) 
                {
                    p->qq += qqq+qq;
                    if ( p->p==P && qqq<=46 )
                    {
                        P->p->P = new(PP);
                        P->p->P->P = P;
                        P->p->P->p = P->p;
                        *pp = P = P->p = P->p->P;
                        P->qq = 48;
                    }

                    p->p->qq+=qq==0;
                    p->p->qq-=qq!=0;
                }
                else
                {
                    p->qq += 48;
                }
            }
            if ( ppp->P==P ) longjmp(ppp->ppp,aaaaaaa);
        }
    }
    else
    {
        qqq += 1; 

        while (48==P->qq )
        {
            P->P->p = P->p;
            P = P->p->P = P->P;

        }

        if (ppp!=ppp->p->p )
            longjmp(ppp->ppp,aaaaaa);
        else
        {
            printf(""At most one remains\n"");
            exit(0);
        }
    }
}


main(aaa,aaaa)
int aaa;
char **aaaa;
{
    aaAaaa(aaa==aaaaaaa?aaaa[0]:aaaa[1],aaaa[0]);
    qqq = 39;
    ppPppp(&P,P->p);
}


","#define W while
#define S strspn 
#define R return 
#define F fprintf(stderr,
#define C continue;

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>

#ifndef RULES
#define RULES	500
#endif

#define N(p, i)	(p += i, p += S(p, w), i = strcspn(p, w))

char *b, l[BUFSIZ], *t[RULES], *d[RULES], *c[RULES], w[] = ""\n\t "";

time_t M();
int T();
void U();


time_t
M(f)
char *f;
{
	int j, x;
	size_t i = 0;
	struct stat s;
	N(f, i);
	x = f[i];
	f[i] = 0; 
	j = stat(f, &s);
	f[i] = x;
	R j < 0 ? 0 : s.st_mtime;
}

int
T(f)
char *f;
{
	char *q;
	size_t i = 0, j, k = 1;
	N(f, i);
	W ((q = t[k])) {
		j = 0;
		W (N(q, j)) {
			if (i == j && !strncmp(f, q, i))
				R k;
		}
		++k;
	}
	R 0;
}

void
U(f)
char *f;
{
	time_t t = M(f);
	size_t i = 0, j = !t, k = T(f);
	char *p = d[k], *q = c[k];
	if (!N(p, i) && q && *q != '\t' && j) {
		F ""am: Don't know how to make '%s'.\n"", f);
		exit(1);
	}
	W (0 < i) {
		U(p);
		if (t < M(p))
			j = 1;
		N(p, i);
	}
	if (j && q && *q == '\t') {
		sleep(1);
		W (*q++ == '\t') {
			i = j = 1;
			W (0 < S(q, ""-+@"")) {
				if (*q == '@')
					
					i = 0;
				if (*q++ == '-')
					
					j = 0;
			}
			if (i)
				puts(q);
			if (system(q) && j) {
				F ""am: Error making '%s'\n"", f);
				exit(1);
			}
			q += strlen(q) + 1;
		}
		c[k] = 0;
	}
}

int
main(u, v)
int u;
char **v;
{
	FILE *f;
	struct stat s;
	size_t i, j, k;
	char *m, *n, *p, *q, *r;
	if (u < 2) {
		F ""usage: am <makefile> [target]\n"");
		R 2;
	}
	if (stat(*++v, &s) || !(f = fopen(*v, ""r"")))
		R 3;
	q = b = malloc(2*s.st_size);
	if (!b)
		R 4;
	i = 1;
	k = 0;
	m = 0;
	*t = *d = *c = """";
	W ((r = fgets(l, BUFSIZ, f))) {
		if (RULES <= i) {
			F ""am: Number of target-rules exceeds %d.\n"", RULES);
			R 1;
		}
		if (k) {
			*q++ = ' ';
			r += S(r, w);
		} else {
			if (t[i])
				c[i++] = q;
			if (m && putenv(m))
				F ""am: No more environment space.\n"");
			m = 0;
			if (*l == '#' || *l == '\n')
				C
			p = q;
		}
		W (!(k = *r == '\\' && r[1] == '\n') && *r) {
			if (*r == '$') {
				if (r[1] == '(') {
					n = r+2;
					r += strcspn(r, "")"");
					*r++ = 0;
					n = getenv(n);
					if (n) 
						q = strcpy(q, n) + strlen(n);
					C
				}
				if (*r == r[1])
					++r;
			} 
			if (*r == '=' && *l != '\t' && !m) {
				*q = 0;
				m = p;
				j = 0;
				q = N(m, j) + m;
				*q++ = *r;
				j = 1;
				if (!N(r, j))
					*q++ = 0;
				C
			}
			if (*r == ':') {
				t[i] = p;
				*r = 0;
				d[i] = q+1;
			}
			if (*r == '\n')
				*r = 0;
			*q++ = *r++;
		}
	}
	fclose(f);
	U(2 < u ? *++v : t[1]);
	R 0;
}

","#define A(c,a,b) t=b;t+=a;_(c)
#define	B(b,a) P(u,a)t=0;t-=a;R t+=u;t+=1;t/=2;_(b)
#define b(x) x(g)
#define C ;main(argc,argv)char**argv;{for(;!w;){q=0;l
#define c(y) x
#define D(c,a,b) t=a;t/=b;_(c)
#define d(x) S(x,x,1)
#define E(a,d) t=d;t-=p;t*=r;t*=a;p+=t;t=1;t-=a;r*=t;
#define e(x) y
#define f(x) x(e)
#define G(x,y) Q(x,atoi(argv[y]))
#define g(x) x(b)
#define H Q(w,1)Q(p,0)r=0;
#define h(x) x(c)
#define i(c,a,b) a(b,b,c)
#define J(x) Q(p,x)r=0;
#define j(x) Q(f(g),x)
#define K(x) Q(x,argc)
#define k(x) S(a,y,x)
#define L(x) u=p;u-=x;t=u;t*=u;R r+=2;r-=t;r/=2;
#define l L(q) q+=1;
#define M(c,a,b) t=a;t*=b;_(c)
#define m(x) x(a,a)
#define n(x) x(a,y)
#define O(c,a,b) t=b;t+=1;t+=a;t/=2;Q(c,t)
#define o(x,y) M(x,x,y)
#define P(b,a) t=a;R _(b)
#define R t+=2047;t/=2048;t+=8191;t/=8192;
#define Q(a,b) t=b;_(a)
#define S(c,a,b) t=a;t-=b;_(c)
#define T }
#define U(c,a,b) u=b;t=b;t-=1;t*=r;t+=1;b=t;t=a;t/=b;b=u;_(c)
#define V int t,u,q,p=0,r,w=0,
#define X(y) printf(""%x\n"",y);
#define Z(a,d) t=p;t-=d;t*=a;t+=d;_(p)r*=a;
#define _(a) t-=a;t*=r;a+=t;

V a,x,y,s C

	    G(f(g),q)G(          g(h),2)n(B)Z(a,4)n(
	P)E(a,1)j(2989)H l k     (1)m(B)Z(a,6)l k(h(b))
      B(s,a             )m(P)        Z(s             ,8)E
    (a,q                   )Q(       s,h               (g)
   )Q(                               f(c                ),f
  (g)                                )j(                s)l
  i(b                                (h)                ,S,
 f(b                                 ))n               (B)
 E(a                                 ,2)             J(8)
l j(                                x)Q(x,1)l n(P)Z(a,8
)o(x                                ,g(f))d(f(e))J(5)l j
(x)l                                 d(x              )S(a
 ,x,                                 1)m                (B)
  Z(a                                ,10                 )U(
  a,y                                ,x)                 o(a
   ,x)                               k(a                 )m(
    P)E(                   a,7)      l j                (0)
      Q(s,1            )l D(a        ,x,              q)o(
	a,q)S(a,h(g),a)i(s,       M,a)i(a,A,g(f))i(q,D,x
	    )o(s,16)B(a          ,x)E(a,9)H l j(2766)H

T  X(b(f))  T
","#define c m[m[0]++] =
#define z;break;case

char s[5000];
int m[20000]={32},L=1,I,T[500],*S=T,t=64,w,f;

a(x)
{
   c L;
   L= *m-1;
   c t;
   c x;
   scanf(""%s"",s+t);
   t+=strlen(s+t)+1;
}

r(x)
{
   switch(m[x++]){
	z 5:	for(w=scanf(""%s"",s)<1?exit(0),0:L;strcmp(s,&s[m[w+1]]);w=m[w]);
		w-1 ? r(w+2) : (c 2,c atoi(s))
	z 12:	I=m[m[1]--]
	z 15:	f=S[-f]
	z 1:	c x 
	z 9:	f *=* S--
	z 7:	m[f]= *S--;
		f= *S--
	z 0:	*++S=f;
		f=m[I++]
	z 8:	f= *S --- f
	z 2:	m[++m[1]]=I;
		I=x
	z 11:	f=0>f
	z 4:	*m-=2;c 2
	z 6:	f=m[f]
	z 10:	f= *S--/f
	z 3:	a(1);
		c 2
	z 13:	putchar(f);
		f= *S--
	z 14:	*++S=f;
		f=getchar();
   }
}

main()
{
   a(3);
   a(4);
   a(1);
   w= *m;
   c 5;
   c 2;
   I= *m;
   c w;
   c I-1;
   for(w=6;w<16;)
      a(1),c w++;
   m[1]= *m;
   for(*m+=512;;r(m[I++]));
}
","#define c 0 [m] ++ [m] =
#define z;break;case

char s[5000];
int m[20000]={32},L=1,I,T[500],*S=T,t=64,w,f;

a(x)
{
   c L;
   L= *m-1;
   c t;
   c x;
   scanf(""%s"",s+t);
   t+=strlen(s+t)+1;
}

r(x)
{
   switch(x++[m]){
	z 5:	for(w=scanf(""%s"",s)<1?exit(0):L;strcmp(s,&w[&m[1]][s]);w=m[w]);
		w-1 ? r(w+2) : (c 2,c atoi(s))
	z 12:	I=1[m]--[m]
	z 15:	f=S[-f]
	z 1:	c x 
	z 9:	f *=* S--
	z 7:	m[f]= *S--;
		f= *S--
	z 0:	*++S=f;
		f=I++[m]
	z 8:	f= *S --- f
	z 2:	m[++1[m]]=I;
		I=x
	z 11:	f=0>f
	z 4:	*m-=2;c 2
	z 6:	f=f[m]
	z 10:	f= *S--/f
	z 3:	a(1);
		c 2
	z 13:	putchar(f);
		f= *S--
	z 14:	*++S=f;
		f=getchar();
   }
}

main()
{
   a(3);
   a(4);
   a(1);
   w= *m;
   c 5;
   c 2;
   I= *m;
   c w;
   c I-1;
   for(w=6;w<16;)
      a(1),c w++;
   m[1]= *m;
   for(*m+=512;;r(m[I++]));
}
","#include <stdio.h> 

long a
[4],b[
4],c[4]
,d[0400],e=1;
typedef struct f{long g
,h,i[4]	   ,j;struct f*k;}f;f g,*
l[4096		     ]; char h[256],*m,k=3;
		     long n	(o, p,q)long*o,*p,*q;{
		     long r		  =4,s,i=0;for(;r--;s=i^
		     *o^*p,			    i=i&*p|(i|*p)&~*o++,*q
		     ++=s,p			    ++);return i;}t(i,p)long*p
		     ;{*c=d		  [i],n(a,c,b),n(p,b,p);}u(j)f*j;{j->h
		     =(j->g	=j->i[0]|j->i[1]|j->i[2]|j->i[3])&4095;}v(
j,s)f*		     j; {int i; for(j->k->k&&v(j->k, ' '),fseek(
stdin,	   j->j, 0);i=getchar(),putchar(i-'\n'?i:s),i-
'\n';);}w(o,r,j,x,p)f*o,*j;long p;{f q;int 
s,i=o->h;q.k=o;r>i?j=l[r=i]:r<i&&
(s=r&~i)?(s|=s>>1, s|=s
>>2,s|=s>>4,s
|=s>>8
,j=l[r
=((r&i
			 |s)&~(s>>1))-1&i]):0;--x;for
		 (;x&&!(p&i);p>>=1);for(;!x&&j;n(o->i,j->i,q.
	    i),u(&q),q.g||(q.j=j->j,v(&q,'\n')),j=j->k);for(;x;j=x
	 ?j->k:0){for(;!j&&((r=(r&i)-1&i)-i&&(r&p)?2:(x=0));j=l[r]);!
      x||(j->g&~o->g)||n			      (o->i,j->i,q.i)||(
    u(&q), q.j=j					      ->j,q.g?w(&q
   ,r,j->k,x							  ,p):v(&q,
  '\n'));							     }}y(){f
 j;char								       *z,*p;
for(;m									? j.j=
ftell(									stdin)
,7,(m=			     gets(m					))||w(
&g,315			     *13,l[					4095]
 ,k,64*			     64)&0:				       0;n(g
  .i,j.i,		     b)||(u				    (&j),j.
   k=l[j.h],l[j.h]= &j,y())){for(z=				p=h;*z&&(
    d[*z++]||(p=0)););for(z=p?n(j.i			  ,j.i,j.i)+h:"""";
  *z;t(*z++,j.i));}}main(o,p)char**		 p; {for(;m = *++p;)for(;*m-
'-'?*m:(k= -atoi(m))&0;d[*m]||(d[*m		 ]=e,e<<=1),t(*m++,g.i)); u(&
			     g),m=h
			     ,y();}
","#include		     <stdio.h> 
#include		     <malloc.h> 
#define			  ext(a) (exit(a),0)
#define I		  "" .:\';+<?F7RQ&%#*""
#define a			""%s?\n""
#define n			""0?\n""
#define C			double	
#define o			 char
#define l			 long
#define L			sscanf
#define i			stderr
#define e			stdout
#define r		       ext   (1)
#define s(O,B)	   L(++J,O,&B)!=1&&c>++q&&L(v[q],O,&B)!=1&&--q
#define F(U,S,C,A) t=0,*++J&&(t=L(J,U,&C,&A)),(!t&&c>++q&&!(t=L(v[q],U,\
		   &C,&A)))?--q:(t<2&&c>++q&&!(t=L(v[q],S,&A))&&--q
#define T(E)		(s(""%d"",E),E||(fputs(n,i),r))
#define d(C,c)		  (F(""%lg,%lg"",""%lg"",C,c)))
#define O	   (F(""%d,%d"",""%d"",N,U),(N&&U)||(fputs(n,i),r)))
#define D		      (s(""%lg"",f))
#define E			  putc
					       C
						G=0,
						R
					     =0,Q,H
					    ,M,P,z,S
					     =0,x=0
				 ,        f=0;l b,j=0,	      k
				  =128,K=1,V,B=0,Y,m=128,p=0,N
				 =768,U=768,h[]={0x59A66A95,256
			     ,192,1,6912,1,0,0},t,A=0,W=0,Z=63,X=23
			    ;o*J,_;main(c,v)l c;o**v;{l q=1;for(;;q<
		  c	   ?(((J=v[q])[0]&&J[0]<48&&J++,((_= *J)<99||
		_/2==	   '2'||(_-1)/3=='\""'||_==107||_/05*2==','||_
	      >0x074)?(   fprintf(i,a,v[q]),r):_>0152?(_/4>27?(_&1?(
	     O,Z=N,X=U):  (W++,N=Z,U=X)):_&1?T(K):T(k)):_>103?(d(G,
	R    ),j=1):_&1? d(S,x):D,q++),q--,main(c-q,v+q)):A==0?(A=
  1,f||(f=N/4.),b=(((N-1)&017)<8),q=(((N+7)>>3)+b)*U,(J=malloc(q)
  )||(perror(""malloc""),r),S-=(N/2)/f,x+=(U/2)/f):A==1?(B<U?(A=2,V
	=    0,Q=x-B/f,j ||(R=Q),W&&E('\n',e),E(46,i)):(W&&E('\n',
	     e),E('\n',i  ),h[1]=N,h[2]=U,h[4]=q,W||(fwrite(h,1,32,
	      e),fwrite   (J,1,q,e)),free(J),ext(0))):A==2?(V<N?(j?
		(H=V/f	   +S,M=Q):(G=V/f+S,H=M=0),Y=0,A=03):((m&0x80
		   )	   ||(m=0x80,p++),b&&(J[p++]=0),A=1,B++)):((Y
			    <k&&(P=H*H)+(z=M*M)<4.)?(M=2*H*M+R,H=P-z
			     +G,Y++):(W&&E(I[0x0f*(Y&K)/K],e),Y&K?J
			         [p]&=~m:(J[p]|=m),(m>>=1)||/*/
				  (m=128,u--),A==6?ext(1):B<u
				 .	  e=3,l=2*c*/(       m
					     =0x80,
					    p++),V++
					     ,A=0x2
						)
						));
					       }
","#include		     <stdio.h> 
#include		     <malloc.h> 
#define I		  "" .:\';+<?F7RQ&%#*""
#define a			""%s?\n""
#define n			""0?\n""
#define C			double	
#define o			 char
#define l			 long
#define L			sscanf
#define i			stderr
#define e			stdout
#define r		      exit   (1)
#define s(O,B)	   L(++J,O,&B)!=1&&c>++q&&L(v[q],O,&B)!=1&&--q
#define F(U,S,C,A) t=0,*++J&&(t=L(J,U,&C,&A)),(!t&&c>++q&&!(t=L(v[q],U,\
		   &C,&A)))?--q:(t<2&&c>++q&&!(t=L(v[q],S,&A))&&--q
#define T(E)		(s(""%d"",E),E||(fputs(n,i),r))
#define d(C,c)		  (F(""%lg,%lg"",""%lg"",C,c)))
#define O	   (F(""%d,%d"",""%d"",N,U),(N&&U)||(fputs(n,i),r)))
#define D		      (s(""%lg"",f))
#define E			  putc
					       C
						G=0,
						R
					     =0,Q,H
					    ,M,P,z,S
					     =0,x=0
				 ,        f=0;l b,j=0,	      k
				  =128,K=1,V,B=0,Y,m=128,p=0,N
				 =768,U=768,h[]={0x59A66A95,256
			     ,192,1,6912,1,0,0},t,A=0,W=0,Z=63,X=23
			    ;o*J,_;main(c,v)l c;o**v;{l q=1;for(;;q<
		  c	   ?(((J=v[q])[0]&&J[0]<48&&J++,((_= *J)<99||
		_/2==	   '2'||(_-1)/3=='\""'||_==107||_/05*2==','||_
	      >0x074)?(   fprintf(i,a,v[q]),r):_>0152?(_/4>27?(_&1?(
	     O,Z=N,X=U):  (W++,N=Z,U=X)):_&1?T(K):T(k)):_>103?(d(G,
	R    ),j=1):_&1? d(S,x):D,q++),q--,main(c-q,v+q)):A==0?(A=
  1,f||(f=N/4.),b=(((N-1)&017)<8),q=(((N+7)>>3)+b)*U,(J=malloc(q)
  )||(perror(""malloc""),r),S-=(N/2)/f,x+=(U/2)/f):A==1?(B<U?(A=2,V
	=    0,Q=x-B/f,j ||(R=Q),W&&E('\n',e),E(46,i)):(W&&E('\n',
	     e),E('\n',i  ),h[1]=N,h[2]=U,h[4]=q,W||(fwrite(h,1,32,
	      e),fwrite   (J,1,q,e)),free(J),exit(0))):A==2?(V<N?(j?
		(H=V/f	   +S,M=Q):(G=V/f+S,H=M=0),Y=0,A=03):((m&0x80
		   )	   ||(m=0x80,p++),b&&(J[p++]=0),A=1,B++)):((Y
			    <k&&(P=H*H)+(z=M*M)<4.)?(M=2*H*M+R,H=P-z
			     +G,Y++):(W&&E(I[0x0f*(Y&K)/K],e),Y&K?J
			         [p]&=~m:(J[p]|=m),(m>>=1)||/*/
				  (m=128,u--),A==6?exit(1):B<u
				 .	  e=3,l=2*c*/(        m
					     =0x80,
					    p++),V++
					     ,A=0x2
						)
						));
					       }
","#include						       <X11/Xlib.h>
#define							 ext(a) (exit(a),0)
# define		     X(	    x,v,y) XMoveWindow(d,s[x],(v)*z,(y)*z)
#  define		     _		ButtonPressMask|ButtonReleaseMask
#   define		     I(		     x,y) XSelectInput(d,s[x],y)
#    define		     N(		      v) (XMapWindow(d,s[v]),v)
#     define		     V			  VisibilityChangeMask
#      define		     A			  XCreateSimpleWindow
#	define		     D			    DefaultScreen(d)
#	 define		     E			   r.xbutton.button
#	  define	     R			    BlackPixel(d,D)
#	   define	     S			    r.xvisibility

	      int main(a)int a;{Window s[53];int w,u,i,c,y,l=0
	  ,q,e=32,t,k,j=~0,z=(a+1)/2,x=a&1,v=z&1;XEvent r;Display*
	d=XOpenDisplay("""");s[0]=A(d,DefaultRootWindow(d),200,200,(x&
       v?330:120)*z,215*z,2,R,R);I(N(c=0),_);for(;c<(x?32:52);c++){s[
       c+1]=A(d,s[0],x	      ?c*20*z:(c-1)%10	      *12*z,x?-20*z:(
      c-1)/10*12*z,x		?z*(c^31?10:		2):z*10*(c?1:2
      ), x& v?z*10:	 (c	 &&!x?10:1+	 x)	 *z,k =q=1, R,
      WhitePixel(d     ,D));I	  (N(c+1),     V);}X(	  N(1),y=(x&v)
      *115+50,x*70+	 60	 ); X(N(c--	 )+	 1,x?-10:(i=y)
      ,u=!x*130-20);		while(c &&e<		160){if(x){if(
      v){l=!(e &32)*9;	      for(w=30; w--;){	      if(s[w+2]){ k=w%
      10;l=e&32?k>l?k:l:k<l?k:l;X(w+2,10+k *20+q,(w/10)*20+e);}}l*=20;
      e&31?e++:e&32?(q++,(q+l>300?e++:0)):(q--,q+l<10?e++:0); } u>140?
      ext(c):u>-20?X(32,i,u-=(v?5:-1 )) :(!v?(u =5,srandom(time(0)),i=
      random()%88+6):0); } else{k>0?i+=(i>105?k= -k:k):(i+=(i<1?k= -k:
      k)); j>0?u	 +=(u>140?ext(++c):j):(u+=(u	    <1?j= -j:j
      )); X(		    52,i,u);}XSync(d,0);		while(
      XCheckMaskEvent(d	      ,_|V,&r))if(!(r.	     type==ButtonPress
      ?(E&1||!x||!v?t=E*4-8			 :u<0?i=y+4,u=122:1):r
      .type==ButtonRelease&&E?t=0,1:r.type^VisibilityNotify|S.state^1)
      )for(x&v?(u=	     -15),w++:(w=0);++w		  <52-x*20;)if
      (s[w]		      ==S.window)x&&v||			 w ^1?
      XUnmapWindow		   (d,s[w])		  ,s[w]=0,c--:
      0,l=1; if(!x&&l)j=			    -j,l=0; if(l&x&&!v
      )u=~19,c--,l=0;t=(!x||!v)		     &&(y<5&&t<0||y>95&&t>0)?0
	  :t;s[1]?X(1,y+=x&v?t:t/(x+1),130):ext(++c);};return(c);}
","#include						       <X11/Xlib.h>
# define		     X(	    x,v,y) XMoveWindow(d,s[x],(v)*z,(y)*z)
#  define		     _		ButtonPressMask|ButtonReleaseMask
#   define		     I(		     x,y) XSelectInput(d,s[x],y)
#    define		     N(		      v) (XMapWindow(d,s[v]),v)
#     define		     V			  VisibilityChangeMask
#      define		     A			  XCreateSimpleWindow
#	define		     D			    DefaultScreen(d)
#	 define		     E			   r.xbutton.button
#	  define	     R			    BlackPixel(d,D)
#	   define	     S			    r.xvisibility

	      int main(a)int a;{Window s[53];int w,u,i,c,y,l=0
	  ,q,e=32,t,k,j=~0,z=(a+1)/2,x=a&1,v=z&1;XEvent r;Display*
	d=XOpenDisplay("""");s[0]=A(d,DefaultRootWindow(d),200,200,(x&
       v?330:120)*z,215*z,2,R,R);I(N(c=0),_);for(;c<(x?32:52);c++){s[
       c+1]=A(d,s[0],x	      ?c*20*z:(c-1)%10	      *12*z,x?-20*z:(
      c-1)/10*12*z,x		?z*(c^31?10:		2):z*10*(c?1:2
      ), x& v?z*10:	 (c	 &&!x?10:1+	 x)	 *z,k =q=1, R,
      WhitePixel(d     ,D));I	  (N(c+1),     V);}X(	  N(1),y=(x&v)
      *115+50,x*70+	 60	 ); X(N(c--	 )+	 1,x?-10:(i=y)
      ,u=!x*130-20);		while(c &&e<		160){if(x){if(
      v){l=!(e &32)*9;	      for(w=30; w--;){	      if(s[w+2]){ k=w%
      10;l=e&32?k>l?k:l:k<l?k:l;X(w+2,10+k *20+q,(w/10)*20+e);}}l*=20;
      e&31?e++:e&32?(q++,(q+l>300?e++:0)):(q--,q+l<10?e++:0); } u>140?
      exit(c):u>-20?X(32,i,u-=(v?5:-1)):(!v?(u =5,srandom(time(0)),i=
      random()%88+6):0); } else{k>0?i+=(i>105?k= -k:k):(i+=(i<1?k= -k:
      k)); j>0?u	+=(u>140?exit(++c):j):(u+=(u	    <1?j= -j:j
      )); X(		    52,i,u);}XSync(d,0);		while(
      XCheckMaskEvent(d	      ,_|V,&r))if(!(r.	     type==ButtonPress
      ?(E&1||!x||!v?t=E*4-8			 :u<0?i=y+4,u=122:1):r
      .type==ButtonRelease&&E?t=0,1:r.type^VisibilityNotify|S.state^1)
      )for(x&v?(u=	     -15),w++:(w=0);++w		  <52-x*20;)if
      (s[w]		      ==S.window)x&&v||			 w ^1?
      XUnmapWindow		   (d,s[w])		  ,s[w]=0,c--:
      0,l=1; if(!x&&l)j=			    -j,l=0; if(l&x&&!v
      )u=~19,c--,l=0;t=(!x||!v)		     &&(y<5&&t<0||y>95&&t>0)?0
	 :t;s[1]?X(1,y+=x&v?t:t/(x+1),130):exit(++c);};return(c);}
","#define f 000:
          char
	  *s,*
	  t,v;
	  char 
	  _  [
	  999]
	  ,x [
	  999]
	  ,*p=
	  x  ;
	  char
	  *av[
	  ]= {
	  ""W"",
	  ""H"",
	  ""o"",
	  ""l"",
	  ""N"",
	  ""e"",
	  "" "",
	  ""r"",
	  ""d"",
	  ""."",
	  ""m"",
          ""s"",
          ""g"",
          ""!"",
          ""*"",
          ""\n""
	  }  ;
	   int 
	  n= 0
	  ;int 
	  __ =
	  0,i=
	  000;
	  main
	  () {
#define f 001:
#define F 042:
#define f 100:
         _[i--
#define f 126:
#define f 132:
#define f 103:
#define f 202:
#define f 666:
#define f 77::
#define f 101:
	   ]=0
#define f 232:
#define f 151:
	  ;if(
#define f 256:
          !i){
          puts
          (""I""
          ""BM""
          "" S""
          ""UX""
          );;;
          ;;;}
	  ;for
	  (  ;
	  gets
	  (_);
	  )  {
	  for(
#define f 301:
	  t=_,
#define f 700:
#define f 999:
	  s=t,
#define f 77 :
#define f 300:
	  s=t;
#define f s=t;
#define f 123:
#define f 127:
	  *t&&
	  !(!(
	  *t <
	  '0'
	  ||*t
	  >'9'
	  )&&!
          ((t[
          1] ^
          ':')
          &&(t
          [1]^
          '.')
	  )) ; 
	  t++)
#define f 137:
#define f 133:
	  ;if(
#define f 111:
#define f 220:
          v^*t
          &&*t
	  ){v=
          *t;;
          n=n*
	  2+(1
	  &*t)
	  ;__=
	  (__+
	  1)&3
	  ; __
	  ||((
	  n<15
	  &&(*
	  p= *
	  av[n
	  ] ),
#define f 2+2:
	  p++)
	  ,n=0
	  );}}
#define f ==4:
	  ;*p=
	  '\0'
	  ;;;;
#define f puts
	  puts
	  (x);
	  s=t;
#define f s=5;
	  s=t;
#define f s=5:
	  s=t;
#define f 445:
#define f 113:
#define f 900:
	  s=t;
#define f n22:
#define f n40:
	  s=t;
#define f nn6:
	  s=t;
#define f nn1:
#define f 0:--
	  s=t;
#define f 19:-
#define f x2:x
	  s=t;
#define f x1:x
	  s=t;
#define f y2:x
#define f y7:y
	  s=t;
#define f 1:::
	  s=t;
#define f @3:@
#define f 10:0
#define f x+1:
	  s=t;
#define f 2:::
#define f 3:::
#define x 7:::
#define y 3:::
#define z 990:
#define Z 47::
	  ;;;}

","#define f 000:
          char
	  *s,*
	  t,v;
	  char 
	  _  [
	  999]
	  ,x [
	  999]
	  ,*p=
	  x  ;
	  char
	  *av[
	  ]= {
	  ""W"",
	  ""H"",
	  ""o"",
	  ""l"",
	  ""N"",
	  ""e"",
	  "" "",
	  ""r"",
	  ""d"",
	  ""."",
	  ""m"",
          ""s"",
          ""g"",
          ""!"",
          ""*"",
          ""\n""
	  }  ;
	   int 
	  n= 0
	  ;int 
	  __ =
	  0,i=
	  000;
	  main
	  () {
#define f 001:
#define F 042:
#define f 100:
          i--[
#define f 126:
#define f 132:
#define f 103:
#define f 202:
#define f 666:
#define f 77::
#define f 101:
	  _]=0
#define f 232:
#define f 151:
	  ;if(
#define f 256:
          !i){
          puts
          (""I""
          ""BM""
          "" S""
          ""UX""
          );;;
          ;;;}
	  ;for
	  (  ;
	  gets
	  (_);
	  )  {
	  for(
#define f 301:
	  t=_,
#define f 700:
#define f 999:
	  s=t,
#define f 77 :
#define f 300:
	  s=t;
#define f s=t;
#define f 123:
#define f 127:
	  *t&&
	  !(!(
	  *t <
	  '0'
	  ||*t
	  >'9'
	  )&&!
          ((t[
          1] ^
          ':')
          &&(t
          [1]^
          '.')
	  )) ; 
	  t++)
#define f 137:
#define f 133:
	  ;if(
#define f 111:
#define f 220:
          v^*t
          &&*t
	  ){v=
          *t;;
          n=n*
	  2+(1
	  &*t)
	  ;__=
	  (__+
	  1)&3
	  ; __
	  ||((
	  n<15
	  &&(*
	  p= *
	  av[n
	  ] ),
#define f 2+2:
	  p++)
	  ,n=0
	  );}}
#define f ==4:
	  ;*p=
	  '\0'
	  ;;;;
#define f puts
	  puts
	  (x);
	  s=t;
#define f s=5;
	  s=t;
#define f s=5:
	  s=t;
#define f 445:
#define f 113:
#define f 900:
	  s=t;
#define f n22:
#define f n40:
	  s=t;
#define f nn6:
	  s=t;
#define f nn1:
#define f 0:--
	  s=t;
#define f 19:-
#define f x2:x
	  s=t;
#define f x1:x
	  s=t;
#define f y2:x
#define f y7:y
	  s=t;
#define f 1:::
	  s=t;
#define f @3:@
#define f 10:0
#define f x+1:
	  s=t;
#define f 2:::
#define f 3:::
#define x 7:::
#define y 3:::
#define z 990:
#define Z 47::
	  ;;;}

","#include <stdio.h>
#include <curses.h>

#define ST strchr
#define SRD srand48
#define RD lrand48
#define ext(a) (exit(a),0)

#define Q return
#define W wrefresh(r)
typedef int i;

#define Z(d,a) (RD()%((a)-(d)+1)+(d))
i f[3][3] = {15,52,36,20,-39,48,60,0,-25};

char z[6][6];
#define Y(x) (4*(x)+3)
#define X(x) (2*(x)+1)
#define I for
WINDOW *r=NULL;
#define K endwin()

char *g =""\
Use l-h-k-j for move.\nUse + for increment. Use - for decrement.\nUse Q to quit."";

i (*d())();
nt()
{
long time();
SRD(time((i *)0));
memset(z,5,36);
initscr();
cbreak();
noecho();
nonl();
if (COLS<80||LINES<24)
K,ext(1);
if (!(r=newwin(X(6),Y(6),
(LINES-X(6))/2,(COLS-Y(6))/2)))
K,ext(1);
mvaddstr(LINES-5,0,g);
refresh();
}
i ci()
{
i x,y=0;
I (;y<6;++y)
I(x=0;x<6;++x)
mvwaddch(r,X(y),Y(x),z[x][y]+'0'); Q(0);
}
void main()
{
char *ST();
i a=0,b=0,c,q,t,s,x,sc=0;
i(*(*p)())()=(nt(),d);
I(x=0 ; x++<20; )d(Z(0,5),Z(0,5),Z(1,2));
I(t=Z(0,2),q=s=0; q<3; s+=f[q][t]*f[q++][t]);
I(box(r,'|','-'),ci(),wmove(r,X(a),Y(b)),
W; (ST (""+-Qlkjh"",(char)(c=wgetch(r))))&&
((i)((i)(q^=s%=Y(q),s/=2)!=(i)(s^=q)&&c&64&&(!(c&7|0)&&--b<0&&
(b=q^s)&0|| c&4&&++b==6&&c&4<(~b&23?q^=s,b^=b
:b&12?b=3:b|2)||c&2&&~c&1&&++a==++q/2+1&&c&16>(
!a|12?a=7,a&=~a:a|4?a=2:a&2)||~c&4&&c&
1&&--a<0&&(a+=6)&0)||~c&64&&(**p(b,a,~c))()||
c&16)?K,ext(0):1)||c; sc==36?ci(),W,K,ext(0):wmove(r,X(a),Y(b)),
W)
I(t=Z(0,2),q=s=0; q<3; s+=f[q][t]*f[q++][t])
I(sc=0; sc<36&&*((char *)z+sc++)==5; );
}
i (*d(a,b,c))()i a,b,c;
{
i x,y;
I(x=a>0?a-1:0; x<=(a<5?a+1:5); ++x)
I(y=b>0?b-1:0; y<=(b<5?b+1:5); ++y)
if(x==a&&y==b&&z[x][y]==(c&2?1:9)||z[x][y]==(c&2?9:1)&&(x!=a||y!=b))Q(ci);
I(x=a>0?a-1:0; x<=(a<5?a+1:5); x++)
I(y=b>0?b-1:0; y<=(b<5?b+1:5)&&(x==a&&y==b&&(z[x][y]+=(c&2?-1:1))||(z[x][y]+=(c&2?1:-1))); y++); Q(ci);
}
","#include <stdio.h>
#include <curses.h>

#define ST strchr
#define SRD srand48
#define RD lrand48

#define Q return
#define W wrefresh(r)
typedef int i;

#define Z(d,a) (RD()%((a)-(d)+1)+(d))
i f[3][3] = {15,52,36,20,-39,48,60,0,-25};

char z[6][6];
#define Y(x) (4*(x)+3)
#define X(x) (2*(x)+1)
#define I for
WINDOW *r=NULL;
#define K endwin()

char *g =""\
Use l-h-k-j for move.\nUse + for increment. Use - for decrement.\nUse Q to quit."";

i (*d())();
nt()
{
long time();
SRD(time((i *)0));
memset(z,5,36);
initscr();
cbreak();
noecho();
nonl();
if (COLS<80||LINES<24)
K,exit(1);
if (!(r=newwin(X(6),Y(6),
(LINES-X(6))/2,(COLS-Y(6))/2)))
K,exit(1);
mvaddstr(LINES-5,0,g);
refresh();
}
i ci()
{
i x,y=0;
I (;y<6;++y)
I(x=0;x<6;++x)
mvwaddch(r,X(y),Y(x),z[x][y]+'0'); Q(0);
}
void main()
{
char *ST();
i a=0,b=0,c,q,t,s,x,sc=0;
i(*(*p)())()=(nt(),d);
I(x=0 ; x++<20; )d(Z(0,5),Z(0,5),Z(1,2));
I(t=Z(0,2),q=s=0; q<3; s+=f[q][t]*f[q++][t]);
I(box(r,'|','-'),ci(),wmove(r,X(a),Y(b)),
W; (ST (""+-Qlkjh"",(char)(c=wgetch(r))))&&
((i)((i)(q^=s%=Y(q),s/=2)!=(i)(s^=q)&&c&64&&(!(c&7|0)&&--b<0&&
(b=q^s)&0|| c&4&&++b==6&&c&4<(~b&23?q^=s,b^=b
:b&12?b=3:b|2)||c&2&&~c&1&&++a==++q/2+1&&c&16>(
!a|12?a=7,a&=~a:a|4?a=2:a&2)||~c&4&&c&
1&&--a<0&&(a+=6)&0)||~c&64&&(**p(b,a,~c))()||
c&16)?K,exit(0):1)||c; sc==36?ci(),W,K,exit(0):wmove(r,X(a),Y(b)),
W)
I(t=Z(0,2),q=s=0; q<3; s+=f[q][t]*f[q++][t])
I(sc=0; sc<36&&*((char *)z+sc++)==5; );
}
i (*d(a,b,c))()i a,b,c;
{
i x,y;
I(x=a>0?a-1:0; x<=(a<5?a+1:5); ++x)
I(y=b>0?b-1:0; y<=(b<5?b+1:5); ++y)
if(x==a&&y==b&&z[x][y]==(c&2?1:9)||z[x][y]==(c&2?9:1)&&(x!=a||y!=b))Q(ci);
I(x=a>0?a-1:0; x<=(a<5?a+1:5); x++)
I(y=b>0?b-1:0; y<=(b<5?b+1:5)&&(x==a&&y==b&&(z[x][y]+=(c&2?-1:1))||(z[x][y]+=(c&2?1:-1))); y++); Q(ci);
}
","/* @(#)mkentry.c	1.20 3/1/92 16:13:00 */
/*
 * mkentry - make an International Obfuscated C Code Contest entry
 *
 * usage:
 *	mkentry -r remarks -b build -p prog.c -o ioccc.entry
 *
 *	-r remarks		file with remarks about the entry
 *	-b build		file containing how prog.c should be built
 *	-p prog.c		the obfuscated program source file
 *	-o ioccc.entry		ioccc entry output file
 *
 * compile by:
 *	cc mkentry.c -o mkentry
 */
/*
 * Copyright (c) 1992, Landon Curt Noll & Larry Bassel.
 * All Rights Reserved.  Permission for personal, educational or non-profit 
 * use is granted provided this this copyright and notice are included in 
 * its entirety and remains unaltered.  All other uses must receive prior
 * permission in writing from both Landon Curt Noll and Larry Bassel.
 */
/*
 * Placed in the public domain by Landon Curt Noll, 1992.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
/*
 * WARNING:
 *
 * This program attempts to implement the IOCCC rules.  Every attempt
 * has been made to make sure that this program produces an entry that
 * conforms to the contest rules.  In all cases, where this program
 * differs from the contest rules, the contest rules will be used.  Be
 * sure to check with the contest rules before submitting an entry.
 *
 * Send questions or comments (but not entries) about the contest, to:
 *
 *	...!{sun,pacbell,uunet,pyramid}!hoptoad!judges
 *	judges@toad.com
 *
 * The rules and the guidelines may (and often do) change from year to
 * year.  You should be sure you have the current rules and guidelines
 * prior to submitting entries.  The IOCCC rules, guidelines and mkentry
 * program may be obtained from the judges using the Email address above.
 * Please use the following subject when sending in your request:
 *
 *	send rules
 *
 * Because contest rules change from year to year, one should only use this
 * program for the year that it was intended.  Be sure that the RULE_YEAR
 * define below matches this current year.
 */

#include <stdio.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

/* logic */
#ifndef TRUE
# define TRUE 1
#endif /* TRUE */
#ifndef FALSE
# define FALSE 0
#endif /* FALSE */
#define EOF_OK TRUE
#define EOF_NOT_OK FALSE

/* global limits */
#define RULE_YEAR 1992		/* NOTE: should match the current year */
#define START_DATE ""1Mar92 0:00 UTC""	/* first confirmation received */
#define MAX_COL 79		/* max column a line should hit */
#define MAX_BUILD_SIZE 256	/* max how to build size */
#define MAX_PROGRAM_SIZE 3217	/* max program source size */
#define MAX_PROGRAM_SIZE2 1536	/* max program source size not counting
				   whitespace and {}; not followed by
				   whitespace or EOF */
#define MAX_TITLE_LEN 10	/* max chars in the title */
#define MAX_ENTRY_LEN 1		/* max length in the entry input line */
#define MAX_ENTRY 8		/* max number of entries per person per year */
#define MAX_FILE_LEN 1024	/* max filename length for a info file */

/* where to send entries */
#define ENTRY_ADDR1 ""...!{apple,pyramid,sun,uunet}!hoptoad!obfuscate""
#define ENTRY_ADDR2 ""obfuscate@toad.com""

/* uuencode process - assumes ASCII */
#define UUENCODE(c) (((c)=='\0') ? '`' : (((c)&0x3f)+' '))
#define UUENCODE_LEN 45		/* max uuencode chunk size */
#define UUINFO_MODE 0444	/* mode of an info file's uuencode file */
#define UUBUILD_MODE 0444	/* mode of the build file's uuencode file */
#define UUBUILD_NAME ""build""	/* name for the build file's uuencode file */
#define UUPROG_MODE 0444	/* mode of the program's uuencode file */
#define UUPROG_NAME ""prog.c""	/* name for the program's uuencode file */

/* global declarations */
char *program;		/* our name */
long start_time;		/* the startup time */

/* forward declarations */
void parse_args();
void usage();
FILE *open_remark();
FILE *open_build();
FILE *open_program();
FILE *open_output();
void output_entry();
void output_remark();
void output_author();
void output_info();
void output_build();
void output_program();
void output_end();
int get_line();
void output_till_dot();
int col_len();
void check_io();
void uuencode();

main(argc, argv)
    int argc;		/* arg count */
    char **argv;	/* the args */
{
    FILE *remark=NULL;	/* open remarks stream */
    FILE *build=NULL;	/* open build file stream */
    FILE *prog=NULL;	/* open program stream */
    FILE *output=NULL;	/* open output stream */
    char *rname=NULL;	/* file with remarks about the entry */
    char *bname=NULL;	/* file containing how prog.c should be built */
    char *pname=NULL;	/* the obfuscated program source file */
    char *oname=NULL;	/* ioccc entry output file */
    struct tm *tm;	/* startup time structure */

    /*
     * check on the year
     */
    start_time = time((long *)0);
    tm = gmtime(&start_time);
    if (tm->tm_year != RULE_YEAR-1900) {
	fprintf(stderr,
	    ""%s: WARNING: this program applies to %d, which differ from %d\n\n"",
	    argv[0], RULE_YEAR, 1900+tm->tm_year);
    }

    /*
     * parse the command line args
     */
    parse_args(argc, argv, &rname, &bname, &pname, &oname);

    /*
     * open/check the input and output files
     *
     * We open and truncate the output file first, in case it is the same
     * as one of the input files.
     */
    output = open_output(oname);
    remark = open_remark(rname);
    build = open_build(bname);
    prog = open_program(pname);
    if (output==NULL || remark==NULL || build==NULL || prog==NULL) {
	exit(1);
    }

    /*
     * output each section
     */
    output_entry(output, oname);
    output_remark(output, oname, remark, rname);
    output_author(output, oname);
    output_info(output, oname);
    output_build(output, oname, build, bname);
    output_program(output, oname, prog, pname);
    output_end(output, oname);

    /* 
     * flush the output 
     */
    if (fflush(output) == EOF) {
	fprintf(stderr, ""%s: flush error in %s: "", program, oname);
	perror("""");
	exit(2);
    }

    /*
     * final words
     */
    printf(""\nYour entry can be found in %s.  You should check this file\n"", 
	oname);
    printf(""correct any problems and verify that the uudecode utility will\n"");
    printf(""correctly decode your build file and program.\n\n"");
    printf(""This program has been provided as a guide for submitters.  In\n"");
    printf(""cases where it conflicts with the rules, the rules shall apply.\n"");
    printf(""It is your responsibility to ensure that your entry conforms to\n"");
    printf(""the current rules.\n\n"");
    printf(""Email your entries to:\n"");
    printf(""\t%s\n"", ENTRY_ADDR1);
    printf(""\t%s\n\n"", ENTRY_ADDR2);
    printf(""Please use the following subject when you Email your entry:\n"");
    printf(""\tioccc entry\n\n"");
    /* all done */
    exit(0);
}

/*
 * parse_args - parse the command line args
 *
 * Given the command line args, this function parses them and sets the
 * required name flags.  This function will return only if the command
 * line syntax is correct.
 */
void
parse_args(argc, argv, rname, bname, pname, oname)
    int argc;		/* arg count */
    char **argv;	/* the args */
    char **rname;	/* file with remarks about the entry */
    char **bname;	/* file containing how prog.c should be built */
    char **pname;	/* the obfuscated program source file */
    char **oname;	/* ioccc entry output file */
{
    char *optarg;	/* -flag option operand */
    int flagname;	/* the name of the -flag */
    int i;

    /*
     * Not everyone has getopt, so we must parse args by hand.
     */
    program = argv[0];
    for (i=1; i < argc; ++i) {

	/* determine the flagname */
	if (argv[i][0] != '-') {
	    usage(1);
	    /*NOTREACHED*/
	}
	flagname = (int)argv[i][1];

	/* determine the flag's operand */
	if (flagname != '\0' && argv[i][2] != '\0') {
	    optarg = &argv[i][2];
	} else {
	    if (i+1 >= argc) {
		usage(2);
		/*NOTREACHED*/
	    } else {
		optarg = argv[++i];
	    }
	}

	/* save the flag's operand in the correct global variable */
	switch (flagname) {
	case 'r':
	    *rname = optarg;
	    break;
	case 'b':
	    *bname = optarg;
	    break;
	case 'p':
	    *pname = optarg;
	    break;
	case 'o':
	    *oname = optarg;
	    break;
	default:
	    usage(3);
	    /*NOTREACHED*/
	}
    }

    /*
     * verify that we have all of the required flags
     */
    if (*rname == NULL || *bname == NULL || *pname == NULL || *oname == NULL) {
	usage(4);
	/*NOTREACHED*/
    }
    return;
}

/*
 * usage - print a usage message and exit
 *
 * This function does not return.
 */
void
usage(exitval)
    int exitval;		/* exit with this value */
{
    fprintf(stderr,
	""usage: %s -r remarks -b build -p prog.c -o ioccc.entry\n\n"", program);
    fprintf(stderr, ""\t-r remarks\tfile with remarks about the entry\n"");
    fprintf(stderr, ""\t-b build\tfile containing how prog.c should be built\n"");
    fprintf(stderr, ""\t-p prog.c\tthe obfuscated program source file\n"");
    fprintf(stderr, ""\t-o ioccc.entry\tioccc entry output file\n"");
    exit(exitval);
}

/*
 * open_remark - open/check the remark file
 *
 * The remark file should be indented by 4 spaces, and should not extend 
 * beyond column MAX_COL.  These are not requirements, so we only warn.
 *
 * This function returns NULL on I/O or format error.
 */
FILE *
open_remark(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    char buf[BUFSIZ+1];		/* input buffer */
    int toolong=0;		/* number of lines that are too long */
    int non_indent=0;		/* number of lines not indented by 4 spaces */

    /*
     * open the remark input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open remark file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * look at each line
     */
    while (fgets(buf, BUFSIZ, stream) != NULL) {

	/* count lines that do not start with 4 spaces */
	if (buf[0] != '\n' && strncmp(buf, ""    "", 4) != 0) {
	    ++non_indent;
	}

	/* count long lines */
	if (col_len(buf) > MAX_COL) {
	    /* found a line that is too long */
	    ++toolong;
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* note long lines if needed */
    if (toolong > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s extend beyond the 80th column\n"",
	    program, toolong, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* note non-indented lines, if needed */
    if (non_indent > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s are not indented by 4 spaces\n"",
	    program, non_indent, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_build - open/check the build file
 *
 * The how to build file must not be longer than MAX_BUILD_SIZE bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_build(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */

    /*
     * open the how to build input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_BUILD_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the how to build file: %s, is %d bytes long\n"",
	    program, filename, statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_BUILD_SIZE);
	return(NULL);
    }

    /* return the open file */
    return(stream);
}

/*
 * open_program - open/check the program source file
 *
 * The program source file must be <= 3217 bytes.  The number of
 * non-whitespace and }{; chars not followed by whitespace must
 * be <= 1536 bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_program(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */
    int count;			/* special count size */
    int c;			/* the character read */

    /*
     * open the program source input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open program source file: %s: "",
	    program, filename);
	perror("""");
	exit(7);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat program source file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_PROGRAM_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the program source file: %s, is %d bytes long\n"",
	    program, filename, statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_PROGRAM_SIZE);
	return(NULL);
    }

    /*
     * count the non-whitespace, non {}; followed by whitespace chars
     */
    count = 0;
    c = 0;
    while ((c=fgetc(stream)) != EOF) {
	/* look at non-whitespace */
	if (!isascii(c) || !isspace(c)) {
	    switch (c) {
	    case '{':		/* count if not followed by EOF or whitespace */
	    case '}':
	    case ';':
		/* peek at next char */
		c = fgetc(stream);
		if (c != EOF && isascii(c) && !isspace(c)) {
		    /* not followed by whitespace or EOF, count it */
		    ungetc(c, stream);
		    ++count;
		}
		break;
	    default:
		++count;
		break;
	    }
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* look at the special size */
    if (count > MAX_PROGRAM_SIZE2) {
	fprintf(stderr,
	    ""%s: FATAL: the number of bytes that are non-whitespace, and\n"",
	    program);
	fprintf(stderr,
	    ""%s:        that are not '{', '}', ';' followed by whitespace\n"",
	    program);
	fprintf(stderr,
	    ""%s:        or EOF must be <= %d bytes\n"",
	    program, MAX_PROGRAM_SIZE2);
	fprintf(stderr,
	    ""%s:        in %s, %d bytes were found\n"",
	    program, filename, count);
	return(NULL);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_output - open/check the entry output file
 *
 * This function returns NULL on open error.
 */
FILE *
open_output(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */

    /*
     * open the ioccc entry output file
     */
    stream = fopen(filename, ""w"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open ioccc entry file for output: %s: "",
	    program, filename);
	perror("""");
	exit(8);
    }

    /* return the open file */
    return(stream);
}

/*
 * output_entry - output the ---entry--- section
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_entry(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char title[MAX_TITLE_LEN+1+1];	/* the entry's title */
    int entry=0;			/* entry number */
    int ret;				/* fields processed by fscanf */
    int ok_line=0;			/* 0 => the line is not ok */
    char skip;				/* input to skip */
    char *p;

    /*
     * write the start of the section
     */
    fprintf(output, ""---entry---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the rule year
     */
    fprintf(output, ""rule:\t%d\n"", RULE_YEAR);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the title
     */
    printf(""Your title must match expression be a [a-zA-Z0-9_+=,] character\n"");
    printf(""followed by 0 to 9 more [a-zA-Z0-9_+=,.-] characters.\n\n"");
    printf(""It is suggested, but not required, that the title should\n"");
    printf(""incorporate your username; in the\n"");
    printf(""case of multiple authors, consider using parts of the usernames\n"");
    printf(""of the authors.\n\n"");
    printf(""enter your title: "");
    do {
	/* prompt and read a line */
	if ((ok_line = get_line(title, MAX_TITLE_LEN+1, MAX_COL-9)) <= 0) {
	    printf(""\ntitle is too long, please re-enter: "");
	    continue;
	}

	/* verify the pattern, not everyone has regexp, so do it by hand */
	if (!isascii((int)title[0]) ||
	    !(isalnum((int)title[0]) || title[0] == '_' || title[0] == '+' ||
	      title[0] == '=' || title[0] == ',')) {
	    printf(""\ninvalid first character in the title\n\n"");
	    printf(""enter your title: "");
	    ok_line = 0;
	} else {
	    for (p=(&title[1]); *p != '\0' && *p != '\n'; ++p) {
		if (!isascii((int)*p) ||
		    !(isalnum((int)*p) || *p == '_' || *p == '+' ||
		      *p == '=' || *p == ',' || *p == '.' || *p == '-')) {
		    printf(""\ninvalid character in the title\n\n"");
		    printf(""enter your title: "");
		    ok_line = 0;
		}
	    }
	}
    } while (ok_line <= 0);
    fprintf(output, ""title:\t%s"", title);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the entry number
     */
    printf(""\nEach person may submit up to %d entries per year.\n\n"",
	MAX_ENTRY);
    printf(""enter an entry number from 0 to %d inclusive: "", MAX_ENTRY-1);
    do {
	/* get a valid input line */
	fflush(stdout);
	ret = fscanf(stdin, ""%d[\n]"", &entry);
	check_io(stdin, ""stdin"", EOF_NOT_OK);
	/* skip over input until newline is found */
	do {
	    skip = fgetc(stdin);
	    check_io(stdin, ""stdin"", EOF_NOT_OK);
	    if (skip != '\n') {
		/* bad text in input, invalidate entry number */
		entry = -1;
	    }
	} while (skip != '\n');

	/* check if we have a number, and if it is in range */
	if (ret != 1 || entry < 0 || entry > MAX_ENTRY-1) {
	    printf(
	      ""\nThe entry number must be between 0 and %d inclusive\n\n"",
		MAX_ENTRY-1);
	    printf(""enter the entry number: "");
	}
    } while (ret != 1 || entry < 0 || entry > MAX_ENTRY-1);
    fprintf(output, ""entry:\t%d\n"", entry);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the submission date
     */
    fprintf(output, ""date:\t%s"", ctime(&start_time));  /* returns a newline */
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the OS/machine host information
     */
    printf(
      ""\nEnter the machine(s) and OS(s) under which your entry was tested.\n"");
    output_till_dot(output, oname, ""host:"");
}

/*
 * output_remark - output the ---remark--- section
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_remark(output, oname, remark, rname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *remark;		/* stream to the file containing remark text */
    char *rname;		/* name of the remark file */
{
    char buf[BUFSIZ+1];		/* input/output buffer */

    /*
     * write the start of the section
     */
    fprintf(output, ""---remark---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * copy the remark file to the section
     */
    while (fgets(buf, BUFSIZ, remark) != NULL) {
	fputs(buf, output);
	check_io(output, oname, EOF_NOT_OK);
    }
    check_io(remark, rname, EOF_OK);

    /* be sure that the remark section ends with a newline */
    if (buf[strlen(buf)-1] != '\n') {
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);
    }
}

/*
 * output_author - output the ---author--- section
 *
 * Read the needed information from stdin, and write the author section.
 * If multiple authors exist, multiple author sections will be written.
 */
void
output_author(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char buf[MAX_COL+1+1];	/* I/O buffer */
    int more_auths;		/* TRUE => more authors to note */
    int auth_cnt=0;		/* number of authors processed */

    /*
     * prompt the user for the author section
     */
    printf(""\nEnter information about each author.  If your entry is after\n"");
    printf(""%s and before the contest deadline, the judges\n"", START_DATE);
    printf(""will attempt to Email back a confirmation to the first author\n"");

    /*
     * place author information for each author in an individual section
     */
    do {

	/* write the start of the section */
	fprintf(output, ""---author---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* write the author */
	printf(""\nAuthor #%d name: "", ++auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nname too long, please re-enter: "");
	}
	fprintf(output, ""name:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the organization */
	printf(""\nEnter the School/Company/Organization of author #%d\n"",
	    auth_cnt);
	printf(""\nAuthor #%d org: "", auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter: "");
	}
	fprintf(output, ""org:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the address */
	printf(
	    ""\nEnter the postal address for author #%d.  Be sure to include\n"",
	    auth_cnt);
	printf(""your country and do not include your name.\n"");
	output_till_dot(output, oname, ""addr:"");

	/* write the Email address */
	printf(
	    ""\nEnter the Email address for author #%d.  Use an address from\n"",
	    auth_cnt);
	printf(
	    ""a registered domain or well known site.  If you give several\n"");
	printf(""forms, list them one per line.\n"");
	output_till_dot(output, oname, ""email:"");

	/* write the anonymous status */
	printf(""\nShould author #%d remain anonymous (enter y or n)? "",
	    auth_cnt);
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	fprintf(output, ""anon:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* determine if there is another author */
	printf(""\nIs there another author (enter y or n)? "");
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	if (buf[0] == 'y') {
	    more_auths = TRUE;
	} else {
	    more_auths = FALSE;
	}
    } while (more_auths == TRUE);
    return;
}

/*
 * output_info - output the ---info--- section(s)
 *
 * Read the needed information from stdin, and write the info section.
 * If multiple info files exist, multiple info sections will be written.
 */
void
output_info(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char infoname[MAX_FILE_LEN+1];	/* filename buffer */
    char yorn[1+1];		/* y or n answer */
    char *uuname;		/* name to uuencode as */
    FILE *infile;		/* info file stream */

    /*
     * prompt the user for info information
     */
    printf(""\nInfo files should be used only to supplement your entry.\n"");
    printf(""For example, info files may provide sample input or detailed\n"");
    printf(""information about your entry.  Because they are supplemental,\n"");
    printf(""the entry should not require them to exist.\n\n"");

    /*
     * while there is another info file to save, uuencode it
     */
    printf(""Do you have a info file to include (enter y or n)? "");
    while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    while (yorn[0] == 'y') {

	/* read the filename */
	printf(""\nEnter the info filename: "");
	while (get_line(infoname, MAX_FILE_LEN+1, 0) <= 0) {
	    printf(""\nInfo filename too long, please re-enter: "");
	}

	/* compute the basename of the info filename */
	/* remove the trailing newline */
	uuname = &infoname[strlen(infoname)-1];
	*uuname = '\0';
	/* avoid rindex/shrrchr compat issues, do it by hand */
	for (--uuname; uuname > infoname; --uuname) {
	    if (*uuname == '/') {
		++uuname;
		break;
	    }
	}

	/* attempt to open the info file */
	infile = fopen(infoname, ""r"");
	if (infile == NULL) {
	    fprintf(stderr, ""\n%s: cannot open info file: %s: "",
		program, infoname);
	    perror("""");
	    continue;
	}

	/*
	 * write the start of the section
	 */
	fprintf(output, ""---info---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* uuencode the info file */
	uuencode(output, oname, infile, infoname, UUINFO_MODE, uuname);

	printf(""\nDo you have another info file to include (enter y or n)? "");
	while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
    };
    return;
}

/*
 * output_build - output the ---build--- section
 *
 * Read the needed information from stdin, and write the build section.
 */
void
output_build(output, oname, build, bname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *build;		/* open build file stream */
    char *bname;		/* name of the build file */
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---build---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, build, bname, UUBUILD_MODE, UUBUILD_NAME);
    return;
}

/*
 * output_program - output the ---program--- section
 *
 * Read the needed information form stdin, and write the program section.
 */
void
output_program(output, oname, prog, pname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *prog;			/* open program stream */
    char *pname;		/* name of program file */
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---program---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, prog, pname, UUPROG_MODE, UUPROG_NAME);
    return;
}

/*
 * output_end - output the ---end--- section
 *
 * Read the needed information form stdin, and write the 'end section'.
 */
void
output_end(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    /*
     * write the final section terminator
     */
    fprintf(output, ""---end---\n"");
    check_io(output, oname, EOF_NOT_OK);
    return;
}

/*
 * get_line - get an answer from stdin
 *
 * This function will flush stdout, in case a prompt is pending, and
 * read in the answer.
 *
 * This function returns 0 if the line is too long, of the length of the
 * line (including the newline) of the line was ok.  This function does
 * not return if ERROR or EOF.
 */
int
get_line(buf, siz, maxcol)
    char *buf;			/* input buffer */
    int siz;			/* length of input, including the newline */
    int maxcol;			/* max col allowed, 0 => disable check */
{
    int length;			/* the length of the input line */

    /* flush terminal output */
    fflush(stdout);

    /* read the line */
    if (fgets(buf, siz+1, stdin) == NULL) {
	/* report the problem */
	check_io(stdin, ""stdin"", EOF_NOT_OK);
    }

    /* look for the newline */
    length = strlen(buf);
    if (buf[length-1] != '\n') {
	int eatchar;		/* the char being eaten */

	/* no newline found, line must be too long, eat the rest of the line */
	do {
	    eatchar = fgetc(stdin);
	} while (eatchar != EOF && eatchar != '\n');
	check_io(stdin, ""stdin"", EOF_NOT_OK);

	/* report the situation */
	return 0;
    }

    /* watch for long lines, if needed */
    if (maxcol > 0 && (length > maxcol || col_len(buf) > maxcol)) {
	/* report the situation */
	return 0;
    }

    /* return length */
    return length;
}

/*
 * output_till_dot - output a set of lines until '.' by itself is read
 *
 * This routine will read a set of lines until (but not including)
 * a single line with '.' is read.  The format of the output is:
 *
 *	leader:\tfirst line
 *	\tnext line
 *	\tnext line
 *	   ...
 *
 * This routine will not return if I/O error or EOF.
 */
void
output_till_dot(output, oname, leader)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    char *leader;		/* the lead text for the first line */
{
    char buf[BUFSIZ+1];		/* input buffer */
    int count;			/* lines read */
    int done=FALSE;		/* TRUE => finished reading input */

    /* instruct the user on how to input */
    printf(""\nTo end input, enter a line with a single period.\n"");

    /* read lines until '.' or EOF */
    count = 0;
    while (!done) {
	/* issue the prompt */
	printf(""%s\t"", (count>0) ? """" : leader);
	fflush(stdout);

	/* get the line */
	if (get_line(buf, BUFSIZ, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter:\n\t"");
	    continue;
	}

	/* note if '.' was read */
	if (strcmp(buf, "".\n"") == 0) {
	    done = TRUE;
	}

	/* write line if we read something */
	if (!done) {
	    fprintf(output, ""%s\t%s"", (count++>0) ? """" : leader, buf);
	    check_io(output, oname, EOF_NOT_OK);
	}
    }

    /* if no lines read, at least output something */
    if (count <= 0) {
	fprintf(output, ""%s\t.\n"", leader);
	check_io(output, oname, EOF_NOT_OK);
    }
    return;
}

/*
 * col_len - determine the highest that a string would reach
 *
 * Given a string, this routine returns that a string would reach
 * if the string were printed at column 1.  Tab stops are assumed
 * to start at 9, 17, 25, 33, ...
 */
int
col_len(string)
    char *string;		/* the string to examine */
{
    int col;	/* current column */
    char *p;	/* current char */

    /* scan the string */
    for (col=0, p=string; *p != '\0' && *p != '\n'; ++p) {
	/* note the column shift */
	col = (*p=='\t') ? 1+((col+8)/8*8) : col+1;
    }
    if (*p == '\n') {
	--col;
    }

    /* return the highest column */
    return col;
}

/*
 * check_io - check for EOF or I/O error on a stream
 *
 * Does not return if EOF or I/O error.
 */
void
check_io(stream, name, eof_ok)
    FILE *stream;		/* the stream to check */
    char *name;			/* the name of this stream */
    int eof_ok;			/* EOF_OK or EOF_NOT_OK */
{
    /* test for I/O error */
    if (ferror(stream)) {
	fprintf(stderr, ""%s: error on %s: "", program, name);
	perror("""");
	exit(1);

    /* test for EOF */
    } else if (eof_ok == EOF_NOT_OK && feof(stream)) {
	fprintf(stderr, ""%s: EOF on %s\n"", program, name);
	exit(1);
    }
    return;
}

/*
 * uuencode - uuencode a file
 *
 * Perform the uuencoding process identical to the process performed
 * by the uuencode(1) utility.
 *
 * This routine implements the algorithm described in the uuencode(5)
 * 4.3BSD Reno man page.
 */
void
uuencode(output, oname, infile, iname, umode, uname)
    FILE *output;		/* output file stream */
    char *oname;		/* output filename */
    FILE *infile;		/* input file stream */
    char *iname;		/* input filename */
    int umode;			/* the mode to put on the uuencode file */
    char *uname;		/* name to put on the uuencode file */
{
    char buf[UUENCODE_LEN+1];	/* the uuencode buffer */
    int read_len;		/* actual number of chars read */
    int val;			/* 6 bit chunk from buf */
    char filler='\0';		/* filler uuencode pad text */
    char *p;

    /*
     * output the initial uuencode header
     */
    fprintf(output, ""begin %o %s\n"", umode, uname);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * clear out the input buffer
     */
    for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	*p = '\0';
    }

    /*
     * We will process UUENCODE_LEN chars at a time, forming
     * a single output line each time.
     */
    while ((read_len=fread(buf,sizeof(buf[0]),UUENCODE_LEN,infile)) > 0) {
	
	/*
	 * the first character is the length character
	 */
	fputc(UUENCODE(read_len), output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * We will convert 24 bits at a time.  Thus we will convert
	 * 3 sets of 8 bits into 4 sets of uuencoded 6 bits.
	 */
	for (p=buf; read_len>0; read_len-=3, p+=3) {

	    /* bits 0 to 5 */
	    val = (p[0]>>2)&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 6 to 11 */
	    val = ((p[0]<<4)&0x30) | ((p[1]>>4)&0x0f);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 12 to 17 */
	    val = ((p[1]<<2)&0x3c) | ((p[2]>>6)&0x03);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 18 to 23 */
	    val = p[2]&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);
	}

	/* end of UUENCODE_LEN line */
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * clear out the input buffer  (don't depend on bzero() or memset())
	 */
	for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	    *p = '\0';
	}
    }

    /* check the last read on the input file */
    check_io(infile, iname, EOF_OK);

    /* write end of uuencode file */
    fprintf(output, ""%c\nend\n"", UUENCODE(filler));
    check_io(output, oname, EOF_NOT_OK);
}
","#include <stdio.h>
static char *text[] =
{
  ""Export of this program from the USA is governed by the US"",
  ""Munitions List from the ITAR (International Traffic in Arms"",
  ""Regulations). This list gives the specific categories of"",
  ""restricted exports and includes cryptographic exports. Traffic"",
  ""entirely external to, entirely internal to, or into the USA is"",
  ""not restricted."",
  ""To obtain a copy of the program, email to nathan@inmos.co.uk"",
  ""with a subject \""IOCCC request\"". If you know that your 'From'"",
  ""line is incorrect, add a single line"",
  ""\""replyto you@your.correct.address\"" to the body of the message."",
  ""A deamon will autoreply."",
  ""WARNING: You must not re-export this out of the USA, or else"",
  ""the men in black might get you."",
  NULL
};
int main()
{
  char **ptr;

  for(ptr = text; *ptr; ptr++)
    printf(""%s\n"", *ptr);
  return 0;
}
","#include <stdio.h>
;	m(x)(x<0?-1:!!x)
;	g tj()-J
;	a(x)(x<0?-x:x)
;	h(x)((x)<=K?x:N-(x))
;	f 9999
;	A return
;	H printf{ 
;	R double
;	U int
;	V for
;	b else
;	u while
;	B if
U v,w,Y}	 -1,W,J,p,F,o}	f,M,N,K,X,YY,_,P[f],s{ } ;
typedef U{ *L} { } ;
L q[f];
tj{ } {
U S}	m{ v} +{ m{ w} <<K} ; 
B{ !S} A J; 
V{ v}	W+S; v!}	J&&!q[v]; v+}	S} ;
A v; 
}
k{ } {
_}	K; 
A v?a{ v} >1||w-Y||!q[J]:{ w-Y&&{ w-Y*2||q[W+Y*{ N+1} ]||
    { J>>K} -K+{ Y-1} / 2} } ||q[J]; 
}
z{ } {
_}	5; 
A v*w||g; 
}
e{ } {
_}	 -2; 
A{ v*v*v-v||w*w*w-w} &&{ J-W-2||{ W&N} -4||{ W>>K!}	{ Y-1?N:0} } ||
    q[W+1]||q[W+2]||q[W+K]!}	z||P[W+K]*Y<0} ; 
}
R VR{ } {
int PZ}	0x7fff; 
A{ R} { rand{ } &PZ} /{ R} PZ; 
}
l{ } {
_}	K+1; 
A{ v*w&&a{ v} -a{ w} } ||g; 
}
R UC{ } {
R {	}	0,d; 
u{ { {	+}	d}	VR{ } } <1.0} ; 
A d; 
}
c{ } {
_}	 -11; 
A a{ v} -a{ w} ||g; 
}
I{ ur,n,x} {
W}	ur; 
J}	n; 
B{ P[W]!}	Y||P[J]}	}	Y} A J+1;
v}	{ J&N} -{ W&N} ; 
w}	{ J>>K} -{ W>>K} ; 
A q[W]{ } ||{ x&&QL{ W,J,s} } ; 
}
TT{ W} {
v}	w}	0; 
A q[W]{ } +K; 
}
s{ } {
U j}	 -1,{	; 
Y}	 -Y; 
V{ {	}	0; {	<M; ++{	} {
B{ j<0&&P[{	]}	}	 -Y&&TT{ {	} &&_}	}	 -2} 
{
j}	{	; 
{	}	 -1; 
}
b B{ j>}	0&&!I{ {	,j,0} } A Y}	 -Y; 
}
A!{ Y}	 -Y} ; 
}
bb{ } {
_}	1; 
A a{ v*w} -2; 
}
uv{ } {
V{ v}	0; v<f; ++v} {
B{ h{ v>>K} }	}	0} {
U S}	h{ v&N} ;
q[v]}	!S?z:{ S}	}	1?bb:{ S}	}	2?c:{ v&N>K?l:e} } } ; 
}
b B{ h{ v>>K} }	}	1} q[v]}	k; 
b q[v]}	0;
P[v]}	!!q[v]*{ 28-v} ; 
}
}
y{ } {
U G}	Y,{	; 
J}	0; 
V{ {	}	0; {	<M; ++{	} {
{	%8||H""\n%4o "",{	} ;
B{ { Y}	P[{	]}	m{ P[{	]} } &&
TT{ {	} } H""%c "",_+93+Y*16} ; 
b H""- ""} ; 
}
H""\n    ""} ; 
do 
H""%2d"",{	++&N} ; 
u{ {	&N} ; 
Y}	G; 
H""\n""} ; 
}
O{ W,J} {
B{ { q[J]}	q[W]} }	}	k&&h{ J>>K} }	}	0} q[J]}	l; 
B{ q[W]}	}	e} B{ J-W}	}	2} O{ J+1,J-1} ;
b B{ W-J}	}	2} O{ W-1,W+1} ; 
P[J]}	P[W]; 
q[W]}	0;
P[W]}	0; 
}
QL{ W,J,D} L D; 
{
U HQ}	P[J],YX; 
L AJ}	q[J],XY}	q[W]; 
O{ W,J} ; 
YX}	D{ } ;
O{ J,W} ; 
q[J]}	AJ; 
q[W]}	XY; 
P[J]}	HQ; 
A YX; 
}
C{ } {
U {	,j,BZ}	0; 
V{ {	}	0; {	<M; ++{	} {
L Z}	q[{	]; 
B{ Z} {
U r}	h{ {	>>K} +h{ {	&N} ,G}	Y,
    S}	Z}	}	z?88:{ Z}	}	k?11
+r+{ P[{	]<0?N-{ {	>>K} :{ {	>>K} } :
{ Z}	}	l?124-{ { YY<8&&{ { {	&N} !}	K||
    { {	>>K} !}	{ P[{	]>0?0:N} } } ?M:0} :
{ Z}	}	c?41+r:{ Z}	}	e?f-r-r:36+r+r} } } } ; 
Y}	P[{	];
V{ j}	0; j<M; ++j} B{ !I{ {	,j,0} } S+}	{ P[j]?5:1} ; 
BZ+}	G}	}	Y?S:-S;
Y}	G; 
}
}
B{ !{ ++X&M-1} } write{ 1,""."",1} ; 
A BZ; 
}
PX{ } {
U {	,Q}	0,XP}	0,JZ}	M*M,E}	 -f,t,S}	o; 
B{ !F--} A++F+C{ } ;
V{ {	}	0; {	<JZ; ++{	} B{ !I{ {	>>K+K,{	&M-1,1} } {
Y}	 -Y; 
o}	 -E;
t}	 -QL{ {	>>K+K,{	&M-1,PX} ; 
Y}	 -Y; 
B{ t>E} {
++XP; 
Q}	{	; 
E}	t; 
B{ E>}	S} 
A++F,E; 
}
}
B{ !XP} E}	s{ } ?-f+1:0; 
p}	Q; 
A++F,E; 
}
RZ{ } {
U {	,j,T}	0; 
V{ ; ; } {
y{ } ; 
o}	f; 
do{
H""\n%d %d %d %s "",X,T,C{ } ,s{ } ?""!"":"">""} ;
fflush{ stdout} ; 
}
u{ scanf{ ""%o%o"",&{	,&j} !}	2||I{ {	,j,1} } ;
O{ {	,j} ; 
y{ } ; 
X}	0; 
++YY;
Y}	 -Y; 
T}	PX{ } ; 
{	}	p>>{ K<<1} ; 
j}	p&{ M-1} ; 
B{ I{ {	,j,1} } {
H""Rats!\n""} ; 
A; 
}
O{ {	,j} ; 
Y}	 -Y; 
B{ T>M*M} H""\nHar har.\n""} ; 
}
}
main{ ac,av} char**av; 
{
long time{ } ,j}	time{ &j} ; 
R {	}	0; 
srand{ { U} j} ;
V{ M}	0; M<}	f; ++M} {	+}	UC{ } ; 
M}	{	/100;
B{ M&3} ++M; 
B{ M&1} --M; 
V{ N}	1; N*N<M; ++N} ;
K}	 --N/2; 
F}	ac>1?atoi{ av[1]} :2; 
uv{ } ;
RZ{ } ; 
}
","#include <stdio.h>
;	m(x)(x<0?-1:!!x)
;	g tj()-J
;	a(x)(x<0?-x:x)
;	h(x)((x)<=K?x:N-(x))
;	f 9999
;	A return
;	H printf{ 
;	R double
;	U int
;	V for
;	b else
;	u while
;	B if
U v,w,Y}	 -1,W,J,p,F,o}	f,M,N,K,X,YY,_,P[f],s{ } ;
typedef U{ *L} { } ;
L q[f];
tj{ } {
U S}	m{ v} +{ m{ w} <<K} ; 
B{ !S} A J; 
V{ v}	W+S; v!}	J&&!q[v]; v+}	S} ;
A v; 
}
k{ } {
_}	K; 
A v?a{ v} >1||w-Y||!q[J]:{ w-Y&&{ w-Y*2||q[W+Y*{ N+1} ]||
    { J>>K} -K+{ Y-1} / 2} } ||q[J]; 
}
z{ } {
_}	5; 
A v*w||g; 
}
e{ } {
_}	 -2; 
A{ v*v*v-v||w*w*w-w} &&{ J-W-2||{ W&N} -4||{ W>>K!}	{ Y-1?N:0} } ||
    q[W+1]||q[W+2]||q[W+K]!}	z||P[W+K]*Y<0} ; 
}
R VR{ } {
int PZ}	0x7fff; 
A{ R} { rand{ } &PZ} /{ R} PZ; 
}
l{ } {
_}	K+1; 
A{ v*w&&a{ v} -a{ w} } ||g; 
}
R UC{ } {
R {	}	0,d; 
u{ { {	+}	d}	VR{ } } <1.0} ; 
A d; 
}
c{ } {
_}	 -11; 
A a{ v} -a{ w} ||g; 
}
I{ ur,n,x} {
W}	ur; 
J}	n; 
B{ P[W]!}	Y||P[J]}	}	Y} A J+1;
v}	{ J&N} -{ W&N} ; 
w}	{ J>>K} -{ W>>K} ; 
A q[W]{ } ||{ x&&QL{ W,J,s} } ; 
}
TT{ W} {
v}	w}	0; 
A q[W]{ } +K; 
}
s{ } {
U j}	 -1,{	; 
Y}	 -Y; 
V{ {	}	0; {	<M; ++{	} {
B{ j<0&&P[{	]}	}	 -Y&&TT{ {	} &&_}	}	 -2} 
{
j}	{	; 
{	}	 -1; 
}
b B{ j>}	0&&!I{ {	,j,0} } A Y}	 -Y; 
}
A!{ Y}	 -Y} ; 
}
bb{ } {
_}	1; 
A a{ v*w} -2; 
}
uv{ } {
V{ v}	0; v<f; ++v} {
B{ h{ v>>K} }	}	0} {
U S}	h{ v&N} ;
q[v]}	!S?z:{ S}	}	1?bb:{ S}	}	2?c:{ v&N>K?l:e} } } ; 
}
b B{ h{ v>>K} }	}	1} q[v]}	k; 
b q[v]}	0;
P[v]}	!!q[v]*{ 28-v} ; 
}
}
y{ } {
U G}	Y,{	; 
J}	0; 
V{ {	}	0; {	<M; ++{	} {
{	%8||H""\n%4o "",{	} ;
B{ { Y}	P[{	]}	m{ P[{	]} } &&TT{ {	} } H""%c "",_+93+Y*16} ; 
b H""- ""} ; 
}
H""\n    ""} ; 
do 
H""%2d"",{	++&N} ; 
u{ {	&N} ; 
Y}	G; 
H""\n""} ; 
}
O{ W,J} {
B{ { q[J]}	q[W]} }	}	k&&h{ J>>K} }	}	0} q[J]}	l; 
B{ q[W]}	}	e} B{ J-W}	}	2} O{ J+1,J-1} ;
b B{ W-J}	}	2} O{ W-1,W+1} ; 
P[J]}	P[W]; 
q[W]}	0;
P[W]}	0; 
}
QL{ W,J,D} L D; 
{
U HQ}	P[J],YX; 
L AJ}	q[J],XY}	q[W]; 
O{ W,J} ; 
YX}	D{ } ;
O{ J,W} ; 
q[J]}	AJ; 
q[W]}	XY; 
P[J]}	HQ; 
A YX; 
}
C{ } {
U {	,j,BZ}	0; 
V{ {	}	0; {	<M; ++{	} {
L Z}	q[{	]; 
B{ Z} {
U r}	h{ {	>>K} +h{ {	&N} ,G}	Y,
    S}	Z}	}	z?88:{ Z}	}	k?11+r+{ P[{	]<0?N-{ {	>>K} :{ {	>>K} } :
{ Z}	}	l?124-{ { YY<8&&{ { {	&N} !}	K||
    { {	>>K} !}	{ P[{	]>0?0:N} } } ?M:0} :
{ Z}	}	c?41+r:{ Z}	}	e?f-r-r:36+r+r} } } } ; 
Y}	P[{	];
V{ j}	0; j<M; ++j} B{ !I{ {	,j,0} } S+}	{ P[j]?5:1} ; 
BZ+}	G}	}	Y?S:-S;
Y}	G; 
}
}
B{ !{ ++X&M-1} } write{ 1,""."",1} ; 
A BZ; 
}
PX{ } {
U {	,Q}	0,XP}	0,JZ}	M*M,E}	 -f,t,S}	o; 
B{ !F--} A++F+C{ } ;
V{ {	}	0; {	<JZ; ++{	} B{ !I{ {	>>K+K,{	&M-1,1} } {
Y}	 -Y; 
o}	 -E;
t}	 -QL{ {	>>K+K,{	&M-1,PX} ; 
Y}	 -Y; 
B{ t>E} {
++XP; 
Q}	{	; 
E}	t; 
B{ E>}	S} 
A++F,E; 
}
}
B{ !XP} E}	s{ } ?-f+1:0; 
p}	Q; 
A++F,E; 
}
RZ{ } {
U {	,j,T}	0; 
V{ ; ; } {
y{ } ; 
o}	f; 
do{
H""\n%d %d %d %s "",X,T,C{ } ,s{ } ?""!"":"">""} ;
fflush{ stdout} ; 
}
u{ scanf{ ""%o%o"",&{	,&j} !}	2||I{ {	,j,1} } ;
O{ {	,j} ; 
y{ } ; 
X}	0; 
++YY;
Y}	 -Y; 
T}	PX{ } ; 
{	}	p>>{ K<<1} ; 
j}	p&{ M-1} ; 
B{ I{ {	,j,1} } {
H""Rats!\n""} ; 
A; 
}
O{ {	,j} ; 
Y}	 -Y; 
B{ T>M*M} H""\nHar har.\n""} ; 
}
}
main{ ac,av} char**av; 
{
long time{ } ,j}	time{ &j} ; 
R {	}	0; 
srand{ { U} j} ;
V{ M}	0; M<}	f; ++M} {	+}	UC{ } ; 
M}	{	/100;
B{ M&3} ++M; 
B{ M&1} --M; 
V{ N}	1; N*N<M; ++N} ;
K}	 --N/2; 
F}	ac>1?atoi{ av[1]} :2; 
uv{ } ;
RZ{ } ; 
}
","           main(l
      ,a,n,d)char**a;{
  for(d=atoi(a[1])/10*80-
 atoi(a[2])/5-596;n=""@NKA\
CLCCGZAAQBEAADAFaISADJABBA^\
SNLGAQABDAXIMBAACTBATAHDBAN\
ZcEMMCCCCAAhEIJFAEAAABAfHJE\
TBdFLDAANEfDNBPHdBcBBBEA_AL\
 H E L L O,    W O R L D! ""
   [l++-3];)for(;n-->64;)
      putchar(!d+++33^
           l&1);}
","#define D ++*p
#define B **p
#define W while
#define R return 
#define E else
#define Q if
#define G fprintf(stderr,


#include <stdio.h>

#ifndef A
#define A	512
#endif

typedef int I;
typedef char C;
typedef void V;

I z;
I f;
I x;
I a[A], b;


I d[A][A];
I m[A], n, o;

I N();
I M();
I P();
I U();
V X();
V T();
V F();
V L();
V O();

I
main(c, p)
I c;
C B;
{
	I i;
	FILE *j;
	C *k, l[BUFSIZ+1];

	Q (--c < 1) {
		G ""usage:  ag <pattern> [js...]\n"");
		R 2;
	}

	
	N(-3);
	N(-6-b);
	N(0);
	N(-3-b);

	X(&(*++p));

	*l = '\n';
	o = 1;
	i = 1;
	do {
		k = ""-"";
		j = stdin;
		Q (1 < c && **++p != '-') {
			Q (!(j = fopen(k = *p, ""r""))) {
				G 
					""ag: Failed to open '%s'.\n"", k);
				i = 3;
				continue;
			}
		}
		W (fgets(l+1, BUFSIZ, j)) {
			Q (M(l)) {
				printf(""%s:%s"", k, l+1);
				i = 0; 
			}
		}
		fclose(j);
	} W (1 < --c);
	R i;
}


V
X(p)
C B;
{
	I i, j;
	i = N(-3);
	T(p);
	W (B == '|') {
		D;
		j = N(-3);
		N('\n');
		a[i] = -4-b;
		i = N(-3);
		T(p);
		a[j] = -4-b;
	}
}


V
T(p)
C B;
{
	W (B != '|' && (!x || B != ')')  && B)
		F(p);
}


V
F(p)
C B;
{
	I i = N(-3);
	Q (B == '^') {
		D;
		N('\n');
	} E Q (B == '$') {
		D;
		N('\n');
	} E Q (B == '(') { 
		D; 
		++x;
		X(p); 
		Q (B != ')') { 
			G ""ag: Missing ')'.\n""); 
			exit(3); 
		}
		--x;
		D;
	} E {
		L(p);
	}
	Q (B == '*') {
		D;
		a[i] = -4-b;
		N(-5-i);
	} E Q (B == '?') {
		D;
		a[i] = -4-b;
	}
}


V
L(p)
C B;
{
	I i, j;
	Q (B == '.') {
		N(0);
	} E Q (B == '[') {
		D;
		i = N(-2);
		Q (B == '^') {
			D;
			a[i] = -1;
		}
		Q (B == ']') {
			D;
			N(']');
		}
		W ((i = B) != ']') {
			Q ((*p)[1] == '-' && i < (j = (*p)[2])) {
				W (i <= j)
					N(i++);
				*p += 3;
			} E {
				N(i);
				D;
			}
		}
		N('\n');
	} E {
		Q (B == '\\')
			D;
		N(B);
	}
	D;
}


I
N(c)
I c;
{
	Q (A <= b) {
		G ""ag: Pattern too long.\n"");
		exit(3);
	}
	a[b] = c;
	R b++;
}


V
O(p)
I p;
{
	I i = n;
	Q (b <= p)
		R;
	Q (a[p] < -2) {
		Q (a[p] != -3)
			O(-4-a[p]);
		O(p+1);
	} E Q (!a[p] || a[p] == z || P(&p)) {
		
		W (i < o)
			Q (m[i++] == p)
				R;
		
		f = U(p+1);

		Q (A <= o) {
			G ""ag: Out of space.\n"");
			exit(3);
		}
		
		m[o++] = p;
	}
}


I
P(p)
I *p;
{
	I i = 0, j = 0;
	Q (a[*p] == -2 || (j = a[*p] == -1)) {
		W (a[D] != '\n')
			Q (a[*p] == z)
				i = 1;
	}
	R i ^ j;
}


I
U(p)
I p;
{
	R (
		f || p == b || (
			a[p] < -2 && (
				(a[p] != -3 && U(-4-a[p])) 
				|| U(p+1)
			)
		)
	);
}


I
M(p)
C *p;
{
	I c, i, j, k;
	f = c = 0;
	W (*p && 0 <= c) {
		Q (0 < (i = d[c][*p])) {
			
			c = i;
		} E {
			
			z = *p;
			i = d[c][0];
			j = n = o;
			do 
				O(m[i++]+1);
			W (m[i] != 2);

			
			i = k = 0;
			W (i < n) {
				Q (m[i] == 2) {
					j = n;
					++k;
				}
				Q (m[i++] == m[j]) {
					Q (o <= ++j) {
						j = n;
						Q (m[i] == 2) {
							
							o = n;
							break;
						}
					}
				} E {
					j = n;
				}
			}
			Q (n < o) 
				
				d[++k][0] = n;
			c = d[c][*p] = f ? -1 : k;
		}
		++p;
	}
	R c < 0;
}

","long
z[7992],W,H,*t=z,j,k,*T=z,n,b;
#include<X11/Xlib.h>
Window*E,D,s,w[999],*e=w;
Display*d;
Pixmap
p;
m(w,h,x,y,u,v){
#define C XCreateSimpleWindow(d,
XSetWindowBackgroundPixmap(d,s=C*e=C
#define l(n)t[n]=T[n]+
D,l(0)x,l(1)y,t[2]=w,t[3]=h,1,b,0),l(6)-x,l(7)-y,W,H,0,0,0),p);
l(4)u;
l(5)v;
#define M XMapRaised(d,
M
s);
M*e++);
t+=8;
}
main(c,g)char**g;
{
XSetWindowAttributes
a;
XGCValues
v;
n=DefaultScreen(d=XOpenDisplay(0));
p=XCreatePixmap(d,D=RootWindow(d,n),W=DisplayWidth(d,n),H=DisplayHeight(d,n),DefaultDepth(d,n));
v.subwindow_mode=IncludeInferiors;
XCopyArea(d,D,p,XCreateGC(d,D,GCSubwindowMode,&v),0,0,W,H,0,0);
a.override_redirect=True;
XChangeWindowAttributes(d,D=C
D,0,0,W,H,0,0,b=BlackPixel(d,n)),CWOverrideRedirect,&a);
M
D);
m(W,H,0,0,3,3);
for(c=c^1?atoi(g[1]):9;
;
)for(T=z,n=e-(E=w);
n--;
T+=8,++E){
XMoveWindow(d,*E,*T+=T[4]*c,T[1]+=T[5]*c);
j=0;
#define F(n,o,s)o+T[n-4]s-0&&++j&&T[n]s!1&&(T[n]=0-T[n])||
if((F(4,0,<)F(4,T[2]-W,>)F(5,0,<)F(5,T[3]-H,>)1)&&j&&(j=T[2]/2)&&(k=T[3]/2)&&e-w<997&&rand()%32768<=T[2]*T[3]*(T[4]*T[4]+T[5]*T[5])/999){
m(T[2]-j,T[3]-k,j,k,2,2);
m(j,T[3]-k,0,k,-2,-2);
m(T[2]-j,k,j,0,2,-2);
T[7]-=2;
XResizeWindow(d,*E,T[2]=j,T[3]=k);
T[6]-=2;
}
}
}
","#include <stdio.h>

#define maxc (prs >> 16)
#define maxr (prs & 0xff00) >> 8
#define find (col > 1)
#define endb || (prs & 16) && X(0) || chpa || (eols, 0)
#define lnst doln ? 0 : (init, 0) || (prs & 128) && X(0)
#define L    endb) || 0 || (find ? 0 : (rrr++, rrc = 0)) || (lnst
#define X(p) (dfc++ && ((prs & 48) != 32 || rrc < maxc) && ++ccl && \
             (find ? (bat = bit, bit = but, but = p, ccl == col && \
             (ret = bat + bit + but) + 1) : (las = las * 2 + \
             (((main(ccl + 1, cro - 1) + main(ccl + 1, cro) + \
             main(ccl + 1, cro + 1) - p) | p) == 3), occ |= las & 1, \
             printf("" %c"", ""_O""[las & 1]), ccl == 2 && (sta |= (las & 3) << 6),\
             0)))
#define _    || (find || rrc++, 0) || X(0)
#define O    || (find || rrc++, 0) || X(1)
#define chpa (find && col > ccl && ((ret = bit + but) + 1))
#define eols (!find && (cro == 1 ? (sta |= occ << 3) : cro == 2 && \
             (sta |= occ << 2), sta |= (las & 3) << 4))
#define init (find ? (ret = bit = but = 0) : (ocp = occ, las = occ = 0, \
             printf(""\nL"")), dfc = (prs & 192) != 64, ccl = 0)
#define doln !(dfl++ && (((prs & 3) != 2) || rrr < maxr) && \
             (++cro == row || !find))
#define recu (col =- col, (ccl = find ? rcf : rcl), cro = rro, 0 _ || \
             (rrc >= maxc ? 0 : (find ? rcf = ccl : (rcl = ccl), \
             main(-col, row))))
#define addl (lnst || (rro = cro, find ? rcf = ccl : (rrc = 0, rcl = ccl), \
             0) || main(-col, row) || (ccl = rcl + 1, 0) endb)
#define outp (find || printf(""\n\nGEN %d STAT %ld\nEND\n"", ++gen, \
             (long)ccl << 16 | cro << 8 | (sta | occ | ocp << 1) ^ 0x66))
#define GEN  endb) || (prs & 1) && addl || (outp, 0)), ret)); } int gen =
#define STAT ;long prs =
#define END  ;
#define LIFE int bat, bit, but, las, gen, ret, rcl, rcf, rro, rrc, rrr, \
             occ, ocp, sta, dfc; long prs; main(int col, int row) { \
             int dfl = ((prs & 12) != 4), ccl = 0, cro = 0; return \
             col == 1 && printf(""LIFE\n""), (col < 0 ? recu : \
             (((ret = 0) || (prs & 8) && addl || 0 && (0

#include ""life.d""
","

                     static signed char a[] = {0x69,
                   110, 118, 97, 108, 105,  0x64, 1-1,
                 0x6d, 111, 118,  101, 1<<1<<1<<1<<1<<1,
                 114,  105, 0x6e,  103,  32, 'o'/3, 100,
                 32, 102, 114, 111,  0x6d, 32, 115, 116,
                 97, 100-001, 107, 32,37, 2*'2', '@'>>1,
                 116, '%' + '%' + '%','w'-'W',115, 0x74,
                 97, 3*'!', 107, 'q' - 'Q', 37, 10*'\n',
                 10, 0}, * b = a + (1<<1<<1<<1), * w, x,
                 *q, c, r; int main(int d, char *e []) {
                 return q = (signed char *)(e+1+1), (r =
                 e[0] && e[1] ? 0 : 0 * puts (a) + 1) ||
                 (r = e[1<<1] && d != 1 <<1 && 0 * puts(
                 a) + 1) || e[1- -1] ||  (r = atoi(e[1])
                 < -0200 || atoi (e [1]) > 0x7f || ( x =
                 atoi( e[1] ) ) == 0 ? 0 * puts(a) + 1 :
                 0) || e [1- -1] || (x- -x > 1-1 ? (q[0]
                   = x, q[1] = q[3] = 1, q[2] = 2) : (
                     memset ( w = ( signed  char * )







                     malloc(-x), '1', -x), puts (w),
                   q[0] = x, q[1] = '0', q[2] = q[3] =
                 0)), r || (q[3] ? (c = 6 - q[1] - q[2],
                 (q[0] != 1) ? q[0]-- , d = q[2], q[2] =
                 c, main(2, e), c = q[2], q[2] = d, q[0]
                 ++ : 0, printf(b, q[0], q[1], q[2]), (q
                 [0] != 1) ? q[0]--, d = q[1],q[1] = c ,
                 main(2, e), c = q[1], q[1] = d, q[0] ++
                 : 0) : - 1 - q[0] - 1 == 0 ? (w[- x - 1
                 - (q[1] & 1 ^ 1)] = q[1], puts (w), w [
                 - x - 1 - (q[1] & 1)] = q[1], puts(w) )
                 : - 1 - q[0] == 0 ?  (w[- x - 1] = q[ 1
                   ], puts(w)) : (q[0] += 1 + ( q[1] & 1
                       ^ 1), main(2, e), q[0] -= 1 + ( q
                             [1] & 1 ^ 1), q[1] & 1 ? (q
                                [0]+=1+1,  q[1]^=1, main
                                (2, e), q[1]^=1, q[0]-=1
                                +1) : 0, w[q[0] - x] = q
                               [1], puts(w), q[1] & 1 ?
                             0 : (q[0]+=1+1, q[1]^=1,
                           main (2, e), q[1]^=1, q
                         [0]-=1+1), q[0] += 1 +
                      (q[1] & 1),main(2,e)
                  , q[0] -= 1 + (q[1]
                 & 1) ) ), r; }
","  G	int i,j
  K	case
  R	return 0
  S(	x,y) for(x=0; x<y; x++)
  I	S(i,10
  z	I-6)B[t][u
  t	(X[m].b[i].i+g)
  u	(X[m].b[i].j+l)
  M(	x,y) XFillRectangles(D,p,x,a,y);
  s	B[i][j
  W	=XCreateGC(D,p,4,L)
  E(	W,_) k=0; I)S(j,22)if(W s]){ a[k].x=i*20; a[k].y=j*20+30; a[k].w=a[k].h=_; k++; }M(
  A(	W,_) &&!B[W]; if(!j){ z]=1; R; } else{ N(m); _; v(0); }
  Q	]=0; I-6&&j)j=
  F	I-6)B[X[w].b[i].i+g][X[w].b[i].j+l
  e(	x) break; K x:q(c,j,x);
  H	(m){ G; I-6){ a[i].x=t*20; a[i].y=u*20+30; a[i].w=a[i].h=
  v(	_) d(m); z+_]=1; R+1;
struct{
	short x,y,w,h;
} a[220],C;
struct{
	struct{
		G;
	} b[4];
} X[99];
G,l,g=3,p,B[10][22],L[99],o[99],n,r,h,_[4],D,J,T;
f(){
	*L=2;
	n||XSendEvent(D,p,n=1,0,L),XFlush(D);
	P();
}
Z(){
	_[1]=_[3]=(9-h)*40000;
	setitimer(0,_,0);
}
main(){
	G,*_=(int*)X;
	char*c=
""*{{{ {}{{*{{{ {}* {    {{*{{{   *{{{ {* {* * {  {{ {  { *{* {   {* *{{{ *{{{ {   * {  { *{{{ {{  *{{ {  {{* {   {*{{ {{ {{ {* { {*{{ {  *{{{{    *{{ {{ "";
	for(; *c; )
		*_++=(unsigned)(*c+++2)%4;
	srand(time(0));
	L[10]=32769;
	D=XOpenDisplay(0);
	L[1]=L[2]=XWhitePixel(D,j=XDefaultScreen(D));
	XMap@p=XCreate@XRoot@j),0,0,200,470,2,0,1,0,2056,L));
	T W;
	L[2]=XBlackPixel(D,j);
	J W;{
		G,O=0,c=0;
		Z(P());
		q(c,c,1);
		for(; ; ){
			i=lK();
			j=c;
			switch(i){
				K 'k':c=q(c=""$#&'(%)+,-*/01.3254""[c]-35,j,4)?c:j;
				e('j')e('l')e(32)}
			if(n){
				if(!q(c,j,2)){
					G,n;
					for(j=21;j-1;j--){
						n=1;
						I&&n)n=s];
						n&&(X9(j++),O++);
					}
					n=0;
					I&&!n)n=B[i][21];
					Y();
					r++;
					c=rand()%19;
					if(!q(c,c,3))
						R+puts(L);
						U(Z(h=O/9));
					}
				n=0;
			}
		}
	}
}
Y(){
	G,E(,19)J,k)E(!,20)T,k)U();
}
lK(){
	XNextEvent(D,o);
	switch(*o){
		K 2:R+o[2]?0:XX k){
			G=1;switch(k){
				K 1:z+l]=1;
				d(m);R+1;
				K 'j':z Q t A(t-1][u,g--)K 'l':z Q t<9
				A(1+t][u,g++)K 4:F Q
				u<22&&t>=0&&t<10&&!B[t][u ];
				if(!j){
					F]=1;
					R;
				}
			N(w);
		v(0)K 32:for(;
	q(m,m,2);
	)n=r++;
	R+1;
	K 3:l=0;
	g=3;
	I-6&&j)j=!B[t][u+l ];
	if(!j)R;
	v(l)K 2:z Q(u+1)<22 A(t][u+1,l++)}
	R;
}
X9(_){
	G;
	for(j=_; j; j--)I)s]=s-1];
}
U(){
	void*a=&C;
	C.w=200;
	C.h=30;
	M(T,1);
	sprintf(L,""Score%9d Level%9d"",r,h);
	XDrawString(D,p,J,7,15,L,29);}
P(){
	signal(14,f);
}

","#include <stdio.h>
#include <malloc.h>
#include <string.h>

#define A(x) (e^d)&i?e:(e+=i+i/15-d,d<<=4,i<<=4,x)
#define B b+=!((e^d)&i)&&(d|=i),i<<=4,
#define C i=15,B B B B d=d<<4|d>>12,
#define D=(d=g,b=0,C b<<=4, C C C b)
#define E if(**y)goto
#define F=a[rand()%c]
#define G unsigned short
#define H e^=a[z],a[z]^=e,e^=a[z],

void
    main
	(int
	    z,char
		**y)
		    {G*a
			,b,c
			    ,d,e
				,f,g
				    ,h,i
					;*(*
					    y+=
						strlen
						    (*y)
							-1)^=
							    'd';
								srand
								    (time
									(0))
									    ;z==
									2&&
								    sscanf
								(y[1
							    ],""%d""
							,&z)
						    &&z?
						0:(z
					    =6);
					if(!
				    (a=(
				G*)
			    calloc(
			z*z*
		    z*z,
		sizeof
	    (G))
	)){
    printf
(""No\
    memory\
	\n"");
	    exit
		(1);
		    }for
			(c=1
			    ;i=15
				,d=z
				    ,c<z
					*z*z
					    *z&&
						(e=a
						    [c-1
							]+1,
							    a[c]
								=A(A
								    (A(A
									(0))
									    )),1
									);c++
								    );*(
								**y?
							    &g:&
							e)F;
						    do{
						printf
					    (""(%d): ????\b\b\b\b""
					,c);E
				    q0;else
				goto
			    q1;q0:
			printf
		    (""%04X\n""
		,g+
	    4369
	);E
    q2;q1:
scanf
    (""%hx""
	,**y
	    ?&h:
		&g);
		    E q3
			;g-=
			    4369
				;q2:
				    printf
					(""??\b\b""
					    );E q1;
						printf(
						    ""%02x\n""
							,h D
							    );q3
								:for
								    (z=f
									=0;(
									   z<c||
									(c=f
								    ,0))
								&&(H
							    b D!=
							h,H b
						    ||(a[
						f++]=
					    a[z])
					,1);z
				    ++);
				}while
			    (h!=
			64&&
		    c>0&&
		((g F
	    ),1)
	);printf
    (""\n""
);}
","char*_=__FILE__;
","/* @(#)mkentry.c	1.25 4/5/93 15:58:08 */
/*
 * Copyright (c) Landon Curt Noll & Larry Bassel, 1993.
 * All Rights Reserved.  Permission for personal, educational or non-profit 
 * use is granted provided this this copyright and notice are included in 
 * its entirety and remains unaltered.  All other uses must receive prior
 * permission in writing from both Landon Curt Noll and Larry Bassel.
 */
/*
 * mkentry - make an International Obfuscated C Code Contest entry
 *
 * usage:
 *	mkentry -r remarks -b build -p prog.c -o ioccc.entry
 *
 *	-r remarks		file with remarks about the entry
 *	-b build		file containing how prog.c should be built
 *	-p prog.c		the obfuscated program source file
 *	-o ioccc.entry		ioccc entry output file
 *
 * compile by:
 *	cc mkentry.c -o mkentry
 */
/*
 * Placed in the public domain by Landon Curt Noll, 1992.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
/*
 * WARNING:
 *
 * This program attempts to implement the IOCCC rules.  Every attempt
 * has been made to make sure that this program produces an entry that
 * conforms to the contest rules.  In all cases, where this program
 * differs from the contest rules, the contest rules will be used.  Be
 * sure to check with the contest rules before submitting an entry.
 *
 * FOR MORE INFORMATION:
 *
 *   You may contact the judges by sending Email to the following address:
 *
 *	...!{apple,pyramid,sun,uunet}!hoptoad!judges	(not the address for
 *	judges@toad.com					 submitting entries)
 *
 *   Questions and comments about the contest are welcome.
 *
 *  The rules and the guidelines may (and often do) change from year to
 *  year.  You should be sure you have the current rules and guidelines
 *  prior to submitting entries.
 *
 * Because contest rules change from year to year, one should only use this
 * program for the year that it was intended.  Be sure that the RULE_YEAR
 * define below matches this current year.
 */

#include <stdio.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

/* logic */
#ifndef TRUE
# define TRUE 1
#endif /* TRUE */
#ifndef FALSE
# define FALSE 0
#endif /* FALSE */
#define EOF_OK TRUE
#define EOF_NOT_OK FALSE

/* global limits */
#define RULE_YEAR 1993		/* NOTE: should match the current year */
#define START_DATE ""1Mar92 0:00 UTC""	/* first confirmation received */
#define MAX_COL 79		/* max column a line should hit */
#define MAX_BUILD_SIZE 256	/* max how to build size */
#define MAX_PROGRAM_SIZE 3217	/* max program source size */
#define MAX_PROGRAM_SIZE2 1536	/* max program source size not counting
				   whitespace and {}; not followed by
				   whitespace or EOF */
#define MAX_TITLE_LEN 12	/* max chars in the title */
#define MAX_ENTRY_LEN 1		/* max length in the entry input line */
#define MAX_ENTRY 8		/* max number of entries per person per year */
#define MAX_FILE_LEN 1024	/* max filename length for a info file */

/* where to send entries */
#define ENTRY_ADDR1 ""...!{apple,pyramid,sun,uunet}!hoptoad!obfuscate""
#define ENTRY_ADDR2 ""obfuscate@toad.com""

/* uuencode process - assumes ASCII */
#define UUENCODE(c) (encode_str[(int)(c)&0xff])
#define UUENCODE_LEN 45		/* max uuencode chunk size */
#define UUINFO_MODE 0444	/* mode of an info file's uuencode file */
#define UUBUILD_MODE 0444	/* mode of the build file's uuencode file */
#define UUBUILD_NAME ""build""	/* name for the build file's uuencode file */
#define UUPROG_MODE 0444	/* mode of the program's uuencode file */
#define UUPROG_NAME ""prog.c""	/* name for the program's uuencode file */

/* encode_str[(char)val] is the uuencoded character of val */
char encode_str[256+1] = ""`!\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"";

/* global declarations */
char *program;			/* our name */
long start_time;		/* the startup time */

/* forward declarations */
void parse_args();
void usage();
FILE *open_remark();
FILE *open_build();
FILE *open_program();
FILE *open_output();
void output_entry();
void output_remark();
void output_author();
void output_info();
void output_build();
void output_program();
void output_end();
int get_line();
void output_till_dot();
int col_len();
void check_io();
void uuencode();

main(argc, argv)
    int argc;		/* arg count */
    char **argv;	/* the args */
{
    FILE *remark=NULL;	/* open remarks stream */
    FILE *build=NULL;	/* open build file stream */
    FILE *prog=NULL;	/* open program stream */
    FILE *output=NULL;	/* open output stream */
    char *rname=NULL;	/* file with remarks about the entry */
    char *bname=NULL;	/* file containing how prog.c should be built */
    char *pname=NULL;	/* the obfuscated program source file */
    char *oname=NULL;	/* ioccc entry output file */
    struct tm *tm;	/* startup time structure */

    /*
     * check on the year
     */
    start_time = time((long *)0);
    tm = gmtime(&start_time);
    if (tm->tm_year != RULE_YEAR-1900) {
	fprintf(stderr,
	""%s: WARNING: this program applies to %d, which may differ from %d\n\n"",
	    argv[0], RULE_YEAR, 1900+tm->tm_year);
    }

    /*
     * parse the command line args
     */
    parse_args(argc, argv, &rname, &bname, &pname, &oname);

    /*
     * open/check the input and output files
     *
     * We open and truncate the output file first, in case it is the same
     * as one of the input files.
     */
    output = open_output(oname);
    remark = open_remark(rname);
    build = open_build(bname);
    prog = open_program(pname);
    if (output==NULL || remark==NULL || build==NULL || prog==NULL) {
	exit(1);
    }

    /*
     * output each section
     */
    output_entry(output, oname);
    output_remark(output, oname, remark, rname);
    output_author(output, oname);
    output_info(output, oname);
    output_build(output, oname, build, bname);
    output_program(output, oname, prog, pname);
    output_end(output, oname);

    /*
     * flush the output
     */
    if (fflush(output) == EOF) {
	fprintf(stderr, ""%s: flush error in %s: "", program, oname);
	perror("""");
	exit(2);
    }

    /*
     * final words
     */
    printf(""\nYour entry can be found in %s.  You should check this file\n"",
	oname);
    printf(""correct any problems and verify that the uudecode utility will\n"");
    printf(""correctly decode your build file and program.\n\n"");
    printf(""This program has been provided as a guide for submitters.  In\n"");
    printf(""cases where it conflicts with the rules, the rules shall apply.\n"");
    printf(""It is your responsibility to ensure that your entry conforms to\n"");
    printf(""the current rules.\n\n"");
    printf(""Email your entries to:\n"");
    printf(""\t%s\n"", ENTRY_ADDR1);
    printf(""\t%s\n\n"", ENTRY_ADDR2);
    printf(""Please use the following subject when you Email your entry:\n"");
    printf(""\tioccc entry\n\n"");
    /* all done */
    exit(0);
}

/*
 * parse_args - parse the command line args
 *
 * Given the command line args, this function parses them and sets the
 * required name flags.  This function will return only if the command
 * line syntax is correct.
 */
void
parse_args(argc, argv, rname, bname, pname, oname)
    int argc;		/* arg count */
    char **argv;	/* the args */
    char **rname;	/* file with remarks about the entry */
    char **bname;	/* file containing how prog.c should be built */
    char **pname;	/* the obfuscated program source file */
    char **oname;	/* ioccc entry output file */
{
    char *optarg;	/* -flag option operand */
    int flagname;	/* the name of the -flag */
    int i;

    /*
     * Not everyone has getopt, so we must parse args by hand.
     */
    program = argv[0];
    for (i=1; i < argc; ++i) {

	/* determine the flagname */
	if (argv[i][0] != '-') {
	    usage(1);
	    /*NOTREACHED*/
	}
	flagname = (int)argv[i][1];

	/* determine the flag's operand */
	if (flagname != '\0' && argv[i][2] != '\0') {
	    optarg = &argv[i][2];
	} else {
	    if (i+1 >= argc) {
		usage(2);
		/*NOTREACHED*/
	    } else {
		optarg = argv[++i];
	    }
	}

	/* save the flag's operand in the correct global variable */
	switch (flagname) {
	case 'r':
	    *rname = optarg;
	    break;
	case 'b':
	    *bname = optarg;
	    break;
	case 'p':
	    *pname = optarg;
	    break;
	case 'o':
	    *oname = optarg;
	    break;
	default:
	    usage(3);
	    /*NOTREACHED*/
	}
    }

    /*
     * verify that we have all of the required flags
     */
    if (*rname == NULL || *bname == NULL || *pname == NULL || *oname == NULL) {
	usage(4);
	/*NOTREACHED*/
    }
    return;
}

/*
 * usage - print a usage message and exit
 *
 * This function does not return.
 */
void
usage(exitval)
    int exitval;		/* exit with this value */
{
    fprintf(stderr,
	""usage: %s -r remarks -b build -p prog.c -o ioccc.entry\n\n"", program);
    fprintf(stderr, ""\t-r remarks\tfile with remarks about the entry\n"");
    fprintf(stderr, ""\t-b build\tfile containing how prog.c should be built\n"");
    fprintf(stderr, ""\t-p prog.c\tthe obfuscated program source file\n"");
    fprintf(stderr, ""\t-o ioccc.entry\tioccc entry output file\n"");
    exit(exitval);
}

/*
 * open_remark - open/check the remark file
 *
 * The remark file should be indented by 4 spaces, and should not extend
 * beyond column MAX_COL.  These are not requirements, so we only warn.
 *
 * This function returns NULL on I/O or format error.
 */
FILE *
open_remark(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    char buf[BUFSIZ+1];		/* input buffer */
    int toolong=0;		/* number of lines that are too long */
    int non_indent=0;		/* number of lines not indented by 4 spaces */

    /*
     * open the remark input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open remark file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * look at each line
     */
    while (fgets(buf, BUFSIZ, stream) != NULL) {

	/* count lines that do not start with 4 spaces */
	if (buf[0] != '\n' && strncmp(buf, ""    "", 4) != 0) {
	    ++non_indent;
	}

	/* count long lines */
	if (col_len(buf) > MAX_COL) {
	    /* found a line that is too long */
	    ++toolong;
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* note long lines if needed */
    if (toolong > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s extend beyond the 80th column\n"",
	    program, toolong, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* note non-indented lines, if needed */
    if (non_indent > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s are not indented by 4 spaces\n"",
	    program, non_indent, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_build - open/check the build file
 *
 * The how to build file must not be longer than MAX_BUILD_SIZE bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_build(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */

    /*
     * open the how to build input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_BUILD_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the how to build file: %s, is %d bytes long\n"",
	    program, filename, statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_BUILD_SIZE);
	return(NULL);
    }

    /* return the open file */
    return(stream);
}

/*
 * open_program - open/check the program source file
 *
 * The program source file must be <= 3217 bytes.  The number of
 * non-whitespace and }{; chars not followed by whitespace must
 * be <= 1536 bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_program(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */
    int count;			/* special count size */
    int c;			/* the character read */

    /*
     * open the program source input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open program source file: %s: "",
	    program, filename);
	perror("""");
	exit(7);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat program source file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_PROGRAM_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the program source file: %s, is %d bytes long\n"",
	    program, filename, statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_PROGRAM_SIZE);
	return(NULL);
    }

    /*
     * count the non-whitespace, non {}; followed by whitespace chars
     */
    count = 0;
    c = 0;
    while ((c=fgetc(stream)) != EOF) {
	/* look at non-whitespace */
	if (!isascii(c) || !isspace(c)) {
	    switch (c) {
	    case '{':		/* count if not followed by EOF or whitespace */
	    case '}':
	    case ';':
		/* peek at next char */
		c = fgetc(stream);
		if (c != EOF && isascii(c) && !isspace(c)) {
		    /* not followed by whitespace or EOF, count it */
		    ungetc(c, stream);
		    ++count;
		}
		break;
	    default:
		++count;
		break;
	    }
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* look at the special size */
    if (count > MAX_PROGRAM_SIZE2) {
	fprintf(stderr,
	    ""%s: FATAL: the number of bytes that are non-whitespace, and\n"",
	    program);
	fprintf(stderr,
	    ""%s:        that are not '{', '}', ';' followed by whitespace\n"",
	    program);
	fprintf(stderr,
	    ""%s:        or EOF must be <= %d bytes\n"",
	    program, MAX_PROGRAM_SIZE2);
	fprintf(stderr,
	    ""%s:        in %s, %d bytes were found\n"",
	    program, filename, count);
	return(NULL);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_output - open/check the entry output file
 *
 * This function returns NULL on open error.
 */
FILE *
open_output(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */

    /*
     * open the ioccc entry output file
     */
    stream = fopen(filename, ""w"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open ioccc entry file for output: %s: "",
	    program, filename);
	perror("""");
	exit(8);
    }

    /* return the open file */
    return(stream);
}

/*
 * output_entry - output the ---entry--- section
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_entry(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char title[MAX_TITLE_LEN+1+1];	/* the entry's title */
    char buf[MAX_COL+1+1];		/* I/O buffer */
    int entry=0;			/* entry number */
    int ret;				/* fields processed by fscanf */
    int ok_line=0;			/* 0 => the line is not ok */
    char skip;				/* input to skip */
    FILE *date_pipe;			/* pipe to a date command */
    time_t epoch_sec;			/* seconds since the epoch */
    char *p;

    /*
     * write the start of the section
     */
    fprintf(output, ""---entry---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the rule year
     */
    fprintf(output, ""rule:\t%d\n"", RULE_YEAR);
    check_io(output, oname, EOF_NOT_OK);

    /* determine if this is a fix */
    printf(""Is this a fix, update or resubmittion to a "");
    printf(""previous entry (enter y or n)? "");
    while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    if (buf[0] == 'y') {
	fprintf(output, ""fix:\ty\n"");
	check_io(output, oname, EOF_NOT_OK);
	printf(""\nBe sure that the title and entry number that you give\n"");
	printf(""are the same of as the entry you are replacing\n"");
    } else {
	fprintf(output, ""fix:\tn\n"");
	check_io(output, oname, EOF_NOT_OK);
    }

    /*
     * write the title
     */
    printf(""\nYour title must match expression be a [a-zA-Z0-9_=] character\n"");
    printf(""followed by 0 to %d more [a-zA-Z0-9_=+-] characters.\n\n"",
	MAX_TITLE_LEN-1);
    printf(""It is suggested, but not required, that the title should\n"");
    printf(""incorporate your username; in the\n"");
    printf(""case of multiple authors, consider using parts of the usernames\n"");
    printf(""of the authors.\n\n"");
    printf(""enter your title: "");
    do {
	/* prompt and read a line */
	if ((ok_line = get_line(title, MAX_TITLE_LEN+1, MAX_COL-9)) <= 0) {
	    printf(""\ntitle is too long, please re-enter: "");
	    continue;
	}

	/* verify the pattern, not everyone has regexp, so do it by hand */
	if (!isascii((int)title[0]) ||
	    !(isalnum((int)title[0]) || title[0] == '_' || title[0] == '=')) {
	    printf(""\ninvalid first character in the title\n\n"");
	    printf(""enter your title: "");
	    ok_line = 0;
	} else {
	    for (p=(&title[1]); *p != '\0' && *p != '\n'; ++p) {
		if (!isascii((int)*p) ||
		    !(isalnum((int)*p) ||
		      *p == '_' || *p == '=' || *p == '+' || *p == '-')) {
		    printf(""\ninvalid character in the title\n\n"");
		    printf(""enter your title: "");
		    ok_line = 0;
		}
	    }
	}
    } while (ok_line <= 0);
    fprintf(output, ""title:\t%s"", title);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the entry number
     */
    printf(""\nEach person may submit up to %d entries per year.\n\n"",
	MAX_ENTRY);
    printf(""enter an entry number from 0 to %d inclusive: "", MAX_ENTRY-1);
    do {
	/* get a valid input line */
	fflush(stdout);
	ret = fscanf(stdin, ""%d[\n]"", &entry);
	check_io(stdin, ""stdin"", EOF_NOT_OK);
	/* skip over input until newline is found */
	do {
	    skip = fgetc(stdin);
	    check_io(stdin, ""stdin"", EOF_NOT_OK);
	    if (skip != '\n') {
		/* bad text in input, invalidate entry number */
		entry = -1;
	    }
	} while (skip != '\n');

	/* check if we have a number, and if it is in range */
	if (ret != 1 || entry < 0 || entry > MAX_ENTRY-1) {
	    printf(
	      ""\nThe entry number must be between 0 and %d inclusive\n\n"",
		MAX_ENTRY-1);
	    printf(""enter the entry number: "");
	}
    } while (ret != 1 || entry < 0 || entry > MAX_ENTRY-1);
    fprintf(output, ""entry:\t%d\n"", entry);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the submission date
     */
    /* returns a newline */
    epoch_sec = time(NULL);
    fprintf(output, ""date:\t%s"", asctime(gmtime(&epoch_sec)));
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the OS/machine host information
     */
    printf(
      ""\nEnter the machine(s) and OS(s) under which your entry was tested.\n"");
    output_till_dot(output, oname, ""host:"");
}

/*
 * output_remark - output the ---remark--- section
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_remark(output, oname, remark, rname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *remark;		/* stream to the file containing remark text */
    char *rname;		/* name of the remark file */
{
    char buf[BUFSIZ+1];		/* input/output buffer */

    /*
     * write the start of the section
     */
    fprintf(output, ""---remark---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * copy the remark file to the section
     */
    while (fgets(buf, BUFSIZ, remark) != NULL) {
	fputs(buf, output);
	check_io(output, oname, EOF_NOT_OK);
    }
    check_io(remark, rname, EOF_OK);

    /* be sure that the remark section ends with a newline */
    if (buf[strlen(buf)-1] != '\n') {
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);
    }
}

/*
 * output_author - output the ---author--- section
 *
 * Read the needed information from stdin, and write the author section.
 * If multiple authors exist, multiple author sections will be written.
 */
void
output_author(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char buf[MAX_COL+1+1];	/* I/O buffer */
    int more_auths;		/* TRUE => more authors to note */
    int auth_cnt=0;		/* number of authors processed */

    /*
     * prompt the user for the author section
     */
    printf(""\nEnter information about each author.  If your entry is after\n"");
    printf(""%s and before the contest deadline, the judges\n"", START_DATE);
    printf(""will attempt to Email back a confirmation to the first author\n"");

    /*
     * place author information for each author in an individual section
     */
    do {

	/* write the start of the section */
	fprintf(output, ""---author---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* write the author */
	printf(""\nAuthor #%d name: "", ++auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nname too long, please re-enter: "");
	}
	fprintf(output, ""name:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the organization */
	printf(""\nEnter the School/Company/Organization of author #%d\n"",
	    auth_cnt);
	printf(""\nAuthor #%d org: "", auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter: "");
	}
	fprintf(output, ""org:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the address */
	printf(
	    ""\nEnter the postal address for author #%d.  Be sure to include\n"",
	    auth_cnt);
	printf(""your country and do not include your name.\n"");
	output_till_dot(output, oname, ""addr:"");

	/* write the Email address */
	printf(
	    ""\nEnter the Email address for author #%d.  Use an address from\n"",
	    auth_cnt);
	printf(
	    ""a registered domain or well known site.  If you give several\n"");
	printf(""forms, list them one per line.\n"");
	output_till_dot(output, oname, ""email:"");

	/* write the anonymous status */
	printf(""\nShould author #%d remain anonymous (enter y or n)? "",
	    auth_cnt);
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	fprintf(output, ""anon:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* determine if there is another author */
	printf(""\nIs there another author (enter y or n)? "");
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	if (buf[0] == 'y') {
	    more_auths = TRUE;
	} else {
	    more_auths = FALSE;
	}
    } while (more_auths == TRUE);
    return;
}

/*
 * output_info - output the ---info--- section(s)
 *
 * Read the needed information from stdin, and write the info section.
 * If multiple info files exist, multiple info sections will be written.
 */
void
output_info(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char infoname[MAX_FILE_LEN+1];	/* filename buffer */
    char yorn[1+1];		/* y or n answer */
    char *uuname;		/* name to uuencode as */
    FILE *infile;		/* info file stream */

    /*
     * prompt the user for info information
     */
    printf(""\nInfo files should be used only to supplement your entry.\n"");
    printf(""For example, info files may provide sample input or detailed\n"");
    printf(""information about your entry.  Because they are supplemental,\n"");
    printf(""the entry should not require them to exist.\n\n"");

    /*
     * while there is another info file to save, uuencode it
     */
    printf(""Do you have a info file to include (enter y or n)? "");
    while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    while (yorn[0] == 'y') {

	/* read the filename */
	printf(""\nEnter the info filename: "");
	while (get_line(infoname, MAX_FILE_LEN+1, 0) <= 0) {
	    printf(""\nInfo filename too long, please re-enter: "");
	}

	/* compute the basename of the info filename */
	/* remove the trailing newline */
	uuname = &infoname[strlen(infoname)-1];
	*uuname = '\0';
	/* avoid rindex/shrrchr compat issues, do it by hand */
	for (--uuname; uuname > infoname; --uuname) {
	    if (*uuname == '/') {
		++uuname;
		break;
	    }
	}

	/* attempt to open the info file */
	infile = fopen(infoname, ""r"");
	if (infile == NULL) {
	    fprintf(stderr, ""\n%s: cannot open info file: %s: "",
		program, infoname);
	    perror("""");
	    continue;
	}

	/*
	 * write the start of the section
	 */
	fprintf(output, ""---info---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* uuencode the info file */
	uuencode(output, oname, infile, infoname, UUINFO_MODE, uuname);

	printf(""\nDo you have another info file to include (enter y or n)? "");
	while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
    };
    return;
}

/*
 * output_build - output the ---build--- section
 *
 * Read the needed information from stdin, and write the build section.
 */
void
output_build(output, oname, build, bname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *build;		/* open build file stream */
    char *bname;		/* name of the build file */
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---build---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, build, bname, UUBUILD_MODE, UUBUILD_NAME);
    return;
}

/*
 * output_program - output the ---program--- section
 *
 * Read the needed information form stdin, and write the program section.
 */
void
output_program(output, oname, prog, pname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *prog;			/* open program stream */
    char *pname;		/* name of program file */
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---program---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, prog, pname, UUPROG_MODE, UUPROG_NAME);
    return;
}

/*
 * output_end - output the ---end--- section
 *
 * Read the needed information form stdin, and write the 'end section'.
 */
void
output_end(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    /*
     * write the final section terminator
     */
    fprintf(output, ""---end---\n"");
    check_io(output, oname, EOF_NOT_OK);
    return;
}

/*
 * get_line - get an answer from stdin
 *
 * This function will flush stdout, in case a prompt is pending, and
 * read in the answer.
 *
 * This function returns 0 if the line is too long, of the length of the
 * line (including the newline) of the line was ok.  This function does
 * not return if ERROR or EOF.
 */
int
get_line(buf, siz, maxcol)
    char *buf;			/* input buffer */
    int siz;			/* length of input, including the newline */
    int maxcol;			/* max col allowed, 0 => disable check */
{
    int length;			/* the length of the input line */

    /* flush terminal output */
    fflush(stdout);

    /* read the line */
    if (fgets(buf, siz+1, stdin) == NULL) {
	/* report the problem */
	check_io(stdin, ""stdin"", EOF_NOT_OK);
    }

    /* look for the newline */
    length = strlen(buf);
    if (buf[length-1] != '\n') {
	int eatchar;		/* the char being eaten */

	/* no newline found, line must be too long, eat the rest of the line */
	do {
	    eatchar = fgetc(stdin);
	} while (eatchar != EOF && eatchar != '\n');
	check_io(stdin, ""stdin"", EOF_NOT_OK);

	/* report the situation */
	return 0;
    }

    /* watch for long lines, if needed */
    if (maxcol > 0 && (length > maxcol || col_len(buf) > maxcol)) {
	/* report the situation */
	return 0;
    }

    /* return length */
    return length;
}

/*
 * output_till_dot - output a set of lines until '.' by itself is read
 *
 * This routine will read a set of lines until (but not including)
 * a single line with '.' is read.  The format of the output is:
 *
 *	leader:\tfirst line
 *	\tnext line
 *	\tnext line
 *	   ...
 *
 * This routine will not return if I/O error or EOF.
 */
void
output_till_dot(output, oname, leader)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    char *leader;		/* the lead text for the first line */
{
    char buf[BUFSIZ+1];		/* input buffer */
    int count;			/* lines read */
    int done=FALSE;		/* TRUE => finished reading input */

    /* instruct the user on how to input */
    printf(""\nTo end input, enter a line with a single period.\n"");

    /* read lines until '.' or EOF */
    count = 0;
    while (!done) {
	/* issue the prompt */
	printf(""%s\t"", (count>0) ? """" : leader);
	fflush(stdout);

	/* get the line */
	if (get_line(buf, BUFSIZ, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter:\n\t"");
	    continue;
	}

	/* note if '.' was read */
	if (strcmp(buf, "".\n"") == 0) {
	    done = TRUE;
	}

	/* write line if we read something */
	if (!done) {
	    fprintf(output, ""%s\t%s"", (count++>0) ? """" : leader, buf);
	    check_io(output, oname, EOF_NOT_OK);
	}
    }

    /* if no lines read, at least output something */
    if (count <= 0) {
	fprintf(output, ""%s\t.\n"", leader);
	check_io(output, oname, EOF_NOT_OK);
    }
    return;
}

/*
 * col_len - determine the highest that a string would reach
 *
 * Given a string, this routine returns that a string would reach
 * if the string were printed at column 1.  Tab stops are assumed
 * to start at 9, 17, 25, 33, ...
 */
int
col_len(string)
    char *string;		/* the string to examine */
{
    int col;	/* current column */
    char *p;	/* current char */

    /* scan the string */
    for (col=0, p=string; *p != '\0' && *p != '\n'; ++p) {
	/* note the column shift */
	col = (*p=='\t') ? 1+((col+8)/8*8) : col+1;
    }
    if (*p == '\n') {
	--col;
    }

    /* return the highest column */
    return col;
}

/*
 * check_io - check for EOF or I/O error on a stream
 *
 * Does not return if EOF or I/O error.
 */
void
check_io(stream, name, eof_ok)
    FILE *stream;		/* the stream to check */
    char *name;			/* the name of this stream */
    int eof_ok;			/* EOF_OK or EOF_NOT_OK */
{
    /* test for I/O error */
    if (ferror(stream)) {
	fprintf(stderr, ""%s: error on %s: "", program, name);
	perror("""");
	exit(1);

    /* test for EOF */
    } else if (eof_ok == EOF_NOT_OK && feof(stream)) {
	fprintf(stderr, ""%s: EOF on %s\n"", program, name);
	exit(1);
    }
    return;
}

/*
 * uuencode - uuencode a file
 *
 * Perform the uuencoding process identical to the process performed
 * by the uuencode(1) utility.
 *
 * This routine implements the algorithm described in the uuencode(5)
 * 4.3BSD Reno man page.
 */
void
uuencode(output, oname, infile, iname, umode, uname)
    FILE *output;		/* output file stream */
    char *oname;		/* output filename */
    FILE *infile;		/* input file stream */
    char *iname;		/* input filename */
    int umode;			/* the mode to put on the uuencode file */
    char *uname;		/* name to put on the uuencode file */
{
    char buf[UUENCODE_LEN+1];	/* the uuencode buffer */
    int read_len;		/* actual number of chars read */
    int val;			/* 6 bit chunk from buf */
    char filler='\0';		/* filler uuencode pad text */
    char *p;

    /*
     * output the initial uuencode header
     */
    fprintf(output, ""begin %o %s\n"", umode, uname);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * clear out the input buffer
     */
    for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	*p = '\0';
    }

    /*
     * We will process UUENCODE_LEN chars at a time, forming
     * a single output line each time.
     */
    while ((read_len=fread(buf,sizeof(buf[0]),UUENCODE_LEN,infile)) > 0) {

	/*
	 * the first character is the length character
	 */
	fputc(UUENCODE(read_len), output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * We will convert 24 bits at a time.  Thus we will convert
	 * 3 sets of 8 bits into 4 sets of uuencoded 6 bits.
	 */
	for (p=buf; read_len>0; read_len-=3, p+=3) {

	    /* bits 0 to 5 */
	    val = (p[0]>>2)&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 6 to 11 */
	    val = ((p[0]<<4)&0x30) | ((p[1]>>4)&0x0f);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 12 to 17 */
	    val = ((p[1]<<2)&0x3c) | ((p[2]>>6)&0x03);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 18 to 23 */
	    val = p[2]&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);
	}

	/* end of UUENCODE_LEN line */
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * clear out the input buffer  (don't depend on bzero() or memset())
	 */
	for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	    *p = '\0';
	}
    }

    /* check the last read on the input file */
    check_io(infile, iname, EOF_OK);

    /* write end of uuencode file */
    fprintf(output, ""%c\nend\n"", UUENCODE(filler));
    check_io(output, oname, EOF_NOT_OK);
}
","char*_,*O;main(S,l)char**l;{*(O=*(l+++S-1)-1)=13,*l[1]=0;for(;;)for(printf(*l),_=O-1;_>=*l&&++*_>(S+*O+S)*S;*_--=(S+*O)*S);}
","/** J.K.Bonfield **
^	<						 	 							
^	>						 	 							
<			#				>						v		
<			 				 			<					
<			>				>			<		v		
X			 				 			X				j
x			 				 			X				j
X	 						x	^						k
^	 						 	^							
^	#						 									
X			 				X			X				X

^	v						 	 							
v						 	 						v		
v						#	 									
v						X	 						 		
v						x	 						 		
>				#			<						v		
>				 			 				>				
X				 			 				X			l
x				 			 				X			l

41 20
########################################
#                                      #
#  <   <   <   <   <>  <   <   <       #
#       >   >   >  <>   >   >   >   >  #
#  <   <   <   <   <>  <   <   <       #
#       >   >   >  <>   >   >   >   >  #
#  <   <   <   <   <>  <   <   <       #
#       >   >   >  <>   >   >   >   >  #
#                                      #
#                                      #
#                                      #
#                                      #
#                                      #
#                                      #
#                                      #
#                                      #
#                                      #
#                                      #
#           X                          #
########################################*/
#include <stdio.h>
#include <curses.h>
#include <stdlib.h>
#include <setjmp.h>
#include <sys/time.h>
int _tty_ch;
bool _echoit;
bool _rawmode;
SGTTY _tty;
#define U char
#define G for(
#define I )malloc(sizeof(

typedef struct z {U x[20]; struct z*y; } j; j*J[2][256];
struct timeval v= {0,1<<17} ;
U**X,c,*P=""noopoqqnr"",d;

j*a(int Q, int i) {
    G
    clear(),noecho(),cbreak(); ;
)

{
    int x=0,y=0,W=Q,Q=i-1,k;
    G;
    y<=Q;
    (mvaddch(y,x,X[y][x]),++x^W-1)||(x=0,y++));
    k=y=- --x;
    G
    refresh(),c=select(k,&y,0,0,&v)?getch():0;
    k?++x-W||(x=1,++y-Q||(--k,x=W-1,y=Q-1)):--x||(y--,x=W-1),k|y;
)

{
    j *t;
    G
    t=J[1-k][X[y][x]]; t; t=t->y) {
	U*f=t->x;
	if (d==f[17]|f[17]==c) {
	    int i=k&2,u=9,k=1,w=x,_=y,T;
	    G;
	    --u||(d-f[8]&&(X[y][x]=f[8]),w---_--,i=0,u=8,k--);) {
	        _+=P[T=i>u?u:i]-'o';
	        w+=P[4+T]-'p';
	        if(k) {
		    if (d-f[i]&&f[i]-X[_][w]) break;
		        i++;
	        } else
		    f[++i+8]-d && (X[_][w]=f[i+8]);
}   }   }   }   }   }

jmp_buf E;

int main(int open, U**exit) {
    FILE*C=fopen (
	open-2?__FILE__:*++exit,P+8);
	j*t;
	volatile int Q,Y=0;
	int i,q; d=open-2?'\t':'*'; L:

	Q=0; G; setjmp(E)<256; Q--
    )
    longjmp(E,(J[Y][Q]=0,Q++));
    G; ; ) {
	if(!C)return 1;
	if('\n'==(c=getc(C)))
	    if(!Y++)goto L; else
	    {	fscanf(C,""%d %d\n"",&i,&q);
		X=(U**I P++)*q*(i+1));
	    Q=0; G; Q<q; Q++)
        X[Q]=(U*)&X[q]+Q*i;
    
	fread(*X,(initscr(),q*i),1,C);
	a(i,Q);
    }
    t=(j*I*a(Q--,--Q)));
    t->y=J[Y][c]; J[Y][c]=t;
    fgets(t->x,20,C); }
}
","#include      <stdio.h>
#define            iii\
(                     I  )                    if (                     ii(I,6\
 )                   )I [               strlen(I  )                     -1]=!1
          int ii(ll,lll  )              char*ll; {

  char *l=""\""; !l ? 1.1 : l; l,printf("";int l1=1-/*+&|"");  &+|-*/1,li=!1;while

(                lll>l1  )                 li|=! (                  l[3*l1+++3
 ]           -ll[strlen (                 ll)-1]  )                    ;return
(                    li  )                ;}main (                      ll,lll
 )  char*lll[];{char l1 [   111][21],li1[111][21  ]              ,il1[111],i1l
[                   111  ] ;int lli,l11,l1l,li/* (  */,ll1,il,l;FILE*f;if(ll-2
 )             {f=fopen (             lll[1],""r""  )     ;lli=l=ll1=il=!1;while
( fscanf(f,""%s"",l1[lli]  )             +1){li=ii (                   l1[lli],3
 )                 ;iii (                l1[lli]  )          ;l1l=l11=!1;while
(               l1l>-ll  )                  {iii (                   lll[-l1l]
 )          ;strcasecmp (    lll[-l1l--],l1[lli]  )                         ||
(              l11=++il  )       ;}l11||lli++;if (                          li
 )                  {if (                 ll1<il  )    {ll1=il;l1l=l=lli;while
(                 l1l--  )                strcpy (            li1[l1l],l1[l1l]
 )     ;}il=lli=!1;}}if (                   !ll1  )                       puts
(          "" Beats me.""  )              ;else if (                          !l
 )                 puts (                "" Yes.""  ) ;else{*li1[l1l=!1]=toupper
(              *li1[!1]  )                ;while (                       l>l1l
 )               printf (       "" %s"",li1[l1l++]  )                      ;puts
(                   "".""  )       ;}}else{sprintf (    il1,""cat %s;echo"",lll[1]
 )              ;system (                    il1  )                   ;}printf
(                ""\n? ""  )                 ;gets (                         il1
 )             ;sprintf (  i1l,""%s %s %s"",lll[!1  ]        ,lll[1],il1);system
(                 i1l);  }
","O5(O2,O7,O3)char**O7;{return!(O2+=~01+01)?00:!(O2-=02>01)?printf(""\045\157\012""
,O5(012,O7+01,00)):!(O2-=02>>01)?(**O7<=067&&**O7>057?O5(03,O7,*(*O7)++-060+010
   *O3):O3                     ):!(O2      -=-O3-      ~O3)?       (072>**
   O7&&060                     <=**O7      ?O5(04      ,O7,012     *O3-060
    +*(*O7                    )++):O3      ):!(O2      -=!O3+      !!O3)?(
    **O7>057                  &&**O7       <=071?      O5(05,      O7,*(*
     O7)+++                   O3*020       -060):      **O7<=      0106&&
     00101<=                 **O7?O5       (05,O7      ,020*O3     +*(*O7)
      ++-067)               :0140<**       O7&&**      O7<0147     ?O5(05,
      O7,-0127              +*(*O7         )+++020     *O3):O3     ):!(
       O2-=02-             01)?(**         O7==050     ?050**      ++*O7,
       O5(013,             O7,O5(          012,O7      ,00)):*     *O7<056
        &&054<*           *O7?055          **++*       O7,-O5(     06,O7,
        00):054           >**O7&&          052<**      O7?050*     *(*O7)
         ++,O5(06        ,O7,00            ):!(**      O7^0170     )||!(
         0130^**         O7)?*++           *O7,O5      (05,O7      ,00):*
          *O7==0144     ||**O7             ==0104      ?++*O7      ,O5(04,
           O7,00):      O5(03              ,O7,00      )):!--      O2?(*
           *O7==052    ?O5(07              ,O7,O3*     (*++*O7     ,O5(06
           ,O7,00)     )):!(               045-**      O7)?O5(     07,O7,
            O3%(03+( *O7)++,               O5(06,      O7,00)      )):!(**
             O7^057)?O5(07,                O7,O3/(     03-*++      *O7,O5(
             06,O7,00))):O3                ):!(O2      +=01-02     )?O5(07
             ,O7,O5(06,O7,                 00)):!(     O2+=-02/    02)?(!(*
*O7-053)?O5(011,O7,O3+(++*O7,O5(010,O7,00))):!(055^**O7)?O5(011,O7,O3-(03+*(*O7
)++,O5(0010,O7,00))):O3):!(O2-=0563&0215)?O5(011,O7,O5(010,O7,00)):(++*O7,O3);}
","#define X N(a,O(h,W(f,M(c,g))),O(i,W(f,M(d,g))))
#define A(x) r(D(x,1); O(x,-9); D(x,O(x,1)))
#define L(x) getchar()-x
#define R Z,Z,0,0
#define S 0,9,6,6,6,6,6,6,9,0
#define q D(h,0); A(f)A(g)
#define T 0,6,1,2,2,2,2,1,6,0
#define U 0,6,2,3,3,3,3,2,6,0
#define C(x) ((x<1)||(x>8))
#define F(x,y) printf(x,y);
#define N(x,y,z) *O(*O(x,y),z)
#define y(a,b,c) a[b][c]
#define O(x,y) ((x)+(y))
#define u(x) (O(0,-(x)))
#define W(x,y) ((x)*(y))
#define G(x) printf(x);
#define D(x,y) (x=(y))
#define P (random()%6)
#define Y D(e,O(e,1))
#define s D(f,O(f,Q))
#define H(x) return x
#define B(x) while(x)
#define M(x,y) *O(x,y)
#define z(a,b) a[b]
#define E(x) if(x)
#define I main(){
#define Z 0,0,0,0
#define t G(""\n"")
#define V(x) (!x)
#define v h,i,j,k
#define w e,f,g
#define J int
#define Q u(1)
#define p ""%c""
#define o 'A'
#define r for
#define n 60
#define K do

J y(a,10,10)={R,R,R,R,Z,1,Q,Z,Z,Q,1,R,R,R,R,Z},y(b,10,10)={R,S,T,
U       ,       U       ,       U       ,       U       ,       T
,       S       ,       R       }       ,       z       (       c
,       9       )       =       {       Q       ,       Q       ,
Q,0,0,1,1,1,0},z(d,9)={Q,0,1,Q,1,Q,0,1,0};I J w,v;l();r(D(e,0);O(
e       ,       -       n       )       ;       Y       )       {
q       D       (       h       ,       O       (       h       ,
m       (       f       ,       g       ,       1       ,       1
)));E(h){K{G(""\n?"")K{D(f,L(O('A',Q)));}B(C(f));K{D(g,L('0'));}B(C
(       g       )       )       ;       }       B       (       V
(       m       (       f       ,       g       ,       1       ,
Q       )       )       )       ;       l       (       )       ;
}q E((D(k,O(m(f,g,Q,1),P)))>h){D(h,k);D(i,f);D(j,g);}E(h&&m(i,j,Q
,       Q       )       ) /***/ l /***/ (       )       ;       }
}       J       m       (/*   */v/*****/)       J       v       ;
{       J       w       ; /***/ E /***/ (       N       (       a
,h,i))H(0);E(O(k,Q))D(N(a,h,i),j);D(e,N(b,h,i));r(D(g,1);O(g,-9);
D       (       g       , /***/ O /***/ (       g       ,       1
)       )       )       {/*****/D/*   */(       g       ,       O
(       g       ,       Q /***/ ) /***/ )       ;       E       (
V(O(N(a,O(h,M(c,g)),O(i,M(d,g))),j))){r(D(f,1);V(O(X,j));D(f,O(f,
1       )       )       )       ;       E       (       V       (
O       (       N       (       a       ,       O       (       h
,       W       (       f       ,       M       (       c       ,
g))),O(i,W(f,M(d,g)))),u(j))))r(s;f;s){X=X*k;D(e,O(e,N(b,O(h,W(f,
M       (       c       ,       g       )       )       )       ,
O       (       i       ,       W       (       f       ,       M
(       d       ,       g       )       )       )       )       )
);}}D(g,O(g,1));}E(V(O(e,u(N(b,h,i))))){D(N(a,h,i),0);H(0);}H(e);
}       l       (       )       {       J       f       ,       g
;       t       A       (       g       )       {       F       (
p       ,       O       (       O       (       o       ,       g
),Q))A(f)F(""%c:"",M(""X O<"",O(N(a,g,f),1)))t}G("" "")A(f)F(""%d "",f)t}
","#include <ctype.h>
#include <stdio.h>
#define A { E""Your score is %d\n"",j);exit(0);}
#define B(x,y) K(x<y){p=x;x=y;y=p;}
#define C do{p=random()%N;}F(c[p]||d[p]);
#define D random()%N
#define E printf(
#define F while
#define G int
#define H return
#define I for
#define J(r,j) a[r][j]
#define K if
#define L else
#define M isdigit
#define N 30
#define P getchar()
G a[N][3],b[N],c[N],d[N],e[N],f[N],g[N],i,j=0,k,l=0;
main(){m();n();A;}m(){G o;srandom(getpid());do{I(o=0;
o<N;e[o++]=3){J(o,0)=J(o,1)=J(o,2)=-1;c[o]=d[o]=g[o]=0;
b[o]=N*2;}r(0);s();}F(s());t();}s(){G o,p;I(o=0;o<N;o++){
B(J(o,2),J(o,1))B(J(o,1),J(o,0))B(J(o,2),J(o,1))K(J(o,0)==-1)H(1);
}H(0);}t(){G o,p;I(o=0;o<N;o+=8){C c[p]=1;C d[p]=1;}w(D,0);I(o=0;
o<3;o++){do{p=D;}F(c[p]||d[p]||f[p]||!b[p]);f[p]=1;}do{k=D;}
F((c[k])||(d[k])||(b[k]==0));}w(o,d)G o,d;{G x;b[o]=d;I(x=0;
x<3;x++)K(b[J(o,x)]>d)w(J(o,x),d+1);}G r(x)G x;{G y,t=0,u;
F(e[x]){u=3;(e[x])--;do{y=D;K(t++>1000)H(0);K(t%100==0)u--;}
F((y==x)||(e[y]<=0)||(y==J(x,2))||(y==J(x,1))||(e[y]<u));(e[y])--;
J(x,e[x])=y;J(y,e[y])=x;K(!r(y)){J(x,e[x])=J(y,e[y])=-1;(e[y])++;
(e[x])++;}L t=0;}H(1);}n(){G r,n;char v;do{r=D;}
F(c[r]||d[r]||(b[r]<3)||d[J(r,0)]||d[J(r,1)]||d[J(r,2)]||
c[J(r,0)]||c[J(r,1)]||c[J(r,2)]);F(1){E""You are in room %d\n"",r);
K(f[r]){i++;E""You found an arrow\n"");j+=20;f[r]=0;}K(b[r]==0){
E""Wumpus meat\n"");j-=100;A;}K(d[r]){E""You fell in a pit\n"");j-=50;
A;}K(r==k){K(i){i--;l++;j-=20;E""You are missing an arrow!\n"");
}K(l==3){E""You catch the robber and recover all 3 arrows!\n"");
i=3;j+=200;k=-1;}L{E""The robber scurries away\n"");do{k=D;}
F((c[k])||(d[k])||(b[k]==0)||(k==r));}}K(c[r]){c[r]=0;c[D]=1;r=D;
E""The bats pick you up and drop you in room %d\n"",r);j-=10;}L{
K(b[r]<3)E""You smell a wumpus\n"");
K(d[J(r,0)]||d[J(r,1)]||d[J(r,2)])E""You feel a breeze\n"");
K(c[J(r,0)]||c[J(r,1)]||c[J(r,2)])E""You hear a rustling sound\n"");
E""Passageways to room %d, %d, and %d\n"",J(r,0),J(r,1),J(r,2));
K(!g[r]){j+=10;g[r]=1;}do{v=P;K(v=='s')q(r);K(v=='l')break;
K(v=='i')E""You have %d arrow%c\n"",i,i-1?'s':' ');K(v=='q')A;}
F(!M(v));K(M(v)){n=v-'0';v=P;K(M(v))n=n*10+v-'0';
K((J(r,0)==n)||(J(r,1)==n)||(J(r,2)==n))r=n;}}}}q(r)G r;{G z,n;
char v;K(i==0){E""You have no arrows\n"");H;}i--;
E""Shoot into which rooms?  "");I(z=0;z<4;z++){j-=20*z;do{v=P;
K((v=='\n')&&(i>0)){j-=50;E""You have %d arrows\n"",i);H;}}F(!M(v));
n=v-'0';v=P;K(M(v))n=10*n+v-'0';K((J(r,0)==n)||(J(r,1)==n)||(J(r,2)
==n)){r=n;K(b[r]==0){E""You have killed the Wumpus!\n"");j+=500+i*100;
A;}}L K(random()%3==1){E""The arrow bounces back and kills you\n"");
j-=100;A;}L{I(n=0;n<N;n++)b[n]=2*N;w(D,0);j-=100;}K(v=='\n'){j-=50;
E""You have %d arrows\n"",i);H;}}}
","#include <stdio.h>
#include <curses.h>

char graphtab[16][16] = {
' ', '.', '.', ',', '.', ';', ':', 'j', '\'',':', ':', ';', '\'',';', '!', '|',
'.', '_', ':', ',', ';', ';', ';', 'j', '/', ';', ';', ';', 'j', 'j', 'j', 'j',
'.', ',', '-', ',', 'r', '<', 'j', 'q', '/', ';', 'I', ';', '/', '|', 'I', '|',
',', ',', 'r', 'x', '/', '/', '/', 'd', '/', '/', '/', 'd', '/', '/', '/', 'd',
'.', ':', '\\',';', '-', '=', 'v', 'q', '\'',':', '<', '|', '\'',':', '+', '+',
';', ';', '>', ';', '=', '=', 'g', 'g', '\'',':', 'S', 'S', '/', '/', '/', '+',
':', '\\','\\','\\','r', '<', 'w', 'q', '/', '<', '6', '4', '/', '/', 'd', '+',
'l', 'L', '+', 'b', 'y', '[', 'p', 'g', '/', '<', '/', '6', '/', '/', '/', '+',
'`', ':', ':', ';', '`', '\\','\\','\\','""', ':', ':', ';', '`', '\\','Y', 'T',
';', ';', ';', ';', '`', '2', '>', '\\',':', '=', ';', ';', '?', '?', ']', ']',
':', ';', ';', ';', '>', '2', '>', '\\','F', ';', 'O', ';', '7', '?', ']', '7',
';', ';', ';', ';', '?', '2', '>', 'b', ';', ';', ';', ';', '?', '?', ']', '#',
'\'','\\','\\','\\','`', '\\','\\','\\','\'','\'','<', '5', '""', '""', 'V', 'q',
';', '\\','\\','\\','`', '=', '\\','\\','\'','\'','5', '5', '""', '?', 'g', 'g',
'I', 'L', 'L', 'L', 'D', '\\','b', 'f', 'F', '[', '[', '[', 'P', '?', '#', 'M',
'|', '|', '|', '|', '|', '#', '+', '#', 'T', '[', 'F', 'F', 'P', '?', 'P', 'M'
};

#define BITROWS 96
#define BITCOLS 160
#define SCREENROWS 23	/* one less so doesn't scroll off screen */
#define SCREENCOLS 79	/* one less so doesn't scroll off screen */
char framebuffer[BITROWS][BITCOLS];

#define BITSET(r, c) framebuffer[r][c] = 1;
#define BITCLR(r, c) framebuffer[r][c] = 0;

double f();
double atof();

FILE *d;

main(argc, argv)
char **argv;
{
	int i, a, b, c, r;
	char labbuf[100];

	for (i=0; i<48; i++) {
		r = scanf(""%x %x %x"", &a, &b, &c);
		bs(i, 0, a);
		bs(i, 16, b);
		bs(i, 32, c);
	}

	bitshow();
}

bs(r, c, v)
int r, c, v;
{
	int j, q;

	for (j=16; j>0; j--) {
		q = v&0x8000;
		v <<= 1;
		if (q)	/* !q for white on black */
			BITSET(r, c);
		c++;
	}
}

bitshow()
{
	bitshow2();	/* or bitshow1() for bigger version */
}

/* Show bits with 1x2 resolution, 48x80 on screen */
bitshow1()
{
	int r, c;
	int basei, basej;
	int i, j;
	char ch;

	for (r=0; r<SCREENROWS; r++) {
		for (c=0; c<SCREENCOLS; c++) {
			basei = 2*r;
			basej = 1*c;
			i = (framebuffer[basei+0][basej+0] << 1)
			  + (framebuffer[basei+1][basej+0] << 0);
			ch = "" ,\""M""[i];
			/* mvaddch(r, c, ch); */
			putchar (ch);
		}
		putchar('\n');
	}
}

/* Show bits with 2x4 resolution, 96x160 on screen */
bitshow2()
{
	int r, c;
	int basei, basej;
	int i, j;
	char ch;

	for (r=0; r<SCREENROWS; r++) {
		for (c=0; c<SCREENCOLS; c++) {
			basei = 4*r;
			basej = 2*c;
			i = (framebuffer[basei+0][basej+0] << 3)
			  + (framebuffer[basei+1][basej+0] << 2)
			  + (framebuffer[basei+2][basej+0] << 1)
			  + (framebuffer[basei+3][basej+0] << 0);
			j = (framebuffer[basei+0][basej+1] << 3)
			  + (framebuffer[basei+1][basej+1] << 2)
			  + (framebuffer[basei+2][basej+1] << 1)
			  + (framebuffer[basei+3][basej+1] << 0);
			ch = graphtab[i][j];
			putchar(ch);
		}
		putchar ('\n');
	}
}
","#include <stdio.h>
/*
 * Obfuscated version is simpler but can't display labels.
 */

char graphtab[] =
"" ..,.;:j'::;';!|._:,;;;j/;;;jjjj.,-,r<jq/;I;/|I|,,rx///d///d///d.:\\;-=vq':<|':++;;>;==gg':SS///+:\\\\\\r<wq/<64//d+lL+by[pg/</6///+`::;`\\\\\\\""::;`\\YT;;;;`2>\\:=;;??]]:;;;>2>\\F;O;7?]7;;;;?2>b;;;;??]#'\\\\\\`\\\\\\''<5\""\""Vq;\\\\\\`=\\\\''55\""?ggILLLD\\bfF[[[P?#M|||||#+#T[FFP?PM'""
;

#define BITROWS 96
#define BITCOLS 160
#define SCREENROWS 23	/* one less so doesn't scroll off screen */
#define SCREENCOLS 79	/* one less so doesn't scroll off screen */
char framebuffer[BITROWS][BITCOLS];
char screen[SCREENROWS][SCREENCOLS];

#define BITSET(r, c) framebuffer[r][c] = 1;
#define BITCLR(r, c) framebuffer[r][c] = 0;

double f();
double atof();

/* row and column boundaries in frame buffer */
int minr= 10;
int maxr= 80;
int minc= 20;
int maxc=150;

/* x and y boundaries in formula */
double maxy= 500;
double miny=-500;
double maxx=  10;
double minx= -20;

double three, two, one, zero;	/* coefficients */

double xbase, ybase;

main(argc, argv)
char **argv;
{
	double x, y;
	char labbuf[100];

	if (argc < 5) {
		printf(""Usage: %s cube square linear constant\n"", argv[0]);
		exit(1);
	}

	/* Arguments are four coefficients to polynomial */
	three = atof(argv[1]);
	two = atof(argv[2]);
	one = atof(argv[3]);
	zero = atof(argv[4]);

	gbox(minr,maxr,minc-2,maxc+2);

	plotinit();
	for (x=minx; x<=maxx; x += .05) {
		fplot(x, f(x));
	}

	bitshow();

	hlabel(minr-4, (maxc+minc)/2 - 10, ""A Cubic Function"");
	sprintf(labbuf, ""y=%gx^3+%gx^2+%gx+%g"", three, two, one, zero);
	vlabel(12, 5, labbuf);
	hlabel(maxr+4, (maxc+minc)/2, ""x"");

	sprintf(labbuf, ""%g"", minx);
	hlabel(maxr+4, minc, labbuf);
	sprintf(labbuf, ""%g"", maxx);
	hlabel(maxr+4, maxc-strlen(labbuf)*2, labbuf);

	sprintf(labbuf, ""%g"", miny);
	vlabel(minr+4, minc-4, labbuf);
	sprintf(labbuf, ""%g"", maxy);
	vlabel(maxr-strlen(labbuf)*4, minc-4, labbuf);

	/* bigshow(20, 55, 0, 70); */
	srefresh();
}

double f(x)
double x;
{
	double y;

	y = three*x*x*x + two*x*x + one*x + zero;
	return y;
}

fplot(x, y)
double x, y;
{
	int r, c;

	r = (maxy - y) * ybase + minr;
	c = (x - minx) * xbase + minc;
	if (r >= minr && r <= maxr && c >= minc && c <= maxc)
		BITSET(r, c);
}

hlabel(r, c, lab)
int r, c;
char *lab;
{
	r = r/4;
	c = c/2;
	while (*lab)
		screen[r][c++] = *lab++;
}

vlabel(r, c, lab)
int r, c;
char *lab;
{
	r = r/4;
	c = c/2;
	while (*lab && r<maxr)
		screen[r++][c] = *lab++;
}

plotinit()
{
	ybase = (maxr-minr)/(maxy-miny);
	xbase = (maxc-minc)/(maxx-minx);
}

/* Draw the frame buffer onto the screen, 96x180 mode, 4x2 per character */
bitshow()
{
	int r, c;
	int basei, basej;
	int i, j;
	char ch;

	for (r=0; r<SCREENROWS; r++)
		for (c=0; c<SCREENCOLS; c++) {
			basei = 4*r;
			basej = 2*c;
			i = (framebuffer[basei+0][basej+0] << 3)
			  + (framebuffer[basei+1][basej+0] << 2)
			  + (framebuffer[basei+2][basej+0] << 1)
			  + (framebuffer[basei+3][basej+0] << 0);
			j = (framebuffer[basei+0][basej+1] << 3)
			  + (framebuffer[basei+1][basej+1] << 2)
			  + (framebuffer[basei+2][basej+1] << 1)
			  + (framebuffer[basei+3][basej+1] << 0);
			ch = graphtab[i*16+j];
			screen[r][c] = ch;
		}
}

/* Show all the bits separately */
bigshow(rbase, rmax, cbase, cmax)
{
	int i, j;
	char ch;

	for (i=rbase; i<=rmax; i++) {
		for (j=cbase; j<=cmax; j++) {
			if (framebuffer[i-rbase][j-cbase])
				ch = 'X';
			else
				ch = ' ';
			putchar(ch);
		}
		putchar('\n');
	}
}

/* Draw the box around the graph */
gbox(rmin, rmax, cmin, cmax)
{
	int i;
	for (i=rmin; i<=rmax; i++) {
		BITSET(i, cmin);
		BITSET(i, cmax);
	}

	for (i=cmin; i<=cmax; i++) {
		BITSET(rmin, i);
		BITSET(rmax, i);
	}
}

srefresh()
{
	int r, c;

	for (r=0; r<SCREENROWS; r++) {
		for (c=0; c<SCREENCOLS; c++)
			putchar(screen[r][c]);
		putchar('\n');
	}
}
","#define S(r, c) f[r][c] = 1;

char f[96][160]; main(argc, argv) char **argv; { double x, y, atof(); int
r									,
c									,
bi									,
bj									,
i			       ; for (i=10; i<=80			;
i			    ++) { S(i, 18); S(i, 152)			;
}		for (i=18; i<=152; i++) { S(10, i); S(80, i)		;
}	    for (x=-20;				   x<=10; x += .05)	{
y							=atof(argv[1])  *
x						   * x * x + atof(argv	[
2						])*x*x+atof(argv[3])	*
x					 + atof(argv[4])		;
r				 = (500 - y)*.07+10			;
c					 =(x+20)*4.33333		+
20						; if(r>=10 && r<=80 &&	c
>=							  20 && c<=150)	S
(							   r, c); } for (
r							=0; r < 24; r  ++
)	    for (c=0; c				     <80; c++) { bi	=
4		*r;bj=2*c;			 i=(((f[bi][bj]<<	3
)		     +(f[bi+1][bj]<<2)+(f[bi+2][bj]<<1)+(f[bi		+
3			][bj]<<0))*16+ (f[bi][bj+1]<<3)+(		f
[			    bi+1][bj+1]<<2)+(f[bi+2][bj			+
1				]<<1)+(f[bi+3][bj+			1
]				  <<0)+1)*(c<79				)
;					putchar				(

""\n ..,.;:j'::;';!|._:,;;;j/;;;jjjj.,-,r<jq/;I;/|I|,,rx///d///d///d.:\\;\
-=vq':<|':++;;>;==gg':SS///+:\\\\\\r<wq/<64//d+lL+by[pg/</6///+`::;`\\\\\
\\\""::;`\\YT;;;;`2>\\:=;;??]]:;;;>2>\\F;O;7?]7;;;;?2>b;;;;??]#'\\\\\\`\\\
\\\\''<5\""\""Vq;\\\\\\`=\\\\''55\""?ggILLLD\\bfF[[[P?#M|||||#+#T[FFP?PM'""
[i]); } }
","#include<stdio.h>
#include<stdlib.h>
#define f (sizeof(int))

int i,j,k,l,m,*t,*u,*v;
int r(x)int x;{return (rand()/256)%x;}
void p(x,y)int *x,y;{for(i=y;--i;k=x[i],x[i]=x[j],x[j]=k)j=r(i+1);}

void o(n,a,q,d)int n,d,*a,*q;
{
   for(m=r(2)?n:1,t=q,l=n/2,i=n;
       i--&&(i!=l||i--);
       *(t++)=i);
   for(p(q,n-1),q[n-1]=l,u=a,i=j=0;
       i<n*n;
       u[i] =q[j]*m,j++,++i%n||(++j,u+=d),j>=n&&(j-=n));
   for(p(q,n-1),u=a,m=n+1-m,i=0,j=n-1;
       i<n*n;
       u[i]+=q[j]*m,j++,++i%n||(--j,u+=d),j>=n&&(j-=n));
}

void s(n,a,q,d)int n,d,*a,*q;
{
   for(q[1]=3-(*q=r(n)),q[3]=3-(q[2]=1^q[r(2)]),t=a,i=n,m=3*r(2);
       i--;
       t+=d)
   for(j=n;
       j--;
       t++[0]=q[j^(i&m)^(i/2)]);
   for(q[1]=3-(*q=r(n)),q[3]=3-(q[2]=1^q[r(2)]),t=a,i=n,m=3-m;
       i--;
       t+=d)
   for(j=n;
       j--;
       t++[0]+=q[j^(i&m)^(i/2)]*4);
}

void e(n,a,q,d)int n,d,*a,*q;
{
   int h,i,k,l,z,g=n/2;
   void (*m)();
   for((m=g!=4?g%2?o:e:s)(g,a,q,g+d),m(g,a+g,q,g+d),l=(n+d)*g,u=a,i=g;
       i--;
       u+=d)
   for(j=n;
       j--;
       j<g&&(*u+=g*2*g),l[u]=*u+(j<g?-1:3)*g*g,u++);
   for(i=g; i--; q[i]=i<g/2);
   for(h=k=(g+1)/2,v=a; v<a+n; v+=g){
      for(u=v,i=g; i--; u+=g+d){
         if(p(q,g),q[z=g-i-1])
         if(k)k--;
         else
         for(j=g;q[--j]||(q[j]=1,q[z]=0););
         else 
         if(k>i)
         for(j=g;!q[--j]||(k--,q[z]=1,q[j]=0););
         if(q[i])
         if(h)h--;
         else
         for(j=g;q[--j]||j==z||(q[j]=1,q[i]=0););
         else
         if(h>i||(g==3&&h&&(k==2||i==z)))
         for(j=g;!q[--j]||j==z||(h--,i==z&&k--,q[i]=1,q[j]=0););
         for(t=q,j=g;j--;u++)
         if(0[t++])z=*u,*u=u[l],u[l]=z;
      }
      for(h=k=g/2-g%2,i=g;i--;q[i]=i<h);
   }
}

int main(c,v)
int c;
char **v;
{
   int n,*a,*b;
   srand(getpid());
   if(c<2 || sscanf(1[v],""%d"",&n)!=1 || n<3) n=5;
   if(!((a=(int*)malloc(n*n*f))&&(b=(int*)malloc(n*f))))
      return perror(""malloc""),1;
   (n!=4?n%2?o:e:s)(n,a,b,0);
   for(i=0;i<n*n;i++)
      printf(""%4d%c"",a[i]+1,(i+1)%n?' ':'\n');
   return 0;
}
","int _,O,__??('}'??);main(){while(O?gets((rand()%O++?':':_)+__)||puts(&__??(_??))&_:srand(time((O+++_)))||O);}
","/* @(#)mkentry.c	1.27 3/5/94 04:22:32 */
/*
 * Copyright (c) Landon Curt Noll & Larry Bassel, 1994.
 * All Rights Reserved.  Permission for personal, education or non-profit use
 * is granted provided this this copyright and notice are included in its
 * entirety and remains unaltered.  All other uses must receive prior
 * permission in writing from both Landon Curt Noll and Larry Bassel.
 */
/*
 * mkentry - make an International Obfuscated C Code Contest entry
 *
 * usage:
 *	mkentry -r remarks -b build -p prog.c -o ioccc.entry
 *
 *	-r remarks		file with remarks about the entry
 *	-b build		file containing how prog.c should be built
 *	-p prog.c		the obfuscated program source file
 *	-o ioccc.entry		ioccc entry output file
 *
 * compile by:
 *	cc mkentry.c -o mkentry
 */
/*
 * Placed in the public domain by Landon Curt Noll, 1992.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
/*
 * WARNING:
 *
 * This program attempts to implement the IOCCC rules.  Every attempt
 * has been made to make sure that this program produces an entry that
 * conforms to the contest rules.  In all cases, where this program
 * differs from the contest rules, the contest rules will be used.  Be
 * sure to check with the contest rules before submitting an entry.
 *
 * FOR MORE INFORMATION:
 *
 *   You may contact the judges by sending EMail to the following address:
 *
 *	...!{apple,pyramid,sun,uunet}!hoptoad!judges	(not the address for
 *	judges@toad.com					 submitting entries)
 *
 *   Questions and comments about the contest are welcome.
 *
 *  The rules and the guidelines may (and often do) change from year to
 *  year.  You should be sure you have the current rules and guidelines
 *  prior to submitting entries.
 *
 * Because contest rules change from year to year, one should only use this
 * program for the year that it was intended.  Be sure that the RULE_YEAR
 * define below matches this current year.
 */

#include <stdio.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

/* logic */
#ifndef TRUE
# define TRUE 1
#endif /* TRUE */
#ifndef FALSE
# define FALSE 0
#endif /* FALSE */
#define EOF_OK TRUE
#define EOF_NOT_OK FALSE

/* global limits */
#define RULE_YEAR 1994		/* NOTE: should match the current year */
#define START_DATE ""4Mar92 0:00 UTC""	/* first confirmation received */
#define MAX_COL 79		/* max column a line should hit */
#define MAX_BUILD_SIZE 256	/* max how to build size */
#define MAX_PROGRAM_SIZE 3217	/* max program source size */
#define MAX_PROGRAM_SIZE2 1536	/* max program source size not counting
				   whitespace and {}; not followed by
				   whitespace or EOF */
#define MAX_TITLE_LEN 12	/* max chars in the title */
#define MAX_ENTRY_LEN 1		/* max length in the entry input line */
#define MAX_ENTRY 8		/* max number of entries per person per year */
#define MAX_FILE_LEN 1024	/* max filename length for a info file */

/* where to send entries */
#define ENTRY_ADDR1 ""...!{apple,pyramid,sun,uunet}!hoptoad!obfuscate""
#define ENTRY_ADDR2 ""obfuscate@toad.com""

/* uuencode process - assumes ASCII */
#define UUENCODE(c) (encode_str[(int)(c)&0xff])
#define UUENCODE_LEN 45		/* max uuencode chunk size */
#define UUINFO_MODE 0444	/* mode of an info file's uuencode file */
#define UUBUILD_MODE 0444	/* mode of the build file's uuencode file */
#define UUBUILD_NAME ""build""	/* name for the build file's uuencode file */
#define UUPROG_MODE 0444	/* mode of the program's uuencode file */
#define UUPROG_NAME ""prog.c""	/* name for the program's uuencode file */

/* encode_str[(char)val] is the uuencoded character of val */
char encode_str[256+1] = ""`!\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"";

/* global declarations */
char *program;			/* our name */
long start_time;		/* the startup time */

/* forward declarations */
void parse_args();
void usage();
FILE *open_remark();
FILE *open_build();
FILE *open_program();
FILE *open_output();
void output_entry();
void output_remark();
void output_author();
void output_info();
void output_build();
void output_program();
void output_end();
int get_line();
void output_till_dot();
int col_len();
void check_io();
void uuencode();

main(argc, argv)
    int argc;		/* arg count */
    char **argv;	/* the args */
{
    FILE *remark=NULL;	/* open remarks stream */
    FILE *build=NULL;	/* open build file stream */
    FILE *prog=NULL;	/* open program stream */
    FILE *output=NULL;	/* open output stream */
    char *rname=NULL;	/* file with remarks about the entry */
    char *bname=NULL;	/* file containing how prog.c should be built */
    char *pname=NULL;	/* the obfuscated program source file */
    char *oname=NULL;	/* ioccc entry output file */
    struct tm *tm;	/* startup time structure */

    /*
     * check on the year
     */
    start_time = time((long *)0);
    tm = gmtime(&start_time);
    if (tm->tm_year != RULE_YEAR-1900) {
	fprintf(stderr,
	""%s: WARNING: this program applies to %d, which may differ from %d\n\n"",
	    argv[0], RULE_YEAR, 1900+tm->tm_year);
    }

    /*
     * parse the command line args
     */
    parse_args(argc, argv, &rname, &bname, &pname, &oname);

    /*
     * open/check the input and output files
     *
     * We open and truncate the output file first, in case it is the same
     * as one of the input files.
     */
    output = open_output(oname);
    remark = open_remark(rname);
    build = open_build(bname);
    prog = open_program(pname);
    if (output==NULL || remark==NULL || build==NULL || prog==NULL) {
	exit(1);
    }

    /*
     * output each section
     */
    output_entry(output, oname);
    output_remark(output, oname, remark, rname);
    output_author(output, oname);
    output_info(output, oname);
    output_build(output, oname, build, bname);
    output_program(output, oname, prog, pname);
    output_end(output, oname);

    /*
     * flush the output
     */
    if (fflush(output) == EOF) {
	fprintf(stderr, ""%s: flush error in %s: "", program, oname);
	perror("""");
	exit(2);
    }

    /*
     * final words
     */
    printf(""\nYour entry can be found in %s.  You should check this file\n"",
	oname);
    printf(""correct any problems and verify that the uudecode utility will\n"");
    printf(""correctly decode your build file and program.\n\n"");
    printf(""This program has been provided as a guide for submitters.  In\n"");
    printf(""cases where it conflicts with the rules, the rules shall apply.\n"");
    printf(""It is your responsibility to ensure that your entry conforms to\n"");
    printf(""the current rules.\n\n"");
    printf(""EMail your entries to:\n"");
    printf(""\t%s\n"", ENTRY_ADDR1);
    printf(""\t%s\n\n"", ENTRY_ADDR2);
    printf(""Please use the following subject when you EMail your entry:\n"");
    printf(""\tioccc entry\n\n"");
    /* all done */
    exit(0);
}

/*
 * parse_args - parse the command line args
 *
 * Given the command line args, this function parses them and sets the
 * required name flags.  This function will return only if the command
 * line syntax is correct.
 */
void
parse_args(argc, argv, rname, bname, pname, oname)
    int argc;		/* arg count */
    char **argv;	/* the args */
    char **rname;	/* file with remarks about the entry */
    char **bname;	/* file containing how prog.c should be built */
    char **pname;	/* the obfuscated program source file */
    char **oname;	/* ioccc entry output file */
{
    char *optarg;	/* -flag option operand */
    int flagname;	/* the name of the -flag */
    int i;

    /*
     * Not everyone has getopt, so we must parse args by hand.
     */
    program = argv[0];
    for (i=1; i < argc; ++i) {

	/* determine the flagname */
	if (argv[i][0] != '-') {
	    usage(1);
	    /*NOTREACHED*/
	}
	flagname = (int)argv[i][1];

	/* determine the flag's operand */
	if (flagname != '\0' && argv[i][2] != '\0') {
	    optarg = &argv[i][2];
	} else {
	    if (i+1 >= argc) {
		usage(2);
		/*NOTREACHED*/
	    } else {
		optarg = argv[++i];
	    }
	}

	/* save the flag's operand in the correct global variable */
	switch (flagname) {
	case 'r':
	    *rname = optarg;
	    break;
	case 'b':
	    *bname = optarg;
	    break;
	case 'p':
	    *pname = optarg;
	    break;
	case 'o':
	    *oname = optarg;
	    break;
	default:
	    usage(3);
	    /*NOTREACHED*/
	}
    }

    /*
     * verify that we have all of the required flags
     */
    if (*rname == NULL || *bname == NULL || *pname == NULL || *oname == NULL) {
	usage(4);
	/*NOTREACHED*/
    }
    return;
}

/*
 * usage - print a usage message and exit
 *
 * This function does not return.
 */
void
usage(exitval)
    int exitval;		/* exit with this value */
{
    fprintf(stderr,
	""usage: %s -r remarks -b build -p prog.c -o ioccc.entry\n\n"", program);
    fprintf(stderr, ""\t-r remarks\tfile with remarks about the entry\n"");
    fprintf(stderr, ""\t-b build\tfile containing how prog.c should be built\n"");
    fprintf(stderr, ""\t-p prog.c\tthe obfuscated program source file\n"");
    fprintf(stderr, ""\t-o ioccc.entry\tioccc entry output file\n"");
    exit(exitval);
}

/*
 * open_remark - open/check the remark file
 *
 * The remark file should be indented by 4 spaces, and should not extend
 * beyond column MAX_COL.  These are not requirements, so we only warn.
 *
 * This function returns NULL on I/O or format error.
 */
FILE *
open_remark(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    char buf[BUFSIZ+1];		/* input buffer */
    int toolong=0;		/* number of lines that are too long */
    int non_indent=0;		/* number of lines not indented by 4 spaces */

    /*
     * open the remark input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open remark file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * look at each line
     */
    while (fgets(buf, BUFSIZ, stream) != NULL) {

	/* count lines that do not start with 4 spaces */
	if (buf[0] != '\n' && strncmp(buf, ""    "", 4) != 0) {
	    ++non_indent;
	}

	/* count long lines */
	if (col_len(buf) > MAX_COL) {
	    /* found a line that is too long */
	    ++toolong;
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* note long lines if needed */
    if (toolong > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s extend beyond the 80th column\n"",
	    program, toolong, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* note non-indented lines, if needed */
    if (non_indent > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s are not indented by 4 spaces\n"",
	    program, non_indent, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_build - open/check the build file
 *
 * The how to build file must not be longer than MAX_BUILD_SIZE bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_build(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */

    /*
     * open the how to build input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_BUILD_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the how to build file: %s, is %d bytes long\n"",
	    program, filename, statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_BUILD_SIZE);
	return(NULL);
    }

    /* return the open file */
    return(stream);
}

/*
 * open_program - open/check the program source file
 *
 * The program source file must be <= 3217 bytes.  The number of
 * non-whitespace and }{; chars not followed by whitespace must
 * be <= 1536 bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_program(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */
    int count;			/* special count size */
    int c;			/* the character read */

    /*
     * open the program source input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open program source file: %s: "",
	    program, filename);
	perror("""");
	exit(7);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat program source file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_PROGRAM_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the program source file: %s, is %d bytes long\n"",
	    program, filename, statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_PROGRAM_SIZE);
	return(NULL);
    }

    /*
     * count the non-whitespace, non {}; followed by whitespace chars
     */
    count = 0;
    c = 0;
    while ((c=fgetc(stream)) != EOF) {
	/* look at non-whitespace */
	if (!isascii(c) || !isspace(c)) {
	    switch (c) {
	    case '{':		/* count if not followed by EOF or whitespace */
	    case '}':
	    case ';':
		/* peek at next char */
		c = fgetc(stream);
		if (c != EOF && isascii(c) && !isspace(c)) {
		    /* not followed by whitespace or EOF, count it */
		    ungetc(c, stream);
		    ++count;
		}
		break;
	    default:
		++count;
		break;
	    }
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* look at the special size */
    if (count > MAX_PROGRAM_SIZE2) {
	fprintf(stderr,
	    ""%s: FATAL: the number of bytes that are non-whitespace, and\n"",
	    program);
	fprintf(stderr,
	    ""%s:        that are not '{', '}', ';' followed by whitespace\n"",
	    program);
	fprintf(stderr,
	    ""%s:        or EOF must be <= %d bytes\n"",
	    program, MAX_PROGRAM_SIZE2);
	fprintf(stderr,
	    ""%s:        in %s, %d bytes were found\n"",
	    program, filename, count);
	return(NULL);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_output - open/check the entry output file
 *
 * This function returns NULL on open error.
 */
FILE *
open_output(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */

    /*
     * open the ioccc entry output file
     */
    stream = fopen(filename, ""w"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open ioccc entry file for output: %s: "",
	    program, filename);
	perror("""");
	exit(8);
    }

    /* return the open file */
    return(stream);
}

/*
 * output_entry - output the ---entry--- section
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_entry(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char title[MAX_TITLE_LEN+1+1];	/* the entry's title */
    char buf[MAX_COL+1+1];		/* I/O buffer */
    int entry=0;			/* entry number */
    int ret;				/* fields processed by fscanf */
    int ok_line=0;			/* 0 => the line is not ok */
    char skip;				/* input to skip */
    FILE *date_pipe;			/* pipe to a date command */
    time_t epoch_sec;			/* seconds since the epoch */
    char *p;

    /*
     * write the start of the section
     */
    fprintf(output, ""---entry---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the rule year
     */
    fprintf(output, ""rule:\t%d\n"", RULE_YEAR);
    check_io(output, oname, EOF_NOT_OK);

    /* determine if this is a fix */
    printf(""Is this a fix, update or resubmittion to a "");
    printf(""previous entry (enter y or n)? "");
    while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    if (buf[0] == 'y') {
	fprintf(output, ""fix:\ty\n"");
	check_io(output, oname, EOF_NOT_OK);
	printf(""\nBe sure that the title and entry number that you give\n"");
	printf(""are the same of as the entry you are replacing\n"");
    } else {
	fprintf(output, ""fix:\tn\n"");
	check_io(output, oname, EOF_NOT_OK);
    }

    /*
     * write the title
     */
    printf(""\nYour title must match expression be a [a-zA-Z0-9_=] character\n"");
    printf(""followed by 0 to %d more [a-zA-Z0-9_=+-] characters.\n\n"",
	MAX_TITLE_LEN-1);
    printf(""It is suggested, but not required, that the title should\n"");
    printf(""incorporate your username; in the\n"");
    printf(""case of multiple authors, consider using parts of the usernames\n"");
    printf(""of the authors.\n\n"");
    printf(""enter your title: "");
    do {
	/* prompt and read a line */
	if ((ok_line = get_line(title, MAX_TITLE_LEN+1, MAX_COL-9)) <= 0) {
	    printf(""\ntitle is too long, please re-enter: "");
	    continue;
	}

	/* verify the pattern, not everyone has regexp, so do it by hand */
	if (!isascii((int)title[0]) ||
	    !(isalnum((int)title[0]) || title[0] == '_' || title[0] == '=')) {
	    printf(""\ninvalid first character in the title\n\n"");
	    printf(""enter your title: "");
	    ok_line = 0;
	} else {
	    for (p=(&title[1]); *p != '\0' && *p != '\n'; ++p) {
		if (!isascii((int)*p) ||
		    !(isalnum((int)*p) ||
		      *p == '_' || *p == '=' || *p == '+' || *p == '-')) {
		    printf(""\ninvalid character in the title\n\n"");
		    printf(""enter your title: "");
		    ok_line = 0;
		}
	    }
	}
    } while (ok_line <= 0);
    fprintf(output, ""title:\t%s"", title);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the entry number
     */
    printf(""\nEach person may submit up to %d entries per year.\n\n"",
	MAX_ENTRY);
    printf(""enter an entry number from 0 to %d inclusive: "", MAX_ENTRY-1);
    do {
	/* get a valid input line */
	fflush(stdout);
	ret = fscanf(stdin, ""%d[\n]"", &entry);
	check_io(stdin, ""stdin"", EOF_NOT_OK);
	/* skip over input until newline is found */
	do {
	    skip = fgetc(stdin);
	    check_io(stdin, ""stdin"", EOF_NOT_OK);
	    if (skip != '\n') {
		/* bad text in input, invalidate entry number */
		entry = -1;
	    }
	} while (skip != '\n');

	/* check if we have a number, and if it is in range */
	if (ret != 1 || entry < 0 || entry > MAX_ENTRY-1) {
	    printf(
	      ""\nThe entry number must be between 0 and %d inclusive\n\n"",
		MAX_ENTRY-1);
	    printf(""enter the entry number: "");
	}
    } while (ret != 1 || entry < 0 || entry > MAX_ENTRY-1);
    fprintf(output, ""entry:\t%d\n"", entry);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the submission date
     */
    /* returns a newline */
    epoch_sec = time(NULL);
    fprintf(output, ""date:\t%s"", asctime(gmtime(&epoch_sec)));
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the OS/machine host information
     */
    printf(
      ""\nEnter the machine(s) and OS(s) under which your entry was tested.\n"");
    output_till_dot(output, oname, ""host:"");
}

/*
 * output_remark - output the ---remark--- section
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_remark(output, oname, remark, rname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *remark;		/* stream to the file containing remark text */
    char *rname;		/* name of the remark file */
{
    char buf[BUFSIZ+1];		/* input/output buffer */

    /*
     * write the start of the section
     */
    fprintf(output, ""---remark---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * copy the remark file to the section
     */
    while (fgets(buf, BUFSIZ, remark) != NULL) {
	fputs(buf, output);
	check_io(output, oname, EOF_NOT_OK);
    }
    check_io(remark, rname, EOF_OK);

    /* be sure that the remark section ends with a newline */
    if (buf[strlen(buf)-1] != '\n') {
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);
    }
}

/*
 * output_author - output the ---author--- section
 *
 * Read the needed information from stdin, and write the author section.
 * If multiple authors exist, multiple author sections will be written.
 */
void
output_author(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char buf[MAX_COL+1+1];	/* I/O buffer */
    int more_auths;		/* TRUE => more authors to note */
    int auth_cnt=0;		/* number of authors processed */

    /*
     * prompt the user for the author section
     */
    printf(""\nEnter information about each author.  If your entry is after\n"");
    printf(""%s and before the contest deadline, the judges\n"", START_DATE);
    printf(""will attempt to EMail back a confirmation to the first author\n"");

    /*
     * place author information for each author in an individual section
     */
    do {

	/* write the start of the section */
	fprintf(output, ""---author---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* write the author */
	printf(""\nAuthor #%d name: "", ++auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nname too long, please re-enter: "");
	}
	fprintf(output, ""name:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the organization */
	printf(""\nEnter the School/Company/Organization of author #%d\n"",
	    auth_cnt);
	printf(""\nAuthor #%d org: "", auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter: "");
	}
	fprintf(output, ""org:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the address */
	printf(
	    ""\nEnter the postal address for author #%d.  Be sure to include\n"",
	    auth_cnt);
	printf(""your country and do not include your name.\n"");
	output_till_dot(output, oname, ""addr:"");

	/* write the EMail address */
	printf(
	    ""\nEnter the EMail address for author #%d.  Use an address from\n"",
	    auth_cnt);
	printf(
	    ""a registered domain or well known site.  If you give several\n"");
	printf(""forms, list them one per line.\n"");
	output_till_dot(output, oname, ""email:"");

	/* write the anonymous status */
	printf(""\nShould author #%d remain anonymous (enter y or n)? "",
	    auth_cnt);
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	fprintf(output, ""anon:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* determine if there is another author */
	printf(""\nIs there another author (enter y or n)? "");
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	if (buf[0] == 'y') {
	    more_auths = TRUE;
	} else {
	    more_auths = FALSE;
	}
    } while (more_auths == TRUE);
    return;
}

/*
 * output_info - output the ---info--- section(s)
 *
 * Read the needed information from stdin, and write the info section.
 * If multiple info files exist, multiple info sections will be written.
 */
void
output_info(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char infoname[MAX_FILE_LEN+1];	/* filename buffer */
    char yorn[1+1];		/* y or n answer */
    char *uuname;		/* name to uuencode as */
    FILE *infile;		/* info file stream */

    /*
     * prompt the user for info information
     */
    printf(""\nInfo files should be used only to supplement your entry.\n"");
    printf(""For example, info files may provide sample input or detailed\n"");
    printf(""information about your entry.  Because they are supplemental,\n"");
    printf(""the entry should not require them to exist.\n\n"");

    /*
     * while there is another info file to save, uuencode it
     */
    printf(""Do you have a info file to include (enter y or n)? "");
    while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    while (yorn[0] == 'y') {

	/* read the filename */
	printf(""\nEnter the info filename: "");
	while (get_line(infoname, MAX_FILE_LEN+1, 0) <= 0) {
	    printf(""\nInfo filename too long, please re-enter: "");
	}

	/* compute the basename of the info filename */
	/* remove the trailing newline */
	uuname = &infoname[strlen(infoname)-1];
	*uuname = '\0';
	/* avoid rindex/shrrchr compat issues, do it by hand */
	for (--uuname; uuname > infoname; --uuname) {
	    if (*uuname == '/') {
		++uuname;
		break;
	    }
	}

	/* attempt to open the info file */
	infile = fopen(infoname, ""r"");
	if (infile == NULL) {
	    fprintf(stderr, ""\n%s: cannot open info file: %s: "",
		program, infoname);
	    perror("""");
	    continue;
	}

	/*
	 * write the start of the section
	 */
	fprintf(output, ""---info---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* uuencode the info file */
	uuencode(output, oname, infile, infoname, UUINFO_MODE, uuname);

	printf(""\nDo you have another info file to include (enter y or n)? "");
	while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
    };
    return;
}

/*
 * output_build - output the ---build--- section
 *
 * Read the needed information from stdin, and write the build section.
 */
void
output_build(output, oname, build, bname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *build;		/* open build file stream */
    char *bname;		/* name of the build file */
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---build---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, build, bname, UUBUILD_MODE, UUBUILD_NAME);
    return;
}

/*
 * output_program - output the ---program--- section
 *
 * Read the needed information form stdin, and write the program section.
 */
void
output_program(output, oname, prog, pname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *prog;			/* open program stream */
    char *pname;		/* name of program file */
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---program---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, prog, pname, UUPROG_MODE, UUPROG_NAME);
    return;
}

/*
 * output_end - output the ---end--- section
 *
 * Read the needed information form stdin, and write the 'end section'.
 */
void
output_end(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    /*
     * write the final section terminator
     */
    fprintf(output, ""---end---\n"");
    check_io(output, oname, EOF_NOT_OK);
    return;
}

/*
 * get_line - get an answer from stdin
 *
 * This function will flush stdout, in case a prompt is pending, and
 * read in the answer.
 *
 * This function returns 0 if the line is too long, of the length of the
 * line (including the newline) of the line was ok.  This function does
 * not return if ERROR or EOF.
 */
int
get_line(buf, siz, maxcol)
    char *buf;			/* input buffer */
    int siz;			/* length of input, including the newline */
    int maxcol;			/* max col allowed, 0 => disable check */
{
    int length;			/* the length of the input line */

    /* flush terminal output */
    fflush(stdout);

    /* read the line */
    if (fgets(buf, siz+1, stdin) == NULL) {
	/* report the problem */
	check_io(stdin, ""stdin"", EOF_NOT_OK);
    }

    /* look for the newline */
    length = strlen(buf);
    if (buf[length-1] != '\n') {
	int eatchar;		/* the char being eaten */

	/* no newline found, line must be too long, eat the rest of the line */
	do {
	    eatchar = fgetc(stdin);
	} while (eatchar != EOF && eatchar != '\n');
	check_io(stdin, ""stdin"", EOF_NOT_OK);

	/* report the situation */
	return 0;
    }

    /* watch for long lines, if needed */
    if (maxcol > 0 && (length > maxcol || col_len(buf) > maxcol)) {
	/* report the situation */
	return 0;
    }

    /* return length */
    return length;
}

/*
 * output_till_dot - output a set of lines until '.' by itself is read
 *
 * This routine will read a set of lines until (but not including)
 * a single line with '.' is read.  The format of the output is:
 *
 *	leader:\tfirst line
 *	\tnext line
 *	\tnext line
 *	   ...
 *
 * This routine will not return if I/O error or EOF.
 */
void
output_till_dot(output, oname, leader)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    char *leader;		/* the lead text for the first line */
{
    char buf[BUFSIZ+1];		/* input buffer */
    int count;			/* lines read */
    int done=FALSE;		/* TRUE => finished reading input */

    /* instruct the user on how to input */
    printf(""\nTo end input, enter a line with a single period.\n"");

    /* read lines until '.' or EOF */
    count = 0;
    while (!done) {
	/* issue the prompt */
	printf(""%s\t"", (count>0) ? """" : leader);
	fflush(stdout);

	/* get the line */
	if (get_line(buf, BUFSIZ, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter:\n\t"");
	    continue;
	}

	/* note if '.' was read */
	if (strcmp(buf, "".\n"") == 0) {
	    done = TRUE;
	}

	/* write line if we read something */
	if (!done) {
	    fprintf(output, ""%s\t%s"", (count++>0) ? """" : leader, buf);
	    check_io(output, oname, EOF_NOT_OK);
	}
    }

    /* if no lines read, at least output something */
    if (count <= 0) {
	fprintf(output, ""%s\t.\n"", leader);
	check_io(output, oname, EOF_NOT_OK);
    }
    return;
}

/*
 * col_len - determine the highest that a string would reach
 *
 * Given a string, this routine returns that a string would reach
 * if the string were printed at column 1.  Tab stops are assumed
 * to start at 9, 17, 25, 33, ...
 */
int
col_len(string)
    char *string;		/* the string to examine */
{
    int col;	/* current column */
    char *p;	/* current char */

    /* scan the string */
    for (col=0, p=string; *p != '\0' && *p != '\n'; ++p) {
	/* note the column shift */
	col = (*p=='\t') ? 1+((col+8)/8*8) : col+1;
    }
    if (*p == '\n') {
	--col;
    }

    /* return the highest column */
    return col;
}

/*
 * check_io - check for EOF or I/O error on a stream
 *
 * Does not return if EOF or I/O error.
 */
void
check_io(stream, name, eof_ok)
    FILE *stream;		/* the stream to check */
    char *name;			/* the name of this stream */
    int eof_ok;			/* EOF_OK or EOF_NOT_OK */
{
    /* test for I/O error */
    if (ferror(stream)) {
	fprintf(stderr, ""%s: error on %s: "", program, name);
	perror("""");
	exit(1);

    /* test for EOF */
    } else if (eof_ok == EOF_NOT_OK && feof(stream)) {
	fprintf(stderr, ""%s: EOF on %s\n"", program, name);
	exit(1);
    }
    return;
}

/*
 * uuencode - uuencode a file
 *
 * Perform the uuencoding process identical to the process performed
 * by the uuencode(1) utility.
 *
 * This routine implements the algorithm described in the uuencode(5)
 * 4.3BSD Reno man page.
 */
void
uuencode(output, oname, infile, iname, umode, uname)
    FILE *output;		/* output file stream */
    char *oname;		/* output filename */
    FILE *infile;		/* input file stream */
    char *iname;		/* input filename */
    int umode;			/* the mode to put on the uuencode file */
    char *uname;		/* name to put on the uuencode file */
{
    char buf[UUENCODE_LEN+1];	/* the uuencode buffer */
    int read_len;		/* actual number of chars read */
    int val;			/* 6 bit chunk from buf */
    char filler='\0';		/* filler uuencode pad text */
    char *p;

    /*
     * output the initial uuencode header
     */
    fprintf(output, ""begin %o %s\n"", umode, uname);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * clear out the input buffer
     */
    for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	*p = '\0';
    }

    /*
     * We will process UUENCODE_LEN chars at a time, forming
     * a single output line each time.
     */
    while ((read_len=fread(buf,sizeof(buf[0]),UUENCODE_LEN,infile)) > 0) {

	/*
	 * the first character is the length character
	 */
	fputc(UUENCODE(read_len), output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * We will convert 24 bits at a time.  Thus we will convert
	 * 3 sets of 8 bits into 4 sets of uuencoded 6 bits.
	 */
	for (p=buf; read_len>0; read_len-=3, p+=3) {

	    /* bits 0 to 5 */
	    val = (p[0]>>2)&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 6 to 11 */
	    val = ((p[0]<<4)&0x30) | ((p[1]>>4)&0x0f);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 12 to 17 */
	    val = ((p[1]<<2)&0x3c) | ((p[2]>>6)&0x03);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 18 to 23 */
	    val = p[2]&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);
	}

	/* end of UUENCODE_LEN line */
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * clear out the input buffer  (don't depend on bzero() or memset())
	 */
	for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	    *p = '\0';
	}
    }

    /* check the last read on the input file */
    check_io(infile, iname, EOF_OK);

    /* write end of uuencode file */
    fprintf(output, ""%c\nend\n"", UUENCODE(filler));
    check_io(output, oname, EOF_NOT_OK);
}
","#include <stdio.h>
int r=0,x,y=0,    /*
nt                 /
c
lx  /\ / \ /|\ /|\
u,  \/ \\/ \-/ \ /
dn                        ]
e= ||| /|\  /\  /\        =                     p p
 0  \/ \ / |||  \/        f        f       f    r r
<,                        tw       t       s s  i i
sy  || /|\      /\     i  eh       e       e c  n n
t= /-  \ /     |||     n  li       l       e a  t t
d0     |||             t  ll       l  {<   k n  f f
i,  ||     /|\ /|\        (e s     (  fr   ( f  ( (
o    _ ||\ \ / \-/     tu s( t    usw o; i s (  "" ""
.   || - /           c [[ tg rv   [th rx=f t ""  % \
h                   mh111 de{l)   +di (+'( d+%  c n+
>                   aa000 itte; > +il x+ n inc  "" ""+
 /                  ir000[ns[nytyrrne<=)'<xn,""  , );
 */                 n         =             0     ;
               main        (       )   {
                char       v   [
                100    ]                   ,  s;
          int t[100     ]                    ,
              u[100               ]     ;  u
                  [                   0
      ]=ftell(stdin        )       ;
         while(gets (v    )                 )
                 {t  [         r ]=
             strlen                 (
               v);y=
                 t[         r             ]
                 >y             ?        t [
                  r         ]    :   y;
              u[++r   ]     =      
        ftell(stdin )   ;                          }
              while          (                    n
                  <              y        )
            {for(x=0             ;         x
            <r;x++) {                           s
               =' '       ;              
              if(n<             t        [
                  x            ]     )    {
        fseek(stdin    ,u       [     x    ]
                 +n   ,  0 )                     ;
        scanf(""%c"",                          &
                                       s        )
                   ;                             }
       printf(""%c"",   s                       )
                                            ;      }
      printf(""\n"");                 n
                 ++   ;            }           }
","#include <stdio.h>
                        /*MLSPXPMPVPOQN
                     POPJLVMMQNQNPSPYPXLRP
                   XMTJMLSPXPMPVPOQNPOPJLVMN
                 QSPWPOPXLRPXMTJMLNPOPPPSPXPOP
                JLYPRLTPVLUPVLWPVLXPVLVPSLJLUQP
              PJQLQSPXPNQPPRLTPVL*/main(){int K/*
             PUOUPWOV*/,L/*WPVLXPVLKPUOVPWOSLU*/,M
            /*PPPPVPOQMQRPR*/=0;FILE/*TPSLUMWQT*/ *
           J/*MPRPKPLQ*/;     J=      fopen(__FILE__
          /*T*/,""r"");for      (;(       L/*KPUOWOWMUQ
         LLOLMPULWLWL         WLW         LWLWLWLWLWLW
         LWLWLULVOXP          LLV          LLLOLMPULOL
        MMNP*/=getc           (J)            )!= -1;L/*
       OLWLRMMQUL             VOX             PLLVLLLMQO
       PMPYPXPNP              MQL              LVLLLWPSP
      XPOQNQOPMQ              LLV              LTj*/>='J'
     &&L/*LRPYP               OQL               QMQLLVLLL
     OLMQVOXPL                LVL                LLVOe*/<=
     'J'+15&&(                (M=                !M/*MMMQMV
     OJMMMMMU                 OOL                 NPU MPMOM
    UMRNOLMQV                 OJM                 MMMMRMLLW
    QUMTJSPX                  PNQ                  JLLPUOWO
    WMUQJMVL                  JMV                  L*/)?K/*
    MQMV*/=L:               putchar                (K/*deMN
    MaVbcLKM                  KMV                  Le*/-'J'
   /*MWQUMTJ                  WPK                  PSPXPR*/
    |(L/*PQV                  LMPSLSPXPNQ*/-       'J'<<4))
    ));exit(                  0);}/*LPQUMMPR       PKPLQJLT
    LTLJLMPU                   MTJUQMPRPKPLQ       JLNPUONM
    JMWOVLTL                                       OPVLPPWM
    PMUMTJNQ                                       SPWPOPYO
    NQJLQPUM                                       TJPNSNVN
    ONJLTLRP                                       VLTLSPUM
    TJQQRPSP                                       VPOPJLRL
    WLWLPPJLP                                     LPLJLKLJQ
     SPJQOPRL                                     NPSLJLPL
     PLJLKLPPY                                   PLQUPRLSL
     SLUMTJRPW                                   MPPNPYPJQ
      OPXPRLPMW                                 LPPVMVMKM
      VLLLKPLLSL                               UMSPWMPPNP
       YPJQOPXPR                               LRLPMWLPP
       VMVMKMSLUL                             KMVLLLLQLL
        SLUMTJPPYP                           LQRLUMUMSL
         UQSPPPRLPPS                       LUQPPQPOPNQ
         MQRLNPVLNMJM                     VLSPSLUMNPUO
          MQNQLQVPOPXPR                 LNPSLWLKMWOWM
           QLVOJMQLUMTJSP             PPRLTLNPWMWMQL
            JMQLULPPSLUQMQJQLQSPXPNQPPRLTLMPVLLLOLM
             QVOXPLLVLNPULKMSLUMYPRLMQNQNPYPOQNQVL
              PMVLPMWLPPVLNPULKMVLJMSLWQTJSPPPRLT
                LNPXMQLJMQLULPPSLYPRLRPVLOMVLNP
                 VLJMVLJMSLWQOPVPMQOPUQNQSPWPO
                   PRLPLQPSLUMOPWMKPMQMPNQSP
                     WPOPRLVPYPMPKPVPNQSPW
                        POPRLPLQPSLSLUM

TJPPYPLQRLPQWMKMUMPQVMPMUMPQULULSLYPRLRPVLPQKLWMKMPLPLPQKLWMPMWLKMVLPQ
ULQLJMQLVLKPNQYPSPRLOPULLPUOPQWOSLVLPQSLMQVPOPOPJQRLKMSLUMWQWQWQTJTJ*/

",,"#include <X11/Xlib.h>
#define M     typedef
#define N(	 a)=r=(a)+j
#define S f(; G; )D[B[H=i[--G]]=F+=F<p]++
#define	f for
#define g [H]
#define Z f(H=0; H<j; H++)
#define X H < j && h g<j*4
#define E h g + j*(T+a g>V)*2
#define o b F; b G = 0; c H = 0; c R

M int b;
M unsigned c;
M unsigned char *d;
M XPoint *e;
M void _;
short *a;
b *h, *i, j, k, l, m, n, p, V;
c T;
b O;
d A, B, C;
_ *q, *r, *calloc ();
e s, t;
Window u, v;
GC x[256];
b D[256];
b w, y, z;
_
Q (b F)
{
  XMapWindow (q, v = XCreateSimpleWindow (q, XRootWindow (q, z = XDefaultScreen (q)), !v * n, 0, n, n, 0, 0, 0));
  XSelectInput (q, v, F);
}
_
P ()
{
  C N (h N (i N (a N (s N (t N (A N (B = calloc (C - B + 256, 1))))))));
}
_
J ()
{
  o;
  R = w % 5;
  F = G = m;
  V = n * !R - 1;
  Z
  {
    h g = l + (R - 4 ? R - 2 ? R - 3 ? (a g = 2 * (F * F - G * G) / m) + 4 * F * G / m * n + (F * F > j / 4 - G * G) * j * !R * 8 : G + F * n : (G * G - F * F) / m * n + 2 * F * G / m : (G - F * F / n) + F * n);
    (s g.x = m - F--, s + H)->y = m - G;
    F = F + m ? F : (G--, m);
  }
}
_
K ()
{
  b H;
  c R;
  Z D[B g = X ? (R = E) < j ? (A[R] < p) + A[R] : 1 : 0]++;
}
_
I (d F)
{
  F || gets (F = B);
  y = atoi (F);
}
_
Y ()
{
  o;
  K ();
  f (H = k + l;
     X && (F = B g) < p;
     H = E)
  {
    D[F]--;
    B[i[G++] = H] = p;
  }
  if (H >= j)
    F = 1;
  S;
}
_
L ()
{
  o;
  Z B g = 0;
  O = -1;
  Z
  {
    f (;
       X && !(F = B g);
       H = E) B[i[G++] = H] = p;
    S;
  }
}
_
U ()
{
  o;
  e L[256], W = t;
  f (H = 0;
     H < y;
     H++)
  {
    L g = W;
    W += D g;
  }
  Z if (A g - B g)
     *L[B g]++ = s g;
  {
    XMotionEvent *R = r = t;
    W = t;
    f (H = 0;
       H < y;
       H++)
    {
      XDrawPoints (q, v, x g, W, L g - W, CoordModeOrigin);
      W += D g;
      D g = 0;
    }
    f (F = k;
       XPending (q) + !++O;
       R->type - ButtonPress ? (k = (T = R->x) + R->y * n - l) : (O = -42)) XNextEvent (q, r = R);
    Z h g += k - F;
  }
}
_
main (b i, d * W)
{
  o;
  if (i > 2)
    {
      P ();
      I (*++W);
      w = y;
      I (*++W);
      n = y * 2;
      j = n * n;
      P ();
      m = y;
      l = j / 2 + m;
      q = XOpenDisplay (0);
      Q (0);
      u = v;
      Q (PointerMotionMask | ButtonPressMask);
      I (0);
      p = y;
      {
	XColor F;
	Colormap G;
	f (H = 0;
	   H < p;
	   H++)
	{
	  I (0);
	  XParseColor (q, G = XDefaultColormap (q, z), r = B, &F);
	  XAllocColor (q, G, &F);
	  XSetForeground (q, x g = XCreateGC (q, u, 0, 0), F.pixel);
	}
      }
      y = p--;
      P ();
      J ();
      f (F = R = H = 0;
	 R < j;
	)++ F < p && X ? (T = R % n, H = G + E) : (D[B[R] = F]++, H = l, G = ++R - H, F = 0);
      T = m;
      G = j;
      U ();
      v = u;
      f (F = w / 5; ;
	 A += G -= G + G, B -= G) (O < 0 ? L : *(""tvr@cs.hut.fi."" + 7 * F) ? F ^ 1 ? Y : K : L) (), (U) ();
    }
  puts (""tvr: mode size < cmap"");
}
","#include <X11/Xlib.h>
#define M     typedef
#define N(	 a)=r=(a)+j
#define S f(; G; )D[B[R=i[--G]]=F+=F<p]++
#define	f for
#define g [H]









  M short a;					       M int b; M
  unsigned  c ;					       M unsigned
  char*d; M XPoint				       *e; M void
  _; b*h,*i,j,k,l,m,n,o,p			       ; b O; d A
  ,B,C; _*q,*r,*calloc(); e s			       ,t; Window
  u,v; GC x[256]; b D[256]; b w,y,		       z;_ Q(b E)
  { XMapWindow(q,v=XCreateSimpleWindow(q,	      XRootWindow
  (q,z=XDefaultScreen(q)),!v*n,0,n,n,0,0,0));	      XSelectInput
  ( q,v,E); }	_ P(){ C N(h N(i N(s N(t N(A N(B=calloc(C-B+256,1)
  ) )) ))); }	      _ J(){ b F,G,H; c R =w %4; F=G=m; f(H=0; H<j
  ; H++){ h g		     =l+(R-2?R?R-1?(G-F*F/n)+F*n:(G*G-F*F)
  /m*n+2*F*G/			    m: 2*(F*F- G*G)/m+4*F*G/m*n:G+
  F*n);( s g.				 x= m-F--,s +H) ->y=m-G;F=
  F+m?F:(G--,				       m);}} _ K(){ b H,R;
  f(H=0;H<j;H					   ++)D[ B g=(c)(R
  =h g+k)< j?					       (A[ R]<p)+A


				 [R
				 ]:
				 1]
				 ++
			    ; } _ I ( d F)
			     { F?(_)0:(_
			       ) (F=B,
				gets(
				 B))
				  ;

  y=atoi(F);}					       _ Y(){ b F,
  G; c R ; F = G					= 0; K( );
  f( R = k + l ; R <					j && ( F =
  B[ R ] ) < p; R = h [R				] + k) { D
  [ F ] -- ; B [ i [ G ++ ] =R				] =p; } if
  ( R >= j) F = 1; S; } _ L() { b H,			F,G; c R ;
  f( H =0; H < j; H ++) B g =0; O =-1; f(		G = R = 0;
  R < j; R++	 ){ f(; R < j && !( F = B[ R ]);	R = h[ R ]
  + k) B [i[	       G ++] = R ] = p; S; } } _ U() { e X [ 256 ]
  ,W; b H; W		     = t; f ( H = 0; H < o; H ++ ) { X g =
  W; W +=D g			      ;} f( H =0; H < j; H ++) if(
  A g - B g)				    * X[ B g ] ++ = s g; {
 XMotionEvent					   * V = r = t ; W
  = t; f ( H						= 0; H < o
  ; H ++ ) {						XDrawPoints


									 (q ,
							      v		  ,x g,
							      W,X	g -W,
							      CoordModeOrigin
							      ) ;    W +=  D
							      g ;      D g

				= 0 ;
				} f(;
			    XPending(q)+!
			    ++O; V->type-
			    ButtonPress?(
				k =V
				->x+


			   V -> y * n - l) : (
		    O = - 42 ) )  XNextEvent ( q , r
	      = V ) ; } } _ main ( b X , d * W ) { b H, F
	,G; c R; if ( X < 3 ) { puts( ""tvr: mode size < cmap""
    ); exit(0);} P(); I(*++ W); w = y %12; I(*++ W); n = y *2; j
   = n * n ; P ( ) ; m =			 y ; l = j / 2 + m
  ; q=XOpenDisplay				     ( 0 ) ; Q ( 0 )
  ; u = v ; Q (					     PointerMotionMask
  |ButtonPressMask				      ) ; I ( 0 ) ; o
   =y ; p = o -1				     ; { XColor F ;
    Colormap G; f				   ( H = 0 ; H < o
      ; H++){ I(0);				  XParseColor(q,G
       =XDefaultColormap		       ( q , z ) , r =
	    B ,	 & F ) ;		       XAllocColor
		(q , G ,		       & F ) ;










				      XSetForeground
				      (q,x g = XCreateGC
				      ( q, u ,0 , 0 ) , F
      .pixel	 ) ; } }		     P ( ); J (); f
      ( F =R	 = G =H = 0;			   H < j; )
      if(++F	 >= p || ( R =			     h [ R ]
      +G)>=j	 ) { D [ B g = F		     ] ++; R
			 = l + k; G=		     ++H -R;
			    F =0; } H=j;	    U(); v=
			      u; f(F=w/4; ; A+=H-=H+H,B-=H
				)(O<0?L:*(""tvr@cs.hut.fi.""
				    +7*F)?F^1?Y:K:L)()
				       ,(U)(); }
","
main(){
	int x=3,n,m=2,*t,*a,*b=0;
	while(b?o:((*(t=b=(int*)malloc(o))=2),a=t+1,o))n=*b,n>=m?c:x%n?(int)b++:N);
}
","#if O
main(){}
#else
























#if rop&onut&((own&rain)|warf)
#include ""						  										  The orc scrambles to the drain,					          trying to get the donut; you						          run out the door and escape!							  										  	       The End								  										  ""
#else
#if escribe
#if ocument
#include ""						  										  It reads:								              Depress Dotted Dog							  										  ""
#else
#if oor
#include ""						  										  The door is decorated with relief						  figures of various dog breeds						            										  ""
#else
#if rain
#include ""						  										  Through the drain you see a dwarf						  in another cell							            										  ""
#else
#if warf
#include ""						  										  The gnarled dwarf looks thirsty					            										  ""
#else
#if ungeon|ebris
#include ""						  										  You notice a desk, a phone, and					          a phone directory among the clutter						  										  ""
#else
#if esk
#include ""						  										  There are some dimes on the desk						  										  ""
#else
#if irectory
#include ""						  										  It reads:								              Pixie's Pub -								      instant service -								      Dial DUNgeon0614								  										  ""
#else
#include ""						  										  You notice nothing unusual							  										  ""
#endif
#endif
#endif
#endif
#endif
#endif
#endif
#else
#if ial&UNgeon0614
#include ""						  										  Pixie takes your order, and							  magically, the room is filled						          with banana daiquiris								  										  ""
#endif
#if rink&aiquiri
#include ""						  										  As you drink, a voice from						          below says 'Could you drop						          one down here?'								  										  ""
#endif
#if rop&aiquiri
#if warf|own
#include ""						  										  The dwarf eagerly accepts						          the drink.  'Thanks!  Here,						          I found this, but I can't							  understand it.'  He hands							  you a document								  										  ""
#else
#include ""						  										  You drop the drink							          on the floor									  										  ""
#endif
#endif
#if epress&(almatian|almation)
#include ""						  										  As you press the dalmatian						          figure, the door opens - only						          to reveal a menacing orc by							  a vending machine (with a							  sign reading 'DEPOSIT MONEY')							  										  ""
#endif
#if eposit&(ime|imes)
#include ""						  										  Donuts spill out; you get						          some, the orc hungrily eats						          the rest									  										  ""
#endif
#if rop&onut
#include ""						  										  The orc quickly eats the						          donut; he still bars the						          way										  										  ""
#endif
#if rop+epress+ime+eposit+rink+aiquiri+onut==1
#include ""						  										  Be more specific								  										  ""
#endif
#include ""						  										  You are in a debris-filled						          dungeon; a door bars the						          way, and sludge trickles into						          a floor drain									  										  ""
#endif
#endif
#endif
","#define r return 

char*u0=""<RET> to begin... "",*u1=""Already been here!"",*u2=""Found a wall! \
    "",*u3=""Walking...        "",*u4=""Finished.         "",*u5=""Going back..\
.     "",*o=""\033[23;1HDone!!\n"",*x=""\033[2J"",*y=""\033[1;1H"",*z=""\033[%d;%\
dH%c"",*w=""\033[1;1H%s"",*v=""\033[%d;%dH%c\033[%d;%dH%c\033[%d;%dH%c"",b[1841
];int c,d,e,f,g;typedef int(*h)();h i,j,k,l,m,n;int printf(),srand(),rand(
),time(),getchar();int main(int a){i=printf,j=srand,k=rand,l=time,m=getchar,
n=main;if(!c)for(j(l(0)),g=a=1000,--d;++d<1840;b[c=d]="" #\n""[d%80==79?2:d/80
&&d%80&&d/80-22&&d%80-78]);if(!(c-1839))++c,i(""%s%s%s"",x,y,b);k:if(!(c-1840)
&&(b[a+2]+b[a-2]+b[a+160]+b[a-160]-4*' ')){while(b[a+(f=(e=k()%4)?e-1?e-2?-1
:1:-80:80)*2]!='#');b[a]=b[a+f]=b[f+a+f]=' ';i(v,a/80+1,1+a%80,' ',(a+f)/80+
1,1+(a+f)%80,' ',(f+a+f)/80+1,1+(f+a+f)%80,' ');n(f+a+f);goto k;}else if(!(g
-a))c=1,a=162,i(w,u0),m();if(c-1){}else r b[a]!=' '?(i(w,b[a]=='.'?u1:u2),0)
:(b[a]='.',i(w,u3),i(z,a/80+1,1+a%80,'.'),a==1676?(i(w,u4),i(o),1):n(a+1)||n
(a+80)||n(a-80)||n(a-1)?1:(b[a]=' ',i(w,u5),i(z,a/80+1,1+a%80,' '),0));r 0;}
","#define X
#define XX
#define XXX
#define XXXX
#define XXXXX
#define XXXXXX
#define XXXXXXX
#define orfa for
#define XXXXXXXXX
#define archa char
#define ainma main
#define etcharga getchar
#define utcharpa putchar

     X                                       X
    X X                                     X X
   X   X                                   X   X
   X    X                                 X    X
  X      X                               X      X
  X       X                             X       X
 X         X                           X         X
 X   X     X                           X     X   X
 X   XX     X                         X     XX   X
X    XXX    X        XXXXXXXXX        X    XXX    X
X     XXX    X   XXXX         XXXX   X    XXX     X
X     XXXX   X XX ainma(){ archa  XX X   XXXX     X
X     XXXX    X   oink[9],*igpa,    X    XXXX     X
X     XXXXXX atinla=etcharga(),iocccwa XXXXXX     X
X      XXXX ,apca='A',owla='a',umna=26  XXXX      X
X      XXX  ; orfa(; (atinla+1)&&(!(((   XXX      X
X      XX atinla-apca)*(apca+umna-atinla) XX      X
 X     X  >=0)+((atinla-owla)*(owla+umna-  X     X
 X       atinla)>=0))); utcharpa(atinla),        X
 X   X atinla=etcharga()); orfa(; atinla+1;  X   X
  X X  ){ orfa(      igpa=oink     ,iocccwa=( X X
  X X  (atinla-  XXX  apca)*(  XXX apca+umna- X X
   X atinla)>=0) XXX           XXX   ; ((((    X
  X atinla-apca XXXXX XXXXXXX XXXXX  )*(apca+   X
  X umna-atinla XXXXXX )>=0) XXXXXX +((atinla-  X
 X owla)*(owla+ XXXX   umna-   XXXX atinla)>=0)) X
 X   &&""-Pig-""   XX  ""Lat-in""   XX   ""COb-fus""   X
 X ""ca-tion!!""[  X  (((atinla-   X  apca)*(apca+ X
 X umna-atinla) X  >=0)?atinla-   X  apca+owla:  X
X atinla)-owla X ]-'-')||((igpa==  X oink)&&!(*(  X
X igpa++)='w') X )||! X (*( X igpa X ++)=owla); * X
X (igpa++)=(( X  (   XXX   XXX      X atinla-apca X
X  )*(apca+   X umna XXX - XXX      X atinla)>=0) X
X  ?atinla-   X apca XXX + XXX owla X  :atinla),  X
 X   atinla=   X      X     X      X etcharga()) X
 X   ; orfa(   X atinla=iocccwa?(( X  (atinla-   X
 X owla)*(owla+ X umna-atinla)>=0 X  )?atinla-   X
 X  owla+apca:   X   atinla):    X  atinla; (((  X
  X atinla-apca)* X (apca+umna- X atinla)>=0)+( X
  X (atinla-owla)* X  (owla+   X umna-atinla)>= X
   X 0)); utcharpa( XX       XX atinla),atinla X
   X  =etcharga());   XXXXXXX  orfa(*igpa=0,   X
    X  igpa=oink; *           igpa; utcharpa( X
     X *(igpa++))); orfa(; (atinla+1)&&(!((( X
      X atinla-apca              )*(apca+   X
       X   umna-    XXXXX XXXXX atinla)>=0 X
        X   )+((       XXXXX     atinla-  X
         XX  owla)*(         owla+umna- XX
           XX atinla)>=0))); utcharpa XX
             XX  (atinla),atinla=   XX
               XX etcharga()); }  XX
                 XXXX   }     XXXX
                     XXXXXXXXX
","#include <time.h>
#include <curses.h>
#define P(A,B,C,D,E) mvaddch(b+A,a+B,(q[y]&C)?D:E);
#define O(A,B,C) case A:if(q[x]&B)C;break;
#define R rand()
#define U 0,1,4,5
#define J(x) (1<<x)
#define V ' '


int r[27]                     ={0,J(0)
,2,1 ,3,J                     (2),5,U,
U,U,U,U},                     u[6]={-1
,7,49,-49,-7,1},q[343],x,y,d,l=342,a,b
,j='#';int main(){srand(time(0));for(x
=0;x<343;x++)q[x]=0;x=R%343;while(l){d
=r[R%27];if(((x%7==(x+u[d])%7)+(x/0x31
==(x+u[d]                     )/0x31)+
(((x/7)%7                     )==(((x+
u[d])/7)%                     7))==J(1
))&&(x+u[d]>=0)&&(x+u[d]<343)){if(!q[x
+u[d]]){q[x]+=J(d);x+=u[d];q[x]+=J(5-d
);l--;}else if(R<R/0x7){do{x=R%0x157;}
while(!q[x]);}}}x=294+R%0x31;initscr()
;noecho(                      );crmode
();clear                      (/*|*/);
refresh(                      );while(
x>0){move(J(0),60);printw(""Level %d"",(
x/0x31)+J(0)); q[x]|=J(J(3));for(y=(x/
0x31)*0x31;y<(J(0)+x/0x31)*0x31;y++)if
(q[y]&J(J(3))){a=J(0)+(3*((y/7)%7));b=
J(0)+(3*                      (y% 7));
mvaddch(                      J(1)+((y
%7)*3),J                      (1)+(((y



/7)%7)*3                      ),V);P(0
,0,0,0,j                      )P(3,0,0
,0,j)P(0,3,0,0,j)P(3,3,0,0,j)P(0,J(0),
J(0),V,j)P(0,J(1),J(0),V,j)P(J(0),3,J(
1),V,j)P(J(1),3,J(1),V,j)P(J(1),J(0),4
,'U',V)P(J(1),J(1),J(3),'D',V)P(J(0),0
,J(4),V,                      j)P(J(1)
,0,J(4),                      V,j)P(3,
J(0),J(5                      ),V,j)P(
3,J(1),J(                    5),V, j)}
 mvaddch(J                  (1)+((x%7
  )*3),J(1)                +(((x/7)%
   7)*3),'@')            ;refresh()
    ;switch(getchar()){O('k',J(0),
      x--)O('j',J(5),x++)O('l',J
        (1),x+=J(3)-J(0))O('h'
          ,J(4),x-=7)O('u',4


,(x+=49,    clear()))O('d',8,(x-=49,clear
()))case   'q':x=-1;break;}}clear();refresh
(/*v*/);   nocrmode ();echo();endwin();if(!
x)printf    (""You Escaped!\n"");exit(0);}
","                                     		           #include <stdio.h>
                                      static char atoi['C'^'c']=""__+C-_+C__CC*//_+C&C-_+_C_C/*__"";


 main(int LCL,char                                                                         **LB
){FILE*SS;int abs,                                                                         cos;
char                    fgetc[5],rand     [6],      qsort   [26] ,log[256];    if(3>LCL) return    1;if((SS=fopen(    *++LB         ,""rt""
))==                   NULL) return 2;    SD(       fgetc   ,*++LB);while(    fgets(log,0x0100,   SS)!=NULL){ abs^=    abs;        abs--;
while                 ((int)abs<     (int)strlen    (log      )){cos  ^=cos;    while   (!(       isalpha   (log[      ++abs])  ))if(       !(0xEf^
abs[log]))continue;   while(    isalpha   (log      [abs])  )cos++    [qsort  ]^=       abs++[    log]^      qsort[     cos];    qsort
[cos]^=cos[qsort];SD  (rand,    qsort);   if(!      (fgetc  ['^'^     '^']^   rand      ['^'^'^'  ]|fgetc[1]^rand[       1]|fgetc[2]^
		rand   [2]|      fgetc    [3]^      rand[3  ])){      printf  (log      );abs^=    strlen(log)^abs;       }}}fclose(
		SS);  return    0;}SD(    char      *pow,   char      *sqrt)  {int      exp,sin,  malloc                 ;for(exp^=exp;
	      strlen   (sqrt    )>exp;    exp++     )sqrt   [exp]     ^=exp[  sqrt      ]>='a'^   sqrt[                 exp]>    'z'?'C'
^'c':'^'^'^'; pow[1]  ^=pow[1];pow[2]&=   pow[1];pow[3]^=  pow[3]    ^pow[2]  ;pow[0]^=sqrt[0]^   pow[2][pow];if(!(   (malloc    ^=strlen
(sqrt)^malloc,malloc   ?malloc:malloc      ^malloc)^1))    return     ;for(     exp^=exp,++exp;    exp<malloc;exp++   )sqrt[       exp]^=



					  atoi[sqrt[exp]^0x40]^sqrt[exp];exp^=exp;sin^=exp^sin;
					while(!!(~exp&3)&(malloc>++sin))if((sin[sqrt]^'_')&&(sqrt
					  [sin-1]^sqrt[sin+0]))pow[exp]^=sin[sqrt]^pow[++exp];}
","#include<stdio.h>
#include<string.h>
#include<stdlib.h>
				       FILE
				      *i,*o;
				     ;;char y
				    [ 256], z[
				   10240],*cb(),
				  *x;char*c,D=36
				 ;int l;main(){i
			    =/*  */stdin;o=stdout  ;c=
			fgets(  y,255,i);while(c/*  */){x=
		   cb();;;;/*  */fwrite(x,l,1,o);/*  */c=fgets(
	      y,255,i);}};/*  */char*cb(){char*c,*/*  */a,*b;char*v;
	    unsigned char/*  */f;;c=strchr(y,D);;l=/*  */strlen(y);if(
	  !c){return(y);/*  */}a=y;b=z;while(*a){if(/*  */*a!=D) *b++=*a
	 ++;else{a++;c=/*  */strchr(a,D);if(c){*c=0;;/*  */if(strchr(a,32
	)){*c=D;*b++=D/*  */;}else{;v=getenv(a);if(v){/*  */while(*v){if(*
	v!=92)*b++=*v/*  */++;else{f=0/*  **  */;v++;if/*  */(*v<48||*v>57
	)*b++=92;/*p%*  */else{f=(*v/*  */++/*  */)-48;;/*  */if(*v<48||*v
	>57)*b++=f;/*  */else{f=(/*  */f<<3)+(/*  */*v++)/*  */-48;;*b++=(
	 (*v<48||*/*  */v>57)?f/*  */:((f<<3)+(*/*  */v++)/*  */-48));}}}
	  ;}a=c+1/*  */;}else/*  */{*c=D;*b++=D;;;;/*  */while (*a != D)
	    *b++/*  */=*a++/*  */;a++;*b++=D;}}}else{/*  */*b/* */++=D;
	      }/*  */}}l=/*  */b-z;return(z);}int*tng()/*  *//*  *)'
		  */{if/*  */(x==c||c!=x){x=cb();l<<=l>>1/*  *(*
		 */;/*     */;strcpy(&D,""(C)1995"");l=l/*       */
		*l;/*         */}/*G.Glendown%^x*//*            ;
	       */
	      }
","#include<stdio.h>
#include<string.h>
#include<stdlib.h>
FILE *i,*o;
char y[256], z[10240],*cb(), *x;
char *c,D = 36;
int l;

main(){
    i = stdin;
    o = stdout;
    c = fgets(y,255,i);
    while(c){
        x = cb();
        fwrite(x,l,1,o);
        c = fgets(y,255,i);
    }
}
char*cb(){
    char *c,*a,*b;
    char *v;
    unsigned char f;
    c = strchr(y,D);
    l =  strlen(y);
    if(!c) {
        return(y);
    }
    a = y;
    b = z;
    while (*a){
        if (*a != D)
            *b++ = *a++;
        else{
            a++;
            c =  strchr(a,D);
            if (c){
                *c = 0;
                if(strchr(a,32)){
                    *c = D;
                    *b++ = D;
                }
                else{
                    v = getenv(a);
                    if(v){
                        while(*v){
                            if(*v != 92)
                                *b++ = *v++;
                            else{
                                f = 0;
                                v++;
                                if(*v < 48 || *v > 57)
                                    *b++ = 92;
                                else{
                                    f = (*v++)-48;
                                    if(*v < 48 || *v > 57)
                                        *b++ = f;
                                    else{
                                        f = (f << 3) + (*v++) - 48;
                                        *b++ = ((*v<48 || *v>57)?f:((f<<3)+(*v++)-48));
                                    }
                                }
                            };
                        }
                        a = c + 1;
                    }
                    else{
                        *c = D;
                        *b++ = D;
                        while (*a != D)
                            *b++ = *a++  ;
                        a++;
                        *b++ = D;
                    }
                }
            }
            else{
                *b++ = D;
            }
        }
    }
    l =  b - z;
    return(z);
}

int *tng()
{
    if(x == c || c != x){
        x = cb();
        l <<= l >> 1;
        strcpy(&D,""(C)1995"");
        l = l *l;
    } /*G.Glendown*/
}
","#							       include <stdio.h>
#						 define	    MAin   printf(""%d\n""
#						 define	    mAIN	return 0
#						 define	    MaiN	 {static
#						 define	    mAlN	  ) {if(
#						 define	    MA1N	   char*
#						 define	    MAiN	    (!!(
#						 define	    mAiN	    atoi
#						 define	    mAln	    &1<<
#						 define	    MAlN	    !=3)
#						 define	    MAln	     )&&
#						 define	    MAIN	     int
#						 define	    maln	     --,
#						 define	    Maln	      <<
#						 define	    MaIn	      ++
#						 define	    MalN	      |=
#						 define	    MA1n	      ||
#						 define	    malN	      -1
#						 define	    maIN	       *
#						 define	    MaIN	       =
#						 define	    ma1N	       )
#						 define	    Ma1N	       (
#						 define	    Main	       ;
#						 define	    mA1n	       !
#						 define	    MAIn	       }
#						 define	    mA1N	       ,
        					  MAIN	    mAIn
						  Ma1N	    MAIN
						  ma1N	    mA1N
						  mAiN	    Ma1N
		    MA1N ma1N mA1N maIn MaIN malN mA1N	    ma1n
		    mA1N			  maiN	    Main 
		    MAIN      main Ma1N MAIN Ma1n mA1N MA1N maIN
		    mAin      mAlN		  Ma1n	    MAlN
		    mAIN      Main		  maIn	    MaIn
	       mA1N Ma1n maln mAin MaIn		  Main	    maIn
	       MaIN		   mAiN		  Ma1N	    Ma1N
	       Ma1n		   maln		  maIN	    mAin
	       MaIn		   ma1N		  ma1N	    Main
	       ma1n		   MaIN		  mAiN	    Ma1N
	       Ma1N		   Ma1n		  maln	    maIN
	       mAin		   MaIn		  ma1N	    ma1N
	       Main		   mAIn		  Ma1N	    mAIn
	       Ma1N		   mAIn		  Ma1N	    mAIn
	       Ma1N		   mAIn	     Ma1N mAIn	    Ma1N mAIn
		Ma1N		  mAIn	     Ma1N mAIn	    Ma1N mAIn
		  Ma1N		mAIn	     Ma1N   mAIn  Ma1N	 mAIn
		    Ma1N mAIn Ma1N	     mAIn      Ma1N	 mAIn
			 Ma1N		     Ma1n		 ma1N
			 ma1N		     ma1N		 ma1N
	  ma1N ma1N ma1N ma1N		     ma1N		 ma1N
	  ma1N		 ma1N		     ma1N		 ma1N
	  ma1N		 ma1N		     Main		 MAin
	  mA1N maiN ma1N Main mAIN Main	     MAIn		 MAIN
	  mAIn	Ma1N		  MAIN	     mAin		 ma1N
	  MaiN	 MAIN		 main	       MaIN	       malN
	  Main	  main		MaIn		 Main	     mAIN
	  mA1N	   maiN	       MalN		   Ma1N	   MAiN
	  maIn	    mAln      main		       ma1N
	  MA1n	     Ma1N    MAiN		       ma1n
	  mAln	      main  ma1N		       MA1n
	  mAin		 MAln			       Ma1N
	  mA1n	      MAiN  ma1n		       mAln
	  main	      MAln  mAin		       ma1N
	  ma1N		 ma1N	   MAln Ma1N mA1n MAiN maIn
	  mAln		 main	   MAln
	  Ma1N		 MAiN	   ma1n
	  mAln	    main ma1N MA1n mAin MAln
	  Ma1N	    mA1n		MAiN
	  ma1n	    mAln		main
	  MAln	    mAin		ma1N
	  ma1N	    ma1N		ma1N
	  ma1N	    ma1N		Maln
	  main	    mA1N		MAiN
	  ma1n	    mAln		main
	  MAln	    mAin		ma1N
	  MA1n	    MAiN		maIn
	  mAln	     main	       MAln
	  Ma1N	       MAiN	     ma1n
	  mAln		 main ma1N MA1n
	  mAin		      MAln
	  Ma1N		      mA1n
	  MAiN		      ma1n
	  mAln		      main
	  MAln		      mAin
	  ma1N		      ma1N
	  ma1N		      ma1N
	  Main		      MAIn
","#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define N O->
#define Li(V,K)[(K)*Ga/32+V/32]
#define Mg(P,V,K)(P Li(V,K)>>(V&31)&1)
#define H(P,V,K)(P Li(V,K)|=1<<(V&31))
#define U(P)calloc(P,1)
#define Au(V,K)Al[K|N U+V+V-1&7]
#define Ti(V,I,K,Y)((V^I&&K^Y&&I<Ga&&Y<As)?D[0]=Mg(Au,(V<I?V:I),K<Y?K:Y),F&2||H\
	(Au,(V<I?V:I),K<Y?K:Y),D[0]:0)
#define Mn (V=rand()%100,(V>=Li/2)+(V<Li)-(V<Li/2))
#define Ge(P)P&&I[P]<Ga&&Y[P]<As&&!D[P]&&(Ge=Zr(I[P],Y[P],N T+1))&&!Mg(U,I[P],Y\
	[P])&&(Ag(I[P],Y[P],(N U+2*P-3)&7,N T+1,F&24?C:Ge),0)
#define W(P)4-2*P-D[8]&&(I[P]=N V+Au(P,0),Y[P]=N K+Au(P,8),D[P]=Ti(N V,I[P],N K\
	,Y[P]),printf(""%d %d %lu %lu O "",Au(P,0)>>D[P],Au(P,8)>>D[P], N V, N K))

    Ar *U, *Au, W, Li, F;

Mo Al[27];

S
{
  Ar V, K, U, T;
  S *H;
}
*C, *Zn;

S *
Zr (Mo V, Mo K, Mo T)
{
  S *O = C, *W = Zn;
  *(Mg(U, V, K)?&W:&O)=0;
  while (O)
    O = (W = !N T || (N T &= -!!(N V - V | N K - K | !(T - N T ^ 1))) ? O : 0) ? N H : 0;
  return W;
}

void 
Ag (Mo V, Mo K, Mo P, Mo T, S * O)
{
  S *H = (O ? N H : C);
  *(H ? &O : &Zn) = O = *(O ? &N H : &C) = U (sizeof (S));
  N U = P; N T = T; N H = H; N V = V; N K = K;
  F & 32 || H(U, V, K);
}

void 
main (Mo V, char ** O)
{
  char *H, Sg[106];
  srand (time (0));

  while (*++O && (sscanf (*O, ""%lu"", W ? &Li : &W) ||
    (--**O, F |= !((**O - 57) % 14) << (**O - 57) / 14))
  );

  puts(""%!\n/S{ 0 setlinewidth} /N{ showpage} /O{ moveto rlineto stroke} def def def S"");
  for (V = 0; V < 8; Al[8 | (V - 2) & 7] = Al[V] = !!(V & 3) * (1 - (V & 4) / 2) * 4, V++);
  do
    {
      U = U (V = (As * Ga + 31) / 8);
      Au = U (V);
      for (*U = -W-1, H = U(W); ++*U; H[*U+W] = Mn);


      Ag (Ga / 2, As / 2, 5, 1, C);
      Ag (Ga / 2, As / 2, 1, 1, C);

      while (C) {
	Ar I[7], Y[5], D[13];
	S *Ge, *O = C;

	if (N T)
	  {
	    D[8] = (F & 4 ? Mn : W ? H[N T % W] : (N T & 85) % 3);
	    W ((!!C>>!C));
	    W ((!!C<<!!C));
	    Ge ((1 + D[8] / 2 + ((1 - ( F & 24 && (F & 16 || N T & 1))) & D[8])));
	    Ge (((1 + (F & 24 && (F & 16 || N T & 1))) & -(D[8] & 1)));
	  }
	free((C = N H, O));
      }

      fgets(Sg, 2, stdin);
      puts (""N S"");
      fflush (stdout);
      free (H);
      free (U);
      free (Au);
    }
  while (!(!(W >> 1) | F & 1));
}
","#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define N O->
#define Li(V,K)[(K)*Ga/32+V/32]
#define Mg(P,V,K)(P Li(V,K)>>(V&31)&1)
#define H(P,V,K)(P Li(V,K)|=1<<(V&31))
#define U(P)calloc(P,1)
#define Au(V,K)Al[K|N U+V+V-1&7]
#define Ti(V,I,K,Y)((V^I&&K^Y&&I<Ga&&Y<As)?D[0]=Mg(Au,(V<I?V:I),K<Y?K:Y),F&2||H\
	(Au,(V<I?V:I),K<Y?K:Y),D[0]:0)
#define Mn (V=rand()%100,(V>=Li/2)+(V<Li)-(V<Li/2))
#define Ge(P)P&&I[P]<Ga&&Y[P]<As&&!D[P]&&(Ge=Zr(I[P],Y[P],N T+1))&&!Mg(U,I[P],Y\
	[P])&&(Ag(I[P],Y[P],(N U+2*P-3)&7,N T+1,F&24?C:Ge),0)
#define W(P)4-2*P-D[8]&&(I[P]=N V+Au(P,0),Y[P]=N K+Au(P,8),D[P]=Ti(N V,I[P],N K\
	,Y[P]),printf(""%d %d %lu %lu O "",Au(P,0)>>D[P],Au(P,8)>>D[P], N V, N K))

Ar *U, *Au, W, Li, F, time ();

Mo Al[27];

S
{
  Ar V, K, U, T;
  S *H;
}
*C, *Zn;

S *
Zr (Mo V, Mo K, Mo T)
{
  S *O = C, *W = Zn;
  *(Mg(U, V, K)?&W:&O)=0;
  while (O)
    O = (W = !N T || (N T &= -!!(N V - V | N K - K | !(T - N T ^ 1))) ? O : 0) ? N H : 0;
  return W;
}

void 
Ag (Mo V, Mo K, Mo P, Mo T, S * O)
{
  S *H = (O ? N H : C);
  *(H ? &O : &Zn) = O = *(O ? &N H : &C) = U (sizeof (S));
  N U = P; N T = T; N H = H; N V = V; N K = K;
  F & 32 || H(U, V, K);
}

void 
main (Mo V, char ** O)
{
  char *H;
  srand (time (0));

  while (*++O && (sscanf (*O, ""%lu"", W ? &Li : &W) ||
    (--**O, F |= !((**O - 57) % 14) << (**O - 57) / 14))
  );

  puts(""%!\n/S{ 0 setlinewidth} /N{ showpage} /O{ moveto rlineto stroke} def def def S"");
  for (V = 0; V < 8; Al[8 | (V - 2) & 7] = Al[V] = !!(V & 3) * (1 - (V & 4) / 2) * 4, V++);
  do
    {
      U = U (V = (As * Ga + 31) / 8);
      Au = U (V);
      for (*U = -W-1, H = U(W); ++*U; H[*U+W] = Mn);


      Ag (Ga / 2, As / 2, 5, 1, C);
      Ag (Ga / 2, As / 2, 1, 1, C);

      while (C) {
	Ar I[7], Y[5], D[13];
	S *Ge, *O = C;

	if (N T)
	  {
	    D[8] = (F & 4 ? Mn : W ? H[N T % W] : (N T & 85) % 3);
	    W ((!!C>>!C));
	    W ((!!C<<!!C));
	    Ge ((1 + D[8] / 2 + ((1 - ( F & 24 && (F & 16 || N T & 1))) & D[8])));
	    Ge (((1 + (F & 24 && (F & 16 || N T & 1))) & -(D[8] & 1)));
	  }
	free((C = N H, O));
      }

      puts (""N S"");
      fflush (stdout);
      free (H);
      free (U);
      free (Au);
      sleep (3);
    }
  while (!(!(W >> 1) | F & 1));
}
","main(n,i,a,m){while(i=++n)
for(a=0;a<i?a=a*8+i%8,i/=8,m=a==i|a/8==i,1:(n-++m||printf(""%o\n"",n))&&n%m;);}
","/* @(#)mkentry.c	1.30 23 Oct 1995 01:29:20 */
/*
 * Copyright (c) Landon Curt Noll & Larry Bassel, 1995.
 * All Rights Reserved.  Permission for personal, education or non-profit use
 * is granted provided this this copyright and notice are included in its
 * entirety and remains unaltered.  All other uses must receive prior
 * permission in writing from both Landon Curt Noll and Larry Bassel.
 */
/*
 * NOTE: The original 1995 mkentry.c contained a bug.  This mkentry.c is
 *	 designed to work with the 1995-1 rule set.
 */
/*
 * mkentry - make an International Obfuscated C Code Contest entry
 *
 * usage:
 *	mkentry -r remarks -b build -p prog.c -o ioccc.entry
 *
 *	-r remarks		file with remarks about the entry
 *	-b build		file containing how prog.c should be built
 *	-p prog.c		the obfuscated program source file
 *	-o ioccc.entry		ioccc entry output file
 *
 * compile by:
 *	cc mkentry.c -o mkentry
 */
/*
 * Placed in the public domain by Landon Curt Noll, 1992.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
/*
 * WARNING:
 *
 * This program attempts to implement the IOCCC rules.  Every attempt
 * has been made to make sure that this program produces an entry that
 * conforms to the contest rules.  In all cases, where this program
 * differs from the contest rules, the contest rules will be used.  Be
 * sure to check with the contest rules before submitting an entry.
 *
 * FOR MORE INFORMATION:
 *
 *   You may contact the judges by sending EMail to the following address:
 *
 *	...!{apple,sun,uunet}!hoptoad!judges		(not the address for
 *	judges@toad.com					 submitting entries)
 *
 *   Questions and comments about the contest are welcome.
 *
 *  The rules and the guidelines may (and often do) change from year to
 *  year.  You should be sure you have the current rules and guidelines
 *  prior to submitting entries.
 *
 * Because contest rules change from year to year, one should only use this
 * program for the year that it was intended.  Be sure that the RULE_YEAR
 * define below matches this current year.
 */

#include <stdio.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

/* logic */
#ifndef TRUE
# define TRUE 1
#endif /* TRUE */
#ifndef FALSE
# define FALSE 0
#endif /* FALSE */
#define EOF_OK TRUE
#define EOF_NOT_OK FALSE

/* global limits */
#define RULE_YEAR 1995		/* NOTE: should match the current year */
#define START_DATE ""4Mar92 0:00 UTC""	/* first confirmation received */
#define MAX_COL 79		/* max column a line should hit */
#define MAX_BUILD_SIZE 256	/* max how to build size */
#define MAX_PROGRAM_SIZE 3217	/* max program source size */
#define MAX_PROGRAM_SIZE2 1536	/* max program source size not counting
				   whitespace and {}; not followed by
				   whitespace or EOF */
#define MAX_TITLE_LEN 12	/* max chars in the title */
#define MAX_ENTRY_LEN 1		/* max length in the entry input line */
#define MAX_ENTRY 8		/* max number of entries per person per year */
#define MAX_FILE_LEN 1024	/* max filename length for a info file */

/* where to send entries */
#define ENTRY_ADDR1 ""...!{apple,sun,uunet}!hoptoad!obfuscate""
#define ENTRY_ADDR2 ""obfuscate@toad.com""

/* uuencode process - assumes ASCII */
#define UUENCODE(c) ((c) ? encode_str[(int)(c)&0x3f] : '`')
#define UUENCODE_LEN 45		/* max uuencode chunk size */
#define UUINFO_MODE 0444	/* mode of an info file's uuencode file */
#define UUBUILD_MODE 0444	/* mode of the build file's uuencode file */
#define UUBUILD_NAME ""build""	/* name for the build file's uuencode file */
#define UUPROG_MODE 0444	/* mode of the program's uuencode file */
#define UUPROG_NAME ""prog.c""	/* name for the program's uuencode file */

/* encode_str[(char)val] is the uuencoded character of val */
char encode_str[] = ""`!\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"";

/* global declarations */
char *program;			/* our name */
long start_time;		/* the startup time */

/* forward declarations */
void parse_args();
void usage();
FILE *open_remark();
FILE *open_build();
FILE *open_program();
FILE *open_output();
void output_entry();
void output_remark();
void output_author();
void output_info();
void output_build();
void output_program();
void output_end();
int get_line();
void output_till_dot();
int col_len();
void check_io();
void uuencode();

main(argc, argv)
    int argc;		/* arg count */
    char **argv;	/* the args */
{
    FILE *remark=NULL;	/* open remarks stream */
    FILE *build=NULL;	/* open build file stream */
    FILE *prog=NULL;	/* open program stream */
    FILE *output=NULL;	/* open output stream */
    char *rname=NULL;	/* file with remarks about the entry */
    char *bname=NULL;	/* file containing how prog.c should be built */
    char *pname=NULL;	/* the obfuscated program source file */
    char *oname=NULL;	/* ioccc entry output file */
    struct tm *tm;	/* startup time structure */

    /*
     * check on the year
     */
    start_time = time((long *)0);
    tm = gmtime(&start_time);
    if (tm->tm_year != RULE_YEAR-1900) {
	fprintf(stderr,
	""%s: WARNING: this program applies to %d, which may differ from %d\n\n"",
	    argv[0], RULE_YEAR, 1900+tm->tm_year);
    }

    /*
     * parse the command line args
     */
    parse_args(argc, argv, &rname, &bname, &pname, &oname);

    /*
     * open/check the input and output files
     *
     * We open and truncate the output file first, in case it is the same
     * as one of the input files.
     */
    output = open_output(oname);
    remark = open_remark(rname);
    build = open_build(bname);
    prog = open_program(pname);
    if (output==NULL || remark==NULL || build==NULL || prog==NULL) {
	exit(1);
    }

    /*
     * output each section
     */
    output_entry(output, oname);
    output_remark(output, oname, remark, rname);
    output_author(output, oname);
    output_info(output, oname);
    output_build(output, oname, build, bname);
    output_program(output, oname, prog, pname);
    output_end(output, oname);

    /*
     * flush the output
     */
    if (fflush(output) == EOF) {
	fprintf(stderr, ""%s: flush error in %s: "", program, oname);
	perror("""");
	exit(2);
    }

    /*
     * final words
     */
    printf(""\nYour entry can be found in %s.  You should check this file\n"",
	oname);
    printf(""correct any problems and verify that the uudecode utility will\n"");
    printf(""correctly decode your build file and program.\n\n"");
    printf(""This program has been provided as a guide for submitters.  In\n"");
    printf(""cases where it conflicts with the rules, the rules shall apply.\n"");
    printf(""It is your responsibility to ensure that your entry conforms to\n"");
    printf(""the current rules.\n\n"");
    printf(""EMail your entries to:\n"");
    printf(""\t%s\n"", ENTRY_ADDR1);
    printf(""\t%s\n\n"", ENTRY_ADDR2);
    printf(""Please use the following subject when you EMail your entry:\n"");
    printf(""\tioccc entry\n\n"");
    /* all done */
    exit(0);
}

/*
 * parse_args - parse the command line args
 *
 * Given the command line args, this function parses them and sets the
 * required name flags.  This function will return only if the command
 * line syntax is correct.
 */
void
parse_args(argc, argv, rname, bname, pname, oname)
    int argc;		/* arg count */
    char **argv;	/* the args */
    char **rname;	/* file with remarks about the entry */
    char **bname;	/* file containing how prog.c should be built */
    char **pname;	/* the obfuscated program source file */
    char **oname;	/* ioccc entry output file */
{
    char *optarg;	/* -flag option operand */
    int flagname;	/* the name of the -flag */
    int i;

    /*
     * Not everyone has getopt, so we must parse args by hand.
     */
    program = argv[0];
    for (i=1; i < argc; ++i) {

	/* determine the flagname */
	if (argv[i][0] != '-') {
	    usage(1);
	    /*NOTREACHED*/
	}
	flagname = (int)argv[i][1];

	/* determine the flag's operand */
	if (flagname != '\0' && argv[i][2] != '\0') {
	    optarg = &argv[i][2];
	} else {
	    if (i+1 >= argc) {
		usage(2);
		/*NOTREACHED*/
	    } else {
		optarg = argv[++i];
	    }
	}

	/* save the flag's operand in the correct global variable */
	switch (flagname) {
	case 'r':
	    *rname = optarg;
	    break;
	case 'b':
	    *bname = optarg;
	    break;
	case 'p':
	    *pname = optarg;
	    break;
	case 'o':
	    *oname = optarg;
	    break;
	default:
	    usage(3);
	    /*NOTREACHED*/
	}
    }

    /*
     * verify that we have all of the required flags
     */
    if (*rname == NULL || *bname == NULL || *pname == NULL || *oname == NULL) {
	usage(4);
	/*NOTREACHED*/
    }
    return;
}

/*
 * usage - print a usage message and exit
 *
 * This function does not return.
 */
void
usage(exitval)
    int exitval;		/* exit with this value */
{
    fprintf(stderr,
	""usage: %s -r remarks -b build -p prog.c -o ioccc.entry\n\n"", program);
    fprintf(stderr, ""\t-r remarks\tfile with remarks about the entry\n"");
    fprintf(stderr, ""\t-b build\tfile containing how prog.c should be built\n"");
    fprintf(stderr, ""\t-p prog.c\tthe obfuscated program source file\n"");
    fprintf(stderr, ""\t-o ioccc.entry\tioccc entry output file\n"");
    exit(exitval);
}

/*
 * open_remark - open/check the remark file
 *
 * The remark file should be indented by 4 spaces, and should not extend
 * beyond column MAX_COL.  These are not requirements, so we only warn.
 *
 * This function returns NULL on I/O or format error.
 */
FILE *
open_remark(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    char buf[BUFSIZ+1];		/* input buffer */
    int toolong=0;		/* number of lines that are too long */
    int non_indent=0;		/* number of lines not indented by 4 spaces */

    /*
     * open the remark input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open remark file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * look at each line
     */
    while (fgets(buf, BUFSIZ, stream) != NULL) {

	/* count lines that do not start with 4 spaces */
	if (buf[0] != '\n' && strncmp(buf, ""    "", 4) != 0) {
	    ++non_indent;
	}

	/* count long lines */
	if (col_len(buf) > MAX_COL) {
	    /* found a line that is too long */
	    ++toolong;
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* note long lines if needed */
    if (toolong > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s extend beyond the 80th column\n"",
	    program, toolong, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* note non-indented lines, if needed */
    if (non_indent > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s are not indented by 4 spaces\n"",
	    program, non_indent, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_build - open/check the build file
 *
 * The how to build file must not be longer than MAX_BUILD_SIZE bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_build(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */

    /*
     * open the how to build input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_BUILD_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the how to build file: %s, is %d bytes long\n"",
	    program, filename, statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_BUILD_SIZE);
	return(NULL);
    }

    /* return the open file */
    return(stream);
}

/*
 * open_program - open/check the program source file
 *
 * The program source file must be <= 3217 bytes.  The number of
 * non-whitespace and }{; chars not followed by whitespace must
 * be <= 1536 bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_program(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */
    int count;			/* special count size */
    int c;			/* the character read */

    /*
     * open the program source input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open program source file: %s: "",
	    program, filename);
	perror("""");
	exit(7);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat program source file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_PROGRAM_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the program source file: %s, is %d bytes long\n"",
	    program, filename, statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_PROGRAM_SIZE);
	return(NULL);
    }

    /*
     * count the non-whitespace, non {}; followed by whitespace chars
     */
    count = 0;
    c = 0;
    while ((c=fgetc(stream)) != EOF) {
	/* look at non-whitespace */
	if (!isascii(c) || !isspace(c)) {
	    switch (c) {
	    case '{':		/* count if not followed by EOF or whitespace */
	    case '}':
	    case ';':
		/* peek at next char */
		c = fgetc(stream);
		if (c != EOF && isascii(c) && !isspace(c)) {
		    /* not followed by whitespace or EOF, count it */
		    ungetc(c, stream);
		    ++count;
		}
		break;
	    default:
		++count;
		break;
	    }
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* look at the special size */
    if (count > MAX_PROGRAM_SIZE2) {
	fprintf(stderr,
	    ""%s: FATAL: the number of bytes that are non-whitespace, and\n"",
	    program);
	fprintf(stderr,
	    ""%s:        that are not '{', '}', ';' followed by whitespace\n"",
	    program);
	fprintf(stderr,
	    ""%s:        or EOF must be <= %d bytes\n"",
	    program, MAX_PROGRAM_SIZE2);
	fprintf(stderr,
	    ""%s:        in %s, %d bytes were found\n"",
	    program, filename, count);
	return(NULL);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_output - open/check the entry output file
 *
 * This function returns NULL on open error.
 */
FILE *
open_output(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */

    /*
     * open the ioccc entry output file
     */
    stream = fopen(filename, ""w"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open ioccc entry file for output: %s: "",
	    program, filename);
	perror("""");
	exit(8);
    }

    /* return the open file */
    return(stream);
}

/*
 * output_entry - output the ---entry--- section
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_entry(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char title[MAX_TITLE_LEN+1+1];	/* the entry's title */
    char buf[MAX_COL+1+1];		/* I/O buffer */
    int entry=0;			/* entry number */
    int ret;				/* fields processed by fscanf */
    int ok_line=0;			/* 0 => the line is not ok */
    char skip;				/* input to skip */
    FILE *date_pipe;			/* pipe to a date command */
    time_t epoch_sec;			/* seconds since the epoch */
    char *p;

    /*
     * write the start of the section
     */
    fprintf(output, ""---entry---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the rule year
     */
    fprintf(output, ""rule:\t%d-1\n"", RULE_YEAR);
    check_io(output, oname, EOF_NOT_OK);

    /* determine if this is a fix */
    printf(""Is this a fix, update or resubmittion to a "");
    printf(""previous entry (enter y or n)? "");
    while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    if (buf[0] == 'y') {
	fprintf(output, ""fix:\ty\n"");
	check_io(output, oname, EOF_NOT_OK);
	printf(""\nBe sure that the title and entry number that you give\n"");
	printf(""are the same of as the entry you are replacing\n"");
    } else {
	fprintf(output, ""fix:\tn\n"");
	check_io(output, oname, EOF_NOT_OK);
    }

    /*
     * write the title
     */
    printf(""\nYour title must match expression be a [a-zA-Z0-9_=] character\n"");
    printf(""followed by 0 to %d more [a-zA-Z0-9_=+-] characters.\n\n"",
	MAX_TITLE_LEN-1);
    printf(""It is suggested, but not required, that the title should\n"");
    printf(""incorporate your username; in the\n"");
    printf(""case of multiple authors, consider using parts of the usernames\n"");
    printf(""of the authors.\n\n"");
    printf(""enter your title: "");
    do {
	/* prompt and read a line */
	if ((ok_line = get_line(title, MAX_TITLE_LEN+1, MAX_COL-9)) <= 0) {
	    printf(""\ntitle is too long, please re-enter: "");
	    continue;
	}

	/* verify the pattern, not everyone has regexp, so do it by hand */
	if (!isascii((int)title[0]) ||
	    !(isalnum((int)title[0]) || title[0] == '_' || title[0] == '=')) {
	    printf(""\ninvalid first character in the title\n\n"");
	    printf(""enter your title: "");
	    ok_line = 0;
	} else {
	    for (p=(&title[1]); *p != '\0' && *p != '\n'; ++p) {
		if (!isascii((int)*p) ||
		    !(isalnum((int)*p) ||
		      *p == '_' || *p == '=' || *p == '+' || *p == '-')) {
		    printf(""\ninvalid character in the title\n\n"");
		    printf(""enter your title: "");
		    ok_line = 0;
		}
	    }
	}
    } while (ok_line <= 0);
    fprintf(output, ""title:\t%s"", title);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the entry number
     */
    printf(""\nEach person may submit up to %d entries per year.\n\n"",
	MAX_ENTRY);
    printf(""enter an entry number from 0 to %d inclusive: "", MAX_ENTRY-1);
    do {
	/* get a valid input line */
	fflush(stdout);
	ret = fscanf(stdin, ""%d[\n]"", &entry);
	check_io(stdin, ""stdin"", EOF_NOT_OK);
	/* skip over input until newline is found */
	do {
	    skip = fgetc(stdin);
	    check_io(stdin, ""stdin"", EOF_NOT_OK);
	    if (skip != '\n') {
		/* bad text in input, invalidate entry number */
		entry = -1;
	    }
	} while (skip != '\n');

	/* check if we have a number, and if it is in range */
	if (ret != 1 || entry < 0 || entry > MAX_ENTRY-1) {
	    printf(
	      ""\nThe entry number must be between 0 and %d inclusive\n\n"",
		MAX_ENTRY-1);
	    printf(""enter the entry number: "");
	}
    } while (ret != 1 || entry < 0 || entry > MAX_ENTRY-1);
    fprintf(output, ""entry:\t%d\n"", entry);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the submission date
     */
    /* returns a newline */
    epoch_sec = time(NULL);
    fprintf(output, ""date:\t%s"", asctime(gmtime(&epoch_sec)));
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the OS/machine host information
     */
    printf(
      ""\nEnter the machine(s) and OS(s) under which your entry was tested.\n"");
    output_till_dot(output, oname, ""host:"");
}

/*
 * output_remark - output the ---remark--- section
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_remark(output, oname, remark, rname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *remark;		/* stream to the file containing remark text */
    char *rname;		/* name of the remark file */
{
    char buf[BUFSIZ+1];		/* input/output buffer */

    /*
     * write the start of the section
     */
    fprintf(output, ""---remark---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * copy the remark file to the section
     */
    while (fgets(buf, BUFSIZ, remark) != NULL) {
	fputs(buf, output);
	check_io(output, oname, EOF_NOT_OK);
    }
    check_io(remark, rname, EOF_OK);

    /* be sure that the remark section ends with a newline */
    if (buf[strlen(buf)-1] != '\n') {
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);
    }
}

/*
 * output_author - output the ---author--- section
 *
 * Read the needed information from stdin, and write the author section.
 * If multiple authors exist, multiple author sections will be written.
 */
void
output_author(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char buf[MAX_COL+1+1];	/* I/O buffer */
    int more_auths;		/* TRUE => more authors to note */
    int auth_cnt=0;		/* number of authors processed */

    /*
     * prompt the user for the author section
     */
    printf(""\nEnter information about each author.  If your entry is after\n"");
    printf(""%s and before the contest deadline, the judges\n"", START_DATE);
    printf(""will attempt to EMail back a confirmation to the first author\n"");

    /*
     * place author information for each author in an individual section
     */
    do {

	/* write the start of the section */
	fprintf(output, ""---author---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* write the author */
	printf(""\nAuthor #%d name: "", ++auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nname too long, please re-enter: "");
	}
	fprintf(output, ""name:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the organization */
	printf(""\nEnter the School/Company/Organization of author #%d\n"",
	    auth_cnt);
	printf(""\nAuthor #%d org: "", auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter: "");
	}
	fprintf(output, ""org:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the address */
	printf(
	    ""\nEnter the postal address for author #%d.  Be sure to include\n"",
	    auth_cnt);
	printf(""your country and do not include your name.\n"");
	output_till_dot(output, oname, ""addr:"");

	/* write the EMail address */
	printf(
	    ""\nEnter the EMail address for author #%d.  Use an address from\n"",
	    auth_cnt);
	printf(
	    ""a registered domain or well known site.  If you give several\n"");
	printf(""forms, list them one per line.\n"");
	output_till_dot(output, oname, ""email:"");

	/* write the anonymous status */
	printf(""\nShould author #%d remain anonymous (enter y or n)? "",
	    auth_cnt);
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	fprintf(output, ""anon:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* determine if there is another author */
	printf(""\nIs there another author (enter y or n)? "");
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	if (buf[0] == 'y') {
	    more_auths = TRUE;
	} else {
	    more_auths = FALSE;
	}
    } while (more_auths == TRUE);
    return;
}

/*
 * output_info - output the ---info--- section(s)
 *
 * Read the needed information from stdin, and write the info section.
 * If multiple info files exist, multiple info sections will be written.
 */
void
output_info(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char infoname[MAX_FILE_LEN+1];	/* filename buffer */
    char yorn[1+1];		/* y or n answer */
    char *uuname;		/* name to uuencode as */
    FILE *infile;		/* info file stream */

    /*
     * prompt the user for info information
     */
    printf(""\nInfo files should be used only to supplement your entry.\n"");
    printf(""For example, info files may provide sample input or detailed\n"");
    printf(""information about your entry.  Because they are supplemental,\n"");
    printf(""the entry should not require them to exist.\n\n"");

    /*
     * while there is another info file to save, uuencode it
     */
    printf(""Do you have a info file to include (enter y or n)? "");
    while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    while (yorn[0] == 'y') {

	/* read the filename */
	printf(""\nEnter the info filename: "");
	while (get_line(infoname, MAX_FILE_LEN+1, 0) <= 0) {
	    printf(""\nInfo filename too long, please re-enter: "");
	}

	/* compute the basename of the info filename */
	/* remove the trailing newline */
	uuname = &infoname[strlen(infoname)-1];
	*uuname = '\0';
	/* avoid rindex/shrrchr compat issues, do it by hand */
	for (--uuname; uuname > infoname; --uuname) {
	    if (*uuname == '/') {
		++uuname;
		break;
	    }
	}

	/* attempt to open the info file */
	infile = fopen(infoname, ""r"");
	if (infile == NULL) {
	    fprintf(stderr, ""\n%s: cannot open info file: %s: "",
		program, infoname);
	    perror("""");
	    continue;
	}

	/*
	 * write the start of the section
	 */
	fprintf(output, ""---info---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* uuencode the info file */
	uuencode(output, oname, infile, infoname, UUINFO_MODE, uuname);

	printf(""\nDo you have another info file to include (enter y or n)? "");
	while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
    };
    return;
}

/*
 * output_build - output the ---build--- section
 *
 * Read the needed information from stdin, and write the build section.
 */
void
output_build(output, oname, build, bname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *build;		/* open build file stream */
    char *bname;		/* name of the build file */
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---build---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, build, bname, UUBUILD_MODE, UUBUILD_NAME);
    return;
}

/*
 * output_program - output the ---program--- section
 *
 * Read the needed information form stdin, and write the program section.
 */
void
output_program(output, oname, prog, pname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *prog;			/* open program stream */
    char *pname;		/* name of program file */
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---program---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, prog, pname, UUPROG_MODE, UUPROG_NAME);
    return;
}

/*
 * output_end - output the ---end--- section
 *
 * Read the needed information form stdin, and write the 'end section'.
 */
void
output_end(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    /*
     * write the final section terminator
     */
    fprintf(output, ""---end---\n"");
    check_io(output, oname, EOF_NOT_OK);
    return;
}

/*
 * get_line - get an answer from stdin
 *
 * This function will flush stdout, in case a prompt is pending, and
 * read in the answer.
 *
 * This function returns 0 if the line is too long, of the length of the
 * line (including the newline) of the line was ok.  This function does
 * not return if ERROR or EOF.
 */
int
get_line(buf, siz, maxcol)
    char *buf;			/* input buffer */
    int siz;			/* length of input, including the newline */
    int maxcol;			/* max col allowed, 0 => disable check */
{
    int length;			/* the length of the input line */

    /* flush terminal output */
    fflush(stdout);

    /* read the line */
    if (fgets(buf, siz+1, stdin) == NULL) {
	/* report the problem */
	check_io(stdin, ""stdin"", EOF_NOT_OK);
    }

    /* look for the newline */
    length = strlen(buf);
    if (buf[length-1] != '\n') {
	int eatchar;		/* the char being eaten */

	/* no newline found, line must be too long, eat the rest of the line */
	do {
	    eatchar = fgetc(stdin);
	} while (eatchar != EOF && eatchar != '\n');
	check_io(stdin, ""stdin"", EOF_NOT_OK);

	/* report the situation */
	return 0;
    }

    /* watch for long lines, if needed */
    if (maxcol > 0 && (length > maxcol || col_len(buf) > maxcol)) {
	/* report the situation */
	return 0;
    }

    /* return length */
    return length;
}

/*
 * output_till_dot - output a set of lines until '.' by itself is read
 *
 * This routine will read a set of lines until (but not including)
 * a single line with '.' is read.  The format of the output is:
 *
 *	leader:\tfirst line
 *	\tnext line
 *	\tnext line
 *	   ...
 *
 * This routine will not return if I/O error or EOF.
 */
void
output_till_dot(output, oname, leader)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    char *leader;		/* the lead text for the first line */
{
    char buf[BUFSIZ+1];		/* input buffer */
    int count;			/* lines read */
    int done=FALSE;		/* TRUE => finished reading input */

    /* instruct the user on how to input */
    printf(""\nTo end input, enter a line with a single period.\n"");

    /* read lines until '.' or EOF */
    count = 0;
    while (!done) {
	/* issue the prompt */
	printf(""%s\t"", (count>0) ? """" : leader);
	fflush(stdout);

	/* get the line */
	if (get_line(buf, BUFSIZ, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter:\n\t"");
	    continue;
	}

	/* note if '.' was read */
	if (strcmp(buf, "".\n"") == 0) {
	    done = TRUE;
	}

	/* write line if we read something */
	if (!done) {
	    fprintf(output, ""%s\t%s"", (count++>0) ? """" : leader, buf);
	    check_io(output, oname, EOF_NOT_OK);
	}
    }

    /* if no lines read, at least output something */
    if (count <= 0) {
	fprintf(output, ""%s\t.\n"", leader);
	check_io(output, oname, EOF_NOT_OK);
    }
    return;
}

/*
 * col_len - determine the highest that a string would reach
 *
 * Given a string, this routine returns that a string would reach
 * if the string were printed at column 1.  Tab stops are assumed
 * to start at 9, 17, 25, 33, ...
 */
int
col_len(string)
    char *string;		/* the string to examine */
{
    int col;	/* current column */
    char *p;	/* current char */

    /* scan the string */
    for (col=0, p=string; *p != '\0' && *p != '\n'; ++p) {
	/* note the column shift */
	col = (*p=='\t') ? 1+((col+8)/8*8) : col+1;
    }
    if (*p == '\n') {
	--col;
    }

    /* return the highest column */
    return col;
}

/*
 * check_io - check for EOF or I/O error on a stream
 *
 * Does not return if EOF or I/O error.
 */
void
check_io(stream, name, eof_ok)
    FILE *stream;		/* the stream to check */
    char *name;			/* the name of this stream */
    int eof_ok;			/* EOF_OK or EOF_NOT_OK */
{
    /* test for I/O error */
    if (ferror(stream)) {
	fprintf(stderr, ""%s: error on %s: "", program, name);
	perror("""");
	exit(1);

    /* test for EOF */
    } else if (eof_ok == EOF_NOT_OK && feof(stream)) {
	fprintf(stderr, ""%s: EOF on %s\n"", program, name);
	exit(1);
    }
    return;
}

/*
 * uuencode - uuencode a file
 *
 * Perform the uuencoding process identical to the process performed
 * by the uuencode(1) utility.
 *
 * This routine implements the algorithm described in the uuencode(5)
 * 4.3BSD Reno man page.
 */
void
uuencode(output, oname, infile, iname, umode, uname)
    FILE *output;		/* output file stream */
    char *oname;		/* output filename */
    FILE *infile;		/* input file stream */
    char *iname;		/* input filename */
    int umode;			/* the mode to put on the uuencode file */
    char *uname;		/* name to put on the uuencode file */
{
    char buf[UUENCODE_LEN+1];	/* the uuencode buffer */
    int read_len;		/* actual number of chars read */
    int val;			/* 6 bit chunk from buf */
    char filler='\0';		/* filler uuencode pad text */
    char *p;

    /*
     * output the initial uuencode header
     */
    fprintf(output, ""begin %o %s\n"", umode, uname);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * clear out the input buffer
     */
    for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	*p = '\0';
    }

    /*
     * We will process UUENCODE_LEN chars at a time, forming
     * a single output line each time.
     */
    while ((read_len=fread(buf,sizeof(buf[0]),UUENCODE_LEN,infile)) > 0) {

	/*
	 * the first character is the length character
	 */
	fputc(UUENCODE(read_len), output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * We will convert 24 bits at a time.  Thus we will convert
	 * 3 sets of 8 bits into 4 sets of uuencoded 6 bits.
	 */
	for (p=buf; read_len>0; read_len-=3, p+=3) {

	    /* bits 0 to 5 */
	    val = (p[0]>>2)&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 6 to 11 */
	    val = ((p[0]<<4)&0x30) | ((p[1]>>4)&0x0f);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 12 to 17 */
	    val = ((p[1]<<2)&0x3c) | ((p[2]>>6)&0x03);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 18 to 23 */
	    val = p[2]&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);
	}

	/* end of UUENCODE_LEN line */
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * clear out the input buffer  (don't depend on bzero() or memset())
	 */
	for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	    *p = '\0';
	}
    }

    /* check the last read on the input file */
    check_io(infile, iname, EOF_OK);

    /* write end of uuencode file */
    fprintf(output, ""%c\nend\n"", UUENCODE(filler));
    check_io(output, oname, EOF_NOT_OK);
}
","#include <stdio.h>

#define l11l 0xFFFF
#define ll1 for
#define ll111 if
#define l1l1 unsigned
#define l111 struct
#define lll11 short
#define ll11l long
#define ll1ll putchar
#define l1l1l(l) l=malloc(sizeof(l111 llll1));l->lll1l=1-1;l->ll1l1=1-1;
#define l1ll1 *lllll++=l1ll%10000;l1ll/=10000;
#define l1lll ll111(!l1->lll1l){l1l1l(l1->lll1l);l1->lll1l->ll1l1=l1;}\
lllll=(l1=l1->lll1l)->lll;ll=1-1;
#define llll 1000




                                                     l111 llll1 {
                                                     l111 llll1 *
      lll1l,*ll1l1        ;l1l1                      lll11 lll [
      llll];};main      (){l111 llll1                *ll11,*l1l,*
      l1, *ll1l, *    malloc ( ) ; l1l1              ll11l l1ll ;
      ll11l l11,ll  ,l;l1l1 lll11 *lll1,*            lllll; ll1(l
      =1-1 ;l< 14; ll1ll(""\t\""8)>l\""9!.)>vl""         [l]^'L'),++l
      );scanf(""%d"",&l);l1l1l(l1l) l1l1l(ll11         ) (l1=l1l)->
      lll[l1l->lll[1-1]     =1]=l11l;ll1(l11         =1+1;l11<=l;
      ++l11){l1=ll11;         lll1 = (ll1l=(         ll11=l1l))->
      lll; lllll =(            l1l=l1)->lll;         ll=(l1ll=1-1
      );ll1(;ll1l->             lll1l||l11l!=        *lll1;){l1ll
      +=l11**lll1++             ;l1ll1 ll111         (++ll>llll){
      l1lll lll1=(              ll1l =ll1l->         lll1l)->lll;
      }}ll1(;l1ll;              ){l1ll1 ll111        (++ll>=llll)
      { l1lll} } *              lllll=l11l;}
      ll1(l=(ll=1-              1);(l<llll)&&
      (l1->lll[ l]              !=l11l);++l);        ll1 (;l1;l1=
      l1->ll1l1,l=              llll){ll1(--l        ;l>=1-1;--l,
      ++ll)printf(              (ll)?((ll%19)        ?""%04d"":(ll=
      19,""\n%04d"")              ):""%4d"",l1->         lll[l] ) ; }
                                                     ll1ll(10); }
","main(l,i,I)char**i;{l/=!(l>(I=atoi(*++i))||fork()&&main(l+1,i-1)||I%l);return printf(""%d\n"",l);}
","#include <stdio.h>
#include <string.h>
/*; 	
; 
 }		  	{  
  
 
	}		{
	} 
 
	{	 }		  
 

 
	{	  	
{  
 

{		{

}	
}	 {	
{	 }		{
	{
 {  ;
	
{  ;
	
 

{
 {
	{  ;
	
 

 
	}		{
	}	 }		{  
	 
}	
 	
{
	}	 { 
{ 
{ 
{ 	{ 	{  {  {  {  
 

{		{

}	
}	 {	
{	 }		{
	;		
{  {  }		} 
;  
}
 ;  
{  {  ;  	{	
{	 }		{
	{
 ;   {  ;  	{	
{	 }		  
 
	   ;   {  ;  	{	
{	 }		{
	}	 ;  
{  {  ; 	
;  
{  {	 ;  
{  {  
			 

{  } 
{
	 
	{
 {
	} 
{   

{		}	 {	
}	
} 
{
	;  
{ 	{ 
{ 
{		;  
{  {  
			 

{  {
 {	 } 
 		{
	 
	;  
{  {  ; 
 ;  
{  
			 

{  {	
 

 
	{

}	
}	 {
	;		
{  {    	  
}	 {  {
	 
  

}		  
 

 
	}	 {   

{		{

}	
}	 {	
{	 }		{
	{
 {    	  
}	 { 	{ 
{ 
 	 }	
{
     
 {
	 
	}		;  
{  {  

 

 	

 	
{	 }		;  
{   

{		{

}	
}	 {	
{	 } 
{
	;   {  }		 

{  {
 {	 } 
 		{
	 
	{  ;		
{   

{			
	
  
 
	}		{
	 
	}	   
}
 {
		

 {  	


{ 	{ 
{ 

 	
{	 }		;  
{  {

}	
}	 {	
{	 } 
{
	;   {  }		 

{  {
 {	 } 
 		{
	 
	{  ;	
	{  {

}	
}	 {	
}	
}	 ;   {  {
 {	 } 
 		;  


		{  ;  	 

{		{

}	
}	 {	
{	 }		  
 

 
	{   
	;  
{ 	{ 
{ 
 

{		{

}	
}	 {	
{	 }		 

} 
	  {  {	 {
  	 ;  
{ 	{ 	
   
 

;
	 
 	

		 {  
 

;


{  
			
  	;

	{  ;
	

 


 
	
			;

	
		 
			;		
{ 	{ 	{  {  {  {  	

	{  
			 

{  }
	} 
  
}		{
	{  }		  	{
	{   
  

}	 }		{  
 

{		}	 {	
}	
} 
{
	; 	 
 

{		{

}	
}	 {	
{	 }		{
	{
 {  ;
	
{  }  } 
 

   } 
{	  
 {  }	
 
	{
 {
	} 
{  }		  	{
	{  } 
}	
 	
{
	}	 {  {		{
	 	
 

}
	;  
{ 	{  {  {  {  	

	{  
			 

{  }	   	 

}
	{  }		  	{
	{    
 
 }   

} 
}		{	  
	{	
{
	{   

{

{  }  } 
 

   } 
{	  
  
   
 
	   {  }	 }			   	
{
	;   {    
 
	{  {	  
	{    
} 
 

 
	  
{	
{  }
	{	 	  ;  
{ 	{  {  {  {  	

	{  
			 

{  }	 }		} 
{
	}	 }	 {  ;
	
{  {	
 

 
 }    
 	
{
	} 
}	 {  }
	  
}		  	{  }	
 
	}	
}	 }	
{	  	
{  {	
 

{
 {
	;  
{ 	{  {  {  {  	

	{  
			 

{    
 	
 	
}	
}	 }		} 
{	 }		{
	{  }	  

 
 {
	{   

{

{  }		  	{
	{  }	 }	
{		}		 	
{
	}		  
{
	}	 {   

{

{  }		  	{
	{  ;
	
{   	
{	  
	   }	
{	    {
	;  
{ 	{  {  {  {  	

	{  
			 

{  }  } 
 

}
   
{
 {
	{  {	 {  }	 {	 {

{
	{  {

 

} 
}	
 
 {  {

 

} 
{  }   

 

} 
{  ;
	
{  {	
 

{
 {
	;  
{  {  ;		
;  		

 { 	{ 	{ 	
	 

		

 	
;

	
		 ;		
{ 	{ 	{  {  {  {  

 
;  
;  
;  


		{ 	{  {  {  {  ; 
 	

 {  

   

}	
} 
{  {
	 
	}		} 
	  {   
 }	
}	 }		{  {		{
	{  ;	
	;	

{  ; 
	; 
 ; 	
;	 
{  {			  }		{
	}	 {    
 
	{   	
{
	 
	   }		  	;  
{  {  
			  	{
	{   
	}	
 
 {		{
	} 
{   

{

{  {	
  	{	 } 
{	 {	
}		{
	} 
}	 { 	{  {  {  {  {  {  {  {
	}

{	
 	
}	
{
   
 
	   {  }
	  	  
}		{
	}	 }  {	 {	
{
	{  	
	
}		{	 {		;   {  }	 }  {	 {	
{
	;   {   
	{
	}
	 	
  
 
	{
		

 ;   {  {	  
	{
 {  {
	}

{	
 	
}	
{
   
 
	   {  {	  
		  {  ;	
 {  	 
{   

} 
{  			{ 	{  {  {  {  {  {  {    
 
  
 {
	{
   
{	 }		{
	 	
	  {  {

 

 	
 	
 

}
	{
	{
 {  {			  {  }
	  	  
}		{
	}	 }  {	 {	
{
	{   

} 
{  {
	 
	{
 {   

{

{  {

  
 	
{
	;   {   
 }	
}	 }		{  {		{
	{  ;	
	;	

{  ; 	
;	  ; 
	;	 	;  
{ 	{  {  {  {  

 
;  
;  
;  


		{ 		
 	{ 	
comments!=style
*/
int c;char*s=""{ }	;\n*"";b(){

return

  strchr	(s,getchar())-s;}
 n		(){int c;
c=		b()*3;
 c		+=b()/2;
  c=c*3+	b()/2;

return

c==0?' ':
c==1?'\n':
c==2?'	':
c<33?c+'a'
-3:(c-32)
*3+' '+b
()/2;

}main(){

while(b()!=6);
	while((c=n())!='$')
		putchar(c);}
","#ifndef  pdbq
#ifndef  n
#define  n 05
#endif   pqbd
#define  dpqb __FILE__ 
#define  ppbd ""Move disk %d from peg %d to peg %d\n""
#define  pdbq
#if      n&01
#define  dqbp
#endif   bpdq
#if      n&02
#define  dbpq
#endif   pbdq
#if      n&04
#define  pbqd
#endif   qbpb
#if      n>>3
#define  bqdp
#endif   pbbq
main(){  pdbq
printf(  pdbq
#include dpqb
#define  qbdp
#include dpqb
);}      qbdp
#else    dpdp
#ifdef   dqbp
#define  bdpq
#endif   bpdd
#ifdef   dbpq
#define  bdpq
#endif   pqpb
#ifdef   pbqd
#define  bdpq
#endif   pdpp
#ifdef   bqdp
#define  bdpq
#endif   pdpp
#ifdef   bdpq
#undef   bdpq
#ifndef  dqbp
#define  dqbp
#ifndef  dbpq
#define  dbpq
#ifndef  pbqd
#define  pbqd
#ifndef  bqdp
#define  bqdp
#else    dbqb
#undef   bqdp
#endif   qdqb
#else    pdbq
#undef   pbqd
#endif   qdbp
#else    pqbb
#undef   dbpq
#endif   pqbd
#else    bbpp
#undef   dqbp
#endif   ppqb
#include dpqb
#ifndef  dqbp
#ifndef  dbpq
#ifndef  pbqd
#ifndef  bqdp
#define  bdpq
#endif   pbpp
#endif   qpdp
#endif   ddpb
#endif   qppb
#ifdef   bdpq
#undef   bdpq
#ifndef  qbdp
pdbq     ppbd
#else    qbbd
#ifdef   pqdb
,1,2,3   pqdb
#undef   pqdb
#define  qdbp
#else    bdbb
#ifdef   qdbp
,1,3,1   qdbp
#undef   qdbp
#else    bdbd
,1,1,2   pdbq
#define  pqdb
#endif   qppq
#endif   pqpb
#endif   bpdd
#else    pqpq
#ifndef  qbdp
pdbq     ppbd
#else    qqqb
,1       pdbq
#ifdef   dqbp
+1       dqbp
#endif   qqdb
#ifdef   dbpq
+2       dbpq
#endif   ppqb
#ifdef   pbqd
+4       pbqd
#endif   pqpp
#ifdef   bqdp
+8       bqdp
#endif   bbpb
#ifdef   pqdb
#ifdef   dqbp
,1,3     dqbp
#else    pddp
,3,1     pdbq
#endif   qpqq
#else    dbqb
#ifdef   qdbp
#ifdef   dqbp
,2,1     dqbp
#else    pqdb
,1,2     pdbq
#endif   dbdp
#else    pdpp
#ifdef   dqbp
,3,2     dqbp
#else    pdbb
,2,3     pdbq
#endif   pqpp
#endif   qbdp
#endif   pqpp
#endif   pdbp
#endif   pqdp
#include dpqb
#ifdef   dqbp
#undef   dqbp
#ifdef   dbpq
#undef   dbpq
#ifdef   pbqd
#undef   pbqd
#ifdef   bqdp
#undef   bqdp
#else    qddb
#define  bqdp
#endif   ppqp
#else    bddq
#define  pbqd
#endif   ddbq
#else    bbdb
#define  dbpq
#endif   qqbd
#else    ddbq
#define  dqbp
#endif   qbdb
#endif   qbdb
#endif   qbpp
","b'/*T\x06\t}\t\xb6 ;\n\x1b\x88\x05\n;\n\x08\n;\n }\n { \x08\x0e\n \n{ \x0b;\t\x08\t;\n\x0e;\t\x081 {\n\xe8\t{\t!\n}  {\n  ; \x02\x07\xe9\x02\t; \n \n;\n {\n\x11\n \t\n {\t]-\t \t} \t; \t  ; | \n\x08\xed\x08 ;\t\x02Q\n;\n\xb4\xeb\x07 ; ; \x16; ""\xfb\x07\t} \n} \x16\xdc\x05; \t;\t-\x01\xfd\x08l \n\n} \n \t} t\t d\xc0 ;\n; +\n t2 { \xec\x0c ;\t\n \n}\t1; C\n i \n; =\t} ; \x0b ;\n\x01\n;\n\x07\xec\x14 ; \t{\n\n  { \xea\n} { \x0b\x8f\x0c { \xef\x10\t}  }\n \n; .\t{\n\r { \xe9\x12\t}  } ;\t\x08\n{ \x05;\n\x1b; /n\xc8; 5\n} \x0c ; \t \xda\r{\t\x05; \x11\n \t; { 1\x08 ;  } \x03; \xa8\xfd\x15\t}  {\n\n;\t\x12 { ; .\t{\t; \x03 } ;\t\x02\t;\n; T ; \n{\n;\t\x02; \xc4;\t\x06;\t\x02\t{\n;\n\x11 {  { \x0c\x0c; \x01;\n\x01\xec\x1d; \x91 ; ; \xef; n!t }\n; \x19\xec!;\tG; \x07\x07t; \x11\x07\x0c\xf8\x1f;\t\xa4\t}\t\x15 ;\n\n \t;\n } ; "";\t\x1b\xe8# }\n;\t\x07\n{\n\x03; \x90$\t{\n;\n\x06;\t\x10&\n\n\x0b; d\x98\n{\n\n\t\xb6; \x0e\t{\n; S\xe9\'\n{ d;\t\x16; \x08\xe8);\t\x16\x8fc\n{\n\x0b;\t\x16\t;\n; &\xef*;\t\r\t;\n\x97\t{\n;\n$; \xa2; \x0e,; \x0e; $\x88d } \x97;\t\x0e\x88; \x1e\xeb/\xce; \xce\n; a; \xcd\t; \x0c {\n\t  } \x1f;\tj; #\xe81;\n\x11 }\n; \x0c\xc4 ; \t{ \xea5a;\t\xfb\r\t \xc4t\t{ \xef4a\t}\n }\n \n\x0e;\t\xa3\x0c;\n\x0f\xdb2;\t-\t\n; 8\t \t\n\n}  ; \t  }\t \n; \x1f\xe88; \t;\t\x1b\t \xda6Q\t; \t a\xcc\t{\t; \x1a\t{ \x01\x88 \n\x08\xec \t\t}\n\x86; v:\n{\n?\n \t}\n\n{ ?\x0c\n \n{ ; 4r\n;\n; v=b;\t\xdb\t \n;\t\n \t; \n  }\t \t; \x1a\n; ; \x04; \xde\t{ \xfa>\n \t} \t}\n\t { \x15 ; \n  {\t\xd5\x19`\n} \x0c\n;\n\t ;\n\x06!;\n\x06;\t\x061; \x06; >\x0f; \x12\xcc\t} 1; X\x0c\n; \t} p\t ; \t\n;\n\n; ;\t\x02;\t\x14\n; ; 2\t} ; vm \n2; ;1\x08\xedJ\n;\n ; ; \xcf\t}\n; \xc9Jc; \x9b; d\t} \n} \x16\xdeG; i\t} \n;\t; \xa7F\n{ \x07vl\xc2\xb6\xfeV;\t\x08\x03z \nn \n\xb6\xe9Oc; \x07s\r\n;\t; \xd1\xde;\n\x12\x0buh\x07\xb6\xebR\t} hRs; A\t cl,;\n\x04; \x19;\tZ;\t\x1b {\nx \nlw\xb6\xeaUch\x9d{\t\x12\t}\n } ; \xe0\xeeVc\t}\n; \x8e; >\xc8D\n\t; G\t;\t; \x86\n;\n\xeeX; \x92\x88\x02\n; \n \t\n;\t2 \t } \x1f\t{ \xe9[; \x1a\n{ \x0f\t}\n\t;\t\xdej;\t\xe5; \x0e\xeb_;\t\r\x11y \n\t;\tD; \x1fT; \x06; ?j; .n; \x12; \xe3 {\n\n; \xda]; !; \xcb; 0a\t\n }\tJ ;\n; ^;\t.\n{ \t{\t\t{ \xeec; \rX\t; \t; \xb4;\nJ\t{\t\n; ;\n\x12 } \x97\t{ \xeaf; \x13\n;\t\t{\n\x0b\t;\t; : } \x01{ \x10\n{\n\n\t; (h} \r }\n{\t\x0f }\n } ; \x13; \x06{ \x10\t\n; \xfbD; \x02T\xec\t\tCr; \r\x10;\tI;\tW\xe8s\xceWQ\n; ;\n\xd7;\tW\t{ \xfb\t}\n;\t(\t; \t;\t\t} \n} \x16; \x0e\t{\n; \x0e\xffn{ k;\t\xa9\x15 ; \x82\x0e; ?; %\xd9k; \x11\t;\n\n \t{ \xefv;\n3{ (; h\t{\n \n; \t; z\n \n; ;\t]{ \x1b; \x98\xefx; \x15S; \x0f{\t* } \x98; \x0fz}\t\x08;\t\xee; \x04\n{\t;\t~\x0f\t \n;\nU; \xf6\n;\t{ \x87\x01\n;\t\x07\xed~;\nOb\t}\t\x15; \xf2;\tUU;\tU{ -{\t%\xda|1\xe8\x83;\n\x1d;\t\x10Q\n ;\n\xb5{\tw{ \x9a;\t\x0e\t;\n\x0e\t{ \xed\x87;\t\x82; \x06\xfc\x9d\n\n\x85\n}\t\xd9\x86;\t\x17?; u\n{\n\n\n\x83\n}\t\t} ;\t\xbb\x1b\t; \xb4\t ;\t\x15; \x14 }\n; \x14\xe8\n{\n\t\n;\t\x10\x19;\t\x10\t}\t\t\n ; p\t;\t;\t\x15; \x07Q; \x07\xdc\x9d{ \x0b; \x06;\tK; $\xec\x93\t\np; 1}\n4;\t$;\n2Q\t;\t}\t\x1d\t{\n; $\xee\x97\t} ;\t#;\nT; 1\n; ;\t+; \xb1 } \x01\n; ;\n. ; { \x1e\n{ ;\t \x9a{\n\xa0\t;\n { \n; ; \x1d }\n \n\n; { [ { ;\t\xa3{ \x14; \x12\x8f; 0{ \x19\n { \xf4r\t; \x08\xe9\x9f\n;\t\n \t}\t=; w\n\n?; \x0e;\n\xe4; B\xaelwx \n\x0c ; \t h\x9dh \n\n} \x0c; pj \n\t; ;\t\x18; \xf6\t{ \xfb\xa7;\t\'n \n; \x0f; \x15{\t)\t{\n; \x13\xfa\xa4;\n\x18;\nQ\x0e\n; f; \'r\n{\n? { \xeb\xac;\t%l\xc2f}\n\x1d; ~\xa9{ q\xdb\xa8; \x06\n{\n\x0e\t{ \xff\xad;\t\xc2\xdb\xac{ \x9c\xda\x9el,u\x0c\t\t \n;\t&\t;\n\n \t{ \xed;\tG } \x1f\n; k \n; \x10\t}\n\x0c;\t\x11\n{\n\n \n; hR; \x1e; W\xdf\xb4; \x13\n} \x16;\n\t\n;\t; \x97\x07e; Z; \x9e{ N;\t= \n } ; <\t\n {\t]-\t B\x9a\x05retur; \xa1if \nelse \nwhil; \x05do; \x10nt \nchar \n {\t;  { \x04pu{\t\x03\t \t} \n{ \x05; =\n} B\n}  {\n; \t\x19\xf8\xbf`\x88; \x11d\xc0; \xb4\t}\t\x9d\n}\t\t} ; \xf8`; wa\xcc\t{\t\x95ma; > \n\t{ ; oJ\n}\t\xc8D\n{ \x15\t; \t;\t; \xb7\t;\n\x02\n; \xc1\t; ;\t\x01; \x02 ; ;\t\x01\n{ \x1f\x0f\n; ; \x80\xd5\x19;\t@\xeb ;\t\xc1; L {\n\n; \xd8\xc8\t; \n */int m[Z];\n\n#define U(x)s--;T=x\n#define C(l,s)I(o==l){s;}E\n#define Q(l,o)C(l,r=P;T=T o r)\n#define O(l,o)C(l,T=o T)\n#define H(l,s)C(l,U(s))\nint\nmain(){int*q,s,f,r,o,l,p,c,b;\nchar*d;\nd="" \\t\\n;{}\\0A\xcaP\x80\xb3\x06\xb2\x89\x8a@\x13\xc9\xb5\x81g\x04E\xcf\xcd\xb1\xb0\x8c0\x17\x8d\x8e\x8bq"";\nb=256;\nq=m;\ng;\no=g;\nc=g;\nc=c+g*b;\np=c;\nI(o){W(p){o=g;\nC(59,r=2)C(\'{\',r=5)C(\'}\',r=8)r=0;\nI(r){r=r+g%4;\nl=1-g-r;\nW(r--){*q=q[l];\nq++;\np--;\n}}E{I((o==32)+(o==9)+(o==10)){r=g;\no=o%4+(r+(r==123))%8*3;\nI(8<o)o=o+g%4*9;\no=d[o]+b;\n}*q++=o%b;\np--;\n}}W(g!=12);\ng;\n}E{W(p--)*q++=g;\n}s=Z;\np=0;\nW(1){o=L;\nO(17,!)O(18,-)Q(12,+)D C(10,r=T;\ns=f;\np=X 1];\nf=X 2];\nl=X 3];\nR)C(22,s++)C(27,return T)C(21,r=T;\nU(r))C(23,T=m[T])C(19,T=m[T]++)C(25,T=m[T]--){l=o%16;\no=o/16;\nI(l==7){l=B;\nl=l+B*b;\n}E I(7<l)l=l+B*8-1;\nH(2,f+l)H(4,f-l-4)H(3,m[f+l])H(5,m[f-l-4])H(6,c+l)H(7,m[c+l])H(12,l)H(8,l)C(9,U(p);\np=p+l)C(11,r=X -l/2];\nI(r<3){I(r)r=putchar(T);\nE\nr=g;\nR;\n}E{X 1]=p;\nX 2]=f;\nX 3]=l;\nf=s;\ns=s-19;\np=r;\n})C(13,p=l)C(15,I(P)p=l)C(14,I(!P)p=l);\n}}}\x0c\n'","b'/*T\x06\t}\t\xb6 ;\n\x1b\x88\x05\n;\n\x08\n;\n }\n { \x08\x0e\n \n{ \x0b;\t\x08\t;\n\x0e;\t\x081 {\n\xe8\t{\t!\n}  {\n  ; \x02\x07\xe9\x02\t; \n \n;\n {\n\x11\n \t\n {\t]-\t \t} \t; \t  ; | \n\x08\xed\x08 ;\t\x02Q\n;\n\xb4\xeb\x07 ; ; \x16; ""\xfb\x07\t} \n} \x16\xdc\x05; \t;\t-\x01\xfd\x08l \n\n} \n \t} t\t d\xc0 ;\n; +\n t2 { \xec\x0c ;\t\n \n}\t1; C\n i \n; =\t} ; \x0b ;\n\x01\n;\n\x07\xec\x14 ; \t{\n\n  { \xea\n} { \x0b\x8f\x0c { \xef\x10\t}  }\n \n; .\t{\n\r { \xe9\x12\t}  } ;\t\x08\n{ \x05;\n\x1b; /n\xc8; 5\n} \x0c ; \t \xda\r{\t\x05; \x11\n \t; { 1\x08 ;  } \x03; \xa8\xfd\x15\t}  {\n\n;\t\x12 { ; .\t{\t; \x03 } ;\t\x02\t;\n; T ; \n{\n;\t\x02; \xc4;\t\x06;\t\x02\t{\n;\n\x11 {  { \x0c\x0c; \x01;\n\x01\xec\x1d; \x91 ; ; \xef; n!t }\n; \x19\xec!;\tG; \x07\x07t; \x11\x07\x0c\xf8\x1f;\t\xa4\t}\t\x15 ;\n\n \t;\n } ; "";\t\x1b\xe8# }\n;\t\x07\n{\n\x03; \x90$\t{\n;\n\x06;\t\x10&\n\n\x0b; d\x98\n{\n\n\t\xb6; \x0e\t{\n; S\xe9\'\n{ d;\t\x16; \x08\xe8);\t\x16\x8fc\n{\n\x0b;\t\x16\t;\n; &\xef*;\t\r\t;\n\x97\t{\n;\n$; \xa2; \x0e,; \x0e; $\x88d } \x97;\t\x0e\x88; \x1e\xeb/\xce; \xce\n; a; \xcd\t; \x0c {\n\t  } \x1f;\tj; #\xe81;\n\x11 }\n; \x0c\xc4 ; \t{ \xea5a;\t\xfb\r\t \xc4t\t{ \xef4a\t}\n }\n \n\x0e;\t\xa3\x0c;\n\x0f\xdb2;\t-\t\n; 8\t \t\n\n}  ; \t  }\t \n; \x1f\xe88; \t;\t\x1b\t \xda6Q\t; \t a\xcc\t{\t; \x1a\t{ \x01\x88 \n\x08\xec \t\t}\n\x86; v:\n{\n?\n \t}\n\n{ ?\x0c\n \n{ ; 4r\n;\n; v=b;\t\xdb\t \n;\t\n \t; \n  }\t \t; \x1a\n; ; \x04; \xde\t{ \xfa>\n \t} \t}\n\t { \x15 ; \n  {\t\xd5\x19`\n} \x0c\n;\n\t ;\n\x06!;\n\x06;\t\x061; \x06; >\x0f; \x12\xcc\t} 1; X\x0c\n; \t} p\t ; \t\n;\n\n; ;\t\x02;\t\x14\n; ; 2\t} ; vm \n2; ;1\x08\xedJ\n;\n ; ; \xcf\t}\n; \xc9Jc; \x9b; d\t} \n} \x16\xdeG; i\t} \n;\t; \xa7F\n{ \x07vl\xc2\xb6\xfeV;\t\x08\x03z \nn \n\xb6\xe9Oc; \x07s\r\n;\t; \xd1\xde;\n\x12\x0buh\x07\xb6\xebR\t} hRs; A\t cl,;\n\x04; \x19;\tZ;\t\x1b {\nx \nlw\xb6\xeaUch\x9d{\t\x12\t}\n } ; \xe0\xeeVc\t}\n; \x8e; >\xc8D\n\t; G\t;\t; \x86\n;\n\xeeX; \x92\x88\x02\n; \n \t\n;\t2 \t } \x1f\t{ \xe9[; \x1a\n{ \x0f\t}\n\t;\t\xdej;\t\xe5; \x0e\xeb_;\t\r\x11y \n\t;\tD; \x1fT; \x06; ?j; .n; \x12; \xe3 {\n\n; \xda]; !; \xcb; 0a\t\n }\tJ ;\n; ^;\t.\n{ \t{\t\t{ \xeec; \rX\t; \t; \xb4;\nJ\t{\t\n; ;\n\x12 } \x97\t{ \xeaf; \x13\n;\t\t{\n\x0b\t;\t; : } \x01{ \x10\n{\n\n\t; (h} \r }\n{\t\x0f }\n } ; \x13; \x06{ \x10\t\n; \xfbD; \x02T\xec\t\tCr; \r\x10;\tI;\tW\xe8s\xceWQ\n; ;\n\xd7;\tW\t{ \xfb\t}\n;\t(\t; \t;\t\t} \n} \x16; \x0e\t{\n; \x0e\xffn{ k;\t\xa9\x15 ; \x82\x0e; ?; %\xd9k; \x11\t;\n\n \t{ \xefv;\n3{ (; h\t{\n \n; \t; z\n \n; ;\t]{ \x1b; \x98\xefx; \x15S; \x0f{\t* } \x98; \x0fz}\t\x08;\t\xee; \x04\n{\t;\t~\x0f\t \n;\nU; \xf6\n;\t{ \x87\x01\n;\t\x07\xed~;\nOb\t}\t\x15; \xf2;\tUU;\tU{ -{\t%\xda|1\xe8\x83;\n\x1d;\t\x10Q\n ;\n\xb5{\tw{ \x9a;\t\x0e\t;\n\x0e\t{ \xed\x87;\t\x82; \x06\xfc\x9d\n\n\x85\n}\t\xd9\x86;\t\x17?; u\n{\n\n\n\x83\n}\t\t} ;\t\xbb\x1b\t; \xb4\t ;\t\x15; \x14 }\n; \x14\xe8\n{\n\t\n;\t\x10\x19;\t\x10\t}\t\t\n ; p\t;\t;\t\x15; \x07Q; \x07\xdc\x9d{ \x0b; \x06;\tK; $\xec\x93\t\np; 1}\n4;\t$;\n2Q\t;\t}\t\x1d\t{\n; $\xee\x97\t} ;\t#;\nT; 1\n; ;\t+; \xb1 } \x01\n; ;\n. ; { \x1e\n{ ;\t \x9a{\n\xa0\t;\n { \n; ; \x1d }\n \n\n; { [ { ;\t\xa3{ \x14; \x12\x8f; 0{ \x19\n { \xf4r\t; \x08\xe9\x9f\n;\t\n \t}\t=; w\n\n?; \x0e;\n\xe4; B\xaelwx \n\x0c ; \t h\x9dh \n\n} \x0c; pj \n\t; ;\t\x18; \xf6\t{ \xfb\xa7;\t\'n \n; \x0f; \x15{\t)\t{\n; \x13\xfa\xa4;\n\x18;\nQ\x0e\n; f; \'r\n{\n? { \xeb\xac;\t%l\xc2f}\n\x1d; ~\xa9{ q\xdb\xa8; \x06\n{\n\x0e\t{ \xff\xad;\t\xc2\xdb\xac{ \x9c\xda\x9el,u\x0c\t\t \n;\t&\t;\n\n \t{ \xed;\tG } \x1f\n; k \n; \x10\t}\n\x0c;\t\x11\n{\n\n \n; hR; \x1e; W\xdf\xb4; \x13\n} \x16;\n\t\n;\t; \x97\x07e; Z; \x9e{ N;\t= \n } ; <\t\n {\t]-\t B\x9a\x05retur; \xa1if \nelse \nwhil; \x05do; \x10nt \nchar \n {\t;  { \x04pu{\t\x03\t \t} \n{ \x05; =\n} B\n}  {\n; \t\x19\xf8\xbf`\x88; \x11d\xc0; \xb4\t}\t\x9d\n}\t\t} ; \xf8`; wa\xcc\t{\t\x95ma; > \n\t{ ; oJ\n}\t\xc8D\n{ \x15\t; \t;\t; \xb7\t;\n\x02\n; \xc1\t; ;\t\x01; \x02 ; ;\t\x01\n{ \x1f\x0f\n; ; \x80\xd5\x19;\t@\xeb ;\t\xc1; L {\n\n; \xd8\xc8\t; \n */int m[Z];\n\n#define U(x)s--;T=x\n#define C(l,s)I(o==l){s;}E\n#define Q(l,o)C(l,r=P;T=T o r)\n#define O(l,o)C(l,T=o T)\n#define H(l,s)C(l,U(s))\nint\nmain(){int*q,s,f,r,o,l,p,c,b;\nchar*d;\nd="" \\t\\n;{}\\0A\xcaP\x80\xb3\x06\xb2\x89\x8a@\x13\xc9\xb5\x81g\x04E\xcf\xcd\xb1\xb0\x8c0\x17\x8d\x8e\x8bq"";\nb=256;\nq=m;\ng;\no=g;\nc=g;\nc=c+g*b;\np=c;\nI(o){W(p){o=g;\nC(59,r=2)C(\'{\',r=5)C(\'}\',r=8)r=0;\nI(r){r=r+g%4;\nl=1-g-r;\nW(r--){*q=q[l];\nq++;\np--;\n}}E{I((o==32)+(o==9)+(o==10)){r=g;\no=o%4+(r+(r==123))%8*3;\nI(8<o)o=o+g%4*9;\no=d[o]+b;\n}*q++=o%b;\np--;\n}}W(g!=12);\ng;\n}E{W(p--)*q++=g;\n}s=Z;\np=0;\nW(1){o=L;\nO(17,!)O(18,-)Q(12,+)D C(10,r=T;\ns=f;\np=X 1];\nf=X 2];\nl=X 3];\nR)C(22,s++)C(27,return T)C(21,r=T;\nU(r))C(23,T=m[T])C(19,T=m[T]++)C(25,T=m[T]--){l=o%16;\no=o/16;\nI(l==7){l=B;\nl=l+B*b;\n}E I(7<l)l=l+B*8-1;\nH(2,f+l)H(4,f-l-4)H(3,m[f+l])H(5,m[f-l-4])H(6,c+l)H(7,m[c+l])H(12,l)H(8,l)C(9,U(p);\np=p+l)C(11,r=X-l/2];\nI(r<3){I(r)r=putchar(T);\nE\nr=g;\nR;\n}E{X 1]=p;\nX 2]=f;\nX 3]=l;\nf=s;\ns=s-19;\np=r;\n})C(13,p=l)C(15,I(P)p=l)C(14,I(!P)p=l);\n}}}\x0c\n'","#include<stdlib.h>
#include<stdio.h>
main(I,O,O0,OO,l)
int I,O0,OO,l;
char **O;
{
	return !!I>=I?!I>=I?!!~I>=~I?!~I>=~I?!OO?!I:OO%2?
		OO=main(I,O,O0,OO>>!!OO,l),
		OO=main(I-!I-!!I,O,OO,OO,l),
		OO=main(I-!I-!!I,O,O0,OO,l),
		!(OO-!I||I)?l-1:OO
	:(OO=main(I,O,O0,OO>>!!OO,l),
		!(OO-l+!I||I)?l-1:main(I-!I-!!I,O,OO,OO,l))
	:(O0+OO)%l
	:main(I-I/I-I/I,O,O0,OO+OO/OO,
		main(0,O,O0,OO,I-I-I)+I+1?1:printf(""%d "",I-I-I)+fflush(stdout))
	:main(I-I-I-I-I,O,I+I-I+I,I,0)
	:main(~!!I-!!I,O,atoi(1[O]),1,atoi(0[O]));
}
","float s=1944,x[5],y[5],z[5],r[5],j,h,a,b,d,e;int i=33,c,l,f=1;int g(){return f=
(f*6478+1)%65346;}m(){x[i]=g()-l;y[i]=(g()-l)/4;r[i]=g()>>4;}main(){char t[1948
]="" `MYmtw%FFlj%Jqig~%`jqig~Etsqnsj3stb"",*p=t+3,*k=""3tjlq9TX"";l=s*20;while(i<s)
p[i++]='\n'+5;for(i=0;i<5;i++)z[i]=(i?z[i-1]:0)+l/3+!m();while(1){for(c=33;c<s;
c++){c+=!((c+1)%81);j=c/s-.5;h=c%81/40.0-1;p[c]=37;for(i=4;i+1;i--)if((b=(a=h*x
[i]+j*y[i]+z[i])*a-(d=1+j*j+h*h)*(-r[i]*r[i]+x[i]*x[i]+y[i]*y[i]+z[i]*z[i]))>0)
{for(e=b;e*e>b*1.01||e*e<b*.99;e-=.5*(e*e-b)/e);p[c]=k[(int)(8*e/d/r[i])];}}for
(i=4;i+1;z[i]-=s/2,i--)z[i]=z[i]<0?l*2+!m():z[i];while(i<s)putchar(t[i++]-5);}}
","#define fine #define de #define/**/ /**/*#define*/
#define de #define
#define do de

do { begin
do you like (green eggs and ham++)?
do you eat them: in a box?
do you eat them with a fox?0
do } end

fine
fine, just fine.

                    /*@@@@@@@@@@@@=___
                   /@@@@@@@@@@@@@@@@@@@a
                   @@@@@@@@@@@@@@@@@@@@@
                   |@@@@@@@@@@@@@@@@@@@@
                    @@@@@@@@@@@@@@@@@@@@
                     \@=~         ~~@@@/
                      \               /
                       \              |
                       /@@@@@===__    |
                       @@@@@@@@@@@@==/
                      /@@@@@@@@@@@@@@
                      @@@@@@@@@@@@@@@
                     / ~~~====@@@@@@
                    /           ~~~/
                   |              /
                  /____          |
                 @@@@@@@@=====__/
                @@@@@@@@@@@@@@@@
               /@@@@@@@@@@@@@@@
              /@@@@@@@@@@@@@@@|
          ___/        ~~~~@@*/
   char groo(p,q)int p;int q;{return
((char)          (--q*q+   (p/10)*q+--p))
       ;          }void grem /**/  (){ int x=0
     ;             printf(""   "")
     ;/**/   /**/    for(;x<16
    ;                x++)printf
   (                 ""%c"",groo(x
   ,    8))            ;printf
   (                   ""\n\n"")
  ;                  }void cred(a
 )                   int a;{int
                    x=0;printf
 (                  ""%c  ""
 , /*_____===~*/  groo(a,8))
  ;             for(;x<16
   ;           x++)printf
    (         ""%c"",(char)
      a*16+ x);printf(
       ""\n"");}main(a
          ,b)int a;
 char **b   ;{int        x=2;
    do(x=0;x<4;x++)exit(0);
  for(grem();x<1<<3+(int)b[0]
[0]%2;)cred            (++x-1);}

","#define x char
#define z else
#define w gets
#define r if
#define u int
#define s main
#define v putchar
#define y while
#define t "" A?B?K?L?CIF?MSP?E?H?O?R?DJG?NTQ?????U?V?????X???????Z????W??Y??""
 s (   )  {   x* c  ,  b[ 5  * 72   ]; u  a, e  ,  d   [  9
*9 *9 ]  ;    y  (w  ( b) ){            r  ( 0   [ b] -7 *
5        )    {  c  =     b    ;       y  (  (*    c  -  6
* 7 )* *  c )c =  c+ 1  ;   r ((   -0 )  [ c  ] &&  w (  b   +
  8 *  5*    3        ) && w          (b   +8      *5  * 6) )
  { a       =  0; y     (                  a       [     b  ]
 ) {    a [  d  ] = ! !    ( a[ b]   -   4 *8 )    ;  a  =   a +
1;  }   y (a   <  8 *  5      *  3   )  d      [   (   a ++ )
]  =      0       ; a        =       0;            y(    b  [
 a +  8  *3   *  5  ] )  {   d  [ a  ]   = a  [    d] +  !  !( b[
a+ 40  *  3     ]  -4  * 8) *  2    ;      ++  a   ;   }     a  =
 0       ;      y  (     a     [  b +      6          *  40 ]
)  {a [d ]  +=  !   !  ( b[ a   +    5 *  6  *    8  ] - 4   *
 8        ) *  4;   a =   a  + 1    ;} a=   0;   y  (a   <3 *8
   *5       )  {    r    (     a    [       d    ]  )    {  e
 =  1  ; y    (   e[ a  +  d] ){    *  ( d+ a+    e )   = a[ d
+e -  1] +(       d   [     a  +   e  ]  <<  (   3* e) )     ;e
 =    e           +  1  ;} a       =        a     +
e -  1     ; v( !! (  *  (  d+
  a)  %   (  64  )  - 12  *  5
  )             +  (  e
>  4   ) ?t [   e   >2 ?  2  :a    [ d   ]  ]   :6 *  8  +( t  [ d[
 a    ]/ 8     /8   ]  -4  )      %( 10 )  )    ;  r(  ! (2 [a
+  d] +  3  [d +       a  ]  )    )        v    (  4  *     8    )
 ;  }    a =   a  + 1 ; } v    (5 *  2     )  ;  }    z {c =b ;   e
=  0    ;     y  (*   c )  {   *   c +=   -  (* c    >   8 *     12
   )    *  32    ;      a         =  8       *  8       ;  r  (* c
 >=  48  &&*  c<8  *8   -6)  {*c  =(   * c  + 1
 )   %(  5    * 2  ) +  65   ;y(  --a  >0   &&*
c-  a[  t]   );   d[   (e   ++   )]   =4   ;(
 * (  d +  (e   ++)  ))=  07   ;}z  y(a  --  >1
 &&*  c-   t[a  ]);  d[   ( e  = e  +    1)  -
1]   =a   %8   ;y   (a   /=   8)   d[   (e  ++
 ) ]  =    a% 8   ; ++ c   ; *  (   e ++   +d )  =0
;} --  e   ;r    (         e >0  ) {a  =   1   ;
y          (  a<       8     )  {   c =       b  ;y
 ( c  <e +b  )   {  v  (  *     ( c  -    b + d  )&   a? 6  *7
:8       *  4     ) ;   c ++   ;} a=  a   +    a  ;    v  ( 2*
   5) ;  }  v    (  5*    2    )          ;   }} }}      }

","#include<stdio.h>

/* $Id: hunni.c,v 1.5 1996/11/17 20:58:04 schweikh Exp schweikh $ */

/* usage: hunni [n_op [start [increment [goal]]]] */

/* Up to 20! = 2432902008176640000 */
/*          < 9223372036854775807 = 2^63-1 */
/* n! fits in signed long long ints, */
/* with 19 operators there are 4^19 = 274,877,906,944 combinations, */

/* up to 12! =  479001600 */
/*          < 2147483647 = 2^31-1 */
/* n! fits in signed long ints, */
/* with 11 operators there are 4^11 = 4,194,304 combinations. */

/*@-loopswitchbreak@*/
/*@-protoparamprefix p_@*/
/*@-pointerarith@*/
/*@+ignorequals@*/

#define FMT     ""%ld""   /* printf and scanf format for this type */
#define LONGEST long    /* longest type of this implementation */


typedef struct { LONGEST num, den; } fraction;
typedef unsigned LONGEST bitvec;

static fraction init[20], work[20], param[4] = {
    { 9, 1 } ,
    { 1, 1 } ,
    { 1, 1 } ,
    { 6 * 7, 1 }
};

static int J;

    static void
out (fraction f)
{
    if (f.den - 1) {
	    J = printf (FMT ""/"" FMT, f.num, f.den);
    } else {
	    J = printf (FMT, f.num);
    }
}

    static void
normalize (fraction *p_f)
{
    LONGEST a = (*p_f).num, b = (*p_f).den;

    if (b) {
	    while (a) {
		    LONGEST i = b % a;
		    b = a;
		    a = i;
	    }
	    b = b < 0 ? - b : b ;
	    (*p_f).num /= b;
	    (*p_f).den /= b;
    }
}

    int
main (int argc, char *argv[])
{
    bitvec m, mask;
    int i, cursor;

    for (i = 1; i < 5; i = i + 1) {
	    if (argc > i) {
		    J = sscanf (argv[i], FMT ""/"" FMT,
		    &param[i-1].num, &param[i-1].den);
	    }
	    normalize (param + i - 1);
    }
    init[0] = param[1];
    for (i = 0; i < param[0].num; i = i + 1) {
	    init[i+1].num = init[i].num * param[2].den
	    + param[2].num * init[i].den;
	    init[i+1].den = init[i].den * param[2].den;
	    normalize (init + i + 1);
    }
    for (mask = ~(~0 << param[0].num*2); ~(bitvec)0 - mask; mask = mask - 1) {
	    /* Pass one computes mult and div. */
	    /* For add and sub the right operand is copied. */
	    work[cursor = 0] = init[0];
	    for (m = mask, i = 1; ! (i > param[0].num); i = i + 1, m = m / 4) {
		    if ((m & 3) < 2) {
			    if (m & 1) {
				    work[cursor].num *= init[i].den;
				    if ((work[cursor].den *= init[i].num) < 0) {
					    work[cursor].num *= -1;
					    work[cursor].den *= -1;
				    }
			    } else {
				    work[cursor].num *= init[i].num;
				    work[cursor].den *= init[i].den;
			    }
		    } else {
			    work[cursor = cursor + 1] = init[i];
		    }
	    }
	    /* Pass two computes the remaining adds and subs. */
	    for (m = mask, i = cursor = 0; i < param[0].num; i = i + 1, m = m / 4) {
		    if ((m & 3) > 1) {
			    work[0].num = work[0].num * work[cursor+1].den +
			    ((m & 1) ? -1 : +1) * work[cursor+1].num * work[0].den;
			    work[0].den = work[0].den * work[cursor = cursor + 1].den;
		    }
	    }
	    normalize (work);
	    /* output result */
	    if (!param[3].den
		    || (!(param[3].num - work[0].num)
		    && !(param[3].den - work[0].den))) {
		    for (m = mask, i = 0; i < param[0].num; i = i + 1, m = m / 4) {
			    out (init[i]);
			    J = printf ("" %c "", ""*/+-""[m & 3]);
		    }
		    out (init[i]);
		    J = printf ("" = "");
		    out (work[0]);
		    J = printf (""%c"", 10); /* newline */
	    }

    }
    return J - 1;
}
","#define O B F U S C A T E D
#define I 8;}t(p){r(p?W:o);XClearWindow(V,m);}main(i,f)char**f;{M((T(h=f),
#define K Y(o,XMapRaised(V,e);)x=3;x--;)for(y=3;y--;r(G))XMapRaised(V,R[D]
#define N z(x+i,(z(H-x-i,x),x)))x<i||z(x-i,x)|z(H-x+i,x)Y(W,)l=k;l>20&&l>x
#define XIMOfIC Z;XID(*w)()=XCreateWindow,m,e,o[2],W[2],G[2],R[2][O]);}GC*g
#define E (++D)));}r(XID*z){XSetWindowBackgroundPixmap(V=d[D],m=R[D][x][y],z[
#define L ;XStoreName(V,e=w(V,RootWindow(V,s),0,0,152,152,2,0,1,0,0,0),""II""+D
#define B 3][3];Display*V,*d[2];char**h,k=25,b[2500],H=50,D,s,x,y,i;T(){float
#define S +k),z(k-P=w(V,e,H*x,H*y,H,H,1,0,1,0,2048,&c));}XEvent J;M(){XFlush(
#define Y(z,y) ;for(z[D]=XCreatePixmapFromBitmapData(Q,x=0,H*H);x<H;x++)y for(
#define A x][y]&&!b[x+k*y]++?t(D),t(!(D^=1)):D);M();}z(x,y){b[x/8+y*7]|=1<<x%I
#define P x,y)-z(y,x+k)+z(y,k-x)*z(x+k,y=H-y),z(k-x,y),z(y,k-x),z(y,k+x)K[x][y]
#define Q V,e,b,H,H,BlackPixel(V,s),WhitePixel(V,s),DefaultDepth(V,s)),memset(b
#define C d[!D]);x=3;for(XNextEvent(V,&J);x--;)for(y=3;y--;J.xany.window==R[D][
#define F l;XSetWindowAttributes c;s=XDefaultScreen(V=d[D]=XOpenDisplay(*(h+=!!
#define U *h)))L)Y(G,)i=c.event_mask=4;i--;x+i>H||N;l-=.5)z(x+k,y=sqrt(l*l-x*x)
#include <math.h>
#include <X11/Xlib.h>
","/* @(#)mkentry.c	1.32 9/27/96 17:16:36 */
/*
 * Copyright (c) Landon Curt Noll & Larry Bassel, 1996.
 * All Rights Reserved.  Permission for personal, education or non-profit use
 * is granted provided this this copyright and notice are included in its
 * entirety and remains unaltered.  All other uses must receive prior
 * permission in writing from both Landon Curt Noll and Larry Bassel.
 */
/*
 * mkentry - make an International Obfuscated C Code Contest entry
 *
 * usage:
 *	mkentry -r remarks -b build -p prog.c -o ioccc.entry
 *
 *	-r remarks		file with remarks about the entry
 *	-b build		file containing how prog.c should be built
 *	-p prog.c		the obfuscated program source file
 *	-o ioccc.entry		ioccc entry output file
 *
 * compile by:
 *	cc mkentry.c -o mkentry
 */
/*
 * Placed in the public domain by Landon Curt Noll, 1992.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
/*
 * WARNING:
 *
 * This program attempts to implement the IOCCC rules.  Every attempt
 * has been made to make sure that this program produces an entry that
 * conforms to the contest rules.  In all cases, where this program
 * differs from the contest rules, the contest rules will be used.  Be
 * sure to check with the contest rules before submitting an entry.
 *
 * FOR MORE INFORMATION:
 *
 *   You may contact the judges by sending EMail to the following address:
 *
 *	...!{apple,sun,uunet}!hoptoad!judges		(not the address for
 *	judges@toad.com					 submitting entries)
 *
 *   Questions and comments about the contest are welcome.
 *
 *  The rules and the guidelines may (and often do) change from year to
 *  year.  You should be sure you have the current rules and guidelines
 *  prior to submitting entries.
 *
 * Because contest rules change from year to year, one should only use this
 * program for the year that it was intended.  Be sure that the RULE_YEAR
 * define below matches this current year.
 */

#include <stdio.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

/* logic */
#ifndef TRUE
# define TRUE 1
#endif /* TRUE */
#ifndef FALSE
# define FALSE 0
#endif /* FALSE */
#define EOF_OK TRUE
#define EOF_NOT_OK FALSE

/* global limits */
#define RULE_YEAR 1996		/* NOTE: should match the current year */
#define START_DATE ""4Mar92 0:00 UTC""	/* first confirmation received */
#define MAX_COL 79		/* max column a line should hit */
#define MAX_BUILD_SIZE 256	/* max how to build size */
#define MAX_PROGRAM_SIZE 3217	/* max program source size */
#define MAX_PROGRAM_SIZE2 1536	/* max program source size not counting
				   whitespace and {}; not followed by
				   whitespace or EOF */
#define MAX_TITLE_LEN 12	/* max chars in the title */
#define MAX_ENTRY_LEN 1		/* max length in the entry input line */
#define MAX_ENTRY 8		/* max number of entries per person per year */
#define MAX_FILE_LEN 1024	/* max filename length for a info file */

/* where to send entries */
#define ENTRY_ADDR1 ""...!{apple,sun,uunet}!hoptoad!obfuscate""
#define ENTRY_ADDR2 ""obfuscate@toad.com""

/* uuencode process - assumes ASCII */
#define UUENCODE(c) ((c) ? encode_str[(int)(c)&0x3f] : '`')
#define UUENCODE_LEN 45		/* max uuencode chunk size */
#define UUINFO_MODE 0444	/* mode of an info file's uuencode file */
#define UUBUILD_MODE 0444	/* mode of the build file's uuencode file */
#define UUBUILD_NAME ""build""	/* name for the build file's uuencode file */
#define UUPROG_MODE 0444	/* mode of the program's uuencode file */
#define UUPROG_NAME ""prog.c""	/* name for the program's uuencode file */

/* encode_str[(char)val] is the uuencoded character of val */
char encode_str[] = ""`!\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"";

/* global declarations */
char *program;			/* our name */
long start_time;		/* the startup time */

/* forward declarations */
void parse_args();
void usage();
FILE *open_remark();
FILE *open_build();
FILE *open_program();
FILE *open_output();
void output_entry();
void output_remark();
void output_author();
void output_info();
void output_build();
void output_program();
void output_end();
int get_line();
void output_till_dot();
int col_len();
void check_io();
void uuencode();

main(argc, argv)
    int argc;		/* arg count */
    char **argv;	/* the args */
{
    FILE *remark=NULL;	/* open remarks stream */
    FILE *build=NULL;	/* open build file stream */
    FILE *prog=NULL;	/* open program stream */
    FILE *output=NULL;	/* open output stream */
    char *rname=NULL;	/* file with remarks about the entry */
    char *bname=NULL;	/* file containing how prog.c should be built */
    char *pname=NULL;	/* the obfuscated program source file */
    char *oname=NULL;	/* ioccc entry output file */
    struct tm *tm;	/* startup time structure */

    /*
     * check on the year
     */
    start_time = time((long *)0);
    tm = gmtime(&start_time);
    if (tm->tm_year != RULE_YEAR-1900) {
	fprintf(stderr,
	""%s: WARNING: this program applies to %d, which may differ from %d\n\n"",
	    argv[0], RULE_YEAR, 1900+tm->tm_year);
    }

    /*
     * parse the command line args
     */
    parse_args(argc, argv, &rname, &bname, &pname, &oname);

    /*
     * open/check the input and output files
     *
     * We open and truncate the output file first, in case it is the same
     * as one of the input files.
     */
    output = open_output(oname);
    remark = open_remark(rname);
    build = open_build(bname);
    prog = open_program(pname);
    if (output==NULL || remark==NULL || build==NULL || prog==NULL) {
	exit(1);
    }

    /*
     * output each section
     */
    output_entry(output, oname);
    output_remark(output, oname, remark, rname);
    output_author(output, oname);
    output_info(output, oname);
    output_build(output, oname, build, bname);
    output_program(output, oname, prog, pname);
    output_end(output, oname);

    /*
     * flush the output
     */
    if (fflush(output) == EOF) {
	fprintf(stderr, ""%s: flush error in %s: "", program, oname);
	perror("""");
	exit(2);
    }

    /*
     * final words
     */
    printf(""\nYour entry can be found in %s.  You should check this file\n"",
	oname);
    printf(""correct any problems and verify that the uudecode utility will\n"");
    printf(""correctly decode your build file and program.\n\n"");
    printf(""This program has been provided as a guide for submitters.  In\n"");
    printf(""cases where it conflicts with the rules, the rules shall apply.\n"");
    printf(""It is your responsibility to ensure that your entry conforms to\n"");
    printf(""the current rules.\n\n"");
    printf(""EMail your entries to:\n"");
    printf(""\t%s\n"", ENTRY_ADDR1);
    printf(""\t%s\n\n"", ENTRY_ADDR2);
    printf(""Please use the following subject when you EMail your entry:\n"");
    printf(""\tioccc entry\n\n"");
    /* all done */
    exit(0);
}

/*
 * parse_args - parse the command line args
 *
 * Given the command line args, this function parses them and sets the
 * required name flags.  This function will return only if the command
 * line syntax is correct.
 */
void
parse_args(argc, argv, rname, bname, pname, oname)
    int argc;		/* arg count */
    char **argv;	/* the args */
    char **rname;	/* file with remarks about the entry */
    char **bname;	/* file containing how prog.c should be built */
    char **pname;	/* the obfuscated program source file */
    char **oname;	/* ioccc entry output file */
{
    char *optarg;	/* -flag option operand */
    int flagname;	/* the name of the -flag */
    int i;

    /*
     * Not everyone has getopt, so we must parse args by hand.
     */
    program = argv[0];
    for (i=1; i < argc; ++i) {

	/* determine the flagname */
	if (argv[i][0] != '-') {
	    usage(1);
	    /*NOTREACHED*/
	}
	flagname = (int)argv[i][1];

	/* determine the flag's operand */
	if (flagname != '\0' && argv[i][2] != '\0') {
	    optarg = &argv[i][2];
	} else {
	    if (i+1 >= argc) {
		usage(2);
		/*NOTREACHED*/
	    } else {
		optarg = argv[++i];
	    }
	}

	/* save the flag's operand in the correct global variable */
	switch (flagname) {
	case 'r':
	    *rname = optarg;
	    break;
	case 'b':
	    *bname = optarg;
	    break;
	case 'p':
	    *pname = optarg;
	    break;
	case 'o':
	    *oname = optarg;
	    break;
	default:
	    usage(3);
	    /*NOTREACHED*/
	}
    }

    /*
     * verify that we have all of the required flags
     */
    if (*rname == NULL || *bname == NULL || *pname == NULL || *oname == NULL) {
	usage(4);
	/*NOTREACHED*/
    }
    return;
}

/*
 * usage - print a usage message and exit
 *
 * This function does not return.
 */
void
usage(exitval)
    int exitval;		/* exit with this value */
{
    fprintf(stderr,
	""usage: %s -r remarks -b build -p prog.c -o ioccc.entry\n\n"", program);
    fprintf(stderr, ""\t-r remarks\tfile with remarks about the entry\n"");
    fprintf(stderr, ""\t-b build\tfile containing how prog.c should be built\n"");
    fprintf(stderr, ""\t-p prog.c\tthe obfuscated program source file\n"");
    fprintf(stderr, ""\t-o ioccc.entry\tioccc entry output file\n"");
    exit(exitval);
}

/*
 * open_remark - open/check the remark file
 *
 * The remark file should be indented by 4 spaces, and should not extend
 * beyond column MAX_COL.  These are not requirements, so we only warn.
 *
 * This function returns NULL on I/O or format error.
 */
FILE *
open_remark(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    char buf[BUFSIZ+1];		/* input buffer */
    int toolong=0;		/* number of lines that are too long */
    int non_indent=0;		/* number of lines not indented by 4 spaces */

    /*
     * open the remark input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open remark file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * look at each line
     */
    while (fgets(buf, BUFSIZ, stream) != NULL) {

	/* count lines that do not start with 4 spaces */
	if (buf[0] != '\n' && strncmp(buf, ""    "", 4) != 0) {
	    ++non_indent;
	}

	/* count long lines */
	if (col_len(buf) > MAX_COL) {
	    /* found a line that is too long */
	    ++toolong;
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* note long lines if needed */
    if (toolong > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s extend beyond the 80th column\n"",
	    program, toolong, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* note non-indented lines, if needed */
    if (non_indent > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s are not indented by 4 spaces\n"",
	    program, non_indent, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_build - open/check the build file
 *
 * The how to build file must not be longer than MAX_BUILD_SIZE bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_build(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */

    /*
     * open the how to build input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_BUILD_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the how to build file: %s, is %d bytes long\n"",
	    program, filename, statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_BUILD_SIZE);
	return(NULL);
    }

    /* return the open file */
    return(stream);
}

/*
 * open_program - open/check the program source file
 *
 * The program source file must be <= 3217 bytes.  The number of
 * non-whitespace and }{; chars not followed by whitespace must
 * be <= 1536 bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_program(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */
    int count;			/* special count size */
    int c;			/* the character read */

    /*
     * open the program source input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open program source file: %s: "",
	    program, filename);
	perror("""");
	exit(7);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat program source file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_PROGRAM_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the program source file: %s, is %d bytes long\n"",
	    program, filename, statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_PROGRAM_SIZE);
	return(NULL);
    }

    /*
     * count the non-whitespace, non {}; followed by whitespace chars
     */
    count = 0;
    c = 0;
    while ((c=fgetc(stream)) != EOF) {
	/* look at non-whitespace */
	if (!isascii(c) || !isspace(c)) {
	    switch (c) {
	    case '{':		/* count if not followed by EOF or whitespace */
	    case '}':
	    case ';':
		/* peek at next char */
		c = fgetc(stream);
		if (c != EOF && isascii(c) && !isspace(c)) {
		    /* not followed by whitespace or EOF, count it */
		    ungetc(c, stream);
		    ++count;
		}
		break;
	    default:
		++count;
		break;
	    }
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* look at the special size */
    if (count > MAX_PROGRAM_SIZE2) {
	fprintf(stderr,
	    ""%s: FATAL: the number of bytes that are non-whitespace, and\n"",
	    program);
	fprintf(stderr,
	    ""%s:        that are not '{', '}', ';' followed by whitespace\n"",
	    program);
	fprintf(stderr,
	    ""%s:        or EOF must be <= %d bytes\n"",
	    program, MAX_PROGRAM_SIZE2);
	fprintf(stderr,
	    ""%s:        in %s, %d bytes were found\n"",
	    program, filename, count);
	return(NULL);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_output - open/check the entry output file
 *
 * This function returns NULL on open error.
 */
FILE *
open_output(filename)
    char *filename;
{
    FILE *stream;		/* the opened file stream */

    /*
     * open the ioccc entry output file
     */
    stream = fopen(filename, ""w"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open ioccc entry file for output: %s: "",
	    program, filename);
	perror("""");
	exit(8);
    }

    /* return the open file */
    return(stream);
}

/*
 * output_entry - output the ---entry--- section
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_entry(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char title[MAX_TITLE_LEN+1+1];	/* the entry's title */
    char buf[MAX_COL+1+1];		/* I/O buffer */
    int entry=0;			/* entry number */
    int ret;				/* fields processed by fscanf */
    int ok_line=0;			/* 0 => the line is not ok */
    char skip;				/* input to skip */
    FILE *date_pipe;			/* pipe to a date command */
    time_t epoch_sec;			/* seconds since the epoch */
    char *p;

    /*
     * write the start of the section
     */
    fprintf(output, ""---entry---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the rule year
     */
    fprintf(output, ""rule:\t%d-1\n"", RULE_YEAR);
    check_io(output, oname, EOF_NOT_OK);

    /* determine if this is a fix */
    printf(""Is this a fix, update or resubmittion to a "");
    printf(""previous entry (enter y or n)? "");
    while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    if (buf[0] == 'y') {
	fprintf(output, ""fix:\ty\n"");
	check_io(output, oname, EOF_NOT_OK);
	printf(""\nBe sure that the title and entry number that you give\n"");
	printf(""are the same of as the entry you are replacing\n"");
    } else {
	fprintf(output, ""fix:\tn\n"");
	check_io(output, oname, EOF_NOT_OK);
    }

    /*
     * write the title
     */
    printf(""\nThe first character of your title should match [a-zA-Z0-9_=]\n"");
    printf(""The next 0 to %d characters should match [a-zA-Z0-9_=+-]\n\n"",
	MAX_TITLE_LEN-1);
    printf(""It is suggested, but not required, that the title should\n"");
    printf(""incorporate your username; in the\n"");
    printf(""case of multiple authors, consider using parts of the usernames\n"");
    printf(""of the authors.\n\n"");
    printf(""enter your title: "");
    do {
	/* prompt and read a line */
	if ((ok_line = get_line(title, MAX_TITLE_LEN+1, MAX_COL-9)) <= 0) {
	    printf(""\ntitle is too long, please re-enter: "");
	    continue;
	}

	/* verify the pattern, not everyone has regexp, so do it by hand */
	if (!isascii((int)title[0]) ||
	    !(isalnum((int)title[0]) || title[0] == '_' || title[0] == '=')) {
	    printf(""\ninvalid first character in the title\n\n"");
	    printf(""enter your title: "");
	    ok_line = 0;
	} else {
	    for (p=(&title[1]); *p != '\0' && *p != '\n'; ++p) {
		if (!isascii((int)*p) ||
		    !(isalnum((int)*p) ||
		      *p == '_' || *p == '=' || *p == '+' || *p == '-')) {
		    printf(""\ninvalid character in the title\n\n"");
		    printf(""enter your title: "");
		    ok_line = 0;
		}
	    }
	}
    } while (ok_line <= 0);
    fprintf(output, ""title:\t%s"", title);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the entry number
     */
    printf(""\nEach person may submit up to %d entries per year.\n\n"",
	MAX_ENTRY);
    printf(""enter an entry number from 0 to %d inclusive: "", MAX_ENTRY-1);
    do {
	/* get a valid input line */
	fflush(stdout);
	ret = fscanf(stdin, ""%d[\n]"", &entry);
	check_io(stdin, ""stdin"", EOF_NOT_OK);
	/* skip over input until newline is found */
	do {
	    skip = fgetc(stdin);
	    check_io(stdin, ""stdin"", EOF_NOT_OK);
	    if (skip != '\n') {
		/* bad text in input, invalidate entry number */
		entry = -1;
	    }
	} while (skip != '\n');

	/* check if we have a number, and if it is in range */
	if (ret != 1 || entry < 0 || entry > MAX_ENTRY-1) {
	    printf(
	      ""\nThe entry number must be between 0 and %d inclusive\n\n"",
		MAX_ENTRY-1);
	    printf(""enter the entry number: "");
	}
    } while (ret != 1 || entry < 0 || entry > MAX_ENTRY-1);
    fprintf(output, ""entry:\t%d\n"", entry);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the submission date
     */
    /* returns a newline */
    epoch_sec = time(NULL);
    fprintf(output, ""date:\t%s"", asctime(gmtime(&epoch_sec)));
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the OS/machine host information
     */
    printf(
      ""\nEnter the machine(s) and OS(s) under which your entry was tested.\n"");
    output_till_dot(output, oname, ""host:"");
}

/*
 * output_remark - output the ---remark--- section
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_remark(output, oname, remark, rname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *remark;		/* stream to the file containing remark text */
    char *rname;		/* name of the remark file */
{
    char buf[BUFSIZ+1];		/* input/output buffer */

    /*
     * write the start of the section
     */
    fprintf(output, ""---remark---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * copy the remark file to the section
     */
    while (fgets(buf, BUFSIZ, remark) != NULL) {
	fputs(buf, output);
	check_io(output, oname, EOF_NOT_OK);
    }
    check_io(remark, rname, EOF_OK);

    /* be sure that the remark section ends with a newline */
    if (buf[strlen(buf)-1] != '\n') {
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);
    }
}

/*
 * output_author - output the ---author--- section
 *
 * Read the needed information from stdin, and write the author section.
 * If multiple authors exist, multiple author sections will be written.
 */
void
output_author(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char buf[MAX_COL+1+1];	/* I/O buffer */
    int more_auths;		/* TRUE => more authors to note */
    int auth_cnt=0;		/* number of authors processed */

    /*
     * prompt the user for the author section
     */
    printf(""\nEnter information about each author.  If your entry is after\n"");
    printf(""%s and before the contest deadline, the judges\n"", START_DATE);
    printf(""will attempt to EMail back a confirmation to the first author\n"");

    /*
     * place author information for each author in an individual section
     */
    do {

	/* write the start of the section */
	fprintf(output, ""---author---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* write the author */
	printf(""\nAuthor #%d name: "", ++auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nname too long, please re-enter: "");
	}
	fprintf(output, ""name:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the organization */
	printf(""\nEnter the School/Company/Organization of author #%d\n"",
	    auth_cnt);
	printf(""\nAuthor #%d org: "", auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter: "");
	}
	fprintf(output, ""org:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the address */
	printf(
	    ""\nEnter the postal address for author #%d.  Be sure to include\n"",
	    auth_cnt);
	printf(""your country and do not include your name.\n"");
	output_till_dot(output, oname, ""addr:"");

	/* write the EMail address */
	printf(
	    ""\nEnter the EMail address for author #%d.  Use an address from\n"",
	    auth_cnt);
	printf(
	    ""a registered domain or well known site.  If you give several\n"");
	printf(""forms, list them one per line.\n"");
	output_till_dot(output, oname, ""email:"");

	/* write the home page URL */
	printf(
	    ""\nEnter the fully qualified home page URL for author #%d\n"",
	    auth_cnt);
	printf(""including the http: part or type none: "");
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0 ||
	       (strncmp(buf, ""http://"", sizeof(""http://"")-1) != 0 &&
		strcmp(buf, ""none\n"") != 0)) {
	      printf(""\nURL too long, does not begin with http:// or\n"");
	      printf(""is not the word none\n"");
	}
	fprintf(output, ""url:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the anonymous status */
	printf(""\nShould author #%d remain anonymous (enter y or n)? "",
	    auth_cnt);
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	fprintf(output, ""anon:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* determine if there is another author */
	printf(""\nIs there another author (enter y or n)? "");
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	if (buf[0] == 'y') {
	    more_auths = TRUE;
	} else {
	    more_auths = FALSE;
	}
    } while (more_auths == TRUE);
    return;
}

/*
 * output_info - output the ---info--- section(s)
 *
 * Read the needed information from stdin, and write the info section.
 * If multiple info files exist, multiple info sections will be written.
 */
void
output_info(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    char infoname[MAX_FILE_LEN+1];	/* filename buffer */
    char yorn[1+1];		/* y or n answer */
    char *uuname;		/* name to uuencode as */
    FILE *infile;		/* info file stream */

    /*
     * prompt the user for info information
     */
    printf(""\nInfo files should be used only to supplement your entry.\n"");
    printf(""For example, info files may provide sample input or detailed\n"");
    printf(""information about your entry.  Because they are supplemental,\n"");
    printf(""the entry should not require them to exist.\n\n"");

    /*
     * while there is another info file to save, uuencode it
     */
    printf(""Do you have a info file to include (enter y or n)? "");
    while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    while (yorn[0] == 'y') {

	/* read the filename */
	printf(""\nEnter the info filename: "");
	while (get_line(infoname, MAX_FILE_LEN+1, 0) <= 0) {
	    printf(""\nInfo filename too long, please re-enter: "");
	}

	/* compute the basename of the info filename */
	/* remove the trailing newline */
	uuname = &infoname[strlen(infoname)-1];
	*uuname = '\0';
	/* avoid rindex/shrrchr compat issues, do it by hand */
	for (--uuname; uuname > infoname; --uuname) {
	    if (*uuname == '/') {
		++uuname;
		break;
	    }
	}

	/* attempt to open the info file */
	infile = fopen(infoname, ""r"");
	if (infile == NULL) {
	    fprintf(stderr, ""\n%s: cannot open info file: %s: "",
		program, infoname);
	    perror("""");
	    continue;
	}

	/*
	 * write the start of the section
	 */
	fprintf(output, ""---info---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* uuencode the info file */
	uuencode(output, oname, infile, infoname, UUINFO_MODE, uuname);

	printf(""\nDo you have another info file to include (enter y or n)? "");
	while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
    };
    return;
}

/*
 * output_build - output the ---build--- section
 *
 * Read the needed information from stdin, and write the build section.
 */
void
output_build(output, oname, build, bname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *build;		/* open build file stream */
    char *bname;		/* name of the build file */
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---build---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, build, bname, UUBUILD_MODE, UUBUILD_NAME);
    return;
}

/*
 * output_program - output the ---program--- section
 *
 * Read the needed information form stdin, and write the program section.
 */
void
output_program(output, oname, prog, pname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    FILE *prog;			/* open program stream */
    char *pname;		/* name of program file */
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---program---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, prog, pname, UUPROG_MODE, UUPROG_NAME);
    return;
}

/*
 * output_end - output the ---end--- section
 *
 * Read the needed information form stdin, and write the 'end section'.
 */
void
output_end(output, oname)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
{
    /*
     * write the final section terminator
     */
    fprintf(output, ""---end---\n"");
    check_io(output, oname, EOF_NOT_OK);
    return;
}

/*
 * get_line - get an answer from stdin
 *
 * This function will flush stdout, in case a prompt is pending, and
 * read in the answer.
 *
 * This function returns 0 if the line is too long, of the length of the
 * line (including the newline) of the line was ok.  This function does
 * not return if ERROR or EOF.
 */
int
get_line(buf, siz, maxcol)
    char *buf;			/* input buffer */
    int siz;			/* length of input, including the newline */
    int maxcol;			/* max col allowed, 0 => disable check */
{
    int length;			/* the length of the input line */

    /* flush terminal output */
    fflush(stdout);

    /* read the line */
    if (fgets(buf, siz+1, stdin) == NULL) {
	/* report the problem */
	check_io(stdin, ""stdin"", EOF_NOT_OK);
    }

    /* look for the newline */
    length = strlen(buf);
    if (buf[length-1] != '\n') {
	int eatchar;		/* the char being eaten */

	/* no newline found, line must be too long, eat the rest of the line */
	do {
	    eatchar = fgetc(stdin);
	} while (eatchar != EOF && eatchar != '\n');
	check_io(stdin, ""stdin"", EOF_NOT_OK);

	/* report the situation */
	return 0;
    }

    /* watch for long lines, if needed */
    if (maxcol > 0 && (length > maxcol || col_len(buf) > maxcol)) {
	/* report the situation */
	return 0;
    }

    /* return length */
    return length;
}

/*
 * output_till_dot - output a set of lines until '.' by itself is read
 *
 * This routine will read a set of lines until (but not including)
 * a single line with '.' is read.  The format of the output is:
 *
 *	leader:\tfirst line
 *	\tnext line
 *	\tnext line
 *	   ...
 *
 * This routine will not return if I/O error or EOF.
 */
void
output_till_dot(output, oname, leader)
    FILE *output;		/* entry's output file stream */
    char *oname;		/* name of the output file */
    char *leader;		/* the lead text for the first line */
{
    char buf[BUFSIZ+1];		/* input buffer */
    int count;			/* lines read */
    int done=FALSE;		/* TRUE => finished reading input */

    /* instruct the user on how to input */
    printf(""\nTo end input, enter a line with a single period.\n"");

    /* read lines until '.' or EOF */
    count = 0;
    while (!done) {
	/* issue the prompt */
	printf(""%s\t"", (count>0) ? """" : leader);
	fflush(stdout);

	/* get the line */
	if (get_line(buf, BUFSIZ, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter:\n\t"");
	    continue;
	}

	/* note if '.' was read */
	if (strcmp(buf, "".\n"") == 0) {
	    done = TRUE;
	}

	/* write line if we read something */
	if (!done) {
	    fprintf(output, ""%s\t%s"", (count++>0) ? """" : leader, buf);
	    check_io(output, oname, EOF_NOT_OK);
	}
    }

    /* if no lines read, at least output something */
    if (count <= 0) {
	fprintf(output, ""%s\t.\n"", leader);
	check_io(output, oname, EOF_NOT_OK);
    }
    return;
}

/*
 * col_len - determine the highest that a string would reach
 *
 * Given a string, this routine returns that a string would reach
 * if the string were printed at column 1.  Tab stops are assumed
 * to start at 9, 17, 25, 33, ...
 */
int
col_len(string)
    char *string;		/* the string to examine */
{
    int col;	/* current column */
    char *p;	/* current char */

    /* scan the string */
    for (col=0, p=string; *p != '\0' && *p != '\n'; ++p) {
	/* note the column shift */
	col = (*p=='\t') ? 1+((col+8)/8*8) : col+1;
    }
    if (*p == '\n') {
	--col;
    }

    /* return the highest column */
    return col;
}

/*
 * check_io - check for EOF or I/O error on a stream
 *
 * Does not return if EOF or I/O error.
 */
void
check_io(stream, name, eof_ok)
    FILE *stream;		/* the stream to check */
    char *name;			/* the name of this stream */
    int eof_ok;			/* EOF_OK or EOF_NOT_OK */
{
    /* test for I/O error */
    if (ferror(stream)) {
	fprintf(stderr, ""%s: error on %s: "", program, name);
	perror("""");
	exit(1);

    /* test for EOF */
    } else if (eof_ok == EOF_NOT_OK && feof(stream)) {
	fprintf(stderr, ""%s: EOF on %s\n"", program, name);
	exit(1);
    }
    return;
}

/*
 * uuencode - uuencode a file
 *
 * Perform the uuencoding process identical to the process performed
 * by the uuencode(1) utility.
 *
 * This routine implements the algorithm described in the uuencode(5)
 * 4.3BSD Reno man page.
 */
void
uuencode(output, oname, infile, iname, umode, uname)
    FILE *output;		/* output file stream */
    char *oname;		/* output filename */
    FILE *infile;		/* input file stream */
    char *iname;		/* input filename */
    int umode;			/* the mode to put on the uuencode file */
    char *uname;		/* name to put on the uuencode file */
{
    char buf[UUENCODE_LEN+1];	/* the uuencode buffer */
    int read_len;		/* actual number of chars read */
    int val;			/* 6 bit chunk from buf */
    char filler='\0';		/* filler uuencode pad text */
    char *p;

    /*
     * output the initial uuencode header
     */
    fprintf(output, ""begin %o %s\n"", umode, uname);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * clear out the input buffer
     */
    for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	*p = '\0';
    }

    /*
     * We will process UUENCODE_LEN chars at a time, forming
     * a single output line each time.
     */
    while ((read_len=fread(buf,sizeof(buf[0]),UUENCODE_LEN,infile)) > 0) {

	/*
	 * the first character is the length character
	 */
	fputc(UUENCODE(read_len), output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * We will convert 24 bits at a time.  Thus we will convert
	 * 3 sets of 8 bits into 4 sets of uuencoded 6 bits.
	 */
	for (p=buf; read_len>0; read_len-=3, p+=3) {

	    /* bits 0 to 5 */
	    val = (p[0]>>2)&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 6 to 11 */
	    val = ((p[0]<<4)&0x30) | ((p[1]>>4)&0x0f);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 12 to 17 */
	    val = ((p[1]<<2)&0x3c) | ((p[2]>>6)&0x03);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 18 to 23 */
	    val = p[2]&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);
	}

	/* end of UUENCODE_LEN line */
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * clear out the input buffer  (don't depend on bzero() or memset())
	 */
	for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	    *p = '\0';
	}
    }

    /* check the last read on the input file */
    check_io(infile, iname, EOF_OK);

    /* write end of uuencode file */
    fprintf(output, ""%c\nend\n"", UUENCODE(filler));
    check_io(output, oname, EOF_NOT_OK);
}
","#include T
#include Y

H W[] = { 16, 17, 18,  0, 8, 7, 9,  6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 }
,u[] = { 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15,  17, 19, 23, 27, 31, 35, 43, 51,
59,  67,  83,  99, 115, 131, 163, 195,  227, 258 } ,P[] = { A A 1, 1, 1, 1, 2,
2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 } ,Q[] = { 1, 2, 3, 4, 5, 7, 9,
13, 17, 25,  33, 49, 65, 97,  129, 193, 257, 385,  513, 769, 1025, 1537, 2049,
3073,  4097,  6145,  8193,  12289, 16385, 24577 } ,L[] = { A 1, 1, 2, 2, 3, 3,
4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 }, y, C, t,
Z[320],  b[17], G[17]; H long  j; H char S[K]; n { n *o, *O; H l; } F, *V, *h,
*I, **e;

H U H l, H O)
{
  H w = 0, o, f, q; J !O) { ; {
    U 24, 1); o = U 8, 1); U 24, 1); U 24, 1); {
      J o & 4) { ; X q = U 16, 1); q--; U 8, 1)); } ; {
        X; o &  8 && U 8, 1); ) { ; ;
    }
  }
  X; o & 16 && U 8, 1); );
  o & 2 && U 16, 1);
}

X o = 0; !o; ) { ;
{
  o = U 1, 1); q = U 2, 1); J
  q || U 8, 7)) { ; { ; { ; } ; ; ;
    q & 1 && U 7, 8);
    q & 2 && U 3, 9); U 5, 6);
    I = V; U 2, 4); I = h; U 9, 4); } ; }
  } ; ; { ; } ; { ; } ; { ; } ; { ; }
}

X; (C M) != (t M); N (C++[S])); } ; }

s 6)
{
  ; { ; { ; } X; (O = U 6, (I = V, 3) ))  != 256; )
  J O > 256 || (U O, 2),  0)) { ; {
    O -= 257; l = u[O] + U P[O],  1);
    I =  h; O = U 5, 3); O = Q[O] + U L[O], 1);
      O = O <= t ?
    t - O : K - O + t; X; l--; O M) U S[O++], 2) ; } ; }
  }
  ;} s 3) {
    ; { X; I->o; I = U 1, 1) ? I->O : I->o); w = I->l; } ;
  } s 5) { ; { X O =  17; O--; O[b] =
  0); X O++; O < l;
    O++[Z][b]++);
      X *b = *G = O = 0 ; O < 16; O++) { ; {
  G[O+1] = (O[G] + b[O]) << 1; ; }
}

X I = 0, O = 0; O < l; O++) J Z[O]) { ;
{
  X e = (q = O[Z][G], Z[O][G]++,
  o = Z[O], &I); o-- && (*e || ((*(*e = R) = F), 1));
  e = ((q >> o) & 1) ? &(*e)->O : &(*e)->o);
  *(*e = R)
  = F; (*e)->l = O; } ; } } ; } s 2) { ; {
  t++[S] = l; (t M) == (C M)
  && N (C++[S]); } ; } s 8) { ; {
    X O = 288; O--; Z[O] = O < 144 ? 8
    : O < 256 ? 9 : O < 280 ? 7 : 8); V = (U 288, 5),
    I); { ; { X O = 32; O--;
    Z[O] = 5); 
  }
}

h = (U 32, 5), I); } ; } s 1 && l)
{
  ; { { ; } ; { ; } ; { ; } ; { ; }
  X; y < l; y += 8)
  j |= 0l + D << y; w = j
    & (1 << l) - 1;
    j >>= l; y -= l; } ; } s 7) { ; { y % 8 && U y % 8, 1);
      X O = U 16, 1), U 16, 1); O--; U U 8, 1), 2));
    } ;
  }
  s 9) { ; {
    H p = U 5, 1) + 257, z = U 5, 1) + 1, v = U 4,
      1) + 4; { X O = 0; O < v; O++[W][Z] = U 3, 1));
    X; 19 > O; W[O++][Z] = 0); { ;
  }
}

V = (U 19, 5), I);
{
  X l = O = 0; O < (p + z); ) {
    I = V; o = U 3, 3); f = o == 16
      ? (o = l), 3 + U 2, 1) : o == 17 ?
        (o = 0), 3 + U 3, 1) : o == 18 ? (o = 0),
          11 + U 7, 1) : ((l = o), 1); X q = f; q--;
            O++[Z] = o); ; ; ; ; ; { ; }
}

I = V;
{
  U 9, 4); }
  V = (U p, 5), I);
  X O = z; O--;
  Z[O] = Z[O+p]);
  h = (U z, 5),
  I); } ; ; ; } ; ; ; } s
  4) { ; ; ; { n *
  i = I; i && (
  I = i->o, U 7, 4),
  I = i->O,
  free (i), U 1, 4));
  } ; }
  return w;
}

main ()
{
  return B (3, 0);
}
","#define _POSIX_SOURCE
#include                                <time.h>
#include                               <stdio.h>
#define                             extern/* ioccc*/
#define                           condition 22+d+e> 31
#define                         declarator main ( void )
#define                       keyword ae(t,d+e-9); ae(m,4)
#define                     false ae (t, d+ e+ 22); ae (m,3)
#define                   syntax_error(n); } else if (J < n) {
#define                 relational_expression(i, o, ccc) i o ccc
#define               errno translation_unit/*Apollo 13*/int errno
#define             iterative_statement  for  (  expressions ) block
#define             translation_unit  declarator  compound_statement
#define             ae(unary_expression,ae)     unary_expression= ae
#define             declaration char T[16];     struct tm ae(s,{ 0})
#define             if_part {macrolist list     ae(b,J%4); type_name
#define             tokens if (t==25&&d==28     &&a > 10) ae (t, 18)
#define             selection_statement(a,b,c) if(a){b; } else{ c; }
#define             storage_class ae(e,(2*b+4*c+6*d+N)%7); statement
#define             statement_list iterative_statement return'^'^'^'
#define            macro(x,y,cast) ae(M,x); ae(N,y)syntax_error(cast)
#define           block { if(relational_expression(J,<,1700))if_part;}
#define          declaration_list int J,a,b,c,d, e,t,m,M,N; declaration
#define         true keyword; selection_statement(t==26,ae(t,19),tokens)
#define        compound_statement { declaration_list ; statement_list ; }
#define       expressions ae(J,1582); relational_expression(J,<,2200); ++J
#define      list macro (24, 5, 2200) ae(M, 24); ae(N, 6); } ae(a, J % 19);
#define     type_name ae (c, J % 7);ae (d, (19 * a + M) % 30); storage_class
#define    statement  selection_statement ( condition,true,false)pptoken cast
#define   macrolist macro(22,2,1800)macro     (23, 3,1900) macro (23, 4, 2100)
#define  pptoken ae(s.tm_year,J-1900);ae       (s.tm_mon,m-1); ae(s.tm_mday,t);
#define cast (void)strftime(T,sizeof T,         ""%a %b %d %Y"",&s),(void)puts(T);
#include                               <errno.h>
","#define C "" ""
#define O( _ ) # _
#define R( n , d ) e ( n , d )
#define e(p,o)o##p
#define D O ( % ) O ( l ) O ( d )
#define U R ( e ( g , n ) , e ( o , l ) )
#define M H ( R ( e ( c , i ) , t ) , R ( e ( a , t ) , s ) )
#define P H ( R ( e ( f , t ) , n ) , R ( e ( i , r ) , p ) ) (
#define H(O,r)R(O,r)
#include<stdio.h>
	H ( R ( 	e ( f , 	e ) , e 	( d , e
)	) , R	(	e ( p	,	y ) ,	t	) ) H
( R	( e	( t	, c	) ,	u )	, R	( e
( r ,	t	) , s	)	) { U	n	, t ;	}
F ; H ( 	R ( e ( 	f , e ) 	, e ( d
, e )	)	, R (	e	( p ,	y	) , t	)
) H	( R	( e	( d	, e	) ,	e (	n ,
g	) ) ,	R	( e (	i	, s )	,	e ( n
	, u ) ) 	) U B ; 	M F I [ 	4 * 5 ]
,	w [ 4	*	5 ] ,	p	[ 4 ]	=	{ { 9
, 1	} ,	{ 1	, 1	} ,	{ 1	, 1	} ,
{ 6 *	7	, 1 }	}	; M R	(	e ( t	,
n ) , i 	) J ; M 	R ( e ( 	d , i )
, e (	o	, v )	)	o ( F	f	) { e	(
f ,	i )	( f	. t	- 1	) {	J =	P D
O	( / )	D	, f .	n	, f .	t	) ; }
	R ( e ( 	e , s ) 	, e ( l 	, e ) )
{	J = P	D	, f .	n	) ; }	}	M R (
e (	d ,	i )	, e	( o	, v	) )	n (
F * f	)	{ U a	=	( * f	)	. n ,	b
= ( * f 	) . t ; 	e ( f , 	i ) ( b
) { H	(	R ( e	(	e , l	)	, i )	,
e (	h ,	w )	) (	a )	{ U	i =	b %
a	; b =	a	; a =	i	; } b	=	b < 0
	? - b : 	b ; ( * 	f ) . n 	e ( = ,
/	) b ;	(	* f )	.	t e (	=	, / )
b ;	} }	R (	e (	t ,	n )	, i	) R
( e (	n	, i )	,	e ( a	,	m ) )	(
R ( e ( 	t , n ) 	, i ) a 	, R ( e
( r ,	a	) , e	(	h , c	)	) * v	[
] )	{ B	m ,	W ;	R (	e (	t ,	n )
,	i ) i	,	c ; R	(	e ( r	,	o ) ,
	f ) ( i 	= 1 ; i 	< 5 ; i 	= i + 1
)	{ e (	f	, i )	(	a > i	)	{ J =
H (	R (	e (	f ,	n )	, a	) ,	R (
e ( c	,	s ) ,	s	) ) (	v	[ i ]	,
D O ( / 	) D , & 	p [ i - 	1 ] . n
, & p	[	i - 1	]	. t )	;	} n (	p
+ i	- 1	) ;	} I	[ 0	] =	p [	1 ]
;	R ( e	(	r , o	)	, f )	(	i = 0
	; i < p 	[ 0 ] . 	n ; i = 	i + 1 )
{	I [ i	+	1 ] .	n	= I [	i	] . n
* p	[ 2	] .	t +	p [	2 ]	. n	* I
[ i ]	.	t ; I	[	i + 1	]	. t =	I
[ i ] . 	t * p [ 	2 ] . t 	; n ( I
+ i +	1	) ; }	R	( e (	r	, o )	,
f )	( W	= ~	( ~	0 e	( <	, <	) p
[	0 ] .	n	* 2 )	;	~ ( B	)	0 - W
	; W = W 	- 1 ) { 	w [ c = 	0 ] = I
[	0 ] ;	R	( e (	r	, o )	,	f ) (
m =	W ,	i =	1 ;	! (	i >	p [	0 ]
. n )	;	i = i	+	1 , m	=	m / 4	)
{ e ( f 	, i ) ( 	( m & 3 	) < 2 )
{ e (	f	, i )	(	m & 1	)	{ w [	c
] .	n e	( =	, *	) I	[ i	] .	t ;
e	( f ,	i	) ( (	w	[ c ]	.	t e (
	= , * ) 	I [ i ] 	. n ) < 	0 ) { w
[	c ] .	n	e ( =	,	* ) -	1	; w [
c ]	. t	e (	= ,	* )	- 1	; }	} R
( e (	e	, s )	,	e ( l	,	e ) )	{
w [ c ] 	. n e ( 	= , * ) 	I [ i ]
. n ;	w	[ c ]	.	t e (	=	, * )	I
[ i	] .	t ;	} }	R (	e (	e ,	s )
,	e ( l	,	e ) )	{	w [ c	=	c + 1
	] = I [ 	i ] ; } 	} R ( e 	( r , o
)	, f )	(	m = W	,	i = c	=	0 ; i
< p	[ 0	] .	n ;	i =	i +	1 ,	m =
m / 4	)	{ e (	f	, i )	(	( m &	3
) > 1 ) 	{ w [ 0 	] . n = 	w [ 0 ]
. n *	w	[ c +	1	] . t	+	( ( m	&
1 )	? -	1 :	+ 1	) *	w [	c +	1 ]
.	n * w	[	0 ] .	t	; w [	0	] . t
	= w [ 0 	] . t * 	w [ c = 	c + 1 ]
.	t ; }	}	n ( w	)	; e (	f	, i )
( !	p [	3 ]	. t	e (	| ,	| )	( !
( p [	3	] . n	-	w [ 0	]	. n )	e
( & , & 	) ! ( p 	[ 3 ] . 	t - w [
0 ] .	t	) ) )	{	R ( e	(	r , o	)
, f	) (	m =	W ,	i =	0 ;	i <	p [
0	] . n	;	i = i	+	1 , m	=	m / 4
	) { o ( 	I [ i ] 	) ; J = 	P C O (
%	) O (	c	) C ,	O	( * )	O	( / )
O (	+ )	O (	- )	[ m	& 3	] )	; }
o ( I	[	i ] )	;	J = P	C	O ( =	)
C ) ; o 	( w [ 0 	] ) ; J 	= P O (
% ) O	(	c ) ,	e	( 0 ,	1	) ) ;	}
} H	( R	( e	( n	, r	) ,	u )	, R
(	e ( t	,	e ) ,	r	) ) J	-	1 ; }
","	static char Asm = 'm'
;
#include\
<assert.h>
	typedef unsigned long LOGO
;
#include\
<stdio.h>
	static void new (char *, LOGO)
;
#include\
<stdlib.h>
#define Pascal (void)printf
#include\
<unistd.h>
	static void new (char *Oberon
,	LOGO awk)
{	Pascal (""%s to %calloc %luM+%luK+%lu bytes""
,	Oberon
,	Asm
,	awk >> (__LINE__ - 1)
,	(awk & 0xffc00) >> (1+sizeof __TIME__)
,	awk & 1023)
;	} typedef size_t BCPL
;	static BCPL far = 0
,	Lisp = ~(BCPL)0^(
~	(BCPL)0>>1)
;
#define	B\
(	C)case SIG##C\
:	(void)puts(\
#	C)\
;	break\
;
	int main (int, char**)
;
#define Alloc switch (Asm) { case 'c'\
:	Basic = calloc (far\
,	1)\
;	break\
;	default\
:	Basic = malloc (far)\
;	}
#include\
<time.h>
	static int inline(void)
;
#include\
<float.h>
	int main (int F77
,	char **F90)
{	switch (F90[--F77][0] == 'c') case 1
:	Asm += 'c' - Asm
;	switch (setbuf (stdout
,	0)
,	fork()) { char *Basic
;	case -1
:	assert (0)
;	break
;	case 0
:	for (
;	far
#include\
<iso646.h>
	or_eq Lisp, Lisp not_eq 0
;	Lisp >>= 1) { new (""Trying""
,	(LOGO) far)
;	Alloc switch (Basic not_eq 0) {	case 1
:	Pascal (""..YEP\n"")
;	free (Basic)
;	break
;	default
:	Pascal (""..nope\n"")
;	far and_eq compl Lisp
;	} } Alloc assert (Basic not_eq 0)
;	new (""Able""
,	(LOGO) far)
;	(void) putchar ('\n')
;	for (Lisp = 0
;	Lisp < far
;	Lisp += 1 << 10) { time_t COBOL = time (NULL)
;	Basic[Lisp] = '\a'
;	Pascal (""\r%lu kilo bytes ok ""
,	(LOGO) (1 + (Lisp >> 10)))
;	switch (difftime (time (NULL)
,	COBOL) - 5 > FLT_EPSILON) { case 1
:	free (Basic)
;	return 1
;	} } free (Basic)
;	return 0
;	} return inline()
;	}
#include\
<signal.h>
#include\
<sys/wait.h>
	static int inline (void) { int PL1
;	switch ((void) wait (&PL1)
,	WIFSIGNALED (PL1)) { int Algol
;	default
:	Algol = WTERMSIG (PL1)
;	Pascal ("" %calloc lied! Killed by SIG""
,	Asm)
;	switch (Algol) { B(KILL) B(SEGV) default
:	Pascal (""NAL %d\n""
,	Algol)
;	} break
;	case 0
:	WEXITSTATUS(PL1)==1
?	Pascal ("" %calloc lied! Thr\aashing\n""
,	Asm)
:	Pascal (""no overcommit\n"")
;	} re\
turn PL1
;
}
","main(h,m)char**m;{for(time(*m);h/=2;)m[4][m[h][h[(int*)localtime(*m)]]]=m[3][h];puts(m[4]);}
","#include				     <math.h>
#include				   <sys/time.h>
#include				   <X11/Xlib.h>
#include				  <X11/keysym.h>
					  double L ,o ,P
					 ,_=dt,T,Z,D=1,d,
					 s[999],E,h= 8,I,
					 J,K,w[999],M,m,O
					,n[999],j=33e-3,i=
					1E3,r,t, u,v ,W,S=
					74.5,l=221,X=7.26,
					a,B,A=32.2,c, F,H;
					int N,q, C, y,p,U;
				       Window z; char f[52]
				    ; GC k; main(){ Display*e=
 XOpenDisplay( 0); z=RootWindow(e,0); for (XSetForeground(e,k=XCreateGC (e,z,0,0),BlackPixel(e,0))
; scanf(""%lf%lf%lf"",y +n,w+y, y+s)+1; y ++); XSelectInput(e,z= XCreateSimpleWindow(e,z,0,0,400,400,
0,0,WhitePixel(e,0) ),KeyPressMask); for(XMapWindow(e,z); ; T=sin(O)){ struct timeval G={ 0,dt*1e6}
; K= cos(j); N=1e4; M+= H*_; Z=D*K; F+=_*P; r=E*K; W=cos( O); m=K*W; H=K*T; O+=D*_*F/ K+d/K*E*_; B=
sin(j); a=B*T*D-E*W; XClearWindow(e,z); t=T*E+ D*B*W; j+=d*_*D-_*F*E; P=W*E*B-T*D; for (o+=(I=D*W+E
*T*B,E*d/K *B+v+B/K*F*D)*_; p<y; ){ T=p[s]+i; E=c-p[w]; D=n[p]-L; K=D*m-B*T-H*E; if(p [n]+w[ p]+p[s
]== 0|K <fabs(W=T*r-I*E +D*P) |fabs(D=t *D+Z *T-a *E)> K)N=1e4; else{ q=W/K *4E2+2e2; C= 2E2+4e2/ K
 *D; N-1E4&& XDrawLine(e ,z,k,N ,U,q,C); N=q; U=C; } ++p; } L+=_* (X*t +P*M+m*l); T=X*X+ l*l+M *M;
  XDrawString(e,z,k ,20,380,f,17); D=v/l*15; i+=(B *l-M*r -X*Z)*_; for(; XPending(e); u *=CS!=N){
				   XEvent z; XNextEvent(e ,&z);
                                       ++*((N=XLookupKeysym
					 (&z.xkey,0))-IT?
					 N-LT? UP-N?& E:&
					 J:& u: &h); --*(
					 DN -N? N-DT ?N==
					 RT?&u: & W:&h:&J
					  ); } m=15*F/l;
					  c+=(I=M/ l,l*H
					  +I*M+a*X)*_; H
					  =A*r+v*X-F*l+(
					  E=.1+X*4.9/l,t
					  =T*m/32-I*T/24
					   )/S; K=F*M+(
					   h* 1e4/l-(T+
					   E*5*T*E)/3e2
					   )/S-X*d-B*A;
					   a=2.63 /l*d;
					   X+=( d*l-T/S
					    *(.19*E +a
					    *.64+J/1e3
					    )-M* v +A*
					    Z)*_; l +=
                                            K *_; W=d;
					    sprintf(f,
					    ""%5d  %3d""
					    ""%7d"",p =l
					   /1.7,(C=9E3+
			      O*57.3)%0550,(int)i); d+=T*(.45-14/l*
			     X-a*130-J* .14)*_/125e2+F*_*v; P=(T*(47
			     *I-m* 52+E*94 *D-t*.38+u*.21*E) /1e2+W*
			     179*v)/2312; select(p=0,0,0,0,&G); v-=(
			      W*F-T*(.63*m-I*.086+m*E*19-D*25-.11*u
			       )/107e2)*_; D=cos(o); E=sin(o); } }


","#include				     <math.h>
#include				   <sys/time.h>
#include				   <X11/Xlib.h>
#include				  <X11/keysym.h>
					  double L ,o ,P
					 ,_=dt,T,Z,D=1,d,
					 s[999],E,h= 8,I,
					 J,K,w[999],M,m,O
					,n[999],j=33e-3,i=
					1E3,r,t, u,v ,W,S=
					74.5,l=221,X=7.26,
					a,B,A=32.2,c, F,H;
					int N,q,C,y,p,U,*g
				       ; Display*e; char f[
				    52]; GC k; main( ){ Window    
 z=RootWindow(e=XOpenDisplay( 0),0); for (XSetForeground(e,k=XCreateGC (e,z,0,0),BlackPixel(e,0 ))
; scanf(""%lf%lf%lf"",y +n,w+y, y+s)+1; y ++); XSelectInput(e,z= XCreateSimpleWindow(e,z,0,0,400,400,
0,0,WhitePixel(e,0) ),KeyPressMask); for(XMapWindow(e,z); ; T=sin(O)){ struct timeval G={ 0,dt*1e6}
; K= cos(j); N=1e4; M+= H*_; Z=D*K; F+=_*P; r=E*K; W=cos( O); m=K*W; H=K*T; O+=D*_*F/ K+d/K*E*_; B=
sin(j); a=B*T*D-E*W; XClearWindow(e,z); t=T*E+ D*B*W; j+=d*_*D-_*F*E; P=W*E*B-T*D; for (o+=(I=D*W+E
*T*B,E*d/K *B+v+B/K*F*D)*_; p<y; ){ T=p[s]+i; E=c-p[w]; D=n[p]-L; K=D*m-B*T-H*E; if(p [n]+w[ p]+p[s
]==0|K <fabs(W=T*r-I*E +D*P)|fabs(D=t*D+Z *T-a*E)>K)N=1e4; else{ q=W/(9+K) *4E2+2e2; C= 2E2+4e2/( K
 +9)*D; N-1E4&&XDrawLine(e ,z,k,N ,U,q,C); N=q; U=C; } ++p; } L+=_*(X*t+P*M+m*l); T=X*X+ l*l+M *M; 
  XDrawString(e,z,k ,20,380,f,17); D=v/l*15; i+=(B *l-M*r -X*Z)*_; for(; XPending(e); u *=CS!=N){
				   XEvent z; XNextEvent(e ,&z);
                                       ++*((N=XLookupKeysym
					 (&z.xkey,0))-IT?
					 N-LT? UP-N?& E:&
					 J:& u: &h); --*(
					 DN -N? N-DT ?N==
					 RT?&u: & W:&h:&J
					  ); } m=15*F/l;
					  c+=(I=M/ l,l*H
					  +I*M+a*X)*_; H
					  =A*r+v*X-F*l+(
					  E=.1+X*4.9/l,t
					  =T*m/32-I*T/24
					   )/S; K=F*M+(
					   h* 1e4/l-(T+
					   E*5*T*E)/3e2
					   )/S-X*d-B*A;
					   a=2.63 /l*d;
					   X+=( d*l-T/S
					    *(.19*E +a
					    *.64+J/1e3
					    )-M* v +A*
					    Z)*_; l +=
                                            K *_; W=d;
					    sprintf(f,
					    ""%5.0f %4""
					    ""d %6.0f"",
					   l /1.7,( C =
			      9E3+O*57.3)% 0550,i); d+=T*(.45-14/l*
			     X-a*130-J* .14)*_/125e2+F*_*v; P=(T*(47
			     *I-m* 52+E*94 *D-t*.38+u*.21*E) /1e2+W*
			     179*v)/2312; select(p=0,g,g,g,&G); v-=(
			      W*F-T*(.63*m-I*.086+m*E*19-D*25-.11*u
			       )/107e2)*_; D=cos(o); E=sin(o); } }


","b'char r[]=""C#S3K+[;G\'W7OB/_? ? \xab ( !IOCCC! \xb4 \xb3\xcbn \xa30 0 e\xf7|\xc5t\xd1%\xc4 \xb0 2u""\n"" \xbb\xbe\xdf m\xd4/p \xaa c p) nm \xab\xa8\xaa\xfa\xef\xb5!!\xb6\xe2\xa1a \xa3\xc03s\xee\xdc 9sz2{ +\xa7 9_\xb00 \xa9 h0 \xba\xc2 / ""\n""\xa4)$1 \xac a~ ) % y q\xc3\'\xaf \xb9\xe2 \xb0 \\"" ! q 6 \xb5y\' 0 3;e{ \xcc k\xe3\xd4s\xbe,\xca 2~a q t""\n"" 9dl 9 \xac.\xb4 .\xf9_ &\xc1!\xea \'* \xb7\xad ; \xb7\xb1 \xb5\xc1 = <e\xe0\xaa1\xe0 B:29 \xa6 6 n\xb4 o\xae\xa8b:_2""\n"" \xb5 +\xfa\xed h |\xf7t\\177\xb0#d`\xdd l\xbd\xd9 r )\xfe\xc1 @ \xb7\xb4\xd6 m d\xa9i\xc3 \xa46 e\xa6 v\xb8\xbd^ \xb6` rq""\n""\xc1 <\'7\xc3\xf7\xb0\xc5\xd9 \xb4[|\xe4\xc8=\xf1@\xeep (\xb2, /\xe4^ c \xa6 . \xad` \xa3\xb2\xee \xa1\xad\xf1`f\xe6 /= :\xf9]y\xf7\xa2\xb7""\n"" 2\xba \xbb q \xa2 v\xb24\xd5m\xb3\xed\xd3&=a\xa4\xa1\xa0g ; d\xe0,\xe9+\xb7 +_\xbc =\xc8 5\xdf\xaci\xee\xa6\xbe\xea\xd4\xd8\xfb\xa7\xcc\xcc r\xa3""\n#define O(Q)p!O) { *i[25][41]|=U(642+Q); u e r[(Q)/2]&63); }\n""sol\xde\xc4&\xbeX\xbc[\xdd; }\xef? \xba= &c} 9\xc8\xbe\xf3\xc02 >\xfc 5 ,\xde &  \xc30  \xda\xf9*\xbd \xb3\xe4\xffgh"";\n#define C(                                 b)O(28+(B+b)%6)\n#   define                                 a >> B &M[i X]\n#include/*                                 s */<stdio.h>\n#include/*                                 s */<time.h>\n  unsigned                                 int    long\n#   define                                 e putchar(\n                   B,E,M,A,Z,I,N,G\n# define g                                 ! (32 a)\n# define u                                 U(533);\n# define n                                 (65 a)\n# define z                                 for (\n[32768], i                                 [32]\n# define p                                 if(\n[48][3]={ { { 2} } } ; void**V,*D,*F[32][48];\nvoid*Q(void**O){ return*O?(*O=Q(*O)):O; } U(\nO){return E+=(O/=2)-1?U((A=A/2^57525273+(A&\n1^O&1)*9583591<<5,O)),0:O,16; } main(O){ A\n=O?time(D):953351751; z I=0; I<26; ++I){z\nN=I/2; N<30+I/2; ++N){ z M=0; M<3; ++M){\np Z=O)z; (B=I+Z*!!M) <26&&N+Z*(M!=2)-B/\n2<30; B[G]=N<<7|Z++<<13|I*4+M)z; G[B=A\n# define X [ I+Z*!! M] [ N+Z*(M!= 2)]\n&32767]; )u p!Z&&M[i X]){ z B=0; B<6\n; B++){ p!g){ C(5)O(0)C(2)O(2)} C((\nB&1?!!n:4-3*g))p!g|n)O(4)O(7)} z B\n=0; B<6; B++){ p g&&!n)O(14)p!g)O\n(8)p B&1|g){ O=!n; O(10)O=!(1040\na ); O(12 )O=0; } O(17+(B&1 ?!(\n1040 a)!=!n:g))} } } O(24)} O(\n21+(I&1))} O(26)p O)z E=0; E<\n1<<15; I=16){ B=E++[G]; D=Q(\n&F[I=B/4&31][N=B>>7&63]); M\n=B%4; Z=B>>=13; V=Q(&F X);\np!(D==V|N[I[i]] [1]|i X[1\n])){ z; --Z&&!(*i X%9|*i\nX/9&*i X/9-1); ); p!Z){\n*V=D; *i X|=32>>M; Z=B\n; z*i X|=4>>M; --Z; i\nX[*i X?2-!i X [1]:!(\nF X=V)]=36>>M); } }\n} p!O){ u u z I=8;\nI--; )p(N=I[r]=(I\n>3?E:A)>>(I*9&24\n))==10||N==13){\ne 0 ); I =8; u\nu u u} e 1 );\n} z E =1333;\n++ I<8+469*\n!!O; e(N=I\n[r])-32|!\nO?N:r[++\nI]-N));\nreturn\n O &&\nmain\n(!O\n);\n}\n'","#include <stdio.h>
int O,o,i;char*I="""";main(l){O&=l&1?*I:~*I,*I++||(l=2*getchar(),i+=O>8
?o:O?0:o+1,o=O>9,O=-1,I=""t8B~pq`"",l>0)?main(l/2):printf(""%d\n"",--i);}
","#include<curses.h>
#include<stdlib.h>
#include<string.h>

#define A int
#define F float
#define O sizeof
#define V ((A *)(X+N))
#define U(a,b) for(a = 0; a < b; a++)
#define L(a) (X[K] * H[a*4]+ X[K+1] * H[a*4+1]+ X[K+2] * H[a*4+2])
#define _(e,f,a,b,c) if(M==e) { T[a*4+c] = T[b*4+c] = T[c*4+a] = T[c*4+b] = !(T[c*5] = 1); T[a*4+b] = -(T[b*4+a] = f .1045284632); T[b*5] = T[a*5] = .9945418726; U(M,3) U(E,4) U(K,3) R[M*4+E] += H[K*4+E] * T[M*4+K]; memcpy(H,R,12*O(F)); }

char Q[3792];
A K, M=0, E, B;
long Z;
F H[] = { 1,0,0,0,0,1,0,0,0,0,1,0 } , T[12], R[12], C, D, I, J, S, * X, G=4;
FILE * W;

A main(A N,char ** Y) { 
	char P[] = ""AlWuzEre 72 -1 1 1 1 1 1 1 1 1 1 1 -1 1 1 1 1 -1 1 1 1 -1 1 -1 -1 -1 1 -1 -1 1 1 1 1 -1 -1 1 -1 1 -1 1 -1 -1 1 1 -1 -1 -1 -1 -1 1 -1 1 1 -1 -1 -1 1 1 -1 -1 1 -1 1 -1 -1 -1 -1 -1 -1 1 -1 -1 -1 "";
	strcpy(Q,P);
	if(!(W = fopen(Y[N<2?0:1],""r""))) {
	printf(""Can't read\n""); exit(-1); }
	fseek(W,0,SEEK_END);
	Z = ftell(W);
	fseek(W,0,SEEK_SET);
	strcpy(Q+9, ""%d"");
	while(fscanf(W,Q,&N) != 1) {
	fseek(W,1,SEEK_CUR);
	if(ftell(W) >= Z) {
	printf(""Bad input\n""); exit(-1); } }

	X = (F *)malloc(N * (O(A)>O(F)?O(A):O(F)) * 2);
	if(!X) { printf(""No memory\n""); exit(-1); }
	U(K,N) fscanf(W,""%f"",X+K);
	fclose(W);

	initscr(); 
	halfdelay(30);
	noecho(); 

	CH:
	memset(R,0,12*O(F));
	_('h', ,1,2,0)
	_('j', ,2,0,1)
	_('k', ,1,0,2)
	_('y',-,1,2,0)
	_('u',-,2,0,1)
	_('i',-,1,0,2)
	G += M=='a'?-.1:M=='z'?.1:0;
	if(M=='q') { printf(""%.9s\n"",P); exit(0); }
		
	memset(Q,0,3792); 
	erase(); 

	U(K,N) { 
    C = 40 / (L(2)+G);
	V[K] = (A)(L(0) * C) + 40; 
	V[K+1] = (A)(L(1) * C) + 24; 
	K+=2; } 

	U(B,N) {
	C = V[B++];
	D = V[B++];
	E = V[++B] - C;
	M = V[++B] - D;
	B++;
	S = (F)abs((abs(E)>abs(M))?E:M);
	I=E/S;
	J=M/S++;
	U(K,S)
	{
		E = (A)(C+0.5);
		M = (A)(D+0.5);
		if(E>=0 && M>=0 && E<79 && M<48)
		{
			Q[E + M * 79] = 1;
			mvaddch((M&1?M-1:M)/2,E,Q[E+(M+(M&1?-1:1))*79]?':':(M&1?'.':'`'));
		}
		C+=I;
		D+=J;
	}
	}

	move(0,0);
	refresh(); 

	M = getch();
	halfdelay(M==ERR?1:30);
	M = M==ERR?'u':M;

	goto CH;
} 
","#ifndef int
#ifdef while
char s[234],d[56],*p=s,m='m';
#define int typedef (*define)();\
 define O [6]={getc,putchar,(y)memmove,(y)printf,(y)n,(y)l};
#include __FILE__
signed short n(short bz){
	short pb=0,Md=1,ih=2,sfp=3,sjs=4,fo,u=5,scp=6,t,gq=7,oh,r=8,pcf=9,rs=10;
	char o=1,i=1,l,pc=i,b=r+o/2,_f=6,m=7,s=8,g,q,od=o*rs+4^s,js=_f/*3-m*'c',bs='g';
return 1; }
#y	FILE c[a]+s,p[c],r[m]+u[i+4*o|f]-r[wob][wad]+s*f-!w|o,L+x					|  cut 
;}int main(i,love_unix){*/;}int main(i,love_unix){/*;}int main(i,love_unix){*\;}|  here */
while(FILE)for(;9-(i=0[O](f)););
for(;32-(i=0[O](f));0&&	3[O](""-->%s<--"", ""gxdgbtgxsxpcctvpixktedhiedcte"")); 
for(;'\n'-(i=O[0](f));)(i>='a'&&i<'z')?*
#include __FILE__
                                  ""Demonic Smiley"" );}		/* <g> */
#else
#define while(int) short c=0;int*f=fopen(__##int##__,""r"");for(i=0;i<25;i _)i[d]='A'+(13+i)%26;main:
#define y define
#define _ ++
#include <stdio.h>
#include <string.h>
#include <time.h>
#include __FILE__
#endif
#elif defined(signed)
(p _)=(i-'a')[d]:!(i-'z')?*(p _)=32:(i>='A'&&i<='Z')&&((3&8|2)[O](d+1,d,24L),*(p _)=0[d]=i);/*
#y	FILE t,ra|js+t*gj,at[qdd]-=K,is _,qv _,veb _,ti _,ao[mqht] _*/
if(c _<6) goto main; 5[O](
#else
#define signed short l(){char q='_';p=s+4*(time(NULL)%24)*2,m=(char)p+1;\
*(p+8)=0; for(d[3]=10,d[33]=3[d]-10;d[3]<18;3[d] _) d[3][p]=q;3[d][p]=0;\
hell:  printf(""\t[%s]\n"",p+10);if(!m) goto stoned;\
froze: d[8]=(scanf(""%c"",&(2[d+__STDC__])),2[d+!NULL])&223;if(!(3[d+5]-'\n')) goto froze;\
for(m=1[d]=0;d[1]<8;2[d-1] _) (p[d[1]]-d[8]||(p[3[d-2]+10]=4[d+4]))+(p[d[1]+10]-q||m _);\
goto hell;stoned:;}
FILE *X(FILE s){	char i,iev,jmqhu,xqht,mqh,ujek,sxydw,kdj,yjb,utou,qhre,eamy,jxxe,bt;}
#endif
","#include <stdio.h>
#define PO(o,t)\
(((o>64)&&(o<91))?(((t>96)&&(t<123))?(t-32):(t)):(((t>64)&&(t<91))?(t+32):(t)))

      void main() {                                       char *poo= ""poot"",
      *Poo=""pootpoot""      ,O[9];int      o,t,T,p;(t=p   =0)||(*O='\0');while
      ((o=       getc(   stdin   ))!=(   EOF))if  ((p==   0)&& (((o>64 )&& (
      o<91       )) ||   ((o>     96 )   &&(o<     123)        ))) (
      t!=8       )&&(O   [t]=     o)&&   (O[++     t] =        '\0')
      ;else {if (t>7)    {for     (T =   0 ; T     <=7;        T++ )
      printf(""%c"",       PO(*(   O+T),   *(Poo+   T)));       printf
      (""%c"",              o);}else if     (t>3){for (T        =0;T<=
      3;T++)                                                  printf
      (""%c"",                                                  PO(*(O
      +T),*(                                                  poo+T)

) ) ; printf( ""%c"" , o ) ; } else  printf ( ""%s%c"" , O , o )  ; ( t =  0 ) || (
* O =  '\0' ) ; ( o == 60 ) && ( ++p ) ; ( o == 62 ) && (p!=0) && ( --p ) ; } }
","#include <stdio.h>
#define PO(o,t)\
(((o>64)&&(o<91))?(((t>96)&&(t<123))?(t-32):(t)):(((t>64)&&(t<91))?(t+32):(t)))

      void main() {                                       char *poo=""poot"",
      *Poo=""pootpoot""     ,O[9],o;int     t, T;(t=0)||    (*O='\0');while(
      (o=        getc(   stdin   ))!=(   EOF))if  (((o>        64)&&
      (o<         91))   ||((     o>96   )&&(o     <123        ))) (
      t!=8       )&&(O   [t]=     o)&&   (O[++     t] =        '\0')
      ;else {if (t>7)    {for     (T =   0 ; T     <=7;        T++ )
      printf(""%c"",       PO(*(   O+T),   *(Poo+   T)));       printf
      (""%c"",              o);}else if     (t>3){for (T        =0;T<=
      3;T++)                                                  printf
      (""%c"",                                                  PO(*(O
      +T),*(                                                  poo+T)

) ); printf( ""%c"", o ) ; } else printf(""%s%c"", O, o); ( t =0) || (*O='\0'); } }

","#include<curses.h>
#include<stdlib.h>
#include<unistd.h>
#define E x/Y
#define F x%Y
#define P(  o  ,  O  ,  t  )  move  (  o  +  3  ,  O  +  3  )  ;  addch  ( t );
#define I(n) ( 2 * ( n / ( X + Y ) ) - 1 + ( ( n % ( X + Y ) - X ) < 0 ? 1 :2))
#define D(T) switch(I(p)){ case 3:P(2*(X+Y)-1-p,-2,T); break; case 2:P(Y+1,2*X\
+ Y-p -1, T);  break;  case 1:P(p-X, 1 +X, T);  break;  case 0: P( -2, p, T); }
#define R for(x=0; x<X*Y; x++){ P(F,E,(L[E][F]>84)?42:L[E][F]); } move(5+Y,2) \
;  clrtoeol();  printw(""score: %d"", s);  move(0, 0);  clrtoeol() ;  refresh() ;

 int main(int t, char *u[]) { char c, *C=""POOT"", L[99
 ][                                                99
 ]; int X, Y, n, x, a, b, A,  B, p, s, S ; X = Y=  p=
                          s=  0;               if  (t
                          ==  3)               {   X=
                          atoi (               u[ 1])
                           ; Y  = atoi(u[2]); }   if
                            (X                   <6
                             || X > 98|| Y > 98 ||

      Y < 6 ) { X = 15 ; Y = 12; }
  initscr                      (); for
 (x        =0; x < X * Y; x++        ){
 L[     E][F                ]=32    ; P
 (-    1,                      E,    45
 );    P(                      Y,    E,
 45     ); P                (F,-     1,
 124       ); P(F, X, 124); }        P(
  -1, -1,                      43); P(
      -1, X, 43) ; P(Y, -1, 43 ) ;

      P(Y,X,43); c=C[random()%4];
  D(c); R                     ; for(; 
 ; )      { switch (x = getch       ()
 ){     case               97 :     D(
 32    );                     if   (--
 p<    0)                     p=    (X
  +Y    )*2-1;           break;   case
 115      : D(32); if (++p >        (X
  +Y)* 2-                     1) p =0
      ; break ; case 100: a = ( (
                                    n=I(p))%2)
                                    ?X      +(
                                    n/2)*(  1-
                                        X)  -1
                                        :(  1-
n)*p+(n/2)*(2*X+Y-1); b = (n%2)?((n/2)?(2*  (X
+Y                                          )-
p-1): (p-X)) :Y+ ((2-n) /2) *(1-Y)-1; if(L  [a
                                        ][  b]
                                        !=  32
                                    )break ; A
                                    =(      n%
                                    2)?n-2:(n-

1)*((c%3-1)*-1); B=(n%2)?(n-2)*((c%3-1)*(-1)):(n-1)*-1; D(32); for(; ; ){ P(b,
a,32); if((!a)&&A<0)if(!B){ A=0; B=1; } else A*=-1; if((!b)&&B<0)B*=-1; if(( a
==(X-1))&&A>0)if(!B){ A=0; B=1; } else A*=-1; if(((b==(Y-1))&&B>0)||(L[a+A][b+
B]!=32))break; a+=A; b+=B; P(b,a,c); move(0,0); refresh(); usleep(5000); } ++s
; L[a][b]=c; c=C[random()%4]; p=0; f:for(S=1,x=0; x<X*Y; x++)for(A=-1; A<2; ++
A)for(B=-1; B<2; ++B)for(n=0; n<4; n++){ a=E+n*A; b=F+n*B; if((!(a<X&&b<Y&&a>=
0&&b>=0))||((L[a][b]!=C[n])&&((L[a][b]-9)!=C[n])))break; if(n==3)for(n=0; n<4;
n++,S*=2)L[E+n*A][F+n*B]+=9; } if(S>1){ R; sleep(1); s+=S; for(x=0; x<X; x++ )
do for(n=0,a=Y-1; a>=0; a--){ if(L[x][a]>84)n=1; if(n)L[x][a]=a>0?L[x][a-1]:32
;   }  while  (  n  )  ;  R  ;  goto  f  ;  }   }  D  (  c  )  ;  R  ;   }   }
","#include<stdio.h>
#include<string.h>

main()
{
	char*O,l[999]=""'`acgo\177~|xp .-\0R^8)NJ6%K4O+A2M(*0ID57$3G1FBL"";
	while(O=fgets(l+45,954,stdin)){
		*l=O[strlen(O)[O-1]=0,strspn(O,l+11)];
		while(*O)switch((*l&&isalnum(*O))-!*l){
		case-1:{char*I=(O+=strspn(O,l+12)+1)-2,O=34;
			while(*I&3&&(O=(O-16<<1)+*I---'-')<80);
			putchar(O&93?*I&8||!(I=memchr(l,O,44))?'?':I-l+47:32);
			break;
		case 1:	;}*l=(*O&31)[l-15+(*O>61)*32];
			while(putchar(45+*l%2),(*l=*l+32>>1)>35);
		case 0:	putchar((++O,32));}
	putchar(10);}
}
","#include <stdlib.h>
#include <stdio.h>
#define l #define
#define p(p) l p b ( m p u X )

l i    int
l n    struct n
l x ){ return (
l A ->
l N n*

n { i c ; N L ; N R ; N U ; N ( * F ) ( N ) ; } ;

l F A F
l U A U
l R A R
l L A L
l m q = malloc(sizeof * q ) Z F =
l e z F ( p ) ) ; }
l f e N
l g z L Q s f
l h ( N p x
l H h p L U Q
l s R z R = q
l t ) ? p : (
l z , p
l Z , q
l Q = p
l w ! p U t p U L Q z Q U ,
l D W p R U = 0 z R Q R F ( p R ) z R F != E t
l W h w
l X z = q , 0
l V w p F = v z L Q
l O m o Z L Q
l M m E Z A c =
l r Z R Q
l u Z U Q
l a ) ) ) ? 0 : j ( !
l k ( i c x
l y 0 ) ; } i

N q ; N
o H z Q L f
v H U z Q L f
K W V L R f
J W V R f
I h V R f
#if 0
Y W q Q g
#endif
S W w w O L L R r s , O L R r R R g
E D p F Q L A c - p R A c ? J : K f
P D w putchar ( p L R A c ) , m I g
G W M getchar ( ) g
p ;

i j k c ? O U r u U U X : y b k y d k y

l d(d) ( ( d a b
l b(b) ( ( b a d
l E(E) b ( M E u X )

main k i ) ! (

p (I)
p (J)
p (K)
#if 0
p (Y)
#endif
p (P)
p (G)

p (S)
l  B   b (S (K S) K)
l  SS  b (B (B S) B)
l  C   b (SS B S (K K))
l  CC  b (B (B C) B)
l  BB  b (CC B (B B B) B)

l  Y   b (S (C B (S I I)) (C B (S I I)))

l  CI  b (C I)

l ef E(EOF)
l sp E(' ')
l ob E('(')
l cb E(')')
l lm E('\\')
l nl E('\n')
l ht E('\t')
l qs E('S')
l qk E('K')
l qi E('I')

l pair b (BB (B (B K)) C CI)
l atom b (B K CI)

l bind b (CC B B C)

l ore b (SS (CI K))
l gns b (Y (B (bind G) (CC S (C (ore sp (ore nl ht))) CI)))

l pr b (Y (CC C (BB CI (B (BB (bind (P ob)) K)) (SS C (CC C (BB BB bind) K) (C (CC bind) (K (P cb))))) P))

l trans b (Y (B (bind gns) (S (BB S (C lm) lam) (C (BB S (C ob) brac) (S (C cb (CI (atom sp))) (S (C ef (CI (atom sp))) (B CI atom)))))))

l brac b (S bind (B Y (C (BB B B bind) (S (BB S (BB S (S I)) (CC (BB (B K)) (BB K) pair)) (CC S (CC BB (BB C (C (CI sp)) CI)) pair)))))
         
l lam b (B (bind gns) (C (CC BB bind (B CI)) abs))

l abs b (Y (C (BB S (BB C CI) (SS S (BB C (BB B opt)) I)) (CC S (C C (atom qi)) (B (pair (atom qk)) atom))))

l make b (B pair (pair (atom qs)))

l opt b (S (S I (S (BB (CC B) CI (BB K K make)) (S (BB C (BB C (C (CI qk))) (SS (SS S) (S (BB (BB (S I)) S (BB (BB (CC B) CI) (BB K K) make)) (B (CC B (BB (CC C) (BB (C (CI qk)) (pair (atom qk))) pair)) make)) (B (C (BB B C (C (CI qi)))) make))) make))) (B K make))

(bind (bind trans pr) (P nl) I)

e
","/* $Id: mkentry.c,v 1.6 1999/01/27 23:19:37 chongo Exp $ */
/*
 * Copyright (c) Leonid A. Broukhis, Jeremy Horn, Landon Curt Noll and
 * Peter Seebach, 1998.
 *
 * All Rights Reserved.  Permission for personal, education or non-profit use
 * is granted provided this this copyright and notice are included in its
 * entirety and remains unaltered.  All other uses must receive prior
 * permission in writing from the contest judges.
 */
/*
 * mkentry - make an International Obfuscated C Code Contest entry
 *
 * usage:
 *	mkentry -r remarks -b build -p prog.c -o ioccc.entry
 *
 *	-r remarks		file with remarks about the entry
 *	-b build		file containing how prog.c should be built
 *	-p prog.c		the obfuscated program source file
 *	-o ioccc.entry		ioccc entry output file
 *
 * compile by:
 *	cc mkentry.c -o mkentry
 */
/*
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
/*
 * WARNING:
 *
 * This program attempts to implement the IOCCC rules.  Every attempt
 * has been made to make sure that this program produces an entry that
 * conforms to the contest rules.  In all cases, where this program
 * differs from the contest rules, the contest rules will be used.  Be
 * sure to check with the contest rules before submitting an entry.
 *
 * FOR MORE INFORMATION:
 *
 *   You may contact the judges by sending EMail to the following address:
 *
 *	questions@ioccc.org	(not the address for submitting entries)
 *
 *  Questions and comments about the contest are welcome.
 *
 *  You must include the words ``ioccc question'' in the subject of your
 *  EMail message when sending EMail to the judges.
 *
 *  Entries must be sent to:
 *
 *	entry@ioccc.org
 *
 *  but be sure to follow the rules and read the guidelines first!
 *
 *  You must include the words ``ioccc entry'' in the subject
 *  of your EMail when sending in your entry!  Failure to do so may
 *  result in the loss of your entry!
 *
 *  The rules and the guidelines may (and often do) change from year to
 *  year.  You should be sure you have the current rules and guidelines
 *  prior to submitting entries.  To obtain them, visit the following URL:
 *
 *	http://www.ioccc.org
 *
 * Because contest rules change from year to year, one should only use this
 * program for the year that it was intended.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

/* logic */
#ifndef TRUE
# define TRUE 1
#endif /* TRUE */
#ifndef FALSE
# define FALSE 0
#endif /* FALSE */
#define EOF_OK TRUE
#define EOF_NOT_OK FALSE

/* global limits */
#define RULE_YEAR 1998		/* NOTE: should match the current year */
#define START_DATE ""26Nov98 12:00 UTC""	/* first confirmation received */
#define MAX_COL 79		/* max column a line should hit */
#define MAX_BUILD_SIZE 256	/* max how to build size */
#define MAX_PROGRAM_SIZE 3217	/* max program source size */
#define MAX_PROGRAM_SIZE2 1536	/* max program source size not counting
				   whitespace and {}; not followed by
				   whitespace or EOF */
#define MAX_TITLE_LEN 31	/* max chars in the title */
#define MAX_ENTRY_LEN 1		/* max length in the entry input line */
#define MAX_ENTRY 8		/* max number of entries per person per year */
#define MAX_FILE_LEN 1024	/* max filename length for a info file */

/* where to send entries */
#define ENTRY_ADDR ""entry@ioccc.org""

/* uuencode process - assumes ASCII */
#define UUENCODE(c) ((c) ? encode_str[(int)(c)&0x3f] : '`')
#define UUENCODE_LEN 45		/* max uuencode chunk size */
#define UUINFO_MODE 0444	/* mode of an info file's uuencode file */
#define UUBUILD_MODE 0444	/* mode of the build file's uuencode file */
#define UUBUILD_NAME ""build""	/* name for the build file's uuencode file */
#define UUPROG_MODE 0444	/* mode of the program's uuencode file */
#define UUPROG_NAME ""prog.c""	/* name for the program's uuencode file */

/* encode_str[(char)val] is the uuencoded character of val */
char encode_str[] = ""`!\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"";

/* global declarations */
char *program;			/* our name */
long start_time;		/* the startup time */

/* forward declarations */
void parse_args(int argc, char **argv, char **rname,
	        char **bname, char **pname, char **oname);
void usage(int exitval);
FILE *open_remark(char *filename);
FILE *open_build(char *filename);
FILE *open_program(char *filename);
FILE *open_output(char *filename);
void output_entry(FILE *output, char *oname);
void output_remark(FILE *output, char *oname, FILE *remark, char *rname);
void output_author(FILE *output, char *oname);
void output_info(FILE *output, char *oname);
void output_build(FILE *output, char *oname, FILE *build, char *bname);
void output_program(FILE *output, char *oname, FILE *prog, char *pname);
void output_end(FILE *output, char *oname);
int get_line(char *buf, int siz, int maxcol);
void output_till_dot(FILE *output, char *oname, char *leader);
int col_len(char *string);
void check_io(FILE *stream, char *name, int eof_ok);
void uuencode(FILE *output, char *oname, FILE *infile,
	      char *iname, int umode, char *uname);

int
main(argc, argv)
    int argc;		/* arg count */
    char **argv;	/* the args */
{
    FILE *remark=NULL;	/* open remarks stream */
    FILE *build=NULL;	/* open build file stream */
    FILE *prog=NULL;	/* open program stream */
    FILE *output=NULL;	/* open output stream */
    char *rname=NULL;	/* file with remarks about the entry */
    char *bname=NULL;	/* file containing how prog.c should be built */
    char *pname=NULL;	/* the obfuscated program source file */
    char *oname=NULL;	/* ioccc entry output file */
    struct tm *tm;	/* startup time structure */

    /*
     * check on the year
     */
    start_time = time((long *)0);
    tm = gmtime(&start_time);
    if (tm->tm_year != RULE_YEAR-1900 &&
	(tm->tm_year != RULE_YEAR-1900+1 || tm->tm_mon != 0)) {
	fprintf(stderr,
	""%s: WARNING: this program applies to %d, which may differ from %d\n\n"",
	    argv[0], RULE_YEAR, 1900+tm->tm_year);
    }

    /*
     * parse the command line args
     */
    parse_args(argc, argv, &rname, &bname, &pname, &oname);

    /*
     * open/check the input and output files
     *
     * We open and truncate the output file first, in case it is the same
     * as one of the input files.
     */
    output = open_output(oname);
    remark = open_remark(rname);
    build = open_build(bname);
    prog = open_program(pname);
    if (output==NULL || remark==NULL || build==NULL || prog==NULL) {
	exit(1);
    }

    /*
     * output each section
     */
    output_entry(output, oname);
    output_remark(output, oname, remark, rname);
    output_author(output, oname);
    output_info(output, oname);
    output_build(output, oname, build, bname);
    output_program(output, oname, prog, pname);
    output_end(output, oname);

    /*
     * flush the output
     */
    if (fflush(output) == EOF) {
	fprintf(stderr, ""%s: flush error in %s: "", program, oname);
	perror("""");
	exit(2);
    }

    /*
     * final words
     */
    printf(""\nYour entry can be found in %s.  You should check this file\n"",
	oname);
    printf(""correct any problems and verify that the uudecode utility will\n"");
    printf(""correctly decode your build file and program.\n\n"");
    printf(""This program has been provided as a guide for submitters.  In\n"");
    printf(""cases where it conflicts with the rules, the rules shall apply.\n"");
    printf(""It is your responsibility to ensure that your entry conforms to\n"");
    printf(""the current rules.\n\n"");
    printf(""EMail your entries to:\n"");
    printf(""\t%s\n\n"", ENTRY_ADDR);
    printf(""Please use the following subject when you EMail your entry:\n"");
    printf(""\tioccc entry\n\n"");
    /* all done */
    return 0;
}

/*
 * parse_args - parse the command line args
 *
 * usage:
 *	argc	arg count
 *	argv	the args
 *	rname	file with remarks about the entry
 *	bname	file containing how prog.c should be built
 *	pname	the obfuscated program source file
 *	oname	ioccc entry output file
 *
 * Given the command line args, this function parses them and sets the
 * required name flags.  This function will return only if the command
 * line syntax is correct.
 */
void
parse_args(int argc, char **argv, char **rname,
	   char **bname, char **pname, char **oname)
{
    char *optarg;	/* -flag option operand */
    int flagname;	/* the name of the -flag */
    int i;

    /*
     * Not everyone has getopt, so we must parse args by hand.
     */
    program = argv[0];
    for (i=1; i < argc; ++i) {

	/* determine the flagname */
	if (argv[i][0] != '-') {
	    usage(1);
	    /*NOTREACHED*/
	}
	flagname = (int)argv[i][1];

	/* determine the flag's operand */
	if (flagname != '\0' && argv[i][2] != '\0') {
	    optarg = &argv[i][2];
	} else {
	    if (i+1 >= argc) {
		usage(2);
		/*NOTREACHED*/
	    } else {
		optarg = argv[++i];
	    }
	}

	/* save the flag's operand in the correct global variable */
	switch (flagname) {
	case 'r':
	    *rname = optarg;
	    break;
	case 'b':
	    *bname = optarg;
	    break;
	case 'p':
	    *pname = optarg;
	    break;
	case 'o':
	    *oname = optarg;
	    break;
	default:
	    usage(3);
	    /*NOTREACHED*/
	}
    }

    /*
     * verify that we have all of the required flags
     */
    if (*rname == NULL || *bname == NULL || *pname == NULL || *oname == NULL) {
	usage(4);
	/*NOTREACHED*/
    }
    return;
}

/*
 * usage - print a usage message and exit
 *
 * usage:
 *	exitval		exit with this value
 *
 * This function does not return.
 */
void
usage(int exitval)
{
    fprintf(stderr,
	""usage: %s -r remarks -b build -p prog.c -o ioccc.entry\n\n"", program);
    fprintf(stderr, ""\t-r remarks\tfile with remarks about the entry\n"");
    fprintf(stderr, ""\t-b build\tfile containing how prog.c should be built\n"");
    fprintf(stderr, ""\t-p prog.c\tthe obfuscated program source file\n"");
    fprintf(stderr, ""\t-o ioccc.entry\tioccc entry output file\n"");
    exit(exitval);
}

/*
 * open_remark - open/check the remark file
 *
 * usage:
 *	filename	remark filename
 *
 * The remark file should be indented by 4 spaces, and should not extend
 * beyond column MAX_COL.  These are not requirements, so we only warn.
 *
 * This function returns NULL on I/O or format error.
 */
FILE *
open_remark(char *filename)
{
    FILE *stream;		/* the opened file stream */
    char buf[BUFSIZ+1];		/* input buffer */
    int toolong=0;		/* number of lines that are too long */
    int non_indent=0;		/* number of lines not indented by 4 spaces */

    /*
     * open the remark input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open remark file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * look at each line
     */
    while (fgets(buf, BUFSIZ, stream) != NULL) {

	/* count lines that do not start with 4 spaces */
	if (buf[0] != '\n' && strncmp(buf, ""    "", 4) != 0) {
	    ++non_indent;
	}

	/* count long lines */
	if (col_len(buf) > MAX_COL) {
	    /* found a line that is too long */
	    ++toolong;
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* note long lines if needed */
    if (toolong > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s extend beyond the 80th column\n"",
	    program, toolong, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* note non-indented lines, if needed */
    if (non_indent > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s are not indented by 4 spaces\n"",
	    program, non_indent, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_build - open/check the build file
 *
 * usage:
 *	filename	build filename
 *
 * The how to build file must not be longer than MAX_BUILD_SIZE bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_build(char *filename)
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */

    /*
     * open the how to build input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_BUILD_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the how to build file: %s, is %ld bytes long\n"",
	    program, filename, (long) statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_BUILD_SIZE);
	return(NULL);
    }

    /* return the open file */
    return(stream);
}

/*
 * open_program - open/check the program source file
 *
 * usage:
 *	filename	source filename
 *
 * The program source file must be <= 3217 bytes.  The number of
 * non-whitespace and }{; chars not followed by whitespace must
 * be <= 1536 bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_program(char *filename)
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */
    int count;			/* special count size */
    int c;			/* the character read */

    /*
     * open the program source input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open program source file: %s: "",
	    program, filename);
	perror("""");
	exit(7);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat program source file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_PROGRAM_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the program source file: %s, is %ld bytes long\n"",
	    program, filename, (long) statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_PROGRAM_SIZE);
	return(NULL);
    }

    /*
     * count the non-whitespace, non {}; followed by whitespace chars
     */
    count = 0;
    c = 0;
    while ((c=fgetc(stream)) != EOF) {
	/* look at non-whitespace */
	if (!isascii(c) || !isspace(c)) {
	    switch (c) {
	    case '{':		/* count if not followed by EOF or whitespace */
	    case '}':
	    case ';':
		/* peek at next char */
		c = fgetc(stream);
		if (c != EOF && isascii(c) && !isspace(c)) {
		    /* not followed by whitespace or EOF, count it */
		    ungetc(c, stream);
		    ++count;
		}
		break;
	    default:
		++count;
		break;
	    }
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* look at the special size */
    if (count > MAX_PROGRAM_SIZE2) {
	fprintf(stderr,
	    ""%s: FATAL: the number of bytes that are non-whitespace, and\n"",
	    program);
	fprintf(stderr,
	    ""%s:        that are not '{', '}', ';' followed by whitespace\n"",
	    program);
	fprintf(stderr,
	    ""%s:        or EOF must be <= %d bytes\n"",
	    program, MAX_PROGRAM_SIZE2);
	fprintf(stderr,
	    ""%s:        in %s, %d bytes were found\n"",
	    program, filename, count);
	return(NULL);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_output - open/check the entry output file
 *
 * usage:
 *	filename	output filename
 *
 * This function returns NULL on open error.
 */
FILE *
open_output(char *filename)
{
    FILE *stream;		/* the opened file stream */

    /*
     * open the ioccc entry output file
     */
    stream = fopen(filename, ""w"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open ioccc entry file for output: %s: "",
	    program, filename);
	perror("""");
	exit(8);
    }

    /* return the open file */
    return(stream);
}

/*
 * output_entry - output the ---entry--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_entry(FILE *output, char *oname)
{
    char title[MAX_TITLE_LEN+1+1];	/* the entry's title */
    char buf[MAX_COL+1+1];		/* I/O buffer */
    int entry=0;			/* entry number */
    int ret;				/* fields processed by fscanf */
    int ok_line=0;			/* 0 => the line is not ok */
    char skip;				/* input to skip */
    time_t epoch_sec;			/* seconds since the epoch */
    char *p;

    /*
     * write the start of the section
     */
    fprintf(output, ""---entry---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the rule year
     */
    fprintf(output, ""rule:\t%d\n"", RULE_YEAR);
    check_io(output, oname, EOF_NOT_OK);

    /* determine if this is a fix */
    printf(""Is this a fix, update or resubmittion to a "");
    printf(""previous entry (enter y or n)? "");
    while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    if (buf[0] == 'y') {
	fprintf(output, ""fix:\ty\n"");
	check_io(output, oname, EOF_NOT_OK);
	printf(""\nBe sure that the title and entry number that you give\n"");
	printf(""are the same of as the entry you are replacing\n"");
    } else {
	fprintf(output, ""fix:\tn\n"");
	check_io(output, oname, EOF_NOT_OK);
    }

    /*
     * write the title
     */
    printf(""\nThe first character of your title should match [a-zA-Z0-9_=]\n"");
    printf(""The next 0 to %d characters should match [a-zA-Z0-9_=+-]\n\n"",
	MAX_TITLE_LEN-1);
    printf(""It is suggested, but not required, that the title should\n"");
    printf(""incorporate your username; in the\n"");
    printf(""case of multiple authors, consider using parts of the usernames\n"");
    printf(""of the authors.\n\n"");
    printf(""enter your title: "");
    do {
	/* prompt and read a line */
	if ((ok_line = get_line(title, MAX_TITLE_LEN+1, MAX_COL-9)) <= 0) {
	    printf(""\ntitle is too long, please re-enter: "");
	    continue;
	}

	/* verify the pattern, not everyone has regexp, so do it by hand */
	if (!isascii((int)title[0]) ||
	    !(isalnum((int)title[0]) || title[0] == '_' || title[0] == '=')) {
	    printf(""\ninvalid first character in the title\n\n"");
	    printf(""enter your title: "");
	    ok_line = 0;
	} else {
	    for (p=(&title[1]); *p != '\0' && *p != '\n'; ++p) {
		if (!isascii((int)*p) ||
		    !(isalnum((int)*p) ||
		      *p == '_' || *p == '=' || *p == '+' || *p == '-')) {
		    printf(""\ninvalid character in the title\n\n"");
		    printf(""enter your title: "");
		    ok_line = 0;
		}
	    }
	}
    } while (ok_line <= 0);
    fprintf(output, ""title:\t%s"", title);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the entry number
     */
    printf(""\nEach person may submit up to %d entries per year.\n\n"",
	MAX_ENTRY);
    printf(""enter an entry number from 0 to %d inclusive: "", MAX_ENTRY-1);
    do {
	/* get a valid input line */
	fflush(stdout);
	ret = fscanf(stdin, ""%d[\n]"", &entry);
	check_io(stdin, ""stdin"", EOF_NOT_OK);
	/* skip over input until newline is found */
	do {
	    skip = fgetc(stdin);
	    check_io(stdin, ""stdin"", EOF_NOT_OK);
	    if (skip != '\n') {
		/* bad text in input, invalidate entry number */
		entry = -1;
	    }
	} while (skip != '\n');

	/* check if we have a number, and if it is in range */
	if (ret != 1 || entry < 0 || entry > MAX_ENTRY-1) {
	    printf(
	      ""\nThe entry number must be between 0 and %d inclusive\n\n"",
		MAX_ENTRY-1);
	    printf(""enter the entry number: "");
	}
    } while (ret != 1 || entry < 0 || entry > MAX_ENTRY-1);
    fprintf(output, ""entry:\t%d\n"", entry);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the submission date
     */
    /* returns a newline */
    epoch_sec = time(NULL);
    fprintf(output, ""date:\t%s"", asctime(gmtime(&epoch_sec)));
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the OS/machine host information
     */
    printf(
      ""\nEnter the machine(s) and OS(s) under which your entry was tested.\n"");
    output_till_dot(output, oname, ""host:"");
}

/*
 * output_remark - output the ---remark--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	remark		stream to the file containing remark text
 *	rname		name of the remark file
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_remark(FILE *output, char *oname, FILE *remark, char *rname)
{
    char buf[BUFSIZ+1];		/* input/output buffer */

    /*
     * write the start of the section
     */
    fprintf(output, ""---remark---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * copy the remark file to the section
     */
    while (fgets(buf, BUFSIZ, remark) != NULL) {
	fputs(buf, output);
	check_io(output, oname, EOF_NOT_OK);
    }
    check_io(remark, rname, EOF_OK);

    /* be sure that the remark section ends with a newline */
    if (buf[strlen(buf)-1] != '\n') {
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);
    }
}

/*
 * output_author - output the ---author--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information from stdin, and write the author section.
 * If multiple authors exist, multiple author sections will be written.
 */
void
output_author(FILE *output, char *oname)
{
    char buf[MAX_COL+1+1];	/* I/O buffer */
    int more_auths;		/* TRUE => more authors to note */
    int auth_cnt=0;		/* number of authors processed */

    /*
     * prompt the user for the author section
     */
    printf(""\nEnter information about each author.  If your entry is after\n"");
    printf(""%s and before the contest deadline, the judges\n"", START_DATE);
    printf(""will attempt to EMail back a confirmation to the first author\n"");

    /*
     * place author information for each author in an individual section
     */
    do {

	/* write the start of the section */
	fprintf(output, ""---author---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* write the author */
	printf(""\nAuthor #%d name: "", ++auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nname too long, please re-enter: "");
	}
	fprintf(output, ""name:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the organization */
	printf(""\nEnter the School/Company/Organization of author #%d\n"",
	    auth_cnt);
	printf(""\nAuthor #%d org: "", auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter: "");
	}
	fprintf(output, ""org:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the address */
	printf(
	    ""\nEnter the postal address for author #%d.  Be sure to include\n"",
	    auth_cnt);
	printf(""your country and do not include your name.\n"");
	output_till_dot(output, oname, ""addr:"");

	/* write the EMail address */
	printf(
	    ""\nEnter the EMail address for author #%d.  Use an address from\n"",
	    auth_cnt);
	printf(
	    ""a registered domain or well known site.  If you give several\n"");
	printf(""forms, list them one per line.\n"");
	output_till_dot(output, oname, ""email:"");

	/* write the home page URL */
	printf(
	    ""\nEnter the fully qualified home page URL for author #%d\n"",
	    auth_cnt);
	printf(""including the http: part or type none: "");
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0 ||
	       (strncmp(buf, ""http://"", sizeof(""http://"")-1) != 0 &&
		strcmp(buf, ""none\n"") != 0)) {
	      printf(""\nURL too long, does not begin with http:// or\n"");
	      printf(""is not the word none\n"");
	}
	fprintf(output, ""url:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the anonymous status */
	printf(""\nShould author #%d remain anonymous (enter y or n)? "",
	    auth_cnt);
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	fprintf(output, ""anon:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* determine if there is another author */
	printf(""\nIs there another author (enter y or n)? "");
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	if (buf[0] == 'y') {
	    more_auths = TRUE;
	} else {
	    more_auths = FALSE;
	}
    } while (more_auths == TRUE);
    return;
}

/*
 * output_info - output the ---info--- section(s)
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information from stdin, and write the info section.
 * If multiple info files exist, multiple info sections will be written.
 */
void
output_info(FILE *output, char *oname)
{
    char infoname[MAX_FILE_LEN+1];	/* filename buffer */
    char yorn[1+1];		/* y or n answer */
    char *uuname;		/* name to uuencode as */
    FILE *infile;		/* info file stream */

    /*
     * prompt the user for info information
     */
    printf(""\nInfo files should be used only to supplement your entry.\n"");
    printf(""For example, info files may provide sample input or detailed\n"");
    printf(""information about your entry.  Because they are supplemental,\n"");
    printf(""the entry should not require them to exist.\n\n"");

    /*
     * while there is another info file to save, uuencode it
     */
    printf(""Do you have a info file to include (enter y or n)? "");
    while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    while (yorn[0] == 'y') {

	/* read the filename */
	printf(""\nEnter the info filename: "");
	while (get_line(infoname, MAX_FILE_LEN+1, 0) <= 0) {
	    printf(""\nInfo filename too long, please re-enter: "");
	}

	/* compute the basename of the info filename */
	/* remove the trailing newline */
	uuname = &infoname[strlen(infoname)-1];
	*uuname = '\0';
	/* avoid rindex/shrrchr compat issues, do it by hand */
	for (--uuname; uuname > infoname; --uuname) {
	    if (*uuname == '/') {
		++uuname;
		break;
	    }
	}

	/* attempt to open the info file */
	infile = fopen(infoname, ""r"");
	if (infile == NULL) {
	    fprintf(stderr, ""\n%s: cannot open info file: %s: "",
		program, infoname);
	    perror("""");
	    continue;
	}

	/*
	 * write the start of the section
	 */
	fprintf(output, ""---info---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* uuencode the info file */
	uuencode(output, oname, infile, infoname, UUINFO_MODE, uuname);

	printf(""\nDo you have another info file to include (enter y or n)? "");
	while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
    };
    return;
}

/*
 * output_build - output the ---build--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	build		open build file stream
 *	bname		name of the build file
 *
 * Read the needed information from stdin, and write the build section.
 */
void
output_build(FILE *output, char *oname, FILE *build, char *bname)
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---build---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, build, bname, UUBUILD_MODE, UUBUILD_NAME);
    return;
}

/*
 * output_program - output the ---program--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	prog		open program stream
 *	pname		name of program file
 *
 * Read the needed information form stdin, and write the program section.
 */
void
output_program(FILE *output, char *oname, FILE *prog, char *pname)
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---program---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, prog, pname, UUPROG_MODE, UUPROG_NAME);
    return;
}

/*
 * output_end - output the ---end--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information form stdin, and write the 'end section'.
 */
void
output_end(FILE *output, char *oname)
{
    /*
     * write the final section terminator
     */
    fprintf(output, ""---end---\n"");
    check_io(output, oname, EOF_NOT_OK);
    return;
}

/*
 * get_line - get an answer from stdin
 *
 * usage:
 *	buf		input buffer
 *	siz		length of input, including the newline
 *	maxcol		max col allowed, 0 => disable check
 *
 * This function will flush stdout, in case a prompt is pending, and
 * read in the answer.
 *
 * This function returns 0 if the line is too long, of the length of the
 * line (including the newline) of the line was ok.  This function does
 * not return if ERROR or EOF.
 */
int
get_line(char *buf, int siz, int maxcol)
{
    int length;			/* the length of the input line */

    /* flush terminal output */
    fflush(stdout);

    /* read the line */
    if (fgets(buf, siz+1, stdin) == NULL) {
	/* report the problem */
	check_io(stdin, ""stdin"", EOF_NOT_OK);
    }

    /* look for the newline */
    length = strlen(buf);
    if (buf[length-1] != '\n') {
	int eatchar;		/* the char being eaten */

	/* no newline found, line must be too long, eat the rest of the line */
	do {
	    eatchar = fgetc(stdin);
	} while (eatchar != EOF && eatchar != '\n');
	check_io(stdin, ""stdin"", EOF_NOT_OK);

	/* report the situation */
	return 0;
    }

    /* watch for long lines, if needed */
    if (maxcol > 0 && (length > maxcol || col_len(buf) > maxcol)) {
	/* report the situation */
	return 0;
    }

    /* return length */
    return length;
}

/*
 * output_till_dot - output a set of lines until '.' by itself is read
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	leader		the lead text for the first line
 *
 * This routine will read a set of lines until (but not including)
 * a single line with '.' is read.  The format of the output is:
 *
 *	leader:\tfirst line
 *	\tnext line
 *	\tnext line
 *	   ...
 *
 * This routine will not return if I/O error or EOF.
 */
void
output_till_dot(FILE *output, char *oname, char *leader)
{
    char buf[BUFSIZ+1];		/* input buffer */
    int count;			/* lines read */
    int done=FALSE;		/* TRUE => finished reading input */

    /* instruct the user on how to input */
    printf(""\nTo end input, enter a line with a single period.\n"");

    /* read lines until '.' or EOF */
    count = 0;
    while (!done) {
	/* issue the prompt */
	printf(""%s\t"", (count>0) ? """" : leader);
	fflush(stdout);

	/* get the line */
	if (get_line(buf, BUFSIZ, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter:\n\t"");
	    continue;
	}

	/* note if '.' was read */
	if (strcmp(buf, "".\n"") == 0) {
	    done = TRUE;
	}

	/* write line if we read something */
	if (!done) {
	    fprintf(output, ""%s\t%s"", (count++>0) ? """" : leader, buf);
	    check_io(output, oname, EOF_NOT_OK);
	}
    }

    /* if no lines read, at least output something */
    if (count <= 0) {
	fprintf(output, ""%s\t.\n"", leader);
	check_io(output, oname, EOF_NOT_OK);
    }
    return;
}

/*
 * col_len - determine the highest that a string would reach
 *
 * usage:
 *	string		the string to examine
 *
 * Given a string, this routine returns that a string would reach
 * if the string were printed at column 1.  Tab stops are assumed
 * to start at 9, 17, 25, 33, ...
 */
int
col_len(char *string)
{
    int col;	/* current column */
    char *p;	/* current char */

    /* scan the string */
    for (col=0, p=string; *p != '\0' && *p != '\n'; ++p) {
	/* note the column shift */
	col = (*p=='\t') ? 1+((col+8)/8*8) : col+1;
    }
    if (*p == '\n') {
	--col;
    }

    /* return the highest column */
    return col;
}

/*
 * check_io - check for EOF or I/O error on a stream
 *
 * usage:
 *	stream		the stream to check
 *	name		the name of this stream
 *	eof_ok		EOF_OK or EOF_NOT_OK
 *
 * Does not return if EOF or I/O error.
 */
void
check_io(FILE *stream, char *name, int eof_ok)
{
    /* test for I/O error */
    if (ferror(stream)) {
	fprintf(stderr, ""%s: error on %s: "", program, name);
	perror("""");
	exit(1);

    /* test for EOF */
    } else if (eof_ok == EOF_NOT_OK && feof(stream)) {
	fprintf(stderr, ""%s: EOF on %s\n"", program, name);
	exit(1);
    }
    return;
}

/*
 * uuencode - uuencode a file
 *
 * usage:
 *	output		output file stream
 *	oname		output filename
 *	infile		input file stream
 *	iname		input filename
 *	umode		the mode to put on the uuencode file
 *	uname		name to put on the uuencode file
 *
 * Perform the uuencoding process identical to the process performed
 * by the uuencode(1) utility.
 *
 * This routine implements the algorithm described in the uuencode(5)
 * 4.3BSD Reno man page.
 */
void
uuencode(FILE *output, char *oname, FILE *infile,
	 char *iname, int umode, char *uname)
{
    char buf[UUENCODE_LEN+1];	/* the uuencode buffer */
    int read_len;		/* actual number of chars read */
    int val;			/* 6 bit chunk from buf */
    char filler='\0';		/* filler uuencode pad text */
    char *p;

    /*
     * output the initial uuencode header
     */
    fprintf(output, ""begin %o %s\n"", umode, uname);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * clear out the input buffer
     */
    for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	*p = '\0';
    }

    /*
     * We will process UUENCODE_LEN chars at a time, forming
     * a single output line each time.
     */
    while ((read_len=fread(buf,sizeof(buf[0]),UUENCODE_LEN,infile)) > 0) {

	/*
	 * the first character is the length character
	 */
	fputc(UUENCODE(read_len), output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * We will convert 24 bits at a time.  Thus we will convert
	 * 3 sets of 8 bits into 4 sets of uuencoded 6 bits.
	 */
	for (p=buf; read_len>0; read_len-=3, p+=3) {

	    /* bits 0 to 5 */
	    val = (p[0]>>2)&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 6 to 11 */
	    val = ((p[0]<<4)&0x30) | ((p[1]>>4)&0x0f);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 12 to 17 */
	    val = ((p[1]<<2)&0x3c) | ((p[2]>>6)&0x03);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 18 to 23 */
	    val = p[2]&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);
	}

	/* end of UUENCODE_LEN line */
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * clear out the input buffer  (don't depend on bzero() or memset())
	 */
	for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	    *p = '\0';
	}
    }

    /* check the last read on the input file */
    check_io(infile, iname, EOF_OK);

    /* write end of uuencode file */
    fprintf(output, ""%c\nend\n"", UUENCODE(filler));
    check_io(output, oname, EOF_NOT_OK);
}
","typedef void e();

e *w,*l,*u,*_o,*j,*t,*O,exit,b,c_,b_,a_,c,a,z_,x_,d,y_,_m;
int q,m,_d,z,k,h,f[99];
char y[26],_p[40][26],_q,r[2],*_,**s,*i,

*x[]= { ""\n"", "")"", ""if ("", ""}\n"", "");\n\n"", ""    "", "",&"", ""\"""",
  "","", "" %%d"", "";\n\n    scanf(\""%%d"", ""%%d "", ""else "", "","", ""<"",
  "");\n"", ""printf(\"""", ""main()\n{\n    int a"" };

void  g(){ O=j; printf(_); }
void _j(){ O=_o; m=!m; h=h+m*(long)t; }
void _u(){ O=g; _=x[0]; j=b; }
void _r(){ O=g; _=x[1]; j=_u; }
void _f(){ O=g; *r=y[k-1]; _=r; j=_r; }
void _l(){ O=g; _=x[2]; j=x_; }
void _c(){ O=(e*)h; }
void  n(){ O=_j; t=w; _o=_c; }
void  p(){ O=_j; h=0; t=l; _o=n; }
void _b(){ O=p; q=*i+q*10-'0'; i=i+1; m=*i; w=_b; l=c; }
void _s(){ O=g; _=x[3]; j=exit; }
void  v(){ O=p; z=z-1; m=z; w=z_; l=_s; }
void _a(){ O=g; _=x[4]; *y=x[17][1]; z=0; j=b; }
void _z(){ O=g; _=x[5]; j=p; k=k-1; m=k; w=_z; l=u; }
void _h(){ O=g; _=x[6]; j=a_; }
void _e(){ O=g; _=x[7]; k=0; j=_h; }
void _t(){ O=g; _=x[8]; j=d; }
void _g(){ O=g; _=x[7]; j=_t; k=0; }
void _k(){ O=_z; k=f[z]; _q=y[k]; y[k]=y[k-1]; y[k-1]=_q; u=b_; k=z; }
void d_(){ O=_k; y[z+1]=x[17][1]+z; f[z]=z+1; }
void b (){ O=p; z=z+1; m=q-z; w=c_; k=z; l=_z; u=a; }
void e_(){ O=g; _=x[9]; k=k+1; m=k<q; w=e_; l=_e; j=p; }
void f_(){ O=g; _=x[10]; k=1; j=e_; }
void g_(){ O=g; _=x[11]; j=p; k=k-1; m=k; w=g_; l=_g; }
void h_(){ O=p; _p[z][k]=y[k]; k=k+1; m=k<=z; w=h_; l=d_; }
void i_(){ O=p; y[k]=_p[z][k]; k=k+1; m=k<=z; w=i_; l=v; }
void j_(){ O=i_; k=0; }
void k_(){ O=p; m=k>1; w=_l; l=_u; }
void l_(){ O=g; _=x[12]; j=k_; }
void m_(){ O=g; _=x[13]; j=y_; }
void n_(){ O=p; k=k+1; m=k<q; w=_h; l=_a; }
void o_(){ O=g; _=x[14]; j=_f; }
void c_(){ O=h_; k=0; }
void p_(){ O=g; _=x[15]; j=v; }
void b_(){ O=p; k=f[z]; m=k<=z; w=l_; l=k_; }
void a_(){ O=g; *r=x[17][1]+k; _=r; j=n_; }
void q_(){ O=p; k=k+1; m=k<q; w=m_; l=f_; }
void c (){ O=g; r[1]=0; k=1; j=m_; }
void a (){ O=g; k=z; j=g_; _=x[16]; }
void z_(){ O=p; f[z]=f[z]-1; m=f[z]; w=_k; l=j_; }
void x_(){ O=g; *r=y[k-2]; _=r; j=o_; }
void d (){ O=g; *r=y[k]; _=r; k=k+1; m=k<z; w=_t; l=p_; j=p; }
void y_(){ O=g; *r=x[17][1]+k; _=r; j=q_; }
void r_(){ O=_b; _=x[17]; s=(char**)_d; s=s+1; i=*s; q=0; }
main(v,c){ O=r_; _d=c;
  x: (O)(); goto x; }
","%:define H(x) <st%:%:x##.h>
#include H(dio)
#include H(dlib)
#include H(ring)

#define x ) == 0 ?__LINE__:0){O =__LINE__;break;} }
#define X(x) __LINE__ x __LINE__
#define t(a)\
for (c = 0; c <n##a; ++c) { \
  if (strchr (a[c], 0[__FILE__])) { if (*a[c] == 0[__FILE__]) { \
      if (strcmp (a[c]+__LINE__, I + strlen (I) + __LINE__ - strlen (a[c]) x else { \
      if (strncmp (a[c], I, strlen (a[c])-__LINE__ x \
  } else { if (strcmp (a[c], I x }

#line 4 ""info\0r""
	int
main (int C, char **V)
{
	FILE *H;
	int c, ne, nn, S = C < 2 ? 060 : *V[1];

	char f[__LINE__][X(*)], K[X(*)], L[X(<<)],
	e[X(<<)][3*__LINE__], n[X(<<)][3*__LINE__], F[__LINE__];

	if (freopen (__FILE__, 5+__FILE__, stdin) == 0) return __LINE__-13;
	for (c = 0;;) {
#line		1 ""#\n""
		if (!fgets (f[c], (int)sizeof *f, stdin)) return __LINE__; if (*f[c] == 0[__FILE__]) continue; if (*f[c] != __LINE__[__FILE__]) { f[c][strlen (f[c]) - __LINE__] = 2[__FILE__];
			++c;
		} else
			break;
	}
	for (ne = 0;;) {
		do {
#line			1 ""#%s%s""
			if (!fgets (L, (int)sizeof L, stdin)) return __LINE__; } while (*L == 0[__FILE__]); switch (sscanf (L, __LINE__+__FILE__, F, e[ne])) { default: goto O;
			case __LINE__: switch (strchr (F, S)!=0) case 1: ++ne;
		}
	}

O:
	nn = 0;
	while ((fgets (L, (int) sizeof L, stdin)) != 0) {


		char A[__LINE__], f3; if (*L == 0[__FILE__]) continue;
#line		1 ""%s%s %c""
		switch (sscanf (L, __FILE__, A, n[nn], &f3)) {
		case __LINE__: if (strchr (A, S)) ++nn; break;
		case __LINE__:
			if (strchr (A, S)) {
#line				8 ""<%s>:\n""
				char *I = L + __LINE__;
				int O = printf (__FILE__, n[nn]) +
#line				2 ""0gcc -ansi -E -dM -undef %s /usr/include/%s>r\0 (""
				sprintf (K, 1+__FILE__, f[S-*__FILE__] + __LINE__, n[nn]);
				O += system (K);
				if ((H = fopen (__FILE__+44, 44+__FILE__)) == 0) return 1;
				while ((fgets (L, (int)sizeof L, H)) != 0) {
					I[strcspn (I, 46+__FILE__)] = O = 0;
#line					1 ""*r""
					t (n) t (e)
					if (0 == O) O = puts (L);
				}
				nn = fclose (H);
			}
		}
	}
	return remove (1+__FILE__);
}
","%:defineH(x) <st%:%:x##.h>
#includeH(dio)
#includeH(dlib)
#includeH(ring)

#definex)==0?__LINE__:0){O=__LINE__;break;}}
#defineX(x)__LINE__x__LINE__
#definet(a)\
for(c=0;c<n##a; ++c) { \
  if(strchr (a[c], 0[__FILE__])) { if (*a[c] == 0[__FILE__]) { \
      if (strcmp (a[c]+__LINE__, I + strlen (I) + __LINE__ - strlen (a[c]) x else { \
      if (strncmp (a[c], I, strlen (a[c])-__LINE__ x \
  }else { if (strcmp (a[c], I x }

#line 4 ""info\0r""
	int
main (int C, char **V)
{
	FILE *H;
	int c, ne, nn, S = C < 2 ? 060 : *V[1];

	char f[__LINE__][X(*)], K[X(*)], L[X(<<)],
	e[X(<<)][3*__LINE__], n[X(<<)][3*__LINE__], F[__LINE__];

	if (freopen (__FILE__, 5+__FILE__, stdin) == 0) return __LINE__-13;
	for (c = 0;;) {
#line		1 ""#\n""
		if (!fgets (f[c], (int)sizeof *f, stdin)) return __LINE__; if (*f[c] == 0[__FILE__]) continue; if (*f[c] != __LINE__[__FILE__]) { f[c][strlen (f[c]) - __LINE__] = 2[__FILE__];
			++c;
		} else
			break;
	}
	for (ne = 0;;) {
		do {
#line			1 ""#%s%s""
			if (!fgets (L, (int)sizeof L, stdin)) return __LINE__; } while (*L == 0[__FILE__]); switch (sscanf (L, __LINE__+__FILE__, F, e[ne])) { default: goto O;
			case __LINE__: switch (strchr (F, S)!=0) case 1: ++ne;
		}
	}

O:
	nn = 0;
	while ((fgets (L, (int) sizeof L, stdin)) != 0) {


		char A[__LINE__], f3; if (*L == 0[__FILE__]) continue;
#line		1 ""%s%s %c""
		switch (sscanf (L, __FILE__, A, n[nn], &f3)) {
		case __LINE__: if (strchr (A, S)) ++nn; break;
		case __LINE__:
			if (strchr (A, S)) {
#line				8 ""<%s>:\n""
				char *I = L + __LINE__;
				int O = printf (__FILE__, n[nn]) +
#line				2 ""0gcc -ansi -E -dM -undef %s /usr/include/%s>r\0 (""
				sprintf (K, 1+__FILE__, f[S-*__FILE__] + __LINE__, n[nn]);
				O += system (K);
				if ((H = fopen (__FILE__+44, 44+__FILE__)) == 0) return 1;
				while ((fgets (L, (int)sizeof L, H)) != 0) {
					I[strcspn (I, 46+__FILE__)] = O = 0;
#line					1 ""*r""
					t (n) t (e)
					if (0 == O) O = puts (L);
				}
				nn = fclose (H);
			}
		}
	}
	return remove (1+__FILE__);
}
","#define _POSIX_SOURCE /* you are not supposed to understand this */
#define O(OOO,OO0,O00,O0O,OO,O0)\0##O0O%:%:OO\0##O0%:%:OOO\0##OO0%:%:O00
#include<signal.h>
static volatile sig_atomic_t One;
#include<stdlib.h>
#include<unistd.h>
#define Zero(NULL)#NULL
#define ONE(One) Zero(One)
in??/
t
#line 10 ""01\015""
main (register zero, char **ONE)
%:
<% switch (sizeof __FILE__ < zero) case 1: return One /= zero;
{ auto one = zero = atoi (ONE<:zero-1:>);
do for (one += alarm (One |= (signal (__LINE__, (void(*)(register))main)
!= SIG_ERR)); One; ++one);
while (zero -= write (1, __FILE__+(one&1), 1));
return write (1, 1+__FILE__+1, 1) != 1;
%>}
","#define _POSIX_SOURCE /* you are not supposed to understand this */
#define O(OOO,OO0,O00,O0O,OO,O0)\0##O0O%:%:OO\0##O0%:%:OOO\0##OO0%:%:O00
#include<signal.h>
static volatile sig_atomic_t One;
#include<stdlib.h>
#include<unistd.h>
#define Zero(NULL)#NULL
#define ONE(One) Zero(One)
in??/
t
??=line 10 ONE(O(1,1,2,6,0,6))
main (register zero, char **ONE)
%:
<% switch (sizeof __FILE__ < zero) case 1: return One /= zero;
{ auto one = zero = atoi (ONE<:zero-1:>);
do for (one += alarm (One |= (signal (__LINE__, (void(*)(register))main)
!= SIG_ERR)); One; ++one);
while (zero -= write (1, __FILE__+(one&1), 1));
return write (1, 1+__FILE__+1, 1) != 1;
%>}
","%:define _POSIX_SOURCE
#include<fcntl.h>
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<string.h>
#include<sys/types.h>
#include<sys/stat.h>
#define D(N,t)Z t*N V<%t*z U M0*z); H z)u z; X}
#define k(x,y)x<0||fstat(x,&y)||
#define h(x)=open(x,O_RDONLY)
#define b(x),(int)x.st_nlink
#define B ;typedef g
#define X exit (1);
#define O .st_size
#define U =malloc(
#define Y S.st_ino
#define v ;%>else
#define W .st_dev
#define o ||read(
#define Z static
#define g struct
#define u return
#define I char*
#define V (M2)
#define H if(
#define _ ->

/* HE WHO SAYS */

Z I A<:32767/      M0(I )]; Z g     stat S,T; Z        size_t    y B f{
I n ; g f *  x     ; dev_t d  ;    ino_t i; } f B      t{ M1     s,c; f
*l; g t*L,*R; }    t; D(a,t)D(E    ,f)Z t*J(t*p,I      n){ H!   p){ p=
a(); p    _ s =S      O; p _       c=1; p              _ L=p    _ R=0;
p _ l=    E(); p      _ l  _       n=n; p              _ l _   x=0; p
_ l  _    d=S W;      p _  l       _ i= Y              v H S   O==p _
s){ f*    e; for      (e=p _       l; e; e=e _ x)      { H S W==e _ 
d&&Y==    e _ i)      { u p;        } } e=E(); e _     x=p _ l; e _ 
n=n; e    _ d =S      W; e _                i=Y; p     _ l=e;  ++p _ 
c v  H    S O< p      _ s) {                p _ L=     J( p _  L,n)v{
p _ R=    J (p _      R,n );                } u  p     ; }  Z   int Q(
I G,I F){ int d    h(G),D h(F);    I m,*M; H k(d,S     )k(D,T   )(y =S 
O)-T O){ y= 0;     goto d; } H!    (m U y))||!(M U     y))o d    ,m,y)-
y o D,M,y)-y)      X y=!memcmp(     m,M,y); M5(m)      ; M5(M    ); d:V

 close (d );V      close(D); u        y; } Z M2 C(M1       z,M1 N){ M1     i=N*(N-1)/2,
j=1,s; I q,*e,*    p,*w,*l; e=q=     M4((size_t)i,1);     H!e) X p=q+i;    for(i=0; e-p
; ++e){ H!*e&&Q    (A[i:>,A[j])){   V printf(""%""""l""""d""   ""\t""""%"" ""s""""\t""   ""%""""s""
""??/t""             ""%""""c""   ""\11""   ""%""""d""      ""??/t""   ""%""""d""    ""\n"",   z,A[i]
,A[j],             S W -T   W?'X'   :'='b(      S)b(T)   ); H j    -i-1)   { s=N-
i-3; w             =e+s+1; l=q+N*   (j-1)-      j*(j-1   )/ 2 ;            do{ *w
=1; H w==l)        break; w+= s;    } while( s-->0); }   } H++j            ==N){ j=i+++
 2; } } M5(q);     } Z M2 P(t*p     ){ H p){ P(p _ R);   H  p _            c>1){ M1 i=0
         ; f*l=    p _ l;           for (;      i< p _   c; ++i            ){ A[i
         ]= l _    n; l=l           _ x; }      C (p _   s, p _    c); }   P (p _ 
         L) ; }    }  int           main V      { t*r=   0; I F    ; for   (; ; )
{ H!(F U 1024))    )X H !           fgets(      F,1024   ,stdin) )break;   *(F+(y
=strlen(F))-1)=    0; H!(          F=M3(F,      y)))X H   stat(F,&S)==0    &&S_ISREG(S.
 st_mode)&&S O     )r=J(r          ,F ); }      H r)P(r    ); u 0; }/*     Obfuscated C

IS FREE THINKS MONEY GROWS ON DIRECTORY TREE */
","#include <stdio.h>
#include <stdlib.h>

int main(int a,char     **A){FILE*B;typedef     unsigned long C;C b
[8]; if(!(a==7&&(B=     fopen(1[A],""rb""))))     return 1;for(7[b]=0
;7[b]<5;7[b]++)b[7[     b]]=strtoul(A[2+7[b     ]],0,16-!7[b]*6);5[
b]=3[b]                 ; while     ((6[b]=     getc(B)
)!=(C)-                 1){if(2     [b])for     (7[b]=0
;7[b]<4                 ;7[b]++     )if(((6     [b]>>7[
b])^(6[                 b]>>(7-7[b])))&1)6[     b] ^=(1
<<7[b])                 ^(1<<(7-7[b]));5[b]     ^= 6[b]
<<(0[b]                 -8);for(7[b]=0;7[b]     <8;7[b]
++)if((                 5[b]>>(0[b]-            1))&1)5
[b]=(5[                 b]<<1)^ 1[b];           else 5[
b]<<=1;                 }5[b]&=((((C)1          <<(0[b]
-1))-1)                 <<1)|1; if(2[b]         )for(7[
b]=0;7[                 b]<(0[b  ]>>1);7        [b] ++)
if(((5[b]>>7[b])^(5     [b]>>(0   [b]-1-7       [b])))&1)5[b]^=((C)
1<<7[b])^((C)1<<(0[     b]-1-7[    b]));5[      b]^=4[b];fclose(B);
printf(""%0*lX\n"", (     int)(0[     b]+3)>>     2,5[b]); return 0;}
","#include <stdio.h>

char
*T=""IeJKLMaYQCE]jbZRskc[SldU^V\\X\\|/_<[<:90!\""$434-./2>]s"",
K[3][1000],*F,x,A,*M[2],*J,r[4],*g,N,Y,*Q,W,*k,q,D;X(){r  [r
[r[3]=M[1-(x&1)][*r=W,1],2]=*Q+2,1]=x+1+Y,*g++=((((x&     7)
-1)>>1)-1)?*r:r[x>>3],(++x<*r)&&X();}E(){A||X(x=0,g       =J
),x=7&(*T>>A*3),J[(x[F]-W-x)^A*7]=Q[x&3]^A*(*M)[2         +(
x&1)],g=J+((x[k]-W)^A*7)-A,g[1]=(*M)[*g=M[T+=A            ,1
][x&1],x&1],(A^=1)&&(E(),J+=W);}l(){E(--q&&l              ()
);}B(){*J&&B((D=*J,Q[2]<D&&D<k[1]&&(*g++=1                ),
!(D-W&&D-9&&D-10&&D-13)&&(!*r&&(*g++=0)                   ,*
r=1)||64<D&&D<91&&(*r=0,*g++=D-63)||D                     >=
97&&D<123&&(*r=0,*g++=D-95)||!(D-k[                       3]
)&&(*r=0,*g++=12)||D>k[3]&&D<=k[                          1]
-1&&(*r=0,*g++=D-47),J++));}j(                            ){
putchar(A);}b(){(j(A=(*K)[D*                              W+
r[2]*Y+x]),++x<Y)&&b();}t                                 ()
{(j((b(D=q[g],x=0),A=W)                                   ),
++q<(*(r+1)<Y?*(r+1):                                     Y)
)&&t();}R(){(A=(t(                                        q=
0),'\n'),j(),++r                                          [2
]<N)&&R();}O()                                            {(
j((r[2]=0,R(                                              ))
),r[1]-=q)                                                &&
O(g-=-q)                                                  ;}
C(){(                                                     J=
gets                                                      (K
[1]))&&C((B(g=K[2]),*r=!(!*r&&(*g++=0)),(*r)[r]=g-K[2],g=K[2
],r[
1]&&
O())
);;}
main
(){C
((l(
(J=(
A=0)
[K],
A[M]
=(F=
(k=(
M[!A
]=(Q
=T+(
q=(Y
=(W=
32)-
(N=4
))))
+N)+
2)+7
)+7)
),Y=
N<<(
*r=!
-A))
);;}
","int m = 754974721, N, t[1 << 22], a, *p, i, e = 1 << 22, j, s, b, c, U;
f (d)
{
  for (s = 1 << 23; s; s /= 2, d = d * 1LL * d % m)
    if (s < N)
      for (p = t; p < t + N; p += s)
	for (i = s, c = 1; i; i--)
	  b = *p + p[s], p[s] = (m + *p - p[s]) *
	    1LL * c % m, *p++ = b % m, c = c * 1LL * d % m;
  for (j = 0; i < N - 1;)
    {
      for (s = N / 2; !((j ^= s) & s); s /= 2);
      if (++i < j)
	a = t[i], t[i] = t[j], t[j] = a;
    }
}

main ()
{
  *t = 2;
  U = N = 1;
  while (e /= 2)
    {
      N *= 2;
      U = U * 1LL * (m + 1) / 2 % m;
      f (362);
      for (p = t; p < t + N;)
	*p++ = (*p * 1LL ** p % m) * U % m;
      f (415027540);
      for (a = 0, p = t; p < t + N;)
	a += (6972593 & e ? 2 : 1) ** p, *p++ = a % 10, a /= 10;
    }
  while (!*--p);
  t[0]--;
  while (p >= t)
    printf (""%d"", *p--);
}
","        #include					       <stdlib.h>
   #include							    <stdio.h>
#define				    a					typedef
a				  long					     N;
#define			    i =m(p(r,o,v),e,d 
N			    G,l,I,C,B,A,W,L,S
,				R,O,c,k,s				      =
80,									   U=13
,T=169;								    a double P;
   #define							 F for(
      a P*E; a char*w;				     P sqrt(P); N H(){ F;
	    O=scanf("" %[#]%*[^\n]"",&O); ); scanf(""%ld%*c"",&O);
			    #define D return
				  D O; } 



#define V						  =malloc(sizeof(
#define	 M						 M(
#define	  X						+=
P M N R){ s=					       s>=k?printf( ""%ld%c""
+3*(C<1),s-k,					      R&7?32:10):s; D R>0?B
/2?H():getchar					     ():R?.9+.7*M R+1):0; }
P t(N x,P K){ D					    x?(x>U?0:t(x+2,K)*(x-1)
/x/K)+1/sqrt(K):				   t(2,K*K/U+1)*K; }  N _(N
J,N x){ F*(x?&W:&				  A)=W+J+x; (O=x=W/(J=k*k))
||A<J||(( O=2*W/J)				 &&2*A/J<3); A	X A-J+1){ F 
J*=x+O; S--*B&&x==O				; O=x=!J){ s X x+s; M 0); } 
W X W-J;  S X 2; L X			       L-J*k+M S%8==B); } D  1; } E 
p(E J,E x,E O){ F R=T;			      R--; )O[R]=J[R]+.8*x[R]; D O; 
} P m(E W,E x,P s){ F R		 =	     U; --R; ){ E A=W+R*U; W[R]X s/
12; *W X s; *A-=*x++; F;	A>W;	    ){ *A/=*W; F O=R; O; O--)A[O]-=
W[O]**A;  A-=U; } W X 14;     } D*W; }	   int main(int z,w*y){ N K=s,g; Y; 
M z); s= B=C=15-H(); s=G=   M 8); s=l=M	  C); G*=g=C%3?1:3; if(I=s=M 8)){ N 
b=G+9,x=b*340+U,J=b*(l+5), * n V N ) * J ),*j=n+5*b; E h V P)*x),q=h+b,e=q+
b; P d=K; F; J--; )n[J]=J<b ? 0: I / 2	; F; x; )h[--x]=0; s=M x); k=256; C
=4-C; B=C/4;  s=_(_(T,0),0); F ; -- z  ; ){ R=atoi(*++y); c=R>0?K=R,c :-2*R; 
} z=G/K+1; z X g>z; I++; c++; F ;  ++ J<l; ){ P u=0,C,y; E H =e+U,o= H+b*T,r
=o-2*T,v=r-T; F; x<G; x++){ p( H , o -T,o); o X T; H X T; q[x]= .7*(q[x-1]+h
			       [x] ); 
			       } p(H,
			       H,r ); 
			       F;  x; 
			      ) { E S= 
			     e ; w  l =
			  "" !{   ,;lf6D@""
			; j X 1-g; F; *++l; 
		      ){ *S++ =*j; j X*l%3*g-
		    g+*l%5*b-3*b; } y =M  x-G); 
		  y =M-J)* M-x)+ M-J-1)*y+.01; y=
		sqrt((u+q[--x]+.1)/y ); o-=T; C i)+
	      #define Z(x)(t(0,(x-C)/y)-l+1e-6*(x-Q))
	    .5; K=M-B); { N f=I,Q=0; F; f-Q>c; ){ P l=0
	  ; N H = C+c/2+1; H%=c; H X(f+Q+c-2*H)/2/c*c; l=
	Z(Q); O=(A-W)*Z(H)/Z(f); _(O,R=B?K>= H:L/k>O+W); *(
      R?&Q:&f)=H; } Q X f; *S=*j=Q/=2; s=B?s:Q+k; f=Q+n[x/z]; 
    n[x/z]=x%z+J%(z*2/g)?f:!putc(x?l[4*g*f/z/z/I-8]:10,stderr); 
  H-=U; F O=156; O--; ){ H--; *H=e[O%U]*e[O/U]/y+.8**H; } C-=Q+.5
; y i/.9)-Q-C; p(p(r+T,r,r),H,r); h[x]=.7*h[x]+C*C; u X h[x]; u*=.7
       ; d X C>0?-y:y; } } j X 9; } _(_(x,x),x); } D 0; } 
","#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#define e(t, v, w) n t(u x, u y) { n a = sqrt(x+y); r ((v - a) * (w - a)); }
#define w while(
#define r return
typedef char u; typedef short q; typedef double n;
u *z = ""Z\253\345\252\256\351\325\232\265f\256\246nyZf\253U^\266\232]z\352i\236\226i[m\266\351\252\255\246\235V\247e\235\226\276Z\371jUg\x3\362\212pX\254\251PH\253\332\225\373\235\b\v\336HO.\203Qf\201\x1d\207\211\357\367S7|)=\331n\x4!E<\233Z\246\x1flv\232d(r\263\274\375\313\305\200\361\302\327\274\375\300\201c\250-|\246]\304\253I\377W\227R^\251\350\x2""""C\251\203\311O\346\242\vDh\r\357\306x\325\274\315\366c\th\325\272\376\311X+:\325\354q\263|\257\x1c\327\316g\204\266s\211\357\370A(\x11""""D\321\x1d:\352\327\x1bk@\x11""""E-\310s\271\235\304\273\x2+\x4I\274jT\256\363\214\307{\232a\3270\a+qm\270\aI\315\337\220\x17\x18\315G\217\371@\215\335\v[v\335\205\343\250-|\246\373:\225\f\2552Oe]\206U\272\355\x10\327)u\rY]\276>\243\333w{3\x19\v""""acC8\3775\351\b\377\204lJnsy.:\330\2553rKx'\362'!%\302\271\376|\236skq\242C\251\263&\x15K\x4""""fA\227\211\242r7]\371\333\200z%\277\207CJ\255^}\264\237\327\275Z\n;L\x1aN#\371N\354G\256skq\242K!\364\211E\214\x17\377\343z\340w\233\272\354eTD\262t\365\335[_\233\225J\313\2746\334\x3\b\244F&\240]\222\332\210\351\376rJs<\2265I;\203Xd\272\377\345\214\x17\263]2I\237\302\253\346\355\332\343\350G\327\""\350f}\301n\223\366\300\210\343j\247\316%\363\210\345\n\252\215c\255\314\3248\300\261\350RM7\203\261\371\265\r_\220\x17\x19\a(+u\x1d=I\235\314\331@\310Cl\x16\210\307\345\357\306\x1f""""e\345R\354y\257\367\350!.\x1f`\345uW&\204\246\367>\226\335\205\353\x18\336;\302\334\266\213Fn\233\201vAE\325+qnVR\222e\237E<e\203!f\333\345[\x17#\205\273I\314\371n\340\304\205\225h\323\336\371\x1c""""7\227\201%\327\201p\326\263\351f\x19\a\v\336;uI\312?\214\265I1$\302+\373\233v\336\x5\306,y\313OD\351d*\350f\357H\262]\x3\332l\365L\237Qs\320{\231\244\204d\352v\335\215\327\357\200\247\302W\x10"", x, y;
n g() { r (n)rand()/18972; } n t, v; q F, B, C; e(a, 0, 3.0) e(b, 3.0, 4.125) 
e(c, 4.125, 9) u f(n (*h)()) { do { t=g() * 6.283184; v = sqrt(g() * 72); y = 
sin(t) * v; x=cos(t)*v; } w (h(x*x,y*y)>=0)||(fabs(x) > 5) || (fabs(y) > 5));
r ((y+5) * 11) + x + 7; } u k(q x, u l) { u o = 0; F = 0; w F < 189) { B =C =
0; w 1) { y = ((z[F/4]>>((F++%4)*2))&3) - 1; if (y&2) 
break; C = (C*2)+y, ++B; } if (!(C - x | B - l)) r (o<26)?o+0x61:((2108973>>(
(o-26)*8))&47); ++o; } r 1; } u s[1079]; u *E(u v) { u *x = s; w v--)w *(x++)
); r x; } main() { q A = 0, B = 0, C = 1078; u l = 0; u *p = s; srand(time( 0
) ); w C) { A = (A*2) + ((((z[B/8+48]+114)^2)>>(7-(B++%8)))&1),++l; x = k(A,l
); if (x-1) { *(p++)=x, A=l=0, C--; } } printf(""%s%s %s%s%s\n"", E(0), E(f(c))
, E(f(a)), E(1), E(f(b))); }
","b'#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#define e(t, v, w) n t(u x, u y) { n a = sqrt(x+y); r ((v - a) * (w - a)); }\n#define w while(\n#define r return\ntypedef char u; typedef short q; typedef double n;\nu *z = ""Z\xab\xe5\xaa\xae\xe9\xd5\x9a\xb5f\xae\xa6nyZf\xabU^\xb6\x9a]z\xeai\x9e\x96i[m\xb6\xe9\xaa\xad\xa6\x9dV\xa7e\x9d\x96\xbeZ\xf9jUg\\x3\xf2\x8apX\xac\xa9PH\xab\xda\x95\xfb\x9d\\b\\v\xdeHO.\x83Qf\x81\\x1d\x87\x89\xef\xf7S7|)=\xd9n\\x4!E<\x9bZ\xa6\\x1flv\x9ad(r\xb3\xbc\xfd\xcb\xc5\x80\xf1\xc2\xd7\xbc\xfd\xc0\x81c\xa8-|\xa6]\xc4\xabI\xffW\x97R^\xa9\xe8\\x2""""C\xa9\x83\xc9O\xe6\xa2\\v\x7fDh\\r\xef\xc6x\xd5\xbc\xcd\xf6c\x7f\\th\xd5\xba\xfe\xc9X+:\xd5\xecq\xb3|\xaf\\x1c\xd7\xceg\x84\xb6s\x89\xef\xf8A(\\x11""""D\xd1\\x1d:\xea\xd7\\x1bk@\\x11""""E-\xc8s\xb9\x9d\xc4\xbb\\x2+\\x4I\xbcjT\xae\xf3\x8c\xc7{\x9aa\xd70\\a+qm\xb8\\aI\xcd\xdf\x90\\x17\\x18\xcdG\x8f\xf9@\x8d\xdd\\v[v\xdd\x85\xe3\xa8-|\xa6\xfb:\x95\\f\xad2Oe]\x86U\xba\xed\\x10\xd7)u\\rY]\xbe>\xa3\xdbw{3\\x19\\v""""acC8\xff5\xe9\\b\xff\x84lJnsy.:\xd8\xad3rKx\'\xf2\'!%\xc2\xb9\xfe|\x9eskq\xa2C\xa9\xb3&\\x15K\\x4""""fA\x97\x89\xa2r7]\xf9\xdb\x80z%\xbf\x87CJ\xad^}\xb4\x9f\xd7\xbdZ\\n;L\\x1aN#\xf9N\xecG\xaeskq\xa2K!\xf4\x89E\x8c\\x17\xff\xe3z\xe0w\x9b\xba\xeceTD\xb2t\xf5\xdd[_\x9b\x95J\xcb\xbc6\xdc\\x3\\b\xa4F&\xa0]\x92\xda\x88\xe9\xferJs<\x965I;\x83Xd\xba\xff\xe5\x8c\\x17\xb3]2I\x9f\xc2\xab\xe6\xed\xda\xe3\xe8G\xd7\\""\xe8f}\xc1n\x93\xf6\xc0\x88\xe3j\xa7\xce%\xf3\x88\xe5\\n\xaa\x8dc\xad\xcc\xd48\xc0\xb1\xe8RM7\x83\xb1\xf9\xb5\\r_\x90\\x17\\x19\\a(+u\\x1d=I\x9d\xcc\xd9@\xc8Cl\\x16\x88\xc7\xe5\xef\xc6\\x1f""""e\xe5R\xecy\xaf\xf7\xe8!.\\x1f`\xe5uW&\x84\xa6\xf7>\x96\xdd\x85\xeb\\x18\xde;\xc2\xdc\xb6\x8bFn\x9b\x81vAE\xd5+qnVR\x92e\x9fE<e\x83!f\xdb\xe5[\\x17#\x85\xbbI\xcc\xf9n\xe0\xc4\x85\x95h\xd3\xde\xf9\\x1c""""7\x97\x81%\xd7\x81p\xd6\xb3\xe9f\\x19\\a\\v\xde;uI\xca?\x8c\xb5I1$\xc2+\xfb\x9bv\xde\\x5\xc6,y\xcbOD\xe9d*\xe8f\xefH\xb2]\\x3\xdal\xf5L\x9fQs\xd0{\x99\xa4\x84d\xeav\xdd\x8d\xd7\xef\x80\xa7\xc2W\\x10"", x, y;\nn g() { r (n)rand()/18972; } n t, v; q F, B, C; e(a, 0, 3.0) e(b, 3.0, 4.125) \ne(c, 4.125, 9) u f(n (*h)()) { do { t=g() * 6.283184; v = sqrt(g() * 72); y = \nsin(t) * v; x=cos(t)*v; } w (h(x*x,y*y)>=0)||(fabs(x) > 5) || (fabs(y) > 5));\nr ((y+5) * 11) + x + 7; } u k(q x, u l) { u o = 0; F = 0; w F < 189) { B =C =\n0; w 1) { y = ((z[F/4]>>((F++%4)*2))&3) - 1; if (y&2) \nbreak; C = (C*2)+y, ++B; } if (!(C - x | B - l)) r (o<26)?o+0x61:((2108973>>(\n(o-26)*8))&47); ++o; } r 1; } u s[1079]; u *E(u v) { u *x = s; w v--)w *(x++)\n); r x; } main() { q A = 0, B = 0, C = 1078; u l = 0; u *p = s; srand(time( 0\n) ); w C) { A = (A*2) + ((((z[B/8+48]+114)^2)>>(7-(B++%8)))&1),++l; x = k(A,l\n); if (x-1) { *(p++)=x, A=l=0, C--; } } printf(""%s%s %s%s%s\\n"", E(0), E(f(c))\n, E(f(a)), E(1), E(f(b))); }\n'","	
		    #define/**/X
		  char*d=""X0[!4cM,!""
	       ""4cK`*!4cJc(!4cHg&!4c$j""
	     ""8f'!&~]9e)!'|:d+!)rAc-!*m*""
	   "":d/!4c(b4e0!1r2e2!/t0e4!-y-c6!""
	  ""+|,c6!)f$b(h*c6!(d'b(i)d5!(b*a'`&c""
	  "")c5!'b+`&b'c)c4!&b-_$c'd*c3!&a.h'd+""
	 ""d1!%a/g'e+e0!%b-g(d.d/!&c*h'd1d-!(d%g)""
	""d4d+!*l,d7d)!,h-d;c'!.b0c>d%!A`Dc$![7)35E""
       ""!'1cA,,!2kE`*!-s@d(!(k(f//g&!)f.e5'f(!+a+)""
       ""f%2g*!?f5f,!=f-*e/!<d6e1!9e0'f3!6f)-g5!4d*b""
       ""+e6!0f%k)d7!+~^'c7!)z/d-+!'n%a0(d5!%c1a+/d4""
       ""!2)c9e2!9b;e1!8b>e/!     7cAd-!5fAe+!7fBe(!""
      ""8hBd&!:iAd$![7S,Q0!1     bF 7!1b?'_6!1c,8b4""
      ""!2b*a,*d3!2n4f2!${4    f.      '!%y4e5!&f%""
     ""d-^-d7!4c+b)d9!4c-a    'd        :!/i('`&d""
     "";!+l'a+d<!)l*b(d=!'   m-        a  &d>!&d'""
    ""`0_&c?!$dAc@!$cBc@!$   b         <    ^&d$`""
    "":!$d9_&l++^$!%f3a'    n1        _       $ !&""
   ""f/c(o/_%!(f+c)q*c     %!         *       f &d+""
   ""f$s&!-n,d)n(!0i-     c-         k)       !  3d""
   ""/b0h*!H`7a,![7*     i]          5        4   71""
  ""[=ohr&o*t*q*`*d      *v         *r         ;  02""
  ""7*~=h./}tcrsth      &t          :          r   9b""
 ""].,b-725-.t--//      #r         [           <   t8-""
 ""752793?  <.~;b      ].t--+r     /           #    53""
 ""7-r[/9~X  .v90      <6/<.v;-52/={            k   goh""
 ""./}q;   u  vto     hr  `.i*$engt$            $    ,b""
 "";$/     =t ;v;     6     =`it.`;7=`          :    ,b-""
 ""725    = / o`.    .d       ;b]`--[/+       55/     }o""
 ""`.d   :   - ?5    /           }o`.'     v/i]q      - ""
 ""-[;   5  2  =`  it            .        o;53-       . ""
 ""v96   <7 /      =o            :            d        =o""
 ""--/i  ]q--      [;           h.            /        = ""
 ""i]q--[  ;v      9h           ./            <        - ""
 ""52={cj   u      c&`          i   t       . o        ; ""
 ""?4=o:d=         o--          /  i        ]q         - ""
 ""-[;54={  cj     uc&          i]q          -          -""
 ""[;76=i]q[;6     =vsr        u.i           /          ={""
 ""=),BihY_gha     ,)\0        ""             ,          o [
  3217];int i,   r,w,f        ,              b        ,x ,
  p;n(){return   r  <X        X               X       X  X
  768?d[X(143+   X  r++       +               *d      )  %
   768]:r>2659   ?  59:       (                x      =  d
   [(r++-768)%   X  947      +             768]       ) ?
   x^(p?6:0):(p  =   34      X            X           X )
   ;}s(){for(x=  n   ();     (           x^           ( p
  ?6:0))==32;x=  n    ()     )   ;return x            ; }
  void/**/main X      ()     {           r           =  p
  =0;w=sprintf  (X     X     X         X X           X o
  ,""char*d="");  for          (    f=1;f <            * d
  +143;)if(33-(  b=d         [      f++ X           ]  )
  ){if(b<93){if   X(!        p          )             o
   [w++]=34;for    X(i       =         35             +
    (p?0:1);i<b;    i++      )         o
    [w++]=s();o[     w++               ]
     =p?s():34;}     else              X
       {for(i=92;     i<b;            i
	++)o[w++]=     32;}           }
	     else o     [w++          ]
			 =10;o        [
			   w]=0      ;
			    puts(o);}
","#include                                                      <EXTERN.h>
#include                                                        <perl.h>
#include                                                        <XSUB.h>
#include                                                        <math.h>
#define                            qq                           __FILE__
#define                            cc                            (((3)))
#define                     ZZ(YY,WW) XS(YY)                     {AV*gg\
= perl_get_av(              ""SS"",cc-cc); SV*              Ss,*uu; char \
ii=*(SvPV(                  perl_get_sv(""_"",                  0*cc),na)\
) %(36+cc); (               av_len(gg) <1)?(               perl_call_pv\
(""__"",0/cc)):(Ss            =av_pop(gg), uu=            av_pop(gg),(((i\
i==pow(2,cc))||(            ii==(40-cc)))&&(            SvNV(Ss)==0))?(\
av_push(gg,uu),             av_push (gg,Ss),             perl_call_pv(""\
_"",3-cc)):(                   av_push (gg,                   newSVnv(WW\
) )                               ,1))                               ; }
ZZ(uu,SvNV(uu)-             (SvNV(Ss)*(SvIV(             uu)/SvIV(Ss))))
ZZ(ii,SvNV                  (uu)-SvNV(Ss))ZZ                 (ff,SvNV(Ss
)+SvNV(uu))ZZ(gg             ,pow(SvNV(uu),             SvNV(Ss)))ZZ(Ss,
SvNV(uu)/SvNV(Ss            ))ZZ(ss,SvNV(Ss)            * SvNV(uu)) void
bb( ){                      newXSproto(""UU"",                      ff,qq,
""""); newXSproto(            ""W""""W"",ii,qq,"""")            ;newXSproto(""TT""
,ss,qq,"""")                  ; newXSproto(""Y""                  ""Y"",Ss,qq,
""""); newXSproto(            ""vv"",uu, qq,"""");            newXSproto(""aa"",
gg,qq,""""); }int             main(int _,char*             *__, char**ee){
PerlInterpreter*            aa=perl_alloc();            char*dd[]= { """",
""-e"", ""0""} ;                 perl_construct                 (aa); perl_\
parse(aa, bb,                  cc,dd ,ee)                  ;perl_eval_sv
(newSVpv(""_:$_=               <> ; defined               or exit; @ARGV""
""=split; __:$_=             shift;defined or             goto _; chomp ""
"";(m*^\\x70oO""              ""\\x74$*i)?(pri""              ""nt \""$_ w\\x""
""61s h\\145r\\x""            ""65!\\n\""):((m*""            ""^\\s\\*(-?\\d+""
""(\\.\\d+)?)\\s""            ""\\*$*)?(push@SS            ,$1):(&{chr(((o""
""rd)%39)+3**4)x2             } )); goto __;             sub ff { @SS= (""
"")} sub __{print            \""stack empty\\""            ""n\""} sub ss{$#""
""SS<0 and goto &            __; print $SS[$""            ""#SS].\""\\n\""} ""
""sub SS{ $#SS<0              and goto &__ ;              print pop @SS}""
""sub _ { print              \""divide by zer""            ""o\\n\""}sub ii{""
""map{ print\""$_""            ""\\n\"" } reverse            @SS} sub AUTOLO""
""AD { print\""un""            ""implemented\\n""            ""\""} sub gg{ $#""
""SS<0 and goto              &__;push@SS,$SS[            $#SS]} sub uu{ ""
""$#SS<1 and goto            &__;$SS[ $#SS]+=            $SS[$#SS-1];$SS""
""[$#SS-1]=$SS[$""            ""#SS]-$SS[$#SS-""            ""1]; $SS[$#SS]-""
""=$SS[$#SS-1]}                   "",0),0                   ); exit(cc); }
","/*
 * Calculates the Julian Day from any day,month,year tuple.
 *
 * This is valid for all dates, including both julian and gregorian calendars.
 *
 * The algorithm is taken from Astronomical Algorithms by Jean Meeus.
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double dmy2jd(double d, int m, int y) {
    int b;

    if (m <= 2) {
	y--;
	m += 12;
    }
    
    /* Handle Julian dates */
    if (y < 1582 || (y == 1582 && (m < 10 || (m == 10 && d <= 4)))) {
	b = 0;
    } else {
	int a;

	a = y/100;
	b = 2 - a + a/4;
    }

    return (int)(365.25 * (y+4716)) + (int)(30.6001 * (m+1)) + d + b - 1524.5;
}

int main(int argc, char **argv) {
    double jd;

    if (argc != 4) {
	fprintf(stderr, ""usage: %s day_float month_int year_int\n"", argv[0]);
	return 1;
    }

    jd = dmy2jd(atof(argv[1]), atoi(argv[2]), atoi(argv[3]));
    printf(""%f\n"", jd);

    return 0;
}
","#include<stdlib.h>
#include<Xlib.h>
#include<keysym.h>
#define b(b)XDraw##b(i,J,k,
#define l :q==
#define o if(
#define a for(
#define t(t)XSetForeground(i,k,t##Pixel(i,0));
#define i(i)o g>1&&*P==*#i){ g--; m[g-1]i##=m[g]; } else
#define n (W-r)
#define s (Z-u)
#define I n*Q-Q,(s+2)*S,Q*3,Q*3,360*A/F*64,360*e/F*64);
#define d E[X][Y]
#define e m[q]
int   q,P,W,Z,X,Y,r,u; char   E[U][U][T+1] ,D[T];   Window J; GC k;  XEvent  w;
 Display*i; v(c,j ,K){ char*P=E[c][j],*X,g=0;  double A=0,F=0,m[T];  a;  K<U&&*
 P;   ){ m[g]=strtod(P  ,&X); a  q=-1;   ++q  <g; F+=*P==64? e:0,A=*P==33 ? e>A
? e:A  :0);  o    isupper(*P)*isdigit(P[1])){ o v(*P-65  ,atoi(P+1)  ,K+1))goto
i; a     m[g++]=atof(D);     P++&&isdigit(*P); ); } else o P-X){  g++;  P=X;  }
else{ i(=)i(+)i(-)i(*)i(/)o  *P-32)goto i;  P++; } }  o !--g)return !sprintf(D,
 ""%10.2f"",*m); i: a; A&&q--; XFillRectangle(i,J,k,(n+q)*Q+S,s*S+S-K,Q/2,K))K=Q*
  e/A; a;  q--&&F;  A+=e){ o     q%2)t(White)XFillArc(i,J,k,I  t(Black)b(Arc)I}
   return   !!strcpy(D   ,E[c][j]); } main(){  read(q,E,z);  i=XOpenDisplay(0);
k=XCreateGC(i,J=RootWindow(i,W),Z,0); XSelectInput(i  ,J=XCreateSimpleWindow(i,
J,P,q,M ,H ,r,u ,WhitePixel(i,X))  ,ButtonPressMask|KeyPressMask|ExposureMask);
a   XMapWindow(i,J); ;   b(String)S ,S,d ,P=strlen(d))){    XNextEvent(i  ,&w);
  XLookupString(&w.xkey,D ,1,&q,0);  q &    96&&q<128  ?   d[P++]=q l C ? Y-- l
L ? Y++  l V ? X++ l  _  ?  d[--P]=0 l   O&&X ? X--:P; o  w.type==ButtonPress){
X=r   +(w.xbutton.x-S)/  Q;     Y=u+w.xbutton.y/S-1;  } X%=26; a  X>r+p ?   r++
 :X;  X<r;   r--);  Y%=U; o  Y<1)Y=1; a; q== R;  exit(write(1 ,E,z))); a  Y>u+G
? u++  :u;  Y<=u; u--);   XClearWindow(i,J); a  Z=u+1;  sprintf(D  ,""%3d"" ,Z)&&
Z<=u+G; Z++){ b(String)0,(s+2)*S-B,D,3); a  W=r;   W<=r+p;  b(String)n*Q+S+N,S*
2-B,D,1),W++){ b(Rectangle)n*Q+S,s*S+S,Q,S); v(W,Z,0);  b(String)n*Q+S+N,(s+2)*
S-B,D ,strlen(D)); *D=65+W; } } b(Rectangle)(X-r) *Q+S+1,(Y-u) *S+S+1,Q-2,S-2);
             }                                                        }        
","/* $Id: mkentry.c,v 1.6 1999/01/27 23:19:37 chongo Exp $ */
/*
 * Copyright (c) Leonid A. Broukhis, Jeremy Horn, Landon Curt Noll and
 * Peter Seebach, 1998.
 *
 * All Rights Reserved.  Permission for personal, education or non-profit use
 * is granted provided this this copyright and notice are included in its
 * entirety and remains unaltered.  All other uses must receive prior
 * permission in writing from the contest judges.
 */
/*
 * mkentry - make an International Obfuscated C Code Contest entry
 *
 * usage:
 *	mkentry -r remarks -b build -p prog.c -o ioccc.entry
 *
 *	-r remarks		file with remarks about the entry
 *	-b build		file containing how prog.c should be built
 *	-p prog.c		the obfuscated program source file
 *	-o ioccc.entry		ioccc entry output file
 *
 * compile by:
 *	cc mkentry.c -o mkentry
 */
/*
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
/*
 * WARNING:
 *
 * This program attempts to implement the IOCCC rules.  Every attempt
 * has been made to make sure that this program produces an entry that
 * conforms to the contest rules.  In all cases, where this program
 * differs from the contest rules, the contest rules will be used.  Be
 * sure to check with the contest rules before submitting an entry.
 *
 * FOR MORE INFORMATION:
 *
 *   You may contact the judges by sending EMail to the following address:
 *
 *	questions@ioccc.org	(not the address for submitting entries)
 *
 *  Questions and comments about the contest are welcome.
 *
 *  Entries must be sent to:
 *
 *	entry@ioccc.org
 *
 *  but be sure to follow the rules and read the guidelines first!
 *
 *  The rules and the guidelines may (and often do) change from year to
 *  year.  You should be sure you have the current rules and guidelines
 *  prior to submitting entries.  To obtain them, visit the following URL:
 *
 *	http://www.ioccc.org
 *
 * Because contest rules change from year to year, one should only use this
 * program for the year that it was intended.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

/* logic */
#ifndef TRUE
# define TRUE 1
#endif /* TRUE */
#ifndef FALSE
# define FALSE 0
#endif /* FALSE */
#define EOF_OK TRUE
#define EOF_NOT_OK FALSE

/* global limits */
#define RULE_YEAR 2000		/* NOTE: should match the current year */
#define START_DATE ""01Feb2000 00:00 UTC"" /* first confirmation received */
#define MAX_COL 79		/* max column a line should hit */
#define MAX_BUILD_SIZE 256	/* max how to build size */
#define MAX_PROGRAM_SIZE 3217	/* max program source size */
#define MAX_PROGRAM_SIZE2 1536	/* max program source size not counting
				   whitespace and {}; not followed by
				   whitespace or EOF */
#define MAX_TITLE_LEN 31	/* max chars in the title */
#define MAX_ENTRY_LEN 1		/* max length in the entry input line */
#define MAX_ENTRY 8		/* max number of entries per person per year */
#define MAX_FILE_LEN 1024	/* max filename length for a info file */

/* where to send entries */
#define ENTRY_ADDR ""entry@ioccc.org""

/* uuencode process - assumes ASCII */
#define UUENCODE(c) ((c) ? encode_str[(int)(c)&0x3f] : '`')
#define UUENCODE_LEN 45		/* max uuencode chunk size */
#define UUINFO_MODE 0444	/* mode of an info file's uuencode file */
#define UUBUILD_MODE 0444	/* mode of the build file's uuencode file */
#define UUBUILD_NAME ""build""	/* name for the build file's uuencode file */
#define UUPROG_MODE 0444	/* mode of the program's uuencode file */
#define UUPROG_NAME ""prog.c""	/* name for the program's uuencode file */

/* encode_str[(char)val] is the uuencoded character of val */
char encode_str[] = ""`!\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"";

/* global declarations */
char *program;			/* our name */
long start_time;		/* the startup time */

/* forward declarations */
void parse_args(int argc, char **argv, char **rname,
	        char **bname, char **pname, char **oname);
void usage(int exitval);
FILE *open_remark(char *filename);
FILE *open_build(char *filename);
FILE *open_program(char *filename);
FILE *open_output(char *filename);
void output_entry(FILE *output, char *oname);
void output_remark(FILE *output, char *oname, FILE *remark, char *rname);
void output_author(FILE *output, char *oname);
void output_info(FILE *output, char *oname);
void output_build(FILE *output, char *oname, FILE *build, char *bname);
void output_program(FILE *output, char *oname, FILE *prog, char *pname);
void output_end(FILE *output, char *oname);
int get_line(char *buf, int siz, int maxcol);
void output_till_dot(FILE *output, char *oname, char *leader);
int col_len(char *string);
void check_io(FILE *stream, char *name, int eof_ok);
void uuencode(FILE *output, char *oname, FILE *infile,
	      char *iname, int umode, char *uname);

int
main(argc, argv)
    int argc;		/* arg count */
    char **argv;	/* the args */
{
    FILE *remark=NULL;	/* open remarks stream */
    FILE *build=NULL;	/* open build file stream */
    FILE *prog=NULL;	/* open program stream */
    FILE *output=NULL;	/* open output stream */
    char *rname=NULL;	/* file with remarks about the entry */
    char *bname=NULL;	/* file containing how prog.c should be built */
    char *pname=NULL;	/* the obfuscated program source file */
    char *oname=NULL;	/* ioccc entry output file */
    struct tm *tm;	/* startup time structure */

    /*
     * check on the year
     */
    start_time = time((long *)0);
    tm = gmtime(&start_time);
    if (tm->tm_year != RULE_YEAR-1900 &&
	(tm->tm_year != RULE_YEAR-1900+1 || tm->tm_mon != 0)) {
	fprintf(stderr,
	""%s: WARNING: this program applies to %d, which may differ from %d\n\n"",
	    argv[0], RULE_YEAR, 1900+tm->tm_year);
    }

    /*
     * parse the command line args
     */
    parse_args(argc, argv, &rname, &bname, &pname, &oname);

    /*
     * open/check the input and output files
     *
     * We open and truncate the output file first, in case it is the same
     * as one of the input files.
     */
    output = open_output(oname);
    remark = open_remark(rname);
    build = open_build(bname);
    prog = open_program(pname);
    if (output==NULL || remark==NULL || build==NULL || prog==NULL) {
	exit(1);
    }

    /*
     * output each section
     */
    output_entry(output, oname);
    output_remark(output, oname, remark, rname);
    output_author(output, oname);
    output_info(output, oname);
    output_build(output, oname, build, bname);
    output_program(output, oname, prog, pname);
    output_end(output, oname);

    /*
     * flush the output
     */
    if (fflush(output) == EOF) {
	fprintf(stderr, ""%s: flush error in %s: "", program, oname);
	perror("""");
	exit(2);
    }

    /*
     * final words
     */
    printf(""\nYour entry can be found in %s.  You should check this file\n"",
	oname);
    printf(""correct any problems and verify that the uudecode utility will\n"");
    printf(""correctly decode your build file and program.\n\n"");
    printf(""This program has been provided as a guide for submitters.  In\n"");
    printf(""cases where it conflicts with the rules, the rules shall apply.\n"");
    printf(""It is your responsibility to ensure that your entry conforms to\n"");
    printf(""the current rules.\n\n"");
    printf(""EMail your entries to:\n"");
    printf(""\t%s\n\n"", ENTRY_ADDR);
    printf(""Please use the following subject when you EMail your entry:\n"");
    printf(""\tioccc entry\n\n"");
    /* all done */
    return 0;
}

/*
 * parse_args - parse the command line args
 *
 * usage:
 *	argc	arg count
 *	argv	the args
 *	rname	file with remarks about the entry
 *	bname	file containing how prog.c should be built
 *	pname	the obfuscated program source file
 *	oname	ioccc entry output file
 *
 * Given the command line args, this function parses them and sets the
 * required name flags.  This function will return only if the command
 * line syntax is correct.
 */
void
parse_args(int argc, char **argv, char **rname,
	   char **bname, char **pname, char **oname)
{
    char *optarg;	/* -flag option operand */
    int flagname;	/* the name of the -flag */
    int i;

    /*
     * Not everyone has getopt, so we must parse args by hand.
     */
    program = argv[0];
    for (i=1; i < argc; ++i) {

	/* determine the flagname */
	if (argv[i][0] != '-') {
	    usage(1);
	    /*NOTREACHED*/
	}
	flagname = (int)argv[i][1];

	/* determine the flag's operand */
	if (flagname != '\0' && argv[i][2] != '\0') {
	    optarg = &argv[i][2];
	} else {
	    if (i+1 >= argc) {
		usage(2);
		/*NOTREACHED*/
	    } else {
		optarg = argv[++i];
	    }
	}

	/* save the flag's operand in the correct global variable */
	switch (flagname) {
	case 'r':
	    *rname = optarg;
	    break;
	case 'b':
	    *bname = optarg;
	    break;
	case 'p':
	    *pname = optarg;
	    break;
	case 'o':
	    *oname = optarg;
	    break;
	default:
	    usage(3);
	    /*NOTREACHED*/
	}
    }

    /*
     * verify that we have all of the required flags
     */
    if (*rname == NULL || *bname == NULL || *pname == NULL || *oname == NULL) {
	usage(4);
	/*NOTREACHED*/
    }
    return;
}

/*
 * usage - print a usage message and exit
 *
 * usage:
 *	exitval		exit with this value
 *
 * This function does not return.
 */
void
usage(int exitval)
{
    fprintf(stderr,
	""usage: %s -r remarks -b build -p prog.c -o ioccc.entry\n\n"", program);
    fprintf(stderr, ""\t-r remarks\tfile with remarks about the entry\n"");
    fprintf(stderr, ""\t-b build\tfile containing how prog.c should be built\n"");
    fprintf(stderr, ""\t-p prog.c\tthe obfuscated program source file\n"");
    fprintf(stderr, ""\t-o ioccc.entry\tioccc entry output file\n"");
    exit(exitval);
}

/*
 * open_remark - open/check the remark file
 *
 * usage:
 *	filename	remark filename
 *
 * The remark file should be indented by 4 spaces, and should not extend
 * beyond column MAX_COL.  These are not requirements, so we only warn.
 *
 * This function returns NULL on I/O or format error.
 */
FILE *
open_remark(char *filename)
{
    FILE *stream;		/* the opened file stream */
    char buf[BUFSIZ+1];		/* input buffer */
    int toolong=0;		/* number of lines that are too long */
    int non_indent=0;		/* number of lines not indented by 4 spaces */

    /*
     * open the remark input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open remark file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * look at each line
     */
    while (fgets(buf, BUFSIZ, stream) != NULL) {

	/* count lines that do not start with 4 spaces */
	if (buf[0] != '\n' && strncmp(buf, ""    "", 4) != 0) {
	    ++non_indent;
	}

	/* count long lines */
	if (col_len(buf) > MAX_COL) {
	    /* found a line that is too long */
	    ++toolong;
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* note long lines if needed */
    if (toolong > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s extend beyond the 80th column\n"",
	    program, toolong, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* note non-indented lines, if needed */
    if (non_indent > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s are not indented by 4 spaces\n"",
	    program, non_indent, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_build - open/check the build file
 *
 * usage:
 *	filename	build filename
 *
 * The how to build file must not be longer than MAX_BUILD_SIZE bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_build(char *filename)
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */

    /*
     * open the how to build input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_BUILD_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the how to build file: %s, is %ld bytes long\n"",
	    program, filename, (long) statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_BUILD_SIZE);
	return(NULL);
    }

    /* return the open file */
    return(stream);
}

/*
 * open_program - open/check the program source file
 *
 * usage:
 *	filename	source filename
 *
 * The program source file must be <= 3217 bytes.  The number of
 * non-whitespace and }{; chars not followed by whitespace must
 * be <= 1536 bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_program(char *filename)
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */
    int count;			/* special count size */
    int c;			/* the character read */

    /*
     * open the program source input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open program source file: %s: "",
	    program, filename);
	perror("""");
	exit(7);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat program source file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_PROGRAM_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the program source file: %s, is %ld bytes long\n"",
	    program, filename, (long) statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_PROGRAM_SIZE);
	return(NULL);
    }

    /*
     * count the non-whitespace, non {}; followed by whitespace chars
     */
    count = 0;
    c = 0;
    while ((c=fgetc(stream)) != EOF) {
	/* look at non-whitespace */
	if (!isascii(c) || !isspace(c)) {
	    switch (c) {
	    case '{':		/* count if not followed by EOF or whitespace */
	    case '}':
	    case ';':
		/* peek at next char */
		c = fgetc(stream);
		if (c != EOF && isascii(c) && !isspace(c)) {
		    /* not followed by whitespace or EOF, count it */
		    ungetc(c, stream);
		    ++count;
		}
		break;
	    default:
		++count;
		break;
	    }
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* look at the special size */
    if (count > MAX_PROGRAM_SIZE2) {
	fprintf(stderr,
	    ""%s: FATAL: the number of bytes that are non-whitespace, and\n"",
	    program);
	fprintf(stderr,
	    ""%s:        that are not '{', '}', ';' followed by whitespace\n"",
	    program);
	fprintf(stderr,
	    ""%s:        or EOF must be <= %d bytes\n"",
	    program, MAX_PROGRAM_SIZE2);
	fprintf(stderr,
	    ""%s:        in %s, %d bytes were found\n"",
	    program, filename, count);
	return(NULL);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_output - open/check the entry output file
 *
 * usage:
 *	filename	output filename
 *
 * This function returns NULL on open error.
 */
FILE *
open_output(char *filename)
{
    FILE *stream;		/* the opened file stream */

    /*
     * open the ioccc entry output file
     */
    stream = fopen(filename, ""w"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open ioccc entry file for output: %s: "",
	    program, filename);
	perror("""");
	exit(8);
    }

    /* return the open file */
    return(stream);
}

/*
 * output_entry - output the ---entry--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_entry(FILE *output, char *oname)
{
    char title[MAX_TITLE_LEN+1+1];	/* the entry's title */
    char buf[MAX_COL+1+1];		/* I/O buffer */
    int entry=0;			/* entry number */
    int ret;				/* fields processed by fscanf */
    int ok_line=0;			/* 0 => the line is not ok */
    char skip;				/* input to skip */
    time_t epoch_sec;			/* seconds since the epoch */
    char *p;

    /*
     * write the start of the section
     */
    fprintf(output, ""---entry---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the rule year
     */
    fprintf(output, ""rule:\t%d\n"", RULE_YEAR);
    check_io(output, oname, EOF_NOT_OK);

    /* determine if this is a fix */
    printf(""Is this a fix, update or resubmittion to a "");
    printf(""previous entry (enter y or n)? "");
    while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    if (buf[0] == 'y') {
	fprintf(output, ""fix:\ty\n"");
	check_io(output, oname, EOF_NOT_OK);
	printf(""\nBe sure that the title and entry number that you give\n"");
	printf(""are the same of as the entry you are replacing\n"");
    } else {
	fprintf(output, ""fix:\tn\n"");
	check_io(output, oname, EOF_NOT_OK);
    }

    /*
     * write the title
     */
    printf(""\nThe first character of your title should match [a-zA-Z0-9_=]\n"");
    printf(""The next 0 to %d characters should match [a-zA-Z0-9_=+-]\n\n"",
	MAX_TITLE_LEN-1);
    printf(""It is suggested, but not required, that the title should\n"");
    printf(""incorporate your username; in the\n"");
    printf(""case of multiple authors, consider using parts of the usernames\n"");
    printf(""of the authors.\n\n"");
    printf(""enter your title: "");
    do {
	/* prompt and read a line */
	if ((ok_line = get_line(title, MAX_TITLE_LEN+1, MAX_COL-9)) <= 0) {
	    printf(""\ntitle is too long, please re-enter: "");
	    continue;
	}

	/* verify the pattern, not everyone has regexp, so do it by hand */
	if (!isascii((int)title[0]) ||
	    !(isalnum((int)title[0]) || title[0] == '_' || title[0] == '=')) {
	    printf(""\ninvalid first character in the title\n\n"");
	    printf(""enter your title: "");
	    ok_line = 0;
	} else {
	    for (p=(&title[1]); *p != '\0' && *p != '\n'; ++p) {
		if (!isascii((int)*p) ||
		    !(isalnum((int)*p) ||
		      *p == '_' || *p == '=' || *p == '+' || *p == '-')) {
		    printf(""\ninvalid character in the title\n\n"");
		    printf(""enter your title: "");
		    ok_line = 0;
		}
	    }
	}
    } while (ok_line <= 0);
    fprintf(output, ""title:\t%s"", title);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the entry number
     */
    printf(""\nEach person may submit up to %d entries per year.\n\n"",
	MAX_ENTRY);
    printf(""enter an entry number from 0 to %d inclusive: "", MAX_ENTRY-1);
    do {
	/* get a valid input line */
	fflush(stdout);
	ret = fscanf(stdin, ""%d[\n]"", &entry);
	check_io(stdin, ""stdin"", EOF_NOT_OK);
	/* skip over input until newline is found */
	do {
	    skip = fgetc(stdin);
	    check_io(stdin, ""stdin"", EOF_NOT_OK);
	    if (skip != '\n') {
		/* bad text in input, invalidate entry number */
		entry = -1;
	    }
	} while (skip != '\n');

	/* check if we have a number, and if it is in range */
	if (ret != 1 || entry < 0 || entry > MAX_ENTRY-1) {
	    printf(
	      ""\nThe entry number must be between 0 and %d inclusive\n\n"",
		MAX_ENTRY-1);
	    printf(""enter the entry number: "");
	}
    } while (ret != 1 || entry < 0 || entry > MAX_ENTRY-1);
    fprintf(output, ""entry:\t%d\n"", entry);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the submission date
     */
    /* returns a newline */
    epoch_sec = time(NULL);
    fprintf(output, ""date:\t%s"", asctime(gmtime(&epoch_sec)));
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the OS/machine host information
     */
    printf(
      ""\nEnter the machine(s) and OS(s) under which your entry was tested.\n"");
    output_till_dot(output, oname, ""host:"");
}

/*
 * output_remark - output the ---remark--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	remark		stream to the file containing remark text
 *	rname		name of the remark file
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_remark(FILE *output, char *oname, FILE *remark, char *rname)
{
    char buf[BUFSIZ+1];		/* input/output buffer */

    /*
     * write the start of the section
     */
    fprintf(output, ""---remark---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * copy the remark file to the section
     */
    while (fgets(buf, BUFSIZ, remark) != NULL) {
	fputs(buf, output);
	check_io(output, oname, EOF_NOT_OK);
    }
    check_io(remark, rname, EOF_OK);

    /* be sure that the remark section ends with a newline */
    if (buf[strlen(buf)-1] != '\n') {
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);
    }
}

/*
 * output_author - output the ---author--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information from stdin, and write the author section.
 * If multiple authors exist, multiple author sections will be written.
 */
void
output_author(FILE *output, char *oname)
{
    char buf[MAX_COL+1+1];	/* I/O buffer */
    int more_auths;		/* TRUE => more authors to note */
    int auth_cnt=0;		/* number of authors processed */

    /*
     * prompt the user for the author section
     */
    printf(""\nEnter information about each author.  If your entry is after\n"");
    printf(""%s and before the contest deadline, the judges\n"", START_DATE);
    printf(""will attempt to EMail back a confirmation to the first author\n"");

    /*
     * place author information for each author in an individual section
     */
    do {

	/* write the start of the section */
	fprintf(output, ""---author---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* write the author */
	printf(""\nAuthor #%d name: "", ++auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nname too long, please re-enter: "");
	}
	fprintf(output, ""name:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the organization */
	printf(""\nEnter the School/Company/Organization of author #%d\n"",
	    auth_cnt);
	printf(""\nAuthor #%d org: "", auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter: "");
	}
	fprintf(output, ""org:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the address */
	printf(
	    ""\nEnter the postal address for author #%d.  Be sure to include\n"",
	    auth_cnt);
	printf(""your country and do not include your name.\n"");
	output_till_dot(output, oname, ""addr:"");

	/* write the EMail address */
	printf(
	    ""\nEnter the EMail address for author #%d.  Use an address from\n"",
	    auth_cnt);
	printf(
	    ""a registered domain or well known site.  If you give several\n"");
	printf(""forms, list them one per line.\n"");
	output_till_dot(output, oname, ""email:"");

	/* write the home page URL */
	printf(
	    ""\nEnter the fully qualified home page URL for author #%d\n"",
	    auth_cnt);
	printf(""including the http: part or type none: "");
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0 ||
	       (strncmp(buf, ""http://"", sizeof(""http://"")-1) != 0 &&
		strcmp(buf, ""none\n"") != 0)) {
	      printf(""\nURL too long, does not begin with http:// or\n"");
	      printf(""is not the word none\n"");
	}
	fprintf(output, ""url:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the anonymous status */
	printf(""\nShould author #%d remain anonymous (enter y or n)? "",
	    auth_cnt);
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	fprintf(output, ""anon:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* determine if there is another author */
	printf(""\nIs there another author (enter y or n)? "");
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	if (buf[0] == 'y') {
	    more_auths = TRUE;
	} else {
	    more_auths = FALSE;
	}
    } while (more_auths == TRUE);
    return;
}

/*
 * output_info - output the ---info--- section(s)
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information from stdin, and write the info section.
 * If multiple info files exist, multiple info sections will be written.
 */
void
output_info(FILE *output, char *oname)
{
    char infoname[MAX_FILE_LEN+1];	/* filename buffer */
    char yorn[1+1];		/* y or n answer */
    char *uuname;		/* name to uuencode as */
    FILE *infile;		/* info file stream */

    /*
     * prompt the user for info information
     */
    printf(""\nInfo files should be used only to supplement your entry.\n"");
    printf(""For example, info files may provide sample input or detailed\n"");
    printf(""information about your entry.  Because they are supplemental,\n"");
    printf(""the entry should not require them to exist.\n\n"");

    /*
     * while there is another info file to save, uuencode it
     */
    printf(""Do you have a info file to include (enter y or n)? "");
    while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    while (yorn[0] == 'y') {

	/* read the filename */
	printf(""\nEnter the info filename: "");
	while (get_line(infoname, MAX_FILE_LEN+1, 0) <= 0) {
	    printf(""\nInfo filename too long, please re-enter: "");
	}

	/* compute the basename of the info filename */
	/* remove the trailing newline */
	uuname = &infoname[strlen(infoname)-1];
	*uuname = '\0';
	/* avoid rindex/shrrchr compat issues, do it by hand */
	for (--uuname; uuname > infoname; --uuname) {
	    if (*uuname == '/') {
		++uuname;
		break;
	    }
	}

	/* attempt to open the info file */
	infile = fopen(infoname, ""r"");
	if (infile == NULL) {
	    fprintf(stderr, ""\n%s: cannot open info file: %s: "",
		program, infoname);
	    perror("""");
	    continue;
	}

	/*
	 * write the start of the section
	 */
	fprintf(output, ""---info---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* uuencode the info file */
	uuencode(output, oname, infile, infoname, UUINFO_MODE, uuname);

	printf(""\nDo you have another info file to include (enter y or n)? "");
	while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
    };
    return;
}

/*
 * output_build - output the ---build--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	build		open build file stream
 *	bname		name of the build file
 *
 * Read the needed information from stdin, and write the build section.
 */
void
output_build(FILE *output, char *oname, FILE *build, char *bname)
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---build---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, build, bname, UUBUILD_MODE, UUBUILD_NAME);
    return;
}

/*
 * output_program - output the ---program--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	prog		open program stream
 *	pname		name of program file
 *
 * Read the needed information form stdin, and write the program section.
 */
void
output_program(FILE *output, char *oname, FILE *prog, char *pname)
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---program---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, prog, pname, UUPROG_MODE, UUPROG_NAME);
    return;
}

/*
 * output_end - output the ---end--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information form stdin, and write the 'end section'.
 */
void
output_end(FILE *output, char *oname)
{
    /*
     * write the final section terminator
     */
    fprintf(output, ""---end---\n"");
    check_io(output, oname, EOF_NOT_OK);
    return;
}

/*
 * get_line - get an answer from stdin
 *
 * usage:
 *	buf		input buffer
 *	siz		length of input, including the newline
 *	maxcol		max col allowed, 0 => disable check
 *
 * This function will flush stdout, in case a prompt is pending, and
 * read in the answer.
 *
 * This function returns 0 if the line is too long, of the length of the
 * line (including the newline) of the line was ok.  This function does
 * not return if ERROR or EOF.
 */
int
get_line(char *buf, int siz, int maxcol)
{
    int length;			/* the length of the input line */

    /* flush terminal output */
    fflush(stdout);

    /* read the line */
    if (fgets(buf, siz+1, stdin) == NULL) {
	/* report the problem */
	check_io(stdin, ""stdin"", EOF_NOT_OK);
    }

    /* look for the newline */
    length = strlen(buf);
    if (buf[length-1] != '\n') {
	int eatchar;		/* the char being eaten */

	/* no newline found, line must be too long, eat the rest of the line */
	do {
	    eatchar = fgetc(stdin);
	} while (eatchar != EOF && eatchar != '\n');
	check_io(stdin, ""stdin"", EOF_NOT_OK);

	/* report the situation */
	return 0;
    }

    /* watch for long lines, if needed */
    if (maxcol > 0 && (length > maxcol || col_len(buf) > maxcol)) {
	/* report the situation */
	return 0;
    }

    /* return length */
    return length;
}

/*
 * output_till_dot - output a set of lines until '.' by itself is read
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	leader		the lead text for the first line
 *
 * This routine will read a set of lines until (but not including)
 * a single line with '.' is read.  The format of the output is:
 *
 *	leader:\tfirst line
 *	\tnext line
 *	\tnext line
 *	   ...
 *
 * This routine will not return if I/O error or EOF.
 */
void
output_till_dot(FILE *output, char *oname, char *leader)
{
    char buf[BUFSIZ+1];		/* input buffer */
    int count;			/* lines read */
    int done=FALSE;		/* TRUE => finished reading input */

    /* instruct the user on how to input */
    printf(""\nTo end input, enter a line with a single period.\n"");

    /* read lines until '.' or EOF */
    count = 0;
    while (!done) {
	/* issue the prompt */
	printf(""%s\t"", (count>0) ? """" : leader);
	fflush(stdout);

	/* get the line */
	if (get_line(buf, BUFSIZ, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter:\n\t"");
	    continue;
	}

	/* note if '.' was read */
	if (strcmp(buf, "".\n"") == 0) {
	    done = TRUE;
	}

	/* write line if we read something */
	if (!done) {
	    fprintf(output, ""%s\t%s"", (count++>0) ? """" : leader, buf);
	    check_io(output, oname, EOF_NOT_OK);
	}
    }

    /* if no lines read, at least output something */
    if (count <= 0) {
	fprintf(output, ""%s\t.\n"", leader);
	check_io(output, oname, EOF_NOT_OK);
    }
    return;
}

/*
 * col_len - determine the highest that a string would reach
 *
 * usage:
 *	string		the string to examine
 *
 * Given a string, this routine returns that a string would reach
 * if the string were printed at column 1.  Tab stops are assumed
 * to start at 9, 17, 25, 33, ...
 */
int
col_len(char *string)
{
    int col;	/* current column */
    char *p;	/* current char */

    /* scan the string */
    for (col=0, p=string; *p != '\0' && *p != '\n'; ++p) {
	/* note the column shift */
	col = (*p=='\t') ? 1+((col+8)/8*8) : col+1;
    }
    if (*p == '\n') {
	--col;
    }

    /* return the highest column */
    return col;
}

/*
 * check_io - check for EOF or I/O error on a stream
 *
 * usage:
 *	stream		the stream to check
 *	name		the name of this stream
 *	eof_ok		EOF_OK or EOF_NOT_OK
 *
 * Does not return if EOF or I/O error.
 */
void
check_io(FILE *stream, char *name, int eof_ok)
{
    /* test for I/O error */
    if (ferror(stream)) {
	fprintf(stderr, ""%s: error on %s: "", program, name);
	perror("""");
	exit(1);

    /* test for EOF */
    } else if (eof_ok == EOF_NOT_OK && feof(stream)) {
	fprintf(stderr, ""%s: EOF on %s\n"", program, name);
	exit(1);
    }
    return;
}

/*
 * uuencode - uuencode a file
 *
 * usage:
 *	output		output file stream
 *	oname		output filename
 *	infile		input file stream
 *	iname		input filename
 *	umode		the mode to put on the uuencode file
 *	uname		name to put on the uuencode file
 *
 * Perform the uuencoding process identical to the process performed
 * by the uuencode(1) utility.
 *
 * This routine implements the algorithm described in the uuencode(5)
 * 4.3BSD Reno man page.
 */
void
uuencode(FILE *output, char *oname, FILE *infile,
	 char *iname, int umode, char *uname)
{
    char buf[UUENCODE_LEN+1];	/* the uuencode buffer */
    int read_len;		/* actual number of chars read */
    int val;			/* 6 bit chunk from buf */
    char filler='\0';		/* filler uuencode pad text */
    char *p;

    /*
     * output the initial uuencode header
     */
    fprintf(output, ""begin %o %s\n"", umode, uname);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * clear out the input buffer
     */
    for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	*p = '\0';
    }

    /*
     * We will process UUENCODE_LEN chars at a time, forming
     * a single output line each time.
     */
    while ((read_len=fread(buf,sizeof(buf[0]),UUENCODE_LEN,infile)) > 0) {

	/*
	 * the first character is the length character
	 */
	fputc(UUENCODE(read_len), output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * We will convert 24 bits at a time.  Thus we will convert
	 * 3 sets of 8 bits into 4 sets of uuencoded 6 bits.
	 */
	for (p=buf; read_len>0; read_len-=3, p+=3) {

	    /* bits 0 to 5 */
	    val = (p[0]>>2)&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 6 to 11 */
	    val = ((p[0]<<4)&0x30) | ((p[1]>>4)&0x0f);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 12 to 17 */
	    val = ((p[1]<<2)&0x3c) | ((p[2]>>6)&0x03);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 18 to 23 */
	    val = p[2]&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);
	}

	/* end of UUENCODE_LEN line */
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * clear out the input buffer  (don't depend on bzero() or memset())
	 */
	for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	    *p = '\0';
	}
    }

    /* check the last read on the input file */
    check_io(infile, iname, EOF_OK);

    /* write end of uuencode file */
    fprintf(output, ""%c\nend\n"", UUENCODE(filler));
    check_io(output, oname, EOF_NOT_OK);
}
","#include <stdio.h>
#include <math.h>
double l;main(_,o,O){return putchar((_--+22&&_+44&&main(_,-43,_),_&&o)?(main(-43,++o,O),((l=(o+21)/sqrt(3-O*22-O*O),l*l<4&&(fabs(((time(0)-607728)%2551443)/405859.-4.7+acos(l/2))<1.57))["" #""])):10);}
","#define BeginProgram void main(int argc, char *argv[])
#define CloseBrace }
#define CommandLineArgument -1
#define Declare int i,j,n,Flag=1;
#define EndOfProgram return;
#define False 0;
#define ForLoop ;for
#define GetCommandLineArgument n=atoi(argv[1]);
#define i F1ag
#define If if
#define Increment ++
#define Is ==
#define LessThan *(c&64)*
#define LessThanOrEqualTo !=
#define Modulo %
#define OpenBrace {
#define PossibleFactor j
#define PossiblePrime i
#define Possib1ePrime (c=getchar())
#define PrimeNumber (c^(!i*n%64));
#define Print putchar
#define SetTo =
#define SmallestPrime 2
#define True 1
#define Variables char c;
#define Zero i%j

BeginProgram
OpenBrace
	Declare Variables
	GetCommandLineArgument

	ForLoop (PossiblePrime SetTo SmallestPrime ;
	         Possib1ePrime LessThanOrEqualTo CommandLineArgument ;
	         Increment PossiblePrime)
	OpenBrace
		F1ag SetTo True
		ForLoop (PossibleFactor SetTo SmallestPrime ;
		         PossibleFactor LessThan PossiblePrime ;
		         Increment PossibleFactor)
			If (PossiblePrime Modulo PossibleFactor Is Zero)
				F1ag SetTo False

		If (Flag Is True)
			Print PrimeNumber
	CloseBrace

	EndOfProgram
CloseBrace
","#		include				  <X11/Xlib.h>
#		include				    <math.h>
#		include				    <time.h>
#	      define W(f)			  f##Window(S,
#	      define  O ;			  break ; case
#	      define  _ *				s

        XID  w,r,l=45<<9,     d,v     =1,E;     GC V[2];	    typedef
       char  * K; Display     *S;   XGCValues   g; typedef        int Y; K j;
      double         *o,I    [99]   ,T=   0,t   ,_,   atof(     ); K	  X(K
     i){ for        (r=0  ; o=s-1  ,*i     ; i  ++       ) {   switch    (*i){
      struct        { K   Y; Y K,  t ;     XID  k ;      } Z;   K z=      j++;
     O  32L         :*o       *=_  --O     '}'  :*o      /=_    --O        73:
    *o += _        --O        61           :*o  -=_      --O   123
   :_=  sin        (_)       O 94         :_=   asin    (_)    O 47
  :_=   cos       (_)        O 45      : _=     fmod(_ ,2*     M_PI
  )O    076       :_=        sqrt      (_) O    33: t=*o;      *o=
  _;    _=t      O 48         :_=         cos   (_)     <0 O   86
 :j=    i O      43:          X(z           =""K I@I-""     )O   93:
 X(z =""/ ="")O    60           : i  =++     r -  4 ?       j-1  :i O         79
 :XDrawArc(S,   d,V           [(Y  )_]     ,(Y  ) (       399   +14        _ [
        -2]     ),(           Y)(  *""'    ""+14  _ [      -1])   ,2,2      ,0,l
        ) ;    { Z.           Y =   i -   127   +r/    3*2 ;     Z.K=    r%3+
        r/3    +1;            Z.t   =0; Z.k=E   ; XDrawText       (S,d,*V,(Y
        ) (    399            +14     *1[s-=     strlen(z)           ]),20,

		   &Z,1); } O 1:default:*i>90?I[*i-32]=_--:(*++s
			  =I[*i+(*i<73)*r]); } } } Y main
				  (Y G,K*A){ *A=

"" 8<$ $li >d# -d8Z'Et#)wWP]WM C\\TI)#%!DcUAvz% H2&08M\\%YaHAW}4+%g ;|XN%W|l!_Kz+$UgBix41r=H7b@_:X 4zS   EFo1i}= _D.%biA xF>)k*T(7&m \""G~ )TY *.^@$0.#yl<  66,/dI ;\\[![:- $u6 VnD  X+ )TY-L38 :%\"" )TY%8Z$ \""G|BfCb <Il8EC}  \""b  \037ST I{kT I-lT I!K ImT I!K =-`LQ { !L{ I[MQ { !M{ Ip@;P=I`L]!LQ ][M]!MQ ]lLL ;; IL;Q  @]>m@{;M} ^`K !T PIIIV[;I{ k;I/@{  K!=k;!={LM=M}  K!=jM!}T!=k@P=`+e+f+g+hK I-[K I-pEF=Q `FG=Q k@]aK]b;]cP]d@{ EIeK{ FIf;{ GIgP{ HIhVAE{ J{AE/  E0\117<"";

    w = DefaultScreen (						       S =
      XOpenDisplay(0)); W(					     XMap
	 )d =W(XCreateSimple					   ) W(
	   Root )w),0,0,800,80					,0,0
	      ,BlackPixel(S,w )))			      ; g.
		foreground=WhitePixel			   (S,w
		  ); *(Y *) &g=6; for			 (; v
		    [V ]=XCreateGC( S,d		       ,4 +
		       v, &g),!--v; ); for	    ( E=
			 XLoadFont(S,""10x20""	 ),81
			   [I]=2; I[84]=(      G>2?
			     atof(2[A])     -2451545
			       :time	  (0 )/ 3.75
			     /l -	10957.5)+ (T+=G
			   > 1?	      atof(A[1]):0); ){ t
			=5e4		*6013; s=I; for(j=*A
		      ;_++		   =pow (t,(j[ 2]*'_'-
		    3028		     +3[j])/t)*pow(6e-4+
		 1,j[			       sizeof* X(++j) ]+95
	       **j-				 3072.)-1; )j+=4; s-=
	    2; W				    (XClear)d); XFillArc
	  (S,d					      ,*V,385,25,0x1c,28,
	0,l)						; X( j+4); XSync(S,
     0) ;						   usleep(10000); } }
","#define A B.
#define C if( 
#define D >>E&1
#define F return
#define G typedef
#define H printf( I(
#define J(E,K) for(E=K; E--; )
#define L(M) =N(O.M)+3*N(O.M&O.P),
G
int
Q;
G
unsigned
R;
G
struct
{
Q
N,
S,
P,
T,
U,
V;
}
W;
R
_;
R
N(
R
X)
{
R
Y=
2,
Z;
for
(;
 Y
;
Y*=
Y)
{
Z=
-1
/-
~Y
;
X=
(X
/Y
&Z
)+
(X
&Z
)*
(Y
*_
-~-
_)
;
}
F
X;
}
W
S(
W
a)
{
W
B;
_=
1;
A
N=
N(
a.
S)
;
A
S=
N(
a.
N)
;
A
P=
N(
a.
P)
;
A
U=
-1
<<
30
;
A
V=
-a
.U
;
F
B;
}
Q
P(
Q
Y,
Q
b,
R
c)
{
Q
E=
Y+
(b
+8
)%
10
-5
+Y
/4
%2
&31
;
F
c
D||
Y/
4-
E/
4-
~-
(b
&2
)?
-1
:E
;
}
Q
T(
W
B,
Q
a,
Q
b)
{
Q
E=
P(
a,
b,
A
N)
;
F~
E?
A
S
D?
~P
(E
,b
,A
S|
A
N)
?128
|b
*32
|a
:-
1:
b*
32
|a
:E
;
}
Q
U(
W
B,
R
c,
Q
Y)
{
Q
E,
b;
J(
E,
32
)C
(A
N&
c)
D)
J(
b,
2<<
(A
P
D)
)C
T(
B,
E,
b)
>=
Y<<
7)
F
1;
F
0;
}
W
V(
W
B,
Q
Z)
{
R
E=
Z&
31
,b
=Z
/32
&3
,Y
=A
T=
P(
E,
b,
0)
,K
=1
<<
Y;
A
N|=
K;
A
P&=
~K
;
A
P|=
(A
P
D)
<<
Y;
_=
A
S
D&&
U(
B,
K,
1)
;
A
P|=
K&-
1<<
28
;
A
N&=
E=
~(
1<<
E)
;
A
P&=
E;
A
S&=
E;
F
Z>>
7?
V(
B,
b<<
5|
Y)
:B
;
}
W
d(
W
B,
Q
b)
;
R
e;
W
f(
W
B,
Q
E,
Q
b,
Q
g)
{
Q
h,
i=
0,
I,
j,
K,
k,
Z,
Y;
J(
h,
2<<
(A
P
D)
){
j=
T(
B,
E,
h)
;
C~
j&&
j>>
7!=
!~
g)
{
++
i;
C
A
U<=
A
V)
{
W
O;
O=
V(
B,
j)
;
K=
g<
0?
j:
g;
++
e;
I=
_?
f(
O,
O.
T,
b,
K)
.U
:(
Y=
b+
U(
O=
S(
O)
,-
1,
1)
)?
-(
d(
O,
~-
Y)
.U
):
(_
=0
,Z
L(
N)
k
L(
S)
(k
-Z
<<
 24
)/
(k
+Z
)+
(short
)rand
()
);
C
I>=
A
U)
{
A
U=
I;
A
T=
K;
}
}
}
}
_=
i;
F
B;
}
W
d(
W
B,
Q
b)
{
Q
E=
32
,Y
=
~U
(B
,-
1,
1)
;
for
(;
E--
&&
A
U<=
A
V;
)C
A
N
D)
{
B=
f(
B,
E,
b,
Y)
;
}
F
B;
}
char
l[
4095
],
*O
=l
,*
b;
char
*I
(char
*X
){
Q
Z=
1,
W=
0,
E,
M=
0,
B;
b=
O;
for
(;
 E
=
*X
++
;
){
E=
E%
65
%6
^2
;
M+=
B=
Z+
1+
E/
4;
W=
W<<
B^
E;
Z=
E<
2;
J(
E,
M/
7)
{
M%=
7;
W^=
(*
O++=
W>>
M)
<<
M;
}
}
*O
++=
0;
F
b;
}
Q
main
()
{
Q
K,
Y,
E,
m,
n,
o=
4,
g,
b,
Z;
W
B;
srand
(clock
()
);
A
S=
(A
N=
4095
)<<
20
;
A
P=
0;
for
(;
;
){
J(
K,
8)
{
J(
Y,
8)
{
E=
K*
4+
Y/
2;
H""	      	 }	{ 	}""
)+
(K
^Y
^1
)%
2*
2,
"".xoXO""
[(
A
P
D)
*2
+(
A
S
D)
*2
+(
A
N
D)
])
;
}
H""	   } }		} }	} }  		 ""
),
-~
E)
;
}
J(
g,
1)
{
O=
l;
H""}	 }	} }	{ }    	  }	}	} {  ;  ;			}""
)+
o/
2*
2)
;
e=
0;
C
o<
4)
B=
S(
B)
;
C!
U(
B,
-1
,0
))
{
H""	  	}	} {	;	{ ;	 }	; 	}	  } 		 ""
))
;
F
0;
}
H""	  	{  {	;	{ ;		 ;		 {	 ; ;	{	{ }  	}  ; ; { } 	   } }	; 	; 	 {	 ;	 }	} }	{ 	;		 {	 ; ;	{	{ ; } }   ""
)+
(o
&1
)*
13
,I
(""   	}			{		{	}	;   }   ""
)+
U(
B,
-1
,1
))
;
C
o&
4)
{
o&
1?
scanf
(""%d""
,&
n)
:(
scanf
(""%d%d""
,&
m,
&n
),
--
m)
;
Z=
A
N>>
m&
1?
T(
B,
m,
n)
:-
1;
C
g=
Z>>
7!=
U(
B,
-1
,1
))
{
H""{	 ; { {	} { }	{ ;	}  ; {  		 ""
))
;
}
}
else
{
A
U=
-(
A
V=
1<<
30
);
for
(b
=4
;
e<
65536
&&
b<
20
;
b++
){
Z=
(o
&1
?f
(B
,m
,b
,-
2)
:d
(B
,b
))
.T
;
}
o&
1?
H""	 }	{ }  		 ""
),
Z>>
5&
3^
3)
:H
""	 }	{ } 	   } }	{ }  		 ""
),
32
-(
Z&
31
),
Z>>
5&
3^
3)
;
}
}
B=
V(
B,
Z)
;
g=
o;
C
_)
{
o|=
1;
m=
A
T;
}
else
{
o=
o/
2*
2^
4;
}
C
g<
4)
{
B=
S(
B)
;
}
}
}
","
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
#include <time.h>

#define I ??(i??)??(j??)
#define K ??(i-1??)??(j??)
#define S strtok(NULL,"",\n\0"")
#define P printf(
#define NB_MSGS 42
#define C( f, m ) mNb = m;\
    s = setjmp( sT??( sI++ ??) );\
    if (!s) goto f;
#define bck longjmp( sT??( --sI ??), 0 );

jmp_buf sT??( 256 ??);
int m5??(84??),sI=0,c1='J'%2,mNb=0,s=0,mI=0,r=1;
unsigned long m1??(32??),q=0,z;
unsigned char m??( NB_MSGS ??)??( 11 ??);

int main( int argc, char *argv??(??) )
{
    time_t tmT = time( NULL );
    struct tm *tmS = localtime( &tmT );
    char tms??( 7 ??);
    int hr,n,i=1,j=0;
    FILE *info = NULL;
    char iS??( 2048 ??);

    if ( argc > 1 ) info = fopen( argv??(1??), ""r"" );
    strftime( tms, 7, ""%H:%M\n"", tmS );
    if ( info != NULL ) {
        fgets( iS, 2048, info );
        m5??( 0 ??) = atoi( strtok( iS, "",\0"" ) );
        for ( hr = 1; hr < 85; hr++ ) m5??(hr??) = atoi(S);
        for ( hr = 0; hr < 32; hr++ ) 
            m1??( hr ??) = strtoul( S, NULL, 10 );
        for ( hr = 0; hr < NB_MSGS; hr++ ) 
            for ( n = 0; n < 11; n++ ) 
                m??(hr??)??(n??) = (unsigned char)atoi( S );
        fclose( info );
        hr = atoi( strtok( tms, "":\0"" ) );
        n = atoi( strtok( NULL, "":\0"" ) );
        C( mA, 0 )
        C( out, 40 )
        s = setjmp( sT??( sI++ ??) );
        if ( s ) {
            s = setjmp( sT??( sI++ ??) );
            if ( s ); else goto doHr;
        } else goto doMin;
    } else {
        P ""%s"", tms );
        goto eoj;
        doMin:
            z = 22;
            C( doIt, 0 )
            bck
        doHr:
            hr = ( n >= 36 ) ? hr+1 : hr;
            if ( hr == 24 ) hr=0;
            if (hr&&hr!=12)(hr<12)?(P ""%d "",hr)):(P ""%d "",hr-12));
            n = hr + 61;
            q = 0;
            r = 1;
            z = 16;
            C( doIt, 0 )
            P ""\n"" );
            bck
        doIt:
            if ( r & m1??( m5??(n??) ??) ) {
                if (z == 22) q = q << 1;
                C( out, q )
                if (z == 22) q = q >> 1;
            }
            r = r << 1;
            q++;
            if ( q < z ) goto doIt;
            bck
        out:
            mI = 0;
            mNb += c1;
            while ( m??( mNb ??)??( mI ??) ) 
                P ""%c"", m??( mNb ??)??( mI++ ??) );
            bck
        mA:
            129<=m I ? 137>=m I ? m K=m I-32
            : 145<=m I ? 153>=m I ? m K=m I-39
            : 162<=m I ? 169>=m I ? m K=m I -47
            : j : j : j : 125==m I ? m K=39
            : 64==m I ? m K=32 : j;
            j++;
            if (m I) goto mA;
            i+=2;
            j = 0;
            if ( i < NB_MSGS ) goto mA;
            bck
    }

    eoj: exit( 0 );

}
","
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
#include <time.h>

#define I ??(i??)??(j??)
#define K ??(i-1??)??(j??)
#define S strtok(NULL,"",\n\0"")
#define P printf(
#define NB_MSGS 42
#define C( f, m ) mNb = m;\
    s = setjmp( sT??( sI++ ??) );\
    if (!s) goto f;
#define bck longjmp( sT??( --sI ??), 0 );

jmp_buf sT??( 256 ??);
int m5??(84??),sI=0,c1='J'%2,mNb=0,s=0,mI=0,r=1;
unsigned long m1??(32??),q=0,z;
unsigned char m??( NB_MSGS ??)??( 11 ??);

int main( int argc, char *argv??(??) )
{
    time_t tmT = time( NULL );
    struct tm *tmS = localtime( &tmT );
    char tms??( 7 ??);
    int hr,n,i=1,j=0;
    FILE *info = NULL;
    char iS??( 2048 ??);

    if ( argc > 1 ) info = fopen( argv??(1??), ""r"" );
    strftime( tms, 7, ""%H:%M\0"", tmS );
    if ( info != NULL ) {
        fgets( iS, 2048, info );
        m5??( 0 ??) = atoi( strtok( iS, "",\0"" ) );
        for ( hr = 1; hr < 85; hr++ ) m5??(hr??) = atoi(S);
        for ( hr = 0; hr < 32; hr++ ) 
            m1??( hr ??) = strtoul( S, NULL, 10 );
        for ( hr = 0; hr < NB_MSGS; hr++ ) 
            for ( n = 0; n < 11; n++ ) 
                m??(hr??)??(n??) = (unsigned char)atoi( S );
        fclose( info );
        hr = atoi( strtok( tms, "":\0"" ) );
        n = atoi( strtok( NULL, "":\0"" ) );
        C( mA, 0 )
        C( out, 40 )
        s = setjmp( sT??( sI++ ??) );
        if ( s ) {
            s = setjmp( sT??( sI++ ??) );
            if ( s ); else goto doHr;
        } else goto doMin;
    } else {
        P ""%s"", tms );
        goto eoj;
        doMin:
            z = 22;
            C( doIt, 0 )
            bck
        doHr:
            hr = ( n >= 36 ) ? hr+1 : hr;
            if ( hr == 24 ) hr=0;
            if (hr&&hr!=12)(hr<12)?(P ""%d "",hr)):(P ""%d "",hr-12));
            n = hr + 61;
            q = 0;
            r = 1;
            z = 16;
            C( doIt, 0 )
            P ""\n"" );
            bck
        doIt:
            if ( r & m1??( m5??(n??) ??) ) {
                if (z == 22) q = q << 1;
                C( out, q )
                if (z == 22) q = q >> 1;
            }
            r = r << 1;
            q++;
            if ( q < z ) goto doIt;
            bck
        out:
            mI = 0;
            mNb += c1;
            while ( m??( mNb ??)??( mI ??) ) 
                P ""%c"", m??( mNb ??)??( mI++ ??) );
            bck
        mA:
            129<=m I ? 137>=m I ? m K=m I-32
            : 145<=m I ? 153>=m I ? m K=m I-39
            : 162<=m I ? 169>=m I ? m K=m I -47
            : j : j : j : 125==m I ? m K=39
            : 64==m I ? m K=32 : j;
            j++;
            if (m I) goto mA;
            i+=2;
            j = 0;
            if ( i < NB_MSGS ) goto mA;
            bck
    }

    eoj: exit( 0 );

}
","
                      int
                   X=320      ,Y=200,
                 n=0,m,     x,y,   j=1024;
               double     T=44.0     /7,P[
              333333     ],C[5]       ={ 0,3,
              0,0,8}      ,p=1,         B=11.0
               /630,      f=0,r   =     3,g
                =7,b        =13,*q=P,   D,*J;
                unsigned               char
                  U[66666],*v=U,*h,l[5555]
                       ,c=0,*e,*a,*z;

                    #include <math.h>
                #define R1(t)   t=(int)(t\
              *123456789           )%j; t/=j;
             #define                 Rl(C,t)\
             n++[C]         =         t*n/12;
              #define      RI(C)     B=-B; R1\
              (r)R1(g     )R1(b     )for(n\
               =0; n<j; ){ Rl(C   ,r)Rl\
                   (C,g)Rl(C    ,b)++n; }



       #ifdef __DJGPP__
         #include <sys/movedata.h>
               #include <dpmi.h>
                 #include <pc.h>
   #define          Q(u,v)         u##portb(0x3##v
     #define          W        ; Q(out,C9),*h++/4)
          void       F(int i){  __dpmi_regs r
           ; if(i){ for(; i>=0; i-=8)while(
                     ~Q(in,DA) 
                  )&8^i); for(m=0,z
              =h+j; h    <z; m     ++){ Q(
         out,C8),m     )W W W; ++h; } dosmemput
   (v,X*Y,0xA0000   ); } else{       r.x.ax=
 0x13;            __dpmi_int(    0x10,&r); } }
                   #elif defined(SDL)
              #include ""SDL/SDL.h""
          SDL_Surface    *s; void
         F(int i){ if   (i){ SDL_SetColors(
     s,h,0,256);         SDL_UpdateRect
     (s,0,0,0,        0); } else {  SDL_Init( 
       SDL_INIT_VIDEO); s=SDL_SetVideoMode
       (X,Y,8,0);       v=s->pixels; } }
                  #else
               #include ""curses.h""
             void F(i){ if(i){ for(y=0;
          y<X*Y                   ; y++)
         { move  (y/X,y%X);        addch
        ((*(v   +y)/     32)      ["" .""
        "",:+""   ""=@#""   ]); } ;  refresh
        (); }     else{          initscr
        (),x=     COLS&~1,X=x<X?x:X,y=
         LINES      &~1,Y=y<Y?y:Y; } }
          #endif

main()
{
    F(0);

    for (x=-X/2,y=-Y/2;y<Y/2;++x>=X/2?x=-X/2,y++:4)
                {*q++ = sqrt(x*x+y*y);

    *q++ = atan2(x,y);

    }for (;n<j*2;l[n++]=0);
        for(;;)
        {
            a=l;z=l+j;e=l+j*2;
            if ((p+=B)>1){p=2-p;RI(l+j)}
                        else if (p<0){p=-p;RI(l)}

            while(a<l+j) D=p**a+++(1-p)**z++,*e++=D;
            h=l+j*2;

            for (J=P,z=v; z<v+X*Y;){
                D = *J++;
                *z++=fabs(sin((*J+++C[1])*1.5+D*C[0]+C[2]*sin(C[3]+D/C[4]))*255);
            }F(8);

            C[2]+=B; f+=T/360; C[3]+=f;

            if (f>T)
                {C[1] += (f-T)/8;

            if (f>T*2)
                C[0]=sin(f)+sin(f*2)/2;
        }
    }
}
","// Initially you will be calm and serene:

                      int
                   X=320      ,Y=200,
                 n=0,m,     x,y,   j=1024;
               double     T=44.0     /7,P[
              333333     ],C[5]       ={ 0,3,
              0,0,8}      ,p=1,         B=11.0
               /630,      f=0,r   =     3,g
                =7,b        =13,*q=P,   D,*J;
                unsigned               char
                  U[66666],*v=U,*h,l[5555]
                       ,c=0,*e,*a,*z;

                    #include <math.h>
                #define R1(t)   t=(int)(t\
              *123456789           )%j; t/=j;
             #define                 Rl(C,t)\
             n++[C]         =         t*n/12;
              #define      RI(C)     B=-B; R1\
              (r)R1(g     )R1(b     )for(n\
               =0; n<j; ){ Rl(C   ,r)Rl\
                   (C,g)Rl(C    ,b)++n; }


// Later your brain will look more like this:

       #ifdef __DJGPP__
         #include <sys/movedata.h>
               #include <dpmi.h>
                 #include <pc.h>
   #define          Q(u,v)         u##portb(0x3##v
     #define          W        ; Q(out,C9),*h++/4)
          void       F(int i){  __dpmi_regs r
           ; if(i){ for(; i>=0; i-=8)while(
                     ~Q(in,DA) 
                  )&8^i); for(m=0,z
              =h+j; h    <z; m     ++){ Q(
         out,C8),m     )W W W; ++h; } dosmemput
   (v,X*Y,0xA0000   ); } else{       r.x.ax=
 0x13;            __dpmi_int(    0x10,&r); } }
                   #elif defined(SDL)
              #include ""SDL/SDL.h""
          SDL_Surface    *s; void
         F(int i){ if   (i){ SDL_SetColors(
     s,h,0,256);         SDL_UpdateRect
     (s,0,0,0,        0); } else {  SDL_Init( 
       SDL_INIT_VIDEO); s=SDL_SetVideoMode
       (X,Y,8,0);       v=s->pixels; } }
                  #else
               #include ""curses.h""
             void F(i){ if(i){ for(y=0;
          y<X*Y                   ; y++)
         { move  (y/X,y%X);        addch
        ((*(v   +y)/     32)      ["" .""
        "",:+""   ""=@#""   ]); } ;  refresh
        (); }     else{          initscr
        (),x=     COLS&~1,X=x<X?x:X,y=
         LINES      &~1,Y=y<Y?y:Y; } }
          #endif

main()
{
    F(0);

    for (x=-X/2,y=-Y/2;y<Y/2;++x>=X/2?x=-X/2,y++:4)
                {*q++ = sqrt(x*x+y*y);

    // store result of atan2 of x and y in *q++
    *q++ = atan2(x,y);

    }for (;n<j*2;l[n++]=0);
        for(;;)
        {
            a=l;z=l+j;e=l+j*2;
            if ((p+=B)>1){p=2-p;RI(l+j)}
                        else if (p<0){p=-p;RI(l)}

            // will the maintenance programmer get this?
            while(a<l+j) D=p**a+++(1-p)**z++,*e++=D;
            h=l+j*2;

            // best way?
            for (J=P,z=v; z<v+X*Y;){
                D = *J++;
                *z++=fabs(sin((*J+++C[1])*1.5+D*C[0]+C[2]*sin(C[3]+D/C[4]))*255);
            }F(8);

            // tidy up later
            C[2]+=B; f+=T/360; C[3]+=f;

            // just in case
            if (f>T)
                {C[1] += (f-T)/8;

            // sorry
            if (f>T*2)
                C[0]=sin(f)+sin(f*2)/2;
        }
    }
}
","#include <stdio.h>
#define  true

true /*:all

CC=cc
PROG=tomx

false :
	make -f $0 $1
	exit 0

all: $(PROG)

%:%.c
	$(CC) $< -o $@

clean:
	rm $(PROG)

.PHONY: /* true clean */
	int main() {return!printf(""Hello, world\n"");}
","#define processor x86

#include <stdio.h>
#include <sys/stat.h>

#define l int*
#define F char
 struct stat t;
#define c return
#define I (P+=4,*L(P-4,0))
#define G (signed F)E(*L(P++,0))
#define C(O,D)E (D[B+V(010)/4+O*10])
#define U R[4]=E(V(17)-4),*(l)V(021)=
F       M [99],Q[99],b[9999],*ss,*d=b,*z;
#define O =(n=*(l)V(021),R[4]=E(V(17)+4),n)
#define p(a,b,c) system((sprintf(a,b,k[1]),c)),z
#define                         g (y/010&7)
#define                         R (B+13)
#define           x86           (F*)index\
(ss+V(i                         ),0100)
#define      D(y,n,a,m,i,c      )d+=sprintf( d,y,n,a,m,i,c ),(F*\
      )                         P
      l       B,i,n,a,r,y       ,
      P                         ;
#define     Tr(an,sl,at,or)     l an##i(d,sl){ c at? an##i(d,r):or; } \
l an(d,                         sl){ c \
r=V(014                         )&63,an##i(d,sl); }
#define add(Ev,Gv) Ev(){ i=((a-=16)+C(r,4))/4,(\
Gv?Ev()    :0)   ; } Ev##n(){ a=C(r,5),Ev(); }
Tr(L,r, C(r,3)&&C(r,3)<=d?(l)(((int)B)+d+C(r,4)-C(r,3)):(((int)B)^d)>>24&&--\
r,(l)d) Tr(Run,a,(ss=strcmp((F*)B+C((V(12)>>16),4)+C(--r,0),A(.strtab))?ss:(F\
*)B+C(r ,4),C(r,1)-2),0) add(Sca ,V(-~i)-P+2) add(ru,strcmp(ss+V(i),A(main)))
E(DX) { c *z? DX:DX <<030|(DX&65280)<<010|DX>>8&65280|DX>>24&0377; } l K(k){
c L(E(k [(l)V(17)]),0); } V(v){ c E(B[v]); }


main (char *ck, char **k) {
  exit(E((ck?main((z?(stat(M,&t)?P+=a+'{'?0:3:execv(M,k),a=G,i=P,y=G&255,sprintf(Q,y/'@'-3?A(*L(V(%d+%d)+%d,0)):A(R[%d]),(y&7),'\r',y/0100-1?0:G),(a+127&&a+'}'&&a+1?(a+61&&a+24&&a+025?(P=a+'H'&&a%061<=0?P:i,D(a>0?""                           R[%d]=E(~-E(R[%d])),\0               U R[%d],\0               R[%d] O,\0                                          U %d,\0R[%d]=0,""+(a&'8')*3:a  <-  'c'?"" %d, %c%s = R[%d], \0    %d, *R=%c%s==R[%d], \0          R[%d]=(int)%c%s,""-a%'w'%'j'*5:""%d,%d,%s=%d,"",a>0?a-'h'?a-49?a&7:g:I:g,a>0?a&7:""& ""[a%3%2+1],a+72?Q:A(*R),a>0|a<-99?g:I,0)):(P=i,i=a+61?a+21?E(I):G:0,D(a%' '+29+""P O,\0 U %d,P=%d,"",P,P+i,0,0,0),p(d,""A'"",b))):(n=g-4?g%5-1?a+127?G:I:0:(Scan(),*( x86?processor :d)=0,(int)(ss+V(i))),g%5<2?D(g%5?""    %s=E(~-E(%s)), \0    U %s,""+4*g:""%s=E(E(%s)%c%d),"",Q,Q,""+    -  ""[g],n,0):(a=G-'u'?'!':'=',D(g-4?""P=%d%c=%s?%d:%d,"":""*R=E(((int(*)(l,l,l))%s)(K(1),K(2),K(3))),P O,"",n,a,Q,P,P+G),p(d,""A'"",b))))):(Run((z=(F*)&ck,stat(k[1],&t),B=(l)mmap(0,i=t.st_size,3,1,open(k[1],2),0))),magic((R[4]=E(B+i/4),run(),P=V(-~i),U 0)),sprintf(M,A(.%s%d),k[1],P),D(""%s %s '-DX=A(%s)' -o %s '-Dmagic="",X,__FILE__,X,M,fflush(0)))),k):p(M,A(rm -f .%s*),M),*R)));
}
","#define PLURAL(bottles) bottles==1?""bottle"":""bottles""

void sing(int bottles) {
  printf(""%d green %s, standing on the wall.\n"", bottles, PLURAL(bottles));
}

int main() {
  int bottles = 10;

  while(bottles) {
    sing(bottles);
    sing(bottles);
    printf(""And if one green bottle should accidently fall,\nThere'd be "");
    sing(--bottles);
    printf(""\n"");
  }

  return 0;
}
","#include <stdio.h>
#define k *(int*)
#define a if(
#define c ad()
#define i else
#define p while(
#define x *(char*)
#define b ==
#define V =calloc(1,99999)
#define f ()
#define J return
#define l ae(
#define n e)
#define u d!=
#define F int 
#define y (j)
#define r m=
#define t +4
F d,z,C,h,P,K,ac,q,G,v,Q,R,D,L,W,M;
E(n{
x D++=e;
}
o f{
a L){
h=x L++;
a h b 2){
L=0;
h=W;
}
}
i h=fgetc(Q);
}
X f{
J isalnum(h)|h b 95;
}
Y f{
a h b 92){
o f;
a h b 110)h=10;
}
}
c{
F e,j,m;
p isspace(h)|h b 35){
a h b 35){
o f;
c;
a d b 536){
c;
E(32);
k d=1;
k(d t)=D;
}
p h!=10){
E(h);
o f;
}
E(h);
E(2);
}
o f;
}
C=0;
d=h;
a X f){
E(32);
M=D;
p X f){
E(h);
o f;
}
a isdigit(d)){
z=strtol(M,0,0);
d=2;
}
i{
x D=32;
d=strstr(R,M-1)-R;
x D=0;
d=d*8+256;
a d>536){
d=P+d;
a k d b 1){
L=k(d t);
W=h;
o f;
c;
}
}
}
}
i{
o f;
a d b 39){
d=2;
Y f;
z=h;
o f;
o f;
}
i a d b 47&h b 42){
o f;
p h){
p h!=42)o f;
o f;
a h b 47)h=0;
}
o f;
c;
}
i{
e=""++#m--%am*@R<^1c/@%[_[H3c%@%[_[H3c+@.B#d-@%:_^BKd<<Z/03e>>`/03e<=0f>=/f<@.f>@1f==&g!='g&&k||#l&@.BCh^@.BSi|@.B+j~@/%Yd!@&d*@b"";
p j=x e++){
r x e++;
z=0;
p(C=x e++-98)<0)z=z*64+C+64;
a j b d&(m b h|m b 64)){
a m b h){
o f;
d=1;
}
break;
}
}
}
}
}
l g){
p g&&g!=-1){
x q++=g;
g=g>>8;
}
}
A(n{
F g;
p n{
g=k e;
k e=q-e-4;
e=g;
}
}
s(g,n{
l g);
k q=e;
e=q;
q=q t;
J e;
}
H(n{
s(184,n;
}
B(n{
J s(233,n;
}
S(j,n{
l 1032325);
J s(132+j,n;
}
Z(n{
l 49465);
H(0);
l 15);
l e+144);
l 192);
}
N(j,n{
l j+131);
s((e<512)<<7|5,n;
}
T y{
F g,e,m,aa;
g=1;
a d b 34){
H(v);
p h!=34){
Y f;
x v++=h;
o f;
}
x v=0;
v=v t&-4;
o f;
c;
}
i{
aa=C;
r z;
e=d;
c;
a e b 2){
H(m);
}
i a aa b 2){
T(0);
s(185,0);
a e b 33)Z(m);
i l m);
}
i a e b 40){
w f;
c;
}
i a e b 42){
c;
e=d;
c;
c;
a d b 42){
c;
c;
c;
c;
e=0;
}
c;
T(0);
a d b 61){
c;
l 80);
w f;
l 89);
l 392+(e b 256));
}
i a n{
a e b 256)l 139);
i l 48655);
q++;
}
}
i a e b 38){
N(10,k d);
c;
}
i{
g=k e;
a!g)g=dlsym(0,M);
a d b 61&j){
c;
w f;
N(6,g);
}
i a u 40){
N(8,g);
a C b 11){
N(0,g);
l z);
c;
}
}
}
}
a d b 40){
a g b 1)l 80);
r s(60545,0);
c;
j=0;
p u 41){
w f;
s(2393225,j);
a d b 44)c;
j=j t;
}
k r j;
c;
a!g){
e=e t;
k e=s(232,k n;
}
i a g b 1){
s(2397439,j);
j=j t;
}
i{
s(232,g-q-5);
}
a j)s(50305,j);
}
}
O y{
F e,g,m;
a j--b 1)T(1);
i{
O y;
r 0;
p j b C){
g=d;
e=z;
c;
a j>8){
r S(e,m);
O y;
}
i{
l 80);
O y;
l 89);
a j b 4|j b 5){
Z(n;
}
i{
l n;
a g b 37)l 146);
}
}
}
a m&&j>8){
r S(e,m);
H(e^1);
B(5);
A(m);
H(n;
}
}
}
w f{
O(11);
}
U f{
w f;
J S(0,0);
}
I y{
F m,g,e;
a d b 288){
c;
c;
r U f;
c;
I y;
a d b 312){
c;
g=B(0);
A(m);
I y;
A(g);
}
i{
A(m);
}
}
i a d b 352|d b 504){
e=d;
c;
c;
a e b 352){
g=q;
r U f;
}
i{
a u 59)w f;
c;
g=q;
r 0;
a u 59)r U f;
c;
a u 41){
e=B(0);
w f;
B(g-q-5);
A(n;
g=e t;
}
}
c;
I(&m);
B(g-q-5);
A(m);
}
i a d b 123){
c;
ab(1);
p u 125)I y;
c;
}
i{
a d b 448){
c;
a u 59)w f;
K=B(K);
}
i a d b 400){
c;
k j=B(k j);
}
i a u 59)w f;
c;
}
}
ab y{
F m;
p d b 256|u-1&!j){
a d b 256){
c;
p u 59){
a j){
G=G t;
k d=-G;
}
i{
k d=v;
v=v t;
}
c;
a d b 44)c;
}
c;
}
i{
A(k(d t));
k d=q;
c;
c;
r 8;
p u 41){
k d=m;
r m t;
c;
a d b 44)c;
}
c;
K=G=0;
l 15042901);
r s(60545,0);
I(0);
A(K);
l 50121);
k r G;
}
}
}
main(g,n{
Q=stdin;
a g-->1){
e=e t;
Q=fopen(k e,""r"");
}
D=strcpy(R V,"" int if else while break return for define main "")+48;
v V;
q=ac V;
P V;
o f;
c;
ab(0);
J(*(int(*)f)k(P+592))(g,n;
}

","/* #!/usr/local/bin/otcc */
/*
 * Sample OTCC C example. You can uncomment the first line and install
 * otcc in /usr/local/bin to make otcc scripts !  
 */

/* Any preprocessor directive except #define are ignored. We put this
   include so that a standard C compiler can compile this code too. */
#include <stdio.h>

/* defines are handled, but macro arguments cannot be given. No
   recursive defines are tolerated */
#define DEFAULT_BASE 10

/*
 * Only old style K&R prototypes are parsed. Only int arguments are
 * allowed (implicit types).
 * 
 * By benchmarking the execution time of this function (for example
 * for fib(35)), you'll notice that OTCC is quite fast because it
 * generates native i386 machine code.  
 */
fib(n)
{
    if (n <= 2)
        return 1;
    else
        return fib(n-1) + fib(n-2);
}

/* Identifiers are parsed the same way as C: begins with letter or
   '_', and then letters, '_' or digits */
fact(n)
{
    /* local variables can be declared. Only 'int' type is supported */
    int i, r;
    r = 1;
    /* 'while' and 'for' loops are supported */
    for(i=2;i<=n;i++)
        r = r * i;
    return r;
}

/* Well, we could use printf, but it would be too easy */
print_num(n, b)
{
    int tab, p, c;
    /* Numbers can be entered in decimal, hexadecimal ('0x' prefix) and
       octal ('0' prefix) */
    /* more complex programs use malloc */
    tab = malloc(0x100); 
    p = tab;
    while (1) {
        c = n % b;
        /* Character constants can be used */
        if (c >= 10)
            c = c + 'a' - 10;
        else
            c = c + '0';
        *(char *)p = c;
        p++;
        n = n / b;
        /* 'break' is supported */
        if (n == 0)
            break;
    }
    while (p != tab) {
        p--;
        printf(""%c"", *(char *)p);
    }
    free(tab);
}

/* 'main' takes standard 'argc' and 'argv' parameters */
main(argc, argv)
{
    /* no local name space is supported, but local variables ARE
       supported. As long as you do not use a globally defined
       variable name as local variable (which is a bad habbit), you
       won't have any problem */
    int s, n, f, base;
    
    /* && and || operator have the same semantics as C (left to right
       evaluation and early exit) */
    if (argc != 2 && argc != 3) {
        /* '*' operator is supported with explicit casting to 'int *',
           'char *' or 'int (*)()' (function pointer). Of course, 'int'
           are supposed to be used as pointers too. */
        s = *(int *)argv;
        help(s);
        return 1;
    }
    /* Any libc function can be used because OTCC uses dynamic linking */
    n = atoi(*(int *)(argv + 4));
    base = DEFAULT_BASE;
    if (argc >= 3) {
        base = atoi(*(int *)(argv + 8));
        if (base < 2 || base > 36) {
            /* external variables can be used too (here: 'stderr') */
            fprintf(stderr, ""Invalid base\n"");
            return 1;
        }
    }
    printf(""fib(%d) = "", n);
    print_num(fib(n), base);
    printf(""\n"");

    printf(""fact(%d) = "", n);
    if (n > 12) {
        printf(""Overflow"");
    } else {
        /* why not using a function pointer ? */
        f = &fact;
        print_num((*(int (*)())f)(n), base);
    }
    printf(""\n"");
    return 0;
}

/* functions can be used before being defined */
help(name)
{
    printf(""usage: %s n [base]\n"", name);
    printf(""Compute fib(n) and fact(n) and output the result in base 'base'\n"");
}

","#include <stdio.h>
int l;int main(int o,char **O,
int I){char c,*D=O[1];if(o>0){
for(l=0;D[l              ];D[l
++]-=10){D   [l++]-=120;D[l]-=
110;while   (!main(0,O,l))D[l]
+=   20;   putchar((D[l]+1032)
/20   )   ;}putchar(10);}else{
c=o+     (D[I]+82)%10-(I>l/2)*
(D[I-l+I]+72)/10-9;D[I]+=I<0?0
:!(o=main(c/10,O,I-1))*((c+999
)%10-(D[I]+92)%10);}return o;}
","#include<unistd.h> 
#include<time.h>

#define k (""C9B7351A@D-/E+F?')G>H%J#=I""[(d[(i/13)*2]*91+d[(i/13)*2+1]-3220)&(\
4096>>(i%13))?l+1:l]-59)
#define g(n)e(n<13?n:n<20?n+1:n>20?11+n/10:13,0);e(n>12&&n<20?26:n>20&&n%10?n%\
10:-1,2);
#define x(n)g(localtime(&a)->tm_##n)

unsigned char *d=""KZs2ITTwhwZYvec@JbYxOjf9-TZRGDb/el7#q(`SZ#|_neTwq\\MqJ5cVgte\
K-ReK-(Mq8+D'6Ui0tG88vXJ-Tu{VI=d%cR]h7CumwBq\\-#{thj8fw$OEfEvLHP13_##w.OD[7Cw2\
]<T{|[F}L;L:*+A#PwLnp{9'M3Mr|w_|unm'}$*(5]_$?O9zO{{wz4p6vP8Ipu}$BQospf=-Isnyl'\
|g53o^c`ov-P`-x+|ZAd<e?<'b9P|LkZOf{B-8`K([srqv&gy1,:}$|s7D{yN6M#cQyKpC|*_|#xA#\
'YfQ}$k$kr7dM#dcnWDg|PHdA#^j&q}$x@(a;k2JB]50ZKp{xRwbkTm.v\\a3fJ@V[`J#fN`s|sZeH\
mmHX7`JKiry4sm,bUfz69{rt'k*pBq^l,ut6UVvb9N%r%l:Py3r[.Z/pBkaz2J4u{GTu)hyp#%gbS$\
r`mzi9G|3M,r}-Dt?w)_##%fQt$k&n]e$HzFXu(|Fvt`i#$A#|ykrz+nhs'P#|pm*9[_#,5P#}$}$x\
&s(i,HzO'&d&g?/_$P#kZ7Dn]e$J{zi8ypi|hq$_.|cLx`sy;f8GRMQM#7R5$hym*:^`sxrvtfQ|z_\
N|ye[7dH[}#Ts\\59V@|#z}$}$y;usL)vXFiA0AukZ8H|fyKurd]|s5<|xq@Cpm,}${,e$KufO?/2M\
t$zmM#vtfQ|zRKlEA#P&fPOwJ#pf_$?/2#@|$w}$?fLxA#^-}$cM^aA#&g#wIv?^|yY#s)Lwt'K#ON\
yoXKYkpCl0m}D[9OGU7n([ZrL)[8eRy7uR*PJ#^5xRG>zSf>p]ZrJ_[9q?qgYe^4$r3lY$4SdsSyNv\
J_l&w2I?q#fN*F1n|s9OGUv|w&l+pR-3Nudtyn@|Dfq#^o|s9Pt=oZCol/{VdgkLdwyn1yDed}?Dzi\
}#Kje#d}Y${8pSt<q?qgIv|`DH?9}$O{k(LgE;|KU-tJnWOw*F@YP#|yY$b4|.50[2d}D'kaqhp;JE\
$r&fH&'6nykYGCv>K$t?yLbwtUn[F{ncOx_.:K#nwF#f|HQs&<&bfQPE?:uJm*&\\S=*/@|We*w@$@\
f0,*H])WL<i@^xX@)(a.>MV*p{Zqf&zH%###################u2#A#_$A#_$A#_$A#_$@tA#QI#\
3#0&:p#?1[P*6WQ@i#C1{[;@|1}S%^r#g.d^z#M}$ziZe|kU6oZbq5$kF]4[E^nA#_.|}e$Ku^r&WA\
#_$?/*P_$@t&gA#[;_$A#^j2#A#_*d}@v^z#8?D?D9Q`s}$5$L|u<3JC/xVz;#s^{?9$M}$x_Y,7uP\
$"",p[6789];

int o[]={145,1145,1745,2545,3045,4045,4345,5145,5745,6369},i=0,j=0,l=0;

void e(n,h){
 for(j=0;n>0;n-=!(p[j++]^9));
 for(;!n&&j[p]^9;j++)write(1,p+p[j][o],o[p[j]+1]-p[j][o]);
 for(i=0;i<h[o];i++)write(1,d+7,1);}

int main(){
 time_t a=time(&a);

 for(;i<8476;j[p]=k>=0?j<*o?k-2:(p[j+1]=k<<4):0,j+=k>=0?1+(j>=*o):0,
 l=-k*(k<0),i++);e(21,4);x(hour)e(22,1);x(min)e(23,1);e(25,0);x(sec)e(24,0);

 return;}
","#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>
#include <signal.h>
#define m(b)a=b;z=*a;while(*++a){y=*a;*a=z;z=y;}
#define h(u)G=u<<3;printf(""\e[%uq"",l[u])
#define c(n,s)case n:s;continue
char x[]=""(((((((((((((((((((((("",w[]=
""\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"";char r[]={92,124,47},l[]={2,3,1
,0};char*T[]={""  |"",""  |"",""%\\|/%"","" %%%"",""""};char d=1,p=40,o=40,k=0,*a,y,z,g=
-1,G,X,**P=&T[4],f=0;unsigned int s=0;void u(int i){int n;printf(
""\233;%uH\233L%c\233;%uH%c\233;%uH%s\23322;%uH@\23323;%uH \n"",*x-*w,r[d],*x+*w
,r[d],X,*P,p+=k,o);if(abs(p-x[21])>=w[21])exit(0);if(g!=G){struct itimerval t=
{0,0,0,0};g+=((g<G)<<1)-1;t.it_interval.tv_usec=t.it_value.tv_usec=72000/((g>>
3)+1);setitimer(0,&t,0);f&&printf(""\e[10;%u]"",g+24);}f&&putchar(7);s+=(9-w[21]
)*((g>>3)+1);o=p;m(x);m(w);(n=rand())&255||--*w||++*w;if(!(**P&&P++||n&7936)){
while(abs((X=rand()%76)-*x+2)-*w<6);++X;P=T;}(n=rand()&31)<3&&(d=n);!d&&--*x<=
*w&&(++*x,++d)||d==2&&++*x+*w>79&&(--*x,--d);signal(i,u);}void e(){signal(14,
SIG_IGN);printf(""\e[0q\ecScore: %u\n"",s);system(""stty echo -cbreak"");}int main
(int C,char**V){atexit(e);(C<2||*V[1]!=113)&&(f=(C=*(int*)getenv(""TERM""))==(
int)0x756E696C||C==(int)0x6C696E75);srand(getpid());system(""stty -echo cbreak""
);h(0);u(14);for(;;)switch(getchar()){case 113:return 0;case 91:case 98:c(44,k
=-1);case 32:case 110:c(46,k=0);case 93:case 109:c(47,k=1);c(49,h(0));c(50,h(1
));c(51,h(2));c(52,h(3));}}
","#include <stdio.h>
#include <string.h>
#include <time.h>
#define A(x,y) i[a++]=(N){c,c+x,y};
#define B(x,y) j[b++]=(N){c,c+x,y};
#define C(j,k) for (j=0; j<k; j++){
#define D(x) C(_,8)if(!(c+x[_]&136)){ if(p[c+x[_]]*p[c]<0)B(x[_],0)else if(!p[c+x[_]])A(x[_],0)} }
#define J printf(
#define O(v) _=v; while(!(c+_&136)){ x=p[c+_]*p[c]; if(x<0){B(_,0)E; } else if(x>0)E; else A(_,0)_+=v; }
#define X(x) G(x,L)
#define Z(x,y) memcpy(x,y,256);

typedef struct {
F a,b,c;
} N;

F g[]=""KSLAU"",
p[256],v[]=""{ ; } ; { ; ; ; {   } ; { ; }   { ;   } {   } ; { ; ; ; { ; } ; } }   ; { ; ; { }   ; { } }   ; { ; ; { { ; ; { } }   ; } ; ; { }   ; { } }   ; { ; ; {   { ; { } }   ; { ; ; { }   ; {   { ; ;   { } ; ;   ; ;   { ; }   { {   ;   ; ;   { } ;   { ; ; "";
F S[]=""{}; "",W[256],L[1024];
P q[]={-14,-31,-33,-18,14,31,33,18},r[]={-1,-17,-16,-15,1,17,16,15},_,a,b,c,d,e,t=1,x,y,z;
N i[500],j[500],*k,u;
P f(N *V) {
	a=b=0;
	C(d,8)
		C(e,8)
			c=d<<4|e;
			if(p[c]==0||p[c]*t<0)continue;
			switch(p[c]<0?-p[c]:p[c]){
				K 80:
					if(56+t*40==(c&112)&&!p[c-32*t])
						A(t*-32,0)
					if(56+t*-40==(c&112)){
						if(!(c-17*t&136)&&p[c-17*t]*t<0){
							C(_,5)
								B(-17*t,(g[_]^_)*t)}
						}
						if(!(c-15*t&136)&&p[c-15*t]*t<0){
							C(_,5)
								B(-15*t,(g[_]^_)*t)}
						}
						C(_,5)
							A(t*-16,(g[_]^_)*t)}
					}else{
						if(!p[c-16*t])
							A(t*-16,0)
						if(!(c-(17*t)&136)&&p[c-17*t]*t<0){
							B(-17*t,0)
						}
						if(!(c-(15*t)&136)&&p[c-15*t]*t<0){
							B(-15*t,0)
						}
					}
					E;
				K 78:D(q)E;
				K 81:
				K 66:O(17)O(-17)O(15)O(-15)
					if(p[c]==66||p[c]==-66)
						E;
				K 82:O(1)O(-1)O(16)O(-16)E;
				K 75:D(r)
			} ;
		}
	}
	if ( b > 0 ) {
		C(_,b)V[_]=j[_]; }
		R b;
	} else {
		C(_,a)V[_]=i[_]; }
		R a;
	}
}
F *G(F *n, F *o){
	a=b=0;
	for(; n[b]; d=0){
		do{
			d*=4;
			d+=W[n[b++]];
		} while(++b<8*a+8);
		o[a++]=d;
	}
	o[a]=0;
	R o;
}
m(N a){ p[a.b]=a.c?a.c:p[a.a]; p[a.a]=0; }
h(){
	J X(""{ ; { { { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { { ; ; ""));
	c=0; C(c,120)c%8==0&&putchar(56-c/16);
 		if(p[c]<0){
			J X(""}     { { ; { { { ; ; ; { ; } } } ; {   ""),-p[c]);
		} else if(p[c]>0)
			J X(""}     { { ; { { { ; } } } ; {   { ; { { ""),p[c]);
		else
			J""|   "");
		c%8==7?J X(""}     { { { ; ; { ; { { { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { ;   } { ;   } { ;   } { ; ;   { { ; ; "")),c+=8:0;
	}
}
s() {
	b=0; C(a,256)
	if(v[b]==94){
		b++; C(c,v[b]-32)p[a++]=v[b+1]-120;}
		b+=2; a--;
	} else
		p[a]=v[b++]-120;
	}
}
P w() {
	P	v=0;
	C(_,120)
		p[_]&&(p[_]*t>0&&v--,p[_]*t<0&&v++);
	}
	v+=f(i); v-=b?100:0;t=-t; v-=f(i); v+=b?100:0;t=-t;

	R v;
}
P V(P n, P o) {
	P s=-I,G,H,Y;
	N M[500];
	F u[256];

  if(!(n+o))R w()+time(NULL)%9-4;
	if(!(H=f(M)))R I;
	H<5?H==1?n++:(o<6?o++:0):0;
	Z(u,p)
	C(G,H)
		Z(p,u)
		m(M[G]);
		t=-t;
		s=(e=-V(n-1,o))>s?Y=G,e:s;
		t=-t;
	}
	e=Y;
	R s;
}
main(P db, F *bd[]){
	N o[500];
	F T[256];

  C(a,256)W[a]=-1; }
	C(a,4)W[S[a]]=a; }
	G(v,v); s();
	while(1){
		h();
		b=f(o);
		scanf(""%s"",L);
		if(strcmp(L,""quit"")==0)R 0;
		else if(strcmp(L,""g"")==0){
			Z(T,p)
			J G(""} } } ; } ; { } } ;   { }   } } } ; } } { ; { { { ; } } } ; } { { { ; ; "",L), V(db>1?atoi(bd[1]):3,0));
			Z(p,T)m(o[e]); t=-t;
		}else{
			u.a=896-16*L[1];
			u.b=896-16*L[3];
			u.a+=L[0]-97;
			u.b+=L[2]-97;
			u.c=L[4]?L[5]:0;
			C(a,b)
				if(u.a==o[a].a&&u.b==o[a].b&&u.c==o[a].c)E;
			}
			a==b?J X(""} { ; } } ;   { } ;   { } ; } } } ; }   } ; { } } ;   { { ; { { } ;   } } ;     }   } ; } ; } } { { ; ; "")):(m(u),t=-t);
		}
	}
}
","#define D  define
#define   U undef
#define     n   #


#undef  __FILE__
  n U   __FILE__
  n D f __FILE__
  n D N endif
  n D p e(prg)
  n D   e(x)  #x
  n D q       #
  n D o E     #F
  n D E Q(
  n D G   x,y,z)
  n D H E   y,z)
  n D F       ,)
  n D g o else
  n D d o D
  n D u o U
  n D w E o F D
#ifdef      prg



#ifndef   tape
n include p
n ifndef  tape
n D       tape O
n endif
#endif
n D O Z(O,
n D I Z(I,
q D i     tape
n U O
n U I
n D O         ,)
n D I         ,)
q D v     tape
n U O
n U I
#undef    tape
  n U     tape
  q U     tape
#endif /* tape */


q  ifndef  P
q D H y ## z
#ifdef   prg
d c 0    & 0
d R i    W v
d   B           Initializing...
d   L    V   /* the turing    */
d   M    Y(O)/* state to      */
d S(x)   T(O,1, start       ##x)
#else
d c 0
#endif
q   D    P P
q        include f
q U Q
q   D    H H 
q   N
q U f
o        ifndef P
E   #    D H y ## z F 
d O 3
d I 3
d x 3
o        if c+2
E o F    include <stdio.h>


int main() {
  return 2+c|!
  printf
  (
    d y ""\n""
    d z ""..""
    d j "" ""
    d P ""*""
    d k "" ""
    o if c
    w Y(Z) #Z
    ""Un""
    ""define""
    ""d state ""
    Y(B) y y
""Tape:""
    o elif !c
""Usage:""
    d M 0
    "" prg=myprg.turing ""
    d L ,
    d R ,
    ""[""
      ""tape=""
      ""\""""
      ""O I O...""
      ""\""""
    ""]""
    g
    ""Final ""
""tape:""
    o N
    u O
    u I
    d O ""O""
    d I ""I""
    g
    d j     _
    d z    ...
    d k     ~

/*StarBox*/
/*********/
     d P *
     d y *
   E E /,*) F 
         *
         * State: B
/*********/

    u O
    u I
    o N
    u x
    u a
    u c
    u B
    o   ifdef s
  d J s
  d A l
  d B m
  d C r
  d t K
  d a L
  d b M
  d c R
    g
  d J S
  d A L
  d B M
  d C R
  d T K
  d a l
  d b m
  d c r
    o N
      y


  /*Triangles*/
  d  V j j j j
  d W j j j j
  d X(G  y j
  d Z(G j y
  d Y(x) P
  y A B C
  u    X
  u   Y
  u  Z
  u V
  u W

  d X(G    y x
  d Z(G   x y
  d V z  O O
  d W O O z
  d Y(x) x
  y A B C
  u    X
  u   Y
  u  Z
  u V
  u W

  d  V k k k k
  d W k k k k
  d X(G  y k
  d Z(G k y
  d Y(x) P
  y A B C
  u    X
  u   Y
  u  Z
  u V
  u W
         y
        u j
       u   k
      u     z
     u       P
    u         y
   u           O
  /*EndOfTriang*/


               /* Rain  */
  o ifndef I  /*/*/ /*/*/
       /*/*/*/*/*/ /*/*/
  E E /*/*/*/*/*/,/) F 
  d   K(G  /*/*/     y
  o  if J(x)
  u   K
  d   K(G x
  w a X(J(x),A       F 
  u   K
  d   Z(G x
  d   W   O
  w b Y(C)
  d P C
  u   Z
  o U W


  d Z(G z ## y
  w c        C
  u          Z
  g               /* <- exit */
  u          K
  d X(G z ## y


  w a A
  u   X
  d   X(G x
  d V O
  w b Y(A)
  d P A
  u   X
  u   V
  d   K(G x
  w c Z(J(x),C F 
  u   K
  o   N
  u   a
  u   b
  o U c


  d X(G  J(_ ## x)
  d V    J(_O)
  d Z(G  J(_ ## x)
  d W    J(_O)
  d Y(x) J(_ ## x)


  o ifdef s
  u       t
  d   t(G z
  d j S(x)
  d k T

  g
  u T
d T(G z
  d j s(x)
  d k t
  o N
  u          tape
  o include  p
  u          tape
  d stop_O   x
  d stop_I   x
  w a(P)     O&I&x


  d O        0
  d I        0
  d x        0
  w c a(P)
  u          O
  u          I
  u          x
  d   left   0
  d   right  1
  w j k(P ## x)
  u   P
  u   left
  u   right
  u   stop_O
  u   stop_I


  u Y
  o U         X
  u V
  u Z
  o U         W
  u A
  u B
  o U         C
  u j
  u k
  w B         J   (.)
  u J
  u t
  o U         T


    /*Codeblk*/
    o  D   P  P
    o include f
    E n  U  Q F 
    E n D H H F 


              g
  );
}
w P           x
o N
o N
o U           f
u l
u L
o U           m
u M
u r
o U           R
u S
u s
o U           B
u a
u c
","char*d,A[9876];char*d,A[9876];char*d,A[9876];char*d,A[9876];char*d,A[9876];char
e;b;*ad,a,c;  te;b;*ad,a,c;  te;*ad,a,c;  w,te;*ad,a,  w,te;*ad,and,  w,te;*ad,
r,T; wri; ;*h; r,T; wri; ;*h; r; wri; ;*h;_, r; wri;*h;_, r; wri;*har;_, r; wri
  ;on; ;l ;i(V)  ;on; ;l ;i(V)  ;o ;l ;mai(V)  ;o  ;mai(n,V)    ;main (n,V)    
   {-!har  ;      {-!har  ;      {har  =A;      {h  =A;ad        =A;read       
(0,&e,o||n -- +(0,&e,o||n -- +(0,&o||n ,o-- +(0,&on ,o-4,- +(0,n ,o-=94,- +(0,n
,l=b=8,!( te-*A,l=b=8,!( te-*A,l=b,!( time-*A,l=b, time)|-*A,l= time(0)|-*A,l= 
~l),srand  (l),~l),srand  (l),~l),and  ,!(l),~l),a  ,!(A,l),~l)  ,!(d=A,l),~l) 
,b))&&+((A + te,b))&&+((A + te,b))+((A -A+ te,b))+A -A+ (&te,b+A -A+(* (&te,b+A
)=+ +95>e?(*& c)=+ +95>e?(*& c) +95>e?(*& _*c) +95>(*& _*c) +95>(*&r= _*c) +95>
5,r+e-r +_:2-195,r+e-r +_:2-195+e-r +_:2-1<-95+e-r +_-1<-95+e-r ++?_-1<-95+e-r 
|(d==d),!n ?*d||(d==d),!n ?*d||(d==d),!n ?*d||(d==d),!n ?*d||(d==d),!n ?*d||(d=
 *( (char**)+V+ *( (char)+V+ *( (c),har)+V+  (c),har)+ (V+  (c),r)+ (V+  (  c),
+0,*d-7 ) -r+8)+0,*d-7 -r+8)+0,*d-c:7 -r+80,*d-c:7 -r+7:80,*d-7 -r+7:80,*d++-7 
+7+! r: and%9- +7+! rand%9-85 +7+! rand%95 +7+!!  rand%95 +7+  rand()%95 +7+  r
-(r+o):(+w,_+ A-(r+o)+w,_+*( A-(r+o)+w,_+ A-(r=e+o)+w,_+ A-(r+o)+wri,_+ A-(r+o)
+(o)+b)),!write+(o)+b,!wri,(te+(o)+b,!write+(o=_)+b,!write+(o)+b,!((write+(o)+b
-b+*h)(1,A+b,!!-b+*h),A+b,((!!-b+*h),A+b,!!-b+((*h),A+b,!!-b+*h),A-++b,!!-b+*h)
, a >T^l,( o-95, a >T,( o-=+95, a >T,( o-95, a)) >T,( o-95, a >T,(w? o-95, a >T
++  &&r:b<<2+a ++  &&b<<2+a+w ++  &&b<<2+w ++  ) &&b<<2+w ++  &&b<<((2+w ++  &&
!main(n*n,V) , !main(n,V) , !main(+-n,V) ,main(+-n,V) ) ,main(n,V) ) ,main),(n,
l)),w= +T-->o +l)),w= +T>o +l)),w=o+ +T>o +l,w=o+ +T>o;{ +l,w=o+T>o;{ +l,w &=o+
!a;}return _+= !a;}return _+= !a;}return _+= !a;}return _+= !a;}return _+= !a;}
","#include <time.h>
#include <stdio.h>
#include <stdlib.h>

#define __ ""Y\n : ! ,.?>""
#define D(f) ; } int f(int i) { return
#define E(a,b,c,d,e) b##d,c,e,a
#define e(a,b,c,d) a##b##c##d
#define B *p++ - ' ' || !p++
#define _(k) o(*#k - 64)
#define G(g,l,k,o,e,d,n,c,i,b,a,f,j,m,p) \
a#b#c#d#e#f#g#a#i#j#k#l#m#n#o e,i l##c,m##b; d g j n h(k 30:1); o p f}

			G(E(f ( 9) -s
				? -s + 'q'
				? f( 5 ) -s &&'d' -
			       s?U(  3 ) ||_(J)
				:A ( s- f( 5 ))
				:(c= 4 *
			      4):

	g(0)D(

		V)c <= 3 *4 + 3&&c && V(X ( i) ) ;
	}

	int , time ( 0)& , c - 15 || P

	(1

):0,
	& ( !!d	    ( 0 )
	  ||(a=! _(S)) ,b= 0 )||
	a
		?d(a  = 0)
			? _
(I):			w ( j =!W(j=_ (V ))) ,

				l(_
				    (Y+ s ) )
				  )e

	(
	main(){;
	    ;;;s , ra,
	 n, d), && C ( j +R( s-j+t( i- 1) )
		   )D( W)m[ c* 4| z( j ) ]
	    &&_( X )E (d	   ( 0
		       )&&  R( 6)/ 6
			   ? c= 17|_ ( T )
			   :01,||+
			       , v =i & 3 ^ 2
			       ,+j & 3&&W ( j)||y ( 10 )D (k) --
				   j ? k ( O[j]=R(15 ))
: 1 D
			 ( H )o ( 7+! !  i+3 )+

				  i?

    c=i /4 & 63,
    a= 1

:0)

    D ( f )( p =M ,q ( i),*p+86)
    D ( l) * f, B?

			   B ?B ?B? B ?B ?B
		 ?7 :B?B ?36: 59 * 89 *5 * 2 :B?6587
	     *77 :9 + 2:B ?B?B?9: 5 : 37 : B ? 5 +5:4:20:
			       B?B?B?32

		  :e( 4, 3 , 1 *4 * 59  * 1 , 7):B?
			       17: 34 : 19 :B ?
				      8 *2 :B ?
				      2:26: B?
				       B?B ?B ?

	82 *+ 576: B ?33 :22  :5 * 5:3 *4 :3:B ?B ?B? B ?6 +
	+ 17 : B?B?13:6 : 9 *2:B?15 : 7 *2 :

				 B ?
				 B ?
			    27:24: 31 : B?


		  B? +  29 :,
		  m [a^ 2  ] =T( 8 * 7) ;j= 3
		      ;
		    ;
	      Q, ;int
	       P ( int
		  i )

      {time_t(x )				=+ 0+
	time(0) ;                       j=E( u (i  ) : i D(R )e(r ,
      a ,n ,d) ()% i+1,                 ( e( l  , o,
      caltim , e ) (& x))     ->e(          tm_h , o, u  , r)
	;retur ,				i?_( W
):	_( U) D(Y)			  *p&&  *p<3 * 11 ?
	  ( ++ p ),				  n j= + 34  +( j< 6
							||j>19 ),Y (i)
: *p

    D ( F)	i == 9  ?1 :
	F(	(i+ 7)% ( 7 +  3) ) +!O[ i
   ]D(u)	*p &&* p -32? p ++)
    D (h  )	i ?*++*S=i%  ( 38)- 1,
    D ( A )!    n?i&&!g ( (0  ) ) ||K (  j=4| ! !i ) :  N(!i )D(
                Q)++j<

	       (s )  &&Q ( t( i)^i )
    D( U	)i>= 0 ?U( i- 1 )||~f (i+1 ) == ~  s
				      &&H (m[c* 4 |z(i)] )
:0;D


		( X) + b && b<, for (*S = M  ; *
p; ),

		gets ( L, + 98 , stdin ) ?
		   p= L, E (r( 0 ): 0 ,h( i /  38 ) : 0;D( C)!
		   ( m[j]+m [a= i] ) ?m[j[m]= i]=j:0;D (d) !
			  b+(*  O-
			   c)*
			     *  O; D (z )


					      -~- ~ -~i +
	v
		& 3 D(y)( putchar ) ( i)
    D ( q )	i& ,!(O[j = i]
		 || _ ( O))+a :0;
    D (w)O[	j] ==c && o

	(( !i ++ ? ! !_ (M

):

	0) +15)|| ++ j<9 &&w (
i)D	( r )*p?			*p -4?
					* p -6 ?
				     y(*p <9 + 2?__[
					    * p
]:			 * p+ 7 +79):o( j+1) : o (26+j),&q ( -!
		  * p ++ + i )D(x)i? a=x ( ( -- i)), ++ p )
	    D( t ) i,   | C((j=i*
       T(i-4 ))  +R
    (3 ) + 4 )
   D(J) !j                                --E( 0 D  ( K )!-!N, || i &,
                                                _( R ) :i* c== (O
   [ j ] )				&&n==f (j+   6  +    5   * 4)?O
    [j]=			   !i *    c-_   (    L)    :J(i )
    D ( N )			j=9, & d(0 )? j= 6 | ! i , J(i )D 
			( o)(*S = p , ++ S,p = M , r (q (i) ),-- S,  p = *S))
		    ( (l (_ (Q )),n =s,i ^5 ) ) ;, E(j ,
		sign ,  v ,ed ( b ) ;;
	      int   c =1 ,O[9])
            ;int(  s
)=
	 E (n ;char, 1 ,a,6 ,o ())*  Z[
	E(M [37 * 9 *3 ] ,0,L [ 99] ,3] , * *S=Z ) ;
	 E (*p=+1 ,char( m)[6 , co , 4 ],ol)
				  +,
	   V ( v=*O = k( j= 9 )) ;
	return ! c&& - ~ ~ - -! printf
	 ( ( ""%d \n"") , F (P ( 0) +6)            *50 + !  ! b*
	  ( +b - (int)time ( 0 )) )
;, (         b= 60 + time ( 0)+ 60 * 4)              ;, n =Y
              (u (s =Y (i) ) )

	:  (exit(                                      0)
	,i)D( g )x (  _(N) ^ 9)? !( a =0) : _  ( P )D (T)!  i|,
	(2); s=35; Q(3);

	s=59; Q(6);


	a=1;




    )
","#include <unistd.h>
#include <curses.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/time.h>

#define o0(M,W) mvprintw(W,M?M-1:M,""%s%s "",M?"" "":"""",_)
#define O0(M,W) M##M=(M+=W##M)-W##M
#define l1(M,W) M.tv_##W##sec
#define L1(m,M,l,L,o,O) for(L=l;L--;)((char*)(m))[o]=((char*)(M))[O]
#define I1 lL,(struct sockaddr*)&il
#define i1 COLS
#define j LINES
#define L_ ((j%2)?j:j-1)

fd_set I;struct socka\
ddr_in il;struct host\
ent*LI; struct timeval
IL,l;char L[9],_[1<<9]
   ;void ___(int __
   ){_[__--]=+0;if(
   ++__)___(--__);_
   [__]='=';}double
   o,oo=+0,Oo=+0.2;
   long O,OO=0,oO=1
   ,ii,iI,Ii,Ll,lL,
   II=sizeof(il),Il
   ,ll,LL=0,i=0,li,
   lI;int main(int\
   iL,char *Li[]){\
   initscr();cbreak
   ();noecho();nonl
   ();___(lI=i1/4);
   _[0]='[';_[lI-1]
   =']';L1(&il,&_,\
   II,O,+O,+lI);il.
   sin_port=htons((
   unsigned long)(\
   PORT&0xffff));lL
   =l_;if(iL=!--iL)
   {il. sin_addr .\
   s_addr=0;bind(I1
   ,II);listen(lL,5
   );lL=accept(I1,&
   II);}else{oO-=2;
   LI=gethostbyname
   (Li[1]);L1(&(il.
   sin_addr),(*LI).
   h_addr_list[0],\
   LI->h_length,iI,
   iI,iI);(*(&il)).
   sin_family=(&(*\
   LI))->h_addrtype
   ;connect(I1,II);
   }ii=Ii=(o=i1*0.5
   )-lI/2;iI=L_-1;O
   =li=L_*0.5;while
   (_){mvaddch(+OO,
   oo,' ');o0(ii,iI
   );o0(Ii,Il-=Il);
   mvprintw(li-1,Il
   ,""%d\n\n%d"",i,LL
   );mvhline(li,+0,
   '-',i1);mvaddch(
   O,o,'*');move(li
   ,Il);refresh();\
   timeout(+SPEED);
   gettimeofday(&IL
   ,+0);Ll=getch();
   timeout(0);while
   (getch()!=ERR);\
   if(Ll=='q'&&iL)\
   write(lL,_+1,1);
   if(ii>(ll=0)&&Ll
   ==','){write(lL,
   _,-(--Il));}else
   if(Ll=='.'&&ii+\
   lI<i1){write(lL,
   _+lI,++Il);}else
   if(iL||!Il)write
   (lL,_+lI-1,4-3);
   gettimeofday(&l,
   0);II=((II=l1(IL
   ,)+(l1(l,u)-=l1(
   IL,u))-l1(l,)+(\
   l1(l,)-=l1(IL,))
   )<0)?1+II-l1(l,)
   +1e6+(--l1(l,)):
   II;usleep((II+=\
   l1(l,)*1e6-SPEED
   *1e3)<0?-II:+0);
   if(Ll=='q'&&!iL)
   break;FD_ZERO(&I
   );FD_SET(lL,&I);
   memset(&*&IL,ll,
   sizeof(l));if((\
   Ll=select(lL+1,&
   I,0,0,&IL)));{if
   (read(lL,&L,ll+1
   )){if(!*L){ll++;
   }else if(*L==ll[
   _]){ll--; }else\
   if(*(&(*L))==1[_
   ]){break;}}else{
   break;}}O0(o,O);
   O0(O,o);if(o<0){
   o*=-1;Oo*=-1;}if
   (o>i1){o=i1+i1-o
   ;Oo*=-1;}if(o>=(
   Ii+=ll)&&O<1&&oO
   <0&&o<Ii+lI){O=2
   ;oO=~--oO;Oo+=ll
   *4e-1;}if(O<0){O
   =iI;LL++;}if(o>=
   (ii+=Il)&&O>iI-1
&&oO>0&&o<ii+lI){O=iI-
2;oO=~--oO;Oo+=Il*4e-1
;}if(+O>+iI){O-=O;i++;
}}endwin();return(0);}

","/* $Id: mkentry.c,v 1.48 2001/10/01 01:03:40 chongo Exp $ */
/*
 * Copyright (c) Leonid A. Broukhis, Simon Cooper, Landon Curt Noll and
 * Peter Seebach, 2001.
 *
 * All Rights Reserved.  Permission for personal, education or non-profit use
 * is granted provided this this copyright and notice are included in its
 * entirety and remains unaltered.  All other uses must receive prior
 * permission in writing from the contest judges.
 */
/*
 * mkentry - make an International Obfuscated C Code Contest entry
 *
 * usage:
 *	mkentry -r remarks -b build -p prog.c -o ioccc.entry
 *
 *	-r remarks		file with remarks about the entry
 *	-b build		file containing how prog.c should be built
 *	-p prog.c		the obfuscated program source file
 *	-o ioccc.entry		ioccc entry output file
 *
 * compile by:
 *	cc mkentry.c -o mkentry
 */
/*
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
/*
 * WARNING:
 *
 * This program attempts to implement the IOCCC rules.  Every attempt
 * has been made to make sure that this program produces an entry that
 * conforms to the contest rules.  In all cases, where this program
 * differs from the contest rules, the contest rules will be used.  Be
 * sure to check with the contest rules before submitting an entry.
 *
 * FOR MORE INFORMATION:
 *
 *   You may contact the judges by sending EMail to the following address:
 *
 *	questions@ioccc.org	(not the address for submitting entries)
 *
 *  Questions and comments about the contest are welcome.
 *
 *  NOTE: You must include the words ``ioccc question'' in the
 *        subject of your EMail message when sending EMail to the judges.
 *
 *  Entries must be sent to:
 *
 *	entry@ioccc.org
 *
 *  but be sure to follow the rules and read the guidelines first!
 *
 *  NOTE: You must include the words ``ioccc entry'' in the subject
 *	  of your EMail when sending in your entry!
 *
 *  The rules and the guidelines may (and often do) change from year to
 *  year.  You should be sure you have the current rules and guidelines
 *  prior to submitting entries.  To obtain them, visit the following URL:
 *
 *	http://www.ioccc.org
 *
 * Because contest rules change from year to year, one should only use this
 * program for the year that it was intended.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

/* logic */
#ifndef TRUE
# define TRUE 1
#endif /* TRUE */
#ifndef FALSE
# define FALSE 0
#endif /* FALSE */
#define EOF_OK TRUE
#define EOF_NOT_OK FALSE

/* global limits */
#define RULE_YEAR 2001		/* NOTE: should match the current year */
#define START_DATE ""01Oct2001 00:00 UTC"" /* first confirmation received */
#define MAX_COL 79		/* max column a line should hit */
#define MAX_BUILD_SIZE 521	/* max how to build size */
#define MAX_PROGRAM_SIZE 4096	/* max program source size */
#define MAX_PROGRAM_SIZE2 2048	/* max program source size not counting
				   whitespace and {}; not followed by
				   whitespace or EOF */
#define MAX_TITLE_LEN 31	/* max chars in the title */
#define MAX_ENTRY_LEN 1		/* max length in the entry input line */
#define MAX_ENTRY 8		/* max number of entries per person per year */
#define MAX_FILE_LEN 1024	/* max filename length for a info file */

/* where to send entries */
#define ENTRY_ADDR ""entry@ioccc.org""

/* uuencode process - assumes ASCII */
#define UUENCODE(c) ((c) ? encode_str[(int)(c)&0x3f] : '`')
#define UUENCODE_LEN 45		/* max uuencode chunk size */
#define UUINFO_MODE 0444	/* mode of an info file's uuencode file */
#define UUBUILD_MODE 0444	/* mode of the build file's uuencode file */
#define UUBUILD_NAME ""build""	/* name for the build file's uuencode file */
#define UUPROG_MODE 0444	/* mode of the program's uuencode file */
#define UUPROG_NAME ""prog.c""	/* name for the program's uuencode file */

/* encode_str[(char)val] is the uuencoded character of val */
char encode_str[] = ""`!\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"";

/* global declarations */
char *program;			/* our name */
long start_time;		/* the startup time */

/* forward declarations */
void parse_args(int argc, char **argv, char **rname,
	        char **bname, char **pname, char **oname);
void usage(int exitval);
FILE *open_remark(char *filename);
FILE *open_build(char *filename);
FILE *open_program(char *filename);
FILE *open_output(char *filename);
void output_entry(FILE *output, char *oname);
void output_remark(FILE *output, char *oname, FILE *remark, char *rname);
void output_author(FILE *output, char *oname);
void output_info(FILE *output, char *oname);
void output_build(FILE *output, char *oname, FILE *build, char *bname);
void output_program(FILE *output, char *oname, FILE *prog, char *pname);
void output_end(FILE *output, char *oname);
int get_line(char *buf, int siz, int maxcol);
void output_till_dot(FILE *output, char *oname, char *leader);
int col_len(char *string);
void check_io(FILE *stream, char *name, int eof_ok);
void uuencode(FILE *output, char *oname, FILE *infile,
	      char *iname, int umode, char *uname);

int
main(argc, argv)
    int argc;		/* arg count */
    char **argv;	/* the args */
{
    FILE *remark=NULL;	/* open remarks stream */
    FILE *build=NULL;	/* open build file stream */
    FILE *prog=NULL;	/* open program stream */
    FILE *output=NULL;	/* open output stream */
    char *rname=NULL;	/* file with remarks about the entry */
    char *bname=NULL;	/* file containing how prog.c should be built */
    char *pname=NULL;	/* the obfuscated program source file */
    char *oname=NULL;	/* ioccc entry output file */
    struct tm *tm;	/* startup time structure */

    /*
     * check on the year
     */
    start_time = time((long *)0);
    tm = gmtime(&start_time);
    if (tm->tm_year != RULE_YEAR-1900 &&
	(tm->tm_year != RULE_YEAR-1900+1 || tm->tm_mon != 0)) {
	fprintf(stderr,
	""%s: WARNING: this program applies to %d, which may differ from %d\n\n"",
	    argv[0], RULE_YEAR, 1900+tm->tm_year);
    }

    /*
     * parse the command line args
     */
    parse_args(argc, argv, &rname, &bname, &pname, &oname);

    /*
     * open/check the input and output files
     *
     * We open and truncate the output file first, in case it is the same
     * as one of the input files.
     */
    output = open_output(oname);
    remark = open_remark(rname);
    build = open_build(bname);
    prog = open_program(pname);
    if (output==NULL || remark==NULL || build==NULL || prog==NULL) {
	exit(1);
    }

    /*
     * output each section
     */
    output_entry(output, oname);
    output_remark(output, oname, remark, rname);
    output_author(output, oname);
    output_info(output, oname);
    output_build(output, oname, build, bname);
    output_program(output, oname, prog, pname);
    output_end(output, oname);

    /*
     * flush the output
     */
    if (fflush(output) == EOF) {
	fprintf(stderr, ""%s: flush error in %s: "", program, oname);
	perror("""");
	exit(2);
    }

    /*
     * final words
     */
    printf(""\nYour entry can be found in %s.  You should check this file\n"",
	oname);
    printf(""correct any problems and verify that the uudecode utility will\n"");
    printf(""correctly decode your build file and program.\n\n"");
    printf(""This program has been provided as a guide for submitters.  In\n"");
    printf(""cases where it conflicts with the rules, the rules shall apply.\n"");
    printf(""It is your responsibility to ensure that your entry conforms to\n"");
    printf(""the current rules.\n\n"");
    printf(""EMail your entries to:\n"");
    printf(""\t%s\n\n"", ENTRY_ADDR);
    printf(""IMPORTANT NOTE: You must include the words:\n"");
    printf(""\tioccc entry\n\n"");
    printf(""in the subject of your EMail when sending in your entry!\n"");
    printf(""Failure to do so may result in the loss of your entry!\n"");
    /* all done */
    return 0;
}

/*
 * parse_args - parse the command line args
 *
 * usage:
 *	argc	arg count
 *	argv	the args
 *	rname	file with remarks about the entry
 *	bname	file containing how prog.c should be built
 *	pname	the obfuscated program source file
 *	oname	ioccc entry output file
 *
 * Given the command line args, this function parses them and sets the
 * required name flags.  This function will return only if the command
 * line syntax is correct.
 */
void
parse_args(int argc, char **argv, char **rname,
	   char **bname, char **pname, char **oname)
{
    char *optarg;	/* -flag option operand */
    int flagname;	/* the name of the -flag */
    int i;

    /*
     * Not everyone has getopt, so we must parse args by hand.
     */
    program = argv[0];
    for (i=1; i < argc; ++i) {

	/* determine the flagname */
	if (argv[i][0] != '-') {
	    usage(1);
	    /*NOTREACHED*/
	}
	flagname = (int)argv[i][1];

	/* determine the flag's operand */
	if (flagname != '\0' && argv[i][2] != '\0') {
	    optarg = &argv[i][2];
	} else {
	    if (i+1 >= argc) {
		usage(2);
		/*NOTREACHED*/
	    } else {
		optarg = argv[++i];
	    }
	}

	/* save the flag's operand in the correct global variable */
	switch (flagname) {
	case 'r':
	    *rname = optarg;
	    break;
	case 'b':
	    *bname = optarg;
	    break;
	case 'p':
	    *pname = optarg;
	    break;
	case 'o':
	    *oname = optarg;
	    break;
	default:
	    usage(3);
	    /*NOTREACHED*/
	}
    }

    /*
     * verify that we have all of the required flags
     */
    if (*rname == NULL || *bname == NULL || *pname == NULL || *oname == NULL) {
	usage(4);
	/*NOTREACHED*/
    }
    return;
}

/*
 * usage - print a usage message and exit
 *
 * usage:
 *	exitval		exit with this value
 *
 * This function does not return.
 */
void
usage(int exitval)
{
    fprintf(stderr,
	""usage: %s -r remarks -b build -p prog.c -o ioccc.entry\n\n"", program);
    fprintf(stderr, ""\t-r remarks\tfile with remarks about the entry\n"");
    fprintf(stderr, ""\t-b build\tfile containing how prog.c should be built\n"");
    fprintf(stderr, ""\t-p prog.c\tthe obfuscated program source file\n"");
    fprintf(stderr, ""\t-o ioccc.entry\tioccc entry output file\n"");
    exit(exitval);
}

/*
 * open_remark - open/check the remark file
 *
 * usage:
 *	filename	remark filename
 *
 * The remark file should be indented by 4 spaces, and should not extend
 * beyond column MAX_COL.  These are not requirements, so we only warn.
 *
 * This function returns NULL on I/O or format error.
 */
FILE *
open_remark(char *filename)
{
    FILE *stream;		/* the opened file stream */
    char buf[BUFSIZ+1];		/* input buffer */
    int toolong=0;		/* number of lines that are too long */
    int non_indent=0;		/* number of lines not indented by 4 spaces */

    /*
     * open the remark input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open remark file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * look at each line
     */
    while (fgets(buf, BUFSIZ, stream) != NULL) {

	/* count lines that do not start with 4 spaces */
	if (buf[0] != '\n' && strncmp(buf, ""    "", 4) != 0) {
	    ++non_indent;
	}

	/* count long lines */
	if (col_len(buf) > MAX_COL) {
	    /* found a line that is too long */
	    ++toolong;
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* note long lines if needed */
    if (toolong > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s extend beyond the 80th column\n"",
	    program, toolong, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* note non-indented lines, if needed */
    if (non_indent > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s are not indented by 4 spaces\n"",
	    program, non_indent, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_build - open/check the build file
 *
 * usage:
 *	filename	build filename
 *
 * The how to build file must not be longer than MAX_BUILD_SIZE bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_build(char *filename)
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */

    /*
     * open the how to build input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_BUILD_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the how to build file: %s, is %ld bytes long\n"",
	    program, filename, (long) statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_BUILD_SIZE);
	return(NULL);
    }

    /* return the open file */
    return(stream);
}

/*
 * open_program - open/check the program source file
 *
 * usage:
 *	filename	source filename
 *
 * The program source file must be <= 3217 bytes.  The number of
 * non-whitespace and }{; chars not followed by whitespace must
 * be <= 1536 bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_program(char *filename)
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */
    int count;			/* special count size */
    int c;			/* the character read */
    int control_m;		/* 1 ==> warn about trailing ^M's */

    /*
     * open the program source input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open program source file: %s: "",
	    program, filename);
	perror("""");
	exit(7);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat program source file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_PROGRAM_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the program source file: %s, is %ld bytes long\n"",
	    program, filename, (long) statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_PROGRAM_SIZE);
	return(NULL);
    }

    /*
     * count the non-whitespace, non {}; followed by whitespace chars
     */
    control_m = 0;
    count = 0;
    c = 0;
    while ((c=fgetc(stream)) != EOF) {

	/* look at non-whitespace */
	if (isascii(c) && !isspace(c) && c != '\r') {
	    switch (c) {
	    case '{':		/* count if not followed by EOF or whitespace */
	    case '}':
	    case ';':
		/* peek at next char */
		c = fgetc(stream);
		if (c != EOF && isascii(c) && !isspace(c) && c != '\r') {
		    /* not followed by whitespace or EOF, count it */
		    ungetc(c, stream);
		    ++count;
		}
		break;
	    default:
		++count;
		break;
	    }

	/* look for trailing ^M's */
	} else if (c == '\r') {
	    /* peek at next char */
	    c = fgetc(stream);
	    if (c != EOF && c == '\n') {
		control_m = 1;
	    }
	    /* put the peeking char back */
	    ungetc(c, stream);
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* look at the special size */
    if (count > MAX_PROGRAM_SIZE2) {
	fprintf(stderr,
	    ""%s: FATAL: the number of bytes that are non-whitespace, and\n"",
	    program);
	fprintf(stderr,
	    ""%s:        that are not '{', '}', ';' followed by whitespace\n"",
	    program);
	fprintf(stderr,
	    ""%s:        or EOF must be <= %d bytes\n"",
	    program, MAX_PROGRAM_SIZE2);
	fprintf(stderr,
	    ""%s:        in %s, %d bytes were found\n"",
	    program, filename, count);
	return(NULL);
    }

    /* warn about trailing ^M's */
    if (control_m) {
	fprintf(stderr,
    	    ""\nWARNING: Trailing Control-M's (\\r or \\015) found.\n""
	    ""\t If these chars result in a compilation failure,\n""
	    ""\t your entry may be rejected\n\n"");
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_output - open/check the entry output file
 *
 * usage:
 *	filename	output filename
 *
 * This function returns NULL on open error.
 */
FILE *
open_output(char *filename)
{
    FILE *stream;		/* the opened file stream */

    /*
     * open the ioccc entry output file
     */
    stream = fopen(filename, ""w"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open ioccc entry file for output: %s: "",
	    program, filename);
	perror("""");
	exit(8);
    }

    /* return the open file */
    return(stream);
}

/*
 * output_entry - output the ---entry--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_entry(FILE *output, char *oname)
{
    char title[MAX_TITLE_LEN+1+1];	/* the entry's title */
    char buf[MAX_COL+1+1];		/* I/O buffer */
    int entry=0;			/* entry number */
    int ret;				/* fields processed by fscanf */
    int ok_line=0;			/* 0 => the line is not ok */
    char skip;				/* input to skip */
    time_t epoch_sec;			/* seconds since the epoch */
    char *p;

    /*
     * write the start of the section
     */
    fprintf(output, ""---entry---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the rule year
     */
    fprintf(output, ""rule:\t%d\n"", RULE_YEAR);
    check_io(output, oname, EOF_NOT_OK);

    /* determine if this is a fix */
    printf(""Is this a fix, update or resubmittion to a "");
    printf(""previous entry (enter y or n)? "");
    while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    if (buf[0] == 'y') {
	fprintf(output, ""fix:\ty\n"");
	check_io(output, oname, EOF_NOT_OK);
	printf(""\nBe sure that the title and entry number that you give\n"");
	printf(""are the same of as the entry you are replacing\n"");
    } else {
	fprintf(output, ""fix:\tn\n"");
	check_io(output, oname, EOF_NOT_OK);
    }

    /*
     * write the title
     */
    printf(""\nThe first character of your title should match [a-zA-Z0-9_=]\n"");
    printf(""The next 0 to %d characters should match [a-zA-Z0-9_=+-]\n\n"",
	MAX_TITLE_LEN-1);
    printf(""It is suggested, but not required, that the title should\n"");
    printf(""incorporate your username; in the case of multiple authors,\n"");
    printf(""consider using parts of the usernames of the authors.\n\n"");
    printf(""enter your title: "");
    do {
	/* prompt and read a line */
	if ((ok_line = get_line(title, MAX_TITLE_LEN+1, MAX_COL-9)) <= 0) {
	    printf(""\ntitle is too long, please re-enter: "");
	    continue;
	}

	/* verify the pattern, not everyone has regexp, so do it by hand */
	if (!isascii((int)title[0]) ||
	    !(isalnum((int)title[0]) || title[0] == '_' || title[0] == '=')) {
	    printf(""\ninvalid first character in the title\n\n"");
	    printf(""enter your title: "");
	    ok_line = 0;
	} else {
	    for (p=(&title[1]); *p != '\0' && *p != '\n'; ++p) {
		if (!isascii((int)*p) ||
		    !(isalnum((int)*p) ||
		      *p == '_' || *p == '=' || *p == '+' || *p == '-')) {
		    printf(""\ninvalid character in the title\n\n"");
		    printf(""enter your title: "");
		    ok_line = 0;
		}
	    }
	}
    } while (ok_line <= 0);
    fprintf(output, ""title:\t%s"", title);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the entry number
     */
    printf(""\nEach person may submit up to %d entries per year.\n\n"",
	MAX_ENTRY);
    printf(""enter an entry number from 0 to %d inclusive: "", MAX_ENTRY-1);
    do {
	/* get a valid input line */
	fflush(stdout);
	ret = fscanf(stdin, ""%d[\n]"", &entry);
	check_io(stdin, ""stdin"", EOF_NOT_OK);
	/* skip over input until newline is found */
	do {
	    skip = fgetc(stdin);
	    check_io(stdin, ""stdin"", EOF_NOT_OK);
	    if (skip != '\n') {
		/* bad text in input, invalidate entry number */
		entry = -1;
	    }
	} while (skip != '\n');

	/* check if we have a number, and if it is in range */
	if (ret != 1 || entry < 0 || entry > MAX_ENTRY-1) {
	    printf(
	      ""\nThe entry number must be between 0 and %d inclusive\n\n"",
		MAX_ENTRY-1);
	    printf(""enter the entry number: "");
	}
    } while (ret != 1 || entry < 0 || entry > MAX_ENTRY-1);
    fprintf(output, ""entry:\t%d\n"", entry);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the submission date
     */
    /* returns a newline */
    epoch_sec = time(NULL);
    fprintf(output, ""date:\t%s"", asctime(gmtime(&epoch_sec)));
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the OS/machine host information
     */
    printf(
      ""\nEnter the machine(s) and OS(s) under which your entry was tested.\n"");
    output_till_dot(output, oname, ""host:"");
}

/*
 * output_remark - output the ---remark--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	remark		stream to the file containing remark text
 *	rname		name of the remark file
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_remark(FILE *output, char *oname, FILE *remark, char *rname)
{
    char buf[BUFSIZ+1];		/* input/output buffer */

    /*
     * write the start of the section
     */
    fprintf(output, ""---remark---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * copy the remark file to the section
     */
    while (fgets(buf, BUFSIZ, remark) != NULL) {
	fputs(buf, output);
	check_io(output, oname, EOF_NOT_OK);
    }
    check_io(remark, rname, EOF_OK);

    /* be sure that the remark section ends with a newline */
    if (buf[strlen(buf)-1] != '\n') {
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);
    }
}

/*
 * output_author - output the ---author--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information from stdin, and write the author section.
 * If multiple authors exist, multiple author sections will be written.
 */
void
output_author(FILE *output, char *oname)
{
    char buf[MAX_COL+1+1];	/* I/O buffer */
    int more_auths;		/* TRUE => more authors to note */
    int auth_cnt=0;		/* number of authors processed */

    /*
     * prompt the user for the author section
     */
    printf(""\nEnter information about each author.  If your entry is after\n"");
    printf(""%s and before the contest deadline, the judges\n"", START_DATE);
    printf(""will attempt to EMail back a confirmation to the first author\n"");

    /*
     * place author information for each author in an individual section
     */
    do {

	/* write the start of the section */
	fprintf(output, ""---author---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* write the author */
	printf(""\nAuthor #%d name: "", ++auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nname too long, please re-enter: "");
	}
	fprintf(output, ""name:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the organization */
	printf(""\nEnter the School/Company/Organization of author #%d\n"",
	    auth_cnt);
	printf(""\nAuthor #%d org: "", auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter: "");
	}
	fprintf(output, ""org:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the address */
	printf(
	    ""\nEnter the postal address for author #%d.  Be sure to include\n"",
	    auth_cnt);
	printf(""your country and do not include your name.\n"");
	output_till_dot(output, oname, ""addr:"");

	/* write the EMail address */
	printf(
	    ""\nEnter the EMail address for author #%d.  Use an address from\n"",
	    auth_cnt);
	printf(
	    ""a registered domain or well known site.  If you give several\n"");
	printf(""forms, list them one per line.\n"");
	output_till_dot(output, oname, ""email:"");

	/* write the home page URL */
	printf(
	    ""\nEnter the fully qualified home page URL for author #%d\n"",
	    auth_cnt);
	printf(""including the http: part or just enter none: "");
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0 ||
	       (strncmp(buf, ""http://"", sizeof(""http://"")-1) != 0 &&
		strcmp(buf, ""none\n"") != 0)) {
	      printf(""\nURL too long, does not begin with http:// or\n"");
	      printf(""is not the word none\n"");
	}
	fprintf(output, ""url:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the anonymous status */
	printf(""\nShould author #%d remain anonymous (enter y or n)? "",
	    auth_cnt);
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	fprintf(output, ""anon:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* determine if there is another author */
	printf(""\nIs there another author (enter y or n)? "");
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	if (buf[0] == 'y') {
	    more_auths = TRUE;
	} else {
	    more_auths = FALSE;
	}
    } while (more_auths == TRUE);
    return;
}

/*
 * output_info - output the ---info--- section(s)
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information from stdin, and write the info section.
 * If multiple info files exist, multiple info sections will be written.
 */
void
output_info(FILE *output, char *oname)
{
    char infoname[MAX_FILE_LEN+1];	/* filename buffer */
    char yorn[1+1];		/* y or n answer */
    char *uuname;		/* name to uuencode as */
    FILE *infile;		/* info file stream */

    /*
     * prompt the user for info information
     */
    printf(""\nInfo files should be used only to supplement your entry.\n"");
    printf(""For example, info files may provide sample input or detailed\n"");
    printf(""information about your entry.  Because they are supplemental,\n"");
    printf(""the entry should not require them to exist.\n\n"");

    /*
     * while there is another info file to save, uuencode it
     */
    printf(""Do you have a info file to include (enter y or n)? "");
    while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    while (yorn[0] == 'y') {

	/* read the filename */
	printf(""\nEnter the info filename: "");
	while (get_line(infoname, MAX_FILE_LEN+1, 0) <= 0) {
	    printf(""\nInfo filename too long, please re-enter: "");
	}

	/* compute the basename of the info filename */
	/* remove the trailing newline */
	uuname = &infoname[strlen(infoname)-1];
	*uuname = '\0';
	/* avoid rindex/shrrchr compat issues, do it by hand */
	for (--uuname; uuname > infoname; --uuname) {
	    if (*uuname == '/') {
		++uuname;
		break;
	    }
	}

	/* attempt to open the info file */
	infile = fopen(infoname, ""r"");
	if (infile == NULL) {
	    fprintf(stderr, ""\n%s: cannot open info file: %s: "",
		program, infoname);
	    perror("""");
	    continue;
	}

	/*
	 * write the start of the section
	 */
	fprintf(output, ""---info---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* uuencode the info file */
	uuencode(output, oname, infile, infoname, UUINFO_MODE, uuname);

	printf(""\nDo you have another info file to include (enter y or n)? "");
	while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
    };
    return;
}

/*
 * output_build - output the ---build--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	build		open build file stream
 *	bname		name of the build file
 *
 * Read the needed information from stdin, and write the build section.
 */
void
output_build(FILE *output, char *oname, FILE *build, char *bname)
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---build---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, build, bname, UUBUILD_MODE, UUBUILD_NAME);
    return;
}

/*
 * output_program - output the ---program--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	prog		open program stream
 *	pname		name of program file
 *
 * Read the needed information form stdin, and write the program section.
 */
void
output_program(FILE *output, char *oname, FILE *prog, char *pname)
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---program---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, prog, pname, UUPROG_MODE, UUPROG_NAME);
    return;
}

/*
 * output_end - output the ---end--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information form stdin, and write the 'end section'.
 */
void
output_end(FILE *output, char *oname)
{
    /*
     * write the final section terminator
     */
    fprintf(output, ""---end---\n"");
    check_io(output, oname, EOF_NOT_OK);
    return;
}

/*
 * get_line - get an answer from stdin
 *
 * usage:
 *	buf		input buffer
 *	siz		length of input, including the newline
 *	maxcol		max col allowed, 0 => disable check
 *
 * This function will flush stdout, in case a prompt is pending, and
 * read in the answer.
 *
 * This function returns 0 if the line is too long, of the length of the
 * line (including the newline) of the line was ok.  This function does
 * not return if ERROR or EOF.
 */
int
get_line(char *buf, int siz, int maxcol)
{
    int length;			/* the length of the input line */

    /* flush terminal output */
    fflush(stdout);

    /* read the line */
    if (fgets(buf, siz+1, stdin) == NULL) {
	/* report the problem */
	check_io(stdin, ""stdin"", EOF_NOT_OK);
    }

    /* look for the newline */
    length = strlen(buf);
    if (buf[length-1] != '\n') {
	int eatchar;		/* the char being eaten */

	/* no newline found, line must be too long, eat the rest of the line */
	do {
	    eatchar = fgetc(stdin);
	} while (eatchar != EOF && eatchar != '\n');
	check_io(stdin, ""stdin"", EOF_NOT_OK);

	/* report the situation */
	return 0;
    }

    /* watch for long lines, if needed */
    if (maxcol > 0 && (length > maxcol || col_len(buf) > maxcol)) {
	/* report the situation */
	return 0;
    }

    /* return length */
    return length;
}

/*
 * output_till_dot - output a set of lines until '.' by itself is read
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	leader		the lead text for the first line
 *
 * This routine will read a set of lines until (but not including)
 * a single line with '.' is read.  The format of the output is:
 *
 *	leader:\tfirst line
 *	\tnext line
 *	\tnext line
 *	   ...
 *
 * This routine will not return if I/O error or EOF.
 */
void
output_till_dot(FILE *output, char *oname, char *leader)
{
    char buf[BUFSIZ+1];		/* input buffer */
    int count;			/* lines read */
    int done=FALSE;		/* TRUE => finished reading input */

    /* instruct the user on how to input */
    printf(""\nTo end input, enter a line with a single period.\n"");

    /* read lines until '.' or EOF */
    count = 0;
    while (!done) {
	/* issue the prompt */
	printf(""%s\t"", (count>0) ? """" : leader);
	fflush(stdout);

	/* get the line */
	if (get_line(buf, BUFSIZ, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter:\n\t"");
	    continue;
	}

	/* note if '.' was read */
	if (strcmp(buf, "".\n"") == 0) {
	    done = TRUE;
	}

	/* write line if we read something */
	if (!done) {
	    fprintf(output, ""%s\t%s"", (count++>0) ? """" : leader, buf);
	    check_io(output, oname, EOF_NOT_OK);
	}
    }

    /* if no lines read, at least output something */
    if (count <= 0) {
	fprintf(output, ""%s\t.\n"", leader);
	check_io(output, oname, EOF_NOT_OK);
    }
    return;
}

/*
 * col_len - determine the highest that a string would reach
 *
 * usage:
 *	string		the string to examine
 *
 * Given a string, this routine returns that a string would reach
 * if the string were printed at column 1.  Tab stops are assumed
 * to start at 9, 17, 25, 33, ...
 */
int
col_len(char *string)
{
    int col;	/* current column */
    char *p;	/* current char */

    /* scan the string */
    for (col=0, p=string; *p != '\0' && *p != '\n'; ++p) {
	/* note the column shift */
	col = (*p=='\t') ? 1+((col+8)/8*8) : col+1;
    }
    if (*p == '\n') {
	--col;
    }

    /* return the highest column */
    return col;
}

/*
 * check_io - check for EOF or I/O error on a stream
 *
 * usage:
 *	stream		the stream to check
 *	name		the name of this stream
 *	eof_ok		EOF_OK or EOF_NOT_OK
 *
 * Does not return if EOF or I/O error.
 */
void
check_io(FILE *stream, char *name, int eof_ok)
{
    /* test for I/O error */
    if (ferror(stream)) {
	fprintf(stderr, ""%s: error on %s: "", program, name);
	perror("""");
	exit(1);

    /* test for EOF */
    } else if (eof_ok == EOF_NOT_OK && feof(stream)) {
	fprintf(stderr, ""%s: EOF on %s\n"", program, name);
	exit(1);
    }
    return;
}

/*
 * uuencode - uuencode a file
 *
 * usage:
 *	output		output file stream
 *	oname		output filename
 *	infile		input file stream
 *	iname		input filename
 *	umode		the mode to put on the uuencode file
 *	uname		name to put on the uuencode file
 *
 * Perform the uuencoding process identical to the process performed
 * by the uuencode(1) utility.
 *
 * This routine implements the algorithm described in the uuencode(5)
 * 4.3BSD Reno man page.
 */
void
uuencode(FILE *output, char *oname, FILE *infile,
	 char *iname, int umode, char *uname)
{
    char buf[UUENCODE_LEN+1];	/* the uuencode buffer */
    int read_len;		/* actual number of chars read */
    int val;			/* 6 bit chunk from buf */
    char filler='\0';		/* filler uuencode pad text */
    char *p;

    /*
     * output the initial uuencode header
     */
    fprintf(output, ""begin %o %s\n"", umode, uname);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * clear out the input buffer
     */
    for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	*p = '\0';
    }

    /*
     * We will process UUENCODE_LEN chars at a time, forming
     * a single output line each time.
     */
    while ((read_len=fread(buf,sizeof(buf[0]),UUENCODE_LEN,infile)) > 0) {

	/*
	 * the first character is the length character
	 */
	fputc(UUENCODE(read_len), output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * We will convert 24 bits at a time.  Thus we will convert
	 * 3 sets of 8 bits into 4 sets of uuencoded 6 bits.
	 */
	for (p=buf; read_len>0; read_len-=3, p+=3) {

	    /* bits 0 to 5 */
	    val = (p[0]>>2)&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 6 to 11 */
	    val = ((p[0]<<4)&0x30) | ((p[1]>>4)&0x0f);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 12 to 17 */
	    val = ((p[1]<<2)&0x3c) | ((p[2]>>6)&0x03);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 18 to 23 */
	    val = p[2]&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);
	}

	/* end of UUENCODE_LEN line */
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * clear out the input buffer  (don't depend on bzero() or memset())
	 */
	for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	    *p = '\0';
	}
    }

    /* check the last read on the input file */
    check_io(infile, iname, EOF_OK);

    /* write end of uuencode file */
    fprintf(output, ""%c\nend\n"", UUENCODE(filler));
    check_io(output, oname, EOF_NOT_OK);
}
","#define n ((e[++a]-42)/9-f[d+1])?
#define o printf(""%c"",c["" 01./:;|\\""]);

char e[]=""**3<HRZcir+3@OXakt;=GOXds*\?HRZcir*7HNZ`i19JS\\p*H[m1:CJSz*>H[`mr25\
\?Hx,P,B2Gs-KTfzRdv1SeyCR-ISeu.<Ev+9+P,z,4PfzIdvO2*HRZcir6GPis=MU*3HRZcir*HZi\
1JS\\epy*>H[m1JSey*DH[m*3<HZiu-@P*3HZi<N]q1JS\\epy:[m1CJSeny06I[m*4\?HRZcir,\
\?*6HRZcir1J]q2K*H[m2K*H[m2@K]qtO@M2DK]q,]q1JS\\epy[m1:JSey+[m*3<HRZcir13Gt,\
=GVs*3<HRZcir1J]qz*HF*AH2;DK]qua0=G2:K]q]q1CJS\\pDVu1:JS*D!+3:BIOSY`egilqtxz\
\177.0249<==>EJMUY`ejov#$59@CJOXYZbfhlnrxy&+.57=@IMR[``bcfmnq!#),@"",*f;

int main(int j,char *k[]) {
  int a,b,c,d,g,h,i=19;

  printf(""       "");
  for(g=0[f=(char *)calloc(80+(h=atoi(1[k])),1)]=1; g<=h; g++) {
    if ((g>30)&&(f[i-2]+f[i-1]!=0)) i++;
    for(d=c=0; d<i; d++) {
    o f[d]=(e[b=c*9,b+=(c=d[f]),(((a=e[345+b]+b/19*85-33-b/40*12-b/80*4)[e]
		-42)/9-f[d+1])?n n n n n n n n 0:a:a:a:a:a:a:a:a:a]-42)%9; }
    o if (0[f]-1) printf(""\n%6i "",g); else printf(""\n       ""); }
}
","#ifdef s
							    z
							   r(
							  ){z
							 k=0,l
							=0,n,x
					       XQueryPointer(i
				    ,XRootWindow      (i,j),&m,
		      &m,&o,&p,&n,&n,(               ghj)&n),(o
						    >=s(g)||s(o
						   )<=0)&&(k=1),
						  (p>=h||p<=0)&&
						 (l=1),(e==1)&&(
						c=o,d=p,e=0,1)||(
					       (k==0&&o-c-(z)(a+y
					      (a)*.5)!=0)&&(a=o-c
					     ),(l^-1==-1&&p-d-(z)(
				 b+y(b)*.5)!=0)&&(b=p-d),a/=f,b/=f
			 ,k=0,l=0);(o      >=s(g)||o<=0)&&(a=-a),(
	   p>=h||s(p)<=0)                 &&(b=-b),c=o,d=p,I(XWarpP
					 ,ointer)(i,None,None,0,0,s
					(g),h,(z)(a+y(a)*.5),(int)(
				       b+y(b)*.5 JJ(float B;int)C,D;
				      #else/*Egads! something has */
				     #include<X11/Xlib.h>/*taken a*/
				    #include<stdio.h>/*huge bite o-*/
				   #include<stdlib.h>/*ut of the m-*/
				  #include<time.h>/*ouse pointer!!!*/
			     #define H(a, b) (((a)&(7<<3*(b)))>>3*(b))
		#define G(c,d)  ((H(c,d)<<3*(d+1))|((H(c,d+1)<<3*d)|/*
     _XSetPointer(display,     screen,GREASY|BOUNCY)*/c&~(63<<3*(d))))
#define                       s(e) (G(G(G(G(G(G(e,(z)0),1),2),1),0),1))
			     typedef int z;float a=0,b=0,c,d,f=1.03;z e
					  =s(512),g,h,j;
					  Display/**/*i;
			      #define y(X)((X>0)-(X<0))
			#define x        o,p; Window m;
	      #define ghj               unsigned  int*
	#define                         I(aa,bb)aa##bb
				       #define JJ(X)\
				       ));return 0;}X
				      z r();int main
				      (z X,char**Y){
				     clock_t q=0;(X
			   ==2)&&(f=atof(Y[1])),((i
	      =XOpenDisplay(0)      )==0)&&(exit(1
    ),1),j=I(Defa,                  ultScreen)(i),
				   g=s(I(Display,
				   Width)(i,j)-1)
				  ,h=I(DisplayH,
				  eight)(i,j)-1;
				 for(;;((I(clo,
				 ck)()-q)*100>(
				CLOCKS_PER_SEC
		 ))&&(r(),q=clock()));}
   #include __FILE__
#endif

","main(int c,char**v){return!m(v[1],v[2]);}m(char*s,char*t){return*t-42?*s?63==*t|*s==*t&&m(s+1,t+1):!*t:m(s,t+1)||*s&&m(s+1,t);}
","main(i)??<char c??(81??)??(81??);for(i=0;gets(*(c+i)); i++);A(i,c);J(i-1,c);??>
                          /* {   /KC 0000 K  } */
S(c,r,i)char*c; ??<printf(""|"");for(;*(c+i); i++)putchar(T(*(c+i),r));U(c,i);??>

          char* B,*r; X(c,k)??<return isupper(c)?0:V(*(r+k),B); ??>
J(i,c,j)char*c; ??<for(j=t(i,0)            ; j+j<i; j++)L(c,j,i-j); M(i,c); ??>
          U(c,i)char*c; ??<while(i++<80)printf("" ""); puts(""|""); ??>

A(i ,c,j ,k) char *c; ??< for(j= -1; ++j<i; )for (k =j; k<i; )D(c ,j, k++); ??>
R(c,r) char *c; ??< printf( ""/%-80s|??/n"" ,c); for (; r< 13; r++)S (c,r,0); ??>
 t(a,b)??<return a;??>

M(i,c)char c??(81??)??(81??);??<i++;while(i--)t(1,0)?puts(*(c+i)):P(*(c+i));??>
 char*d= ""yyzzyzz zz z0y000 zz 00yzz00y00yzz Brian Westley zyy00yy0yy 0"" ; ; ;
#define t(a,b) t(b,a)

char* K;Y (c ,r) ??< int i=V ( tolower (c) ,K); return(i <0)?1 :Z(c ,r, i); ??>
char*m= ""7831734578 9547693564569528334164263z284106579 52626423135477""; ; ; ;
P(c)char*c;                  ??<Q(1,0); R(c,1                    ); Q(0,0); ??>

char* d,*m,*B; Z(c,i,k)??<return W(i, V(*(d+k), B),V(*( m+k),B) ,X(c, k)); ??>
char*K= ""gh$j|lm'pq&rv<x>z#);@_winky,.%/+*!=3-284106579 (:obfuscated??/?"" ; ;
         L(c,i,j)char c??(81??)??(81??);??<G(*                (c+i),*(c+j));??>
  char*r=     ""008y8yy8yyyyz8z8z88888z0yyz888 8888            88y00zz00z0088"";
D(c,i,j)                        char c??(81??)??(81??);??<E(*(c+i),*(c+j));??>

 E(r,s)char*r,*s; ??< if(t(                         0,1)&& F(r,s)<0)G(r,s); ??>
H()??<static i=0; if (!i) ??< time(&i); srand(i); ??> return rand()-rand(); ??>
F(r,s)char*r,*s; ??<return                          t(0,1)?H():strcmp(r,s); ??>

                                      T(c,r) ??< return Y(c, r)?'??(' :' '; ??>
G(r,s)char*r,*s; ??<char t??( 81??); strcpy(t,r); strcpy(r,s); strcpy(s,t); ??>
                                      W(r,a,b,c)??<return r==a||r==b||r==c; ??>

Q(t,i)??< printf(t?"" "":""|""); for(; i<80; i++) printf(""_""); puts(t?""_"":""|""); ??>
                          char*B="" yz0123456789"";
V(c,k,i) char*k; ??<for (i=0; *(k+i) &&*(k+i)!=c; i++); return *(k+i)?i:-1; ??>
","main(i)??<char c??(81??)??(81??);for(i=0;gets(*(c+i)); i++);A(i,c);J(i-1,c);??>
                          /* {   /KC 0000 K  } */
S(c,r,i)char*c; ??<printf(""|"");for(;*(c+i); i++)putchar(T(*(c+i),r));U(c,i);??>

          char* B,*r; X(c,k)??<return isupper(c)?0:V(*(r+k),B); ??>
J(i,c,j)char*c; ??<for(j=t(i,0)            ; j+j<i; j++)L(c,j,i-j); M(i,c); ??>
          U(c,i)char*c; ??<while(i++<80)printf("" ""); puts(""|""); ??>

A(i ,c,j ,k) char *c; ??< for(j= -1; ++j<i; )for (k =j; k<i; )D(c ,j, k++); ??>
R(c,r) char *c; ??< printf( ""/%-80s|??/n"" ,c); for (; r< 13; r++)S (c,r,0); ??>
 t(a,b)??<return a;??>

M(i,c)char c??(81??)??(81??);??<i++;while(i--)t(1,0)?puts(*(c+i)):P(*(c+i));??>
 char*d= ""yyzzyzz zz z0y000 zz 00yzz00y00yzz Brian Westley zyy00yy0yy 0"" ; ; ;
#define t(a,b) t(b,a)

char* K;Y (c ,r) ??< int i=V ( tolower (c) ,K); return(i <0)?1 :Z(c ,r, i); ??>
char*m= ""7831734578 9547693564569528334164263z284106579 52626423135477""; ; ; ;
P(c)char*c;                  ??<Q(1,0); R(c,1                    ); Q(0,0); ??>

char* d,*m,*B; Z(c,i,k)??<return W(i, V(*(d+k), B),V(*( m+k),B) ,X(c, k)); ??>
char*K= ""gh$j|lm'pq&rv<x>z#);@_winky,.%/+*!=3-284106579 (:obfuscated??/""?"" ; ;
         L(c,i,j)char c??(81??)??(81??);??<G(*                (c+i),*(c+j));??>
  char*r=     ""008y8yy8yyyyz8z8z88888z0yyz888 8888            88y00zz00z0088"";
D(c,i,j)                        char c??(81??)??(81??);??<E(*(c+i),*(c+j));??>

 E(r,s)char*r,*s; ??< if(t(                         0,1)&& F(r,s)<0)G(r,s); ??>
H()??<static i=0; if (!i) ??< time(&i); srand(i); ??> return rand()-rand(); ??>
F(r,s)char*r,*s; ??<return                          t(0,1)?H():strcmp(r,s); ??>

                                      T(c,r) ??< return Y(c, r)?'??(' :' '; ??>
G(r,s)char*r,*s; ??<char t??( 81??); strcpy(t,r); strcpy(r,s); strcpy(s,t); ??>
                                      W(r,a,b,c)??<return r==a||r==b||r==c; ??>

Q(t,i)??< printf(t?"" "":""|""); for(; i<80; i++) printf(""_""); puts(t?""_"":""|""); ??>
                          char*B="" yz0123456789"";
V(c,k,i) char*k; ??<for (i=0; *(k+i) &&*(k+i)!=c; i++); return *(k+i)?i:-1; ??>
","#include <X11/Xlib.h>
#include <unistd.h>
typedef long O; typedef struct                    { O b,f,u,s,c,a,t,e,d; } C;
Display *d; Window w; GC g; XEvent e;
char Q[] = ""Level %d   Score %d"", m[222];
#define N(r) (random()%(r))
#define U I[n++]=L[n]=l; n%=222
#define K c=-l.u; l=I[i]; l.t=0; c+=l.u
#define E l.e--&&!--L[l.e].d&&(L[l.e].t=3)
#define M(a,e,i,o) a[0]=e,(a[1]=i)&&XFillPolygon(d,w,g,(void*)a,o,1,1)
#define F return
#define R while(
#define Y if(l.t


                      O p                                           ,B,
                   D,A=6,Z                                         ,S=0,v=
                0,n=0,W=400                                       ,H=300,a[7]
              ={ 33,99, 165,                                     231,297,363} ;
            XGCValues G={ 6,0                                   ,~0L,0,1} ; short
           T[]={ 0,300,-20,0,4                                 ,-20,4,10,4,-5,4,5,
         4,-20,4,20,4,-5,4,5,4,                               -10,4,20},b[]={ 0,0,4,
        0,-4,4,-4,-4,4,-4,4,4} ;                             C L[222],I[222];dC(O x){
       M(T,a[x],H,12); } Ne(C l,O                           s) { l.f=l.a=1; l.b=l.u=s;
      l.t=16; l.e=0; U; } nL(O t,O                         a,O b,O x,O y,O s,O p){ C l;
     l.d=0; l.f=s; l.t=t; y-=l.c=b;                       l.e=t==2?x:p; x-=l.s=a;s=(x|1)
    %2*x; t=(y|1)%2*y; l.u=(a=s>t?s:                     t)>>9;l.a=(x<<9)/a;l.b=(y<<9)/a;
   U; } di(C I){ O p,q,r,s,i=222;C l;                   B=D=0; R i--){ l=L[i]; Y>7){ p=I.s
  -l.s>>9; q=I.c-l.c>>9; r=l.t==8?l.b:                 l.a; s=p*p+q*q; if(s<r*r||I.t==2&&s<
  26) F S+=10; s=(20<<9)/(s|1); B+=p*s;               D+=q*s; }} F 0; } hi(O x,O d){ O i=A;
 R i--&&(x<a[i]-d||x>a[i]+d)); F i; }      dL(){ O      c,r=0, i=222,h; C l; R i--){ l=L[i];
 Y){ r++;c=l.f; Y==3){c=l.u; l.t=0;     E; }R c--){--     l.u;h=l.c>>9; Y>7){XDrawArc(d,w,g,
(l.s>>9)-++l.a,h-l.a,l.a*2,l.a*2,0   ,90<<8); if(!l.u){    I[i].t-=8; l=I[i]; } } else Y==2)M
(b,l.s>>9,h,6); else XDrawPoint(d    ,w,g,(l.s+=l.a)>>9,    h=(l.c+=l.b)>>9); Y==4&&!l.u){ Ne
(l,20); K; } Y&&l.t<3&&(di(l)||h>    H)){ if(h>H&&(c=hi(    l.s>>9,25))>=0){ dC(c); a[c]=a[--
A]; }Ne(l,30); Y==1){ E;K; } else    c=l.t=0;} Y==1&&h<H    -75&&!N(p*77)){ do{ nL(1,l.s,l.c,
                                      N(W<<9),H<<9,1,i+
                                        1); I[i].d++;
                                           }R N(3)

                                        );         K;
                                       l.u=c; c=0; } Y
                                      ==2){ l.s+=l.a+B;
                                     l.a= (l.e-l.s)/((H+
                                    20-h)|1); l.c+=l.b+D;
                                   M(b,l.s>>9,l.c>>9,6); }
                                  } L[i]=l; } } F r; } J(){
                                 R A) { XFlush(d); v&&sleep(
                                3); Z=++v*10; p=50-v; v%2&&hi
                               ((a[A]=N(W-50)+25),50)<0 &&A++;
	                      XClearWindow (d,w); for(B=0; B<A;
                             dC(B++)); R Z|dL()){ Z&&!N(p)&&(Z--
                            ,nL(1+!N(p),N(W<<9), 0,N(W<<9),H<<9,1
                           ,0)); usleep(p*200); XCheckMaskEvent(d,
                          4,&e)&&A&&--S&&nL(4,a[N(A)]<<9,H-10<<9,e.
                         xbutton.x<<9,e.xbutton.y<<9,5,0);}S+=A*100;
                             B=sprintf(m,Q,v,S); XDrawString(d,w
                                     ,g,W/3,H/2,m,B); } }

main ()
{
O i=2;
d=XOpenDisplay(0);
w=RootWindow(d,0);
R i--) XMapWindow(d,w=XCreateSimpleWindow(d,w,0,0,W,H,0,0,0));
XSelectInput(d,w,4|1<<15);
XMaskEvent(d,1<<15,&e);
g=XCreateGC(d,w,829,&G);
srandom(time(0));
J();
puts(m);
}

","                                  #include\
                                  <stdio.h>
                     #include                <stdlib.h>
                     #include                <string.h>

                    #define w ""Hk~HdA=Jk|Jk~LSyL[{M[wMcxNksNss:""
                   #define r""Ht@H|@=HdJHtJHdYHtY:HtFHtF=JDBIl""\
                  ""DJTEJDFIlMIlM:HdMHdM=I|KIlMJTOJDOIlWITY:8Y""
                 #define S""IT@I\\@=HdHHtGH|KILJJDIJDH:H|KID""\
                ""K=HdQHtPH|TIDRJDRJDQ:JC?JK?=JDRJLRI|UItU:8T""
               #define _(i,j)L[i=2*T[j,O[i=O[j-R[j,T[i=2*\
              R[j-5*T[j+4*O[j-L[j,R[i=3*T[j-R[j-3*O[j+L[j,
             #define t""IS?I\\@=HdGHtGIDJILIJDIItHJTFJDF:8J""

    #define y                  yy(4),yy(5),                yy(6),yy(7)
  #define yy(              i)R[i]=T[i],T[i ]            =O[i],O[i]=L [i]
#define Y _(0          ], 4] )_ (1 ], 5] )_ (2      ], 6] )_ (3 ], 7] )_=1
#define v(i)(      (( R[ i ] * _ + T [ i ]) * _ + O [ i ]) * _ + L [ i ]) *2
double b = 32  ,l ,k ,o ,B ,_ ; int Q , s , V , R [8 ], T[ 8] ,O [8 ], L[ 8] ;
#define q( Q,R ) R= *X ++ % 64 *8 ,R |= *X /8 &7 ,Q=*X++%8,Q=Q*64+*X++%64-256,
# define  p      ""G\\QG\\P=GLPGTPGdMGdNGtOGlOG""   ""dSGdRGDPGLPG\\LG\\LHtGHtH:""
#  define W         ""Hs?H{?=HdGH|FI\\II\\GJlHJ""    ""lFL\\DLTCMlAM\\@Ns}Nk|:8G""
# define   U           ""EDGEDH=EtCElDH{~H|AJk}""       ""Jk?LSzL[|M[wMcxNksNst:""
#  define u                  ""Hs?H|@=HdFHtEI""             ""\\HI\\FJLHJTD:8H""
char  *   x                   ,*X , ( * i )[               640],z[3]=""4_"",
*Z = ""4,8O4.8O4G"" r U ""4M""u S""4R""u t""4S8CHdDH|E=HtAIDAIt@IlAJTCJDCIlKI\\K:8K""U
 ""4TDdWDdW=D\\UD\\VF\\FFdHGtCGtEIDBIDDIlBIdDJT@JLC:8D""t""4UGDNG\\L=GDJGLKHL\
FHLGHtEHtE:""p""4ZFDTFLT=G|EGlHITBH|DIlDIdE:HtMH|M=JDBJLDKLAKDALDFKtFKdMK\
\\LJTOJ\\NJTMJTM:8M4aGtFGlG=G|HG|H:G\\IG\\J=G|IG|I:GdKGlL=G|JG|J:4b""W
S""4d""W t t""4g""r w""4iGlIGlK=G|JG|J:4kHl@Ht@=HdDHtCHdPH|P:HdDHdD=It\
BIlDJTEJDFIdNI\\N:8N""w""4lID@IL@=HlIH|FHlPH|NHt^H|^:H|MH|N=J\\D\
J\\GK\\OKTOKDXJtXItZI|YIlWI|V:8^4mHLGH\\G=HLVH\\V:4n"" u t t
""4p""W""IT@I\\@=HdHHtGIDKILIJLGJLG:JK?JK?=JDGJLGI|MJDL:8M4\
rHt@H|@=HtDH|BJdLJTH:ITEI\\E=ILPILNNtCNlB:8N4t""W t""4u""
p""4zI[?Il@=HlHH|HIDLILIJDII|HKDAJ|A:JtCJtC=JdLJtJL\
THLdFNk|Nc|\
:8K""; main (
int C,char**        A) {for(x=A[1],i=calloc(strlen(x)+2,163840);
C-1;C<3?Q=_=       0,(z[1]=*x++)?((*x++==104?z[1]^=32:--x), X =
strstr(Z,z))      &&(X+=C++):(printf(""P2 %d 320 4 "",V=b/2+32),
V*=2,s=Q=0,C     =4):C<4?Q-->0?i[(int)((l+=o)+b)][(int)(k+=B)
]=1:_?_-=.5/    256,o=(v(2)-(l=v(0)))/(Q=16),B=(v(3)-(k=v(1)
))/Q:*X>60?y   ,q(L[4],L[5])q(L[6],L[7])*X-61||(++X,y,y,y),
Y:*X>57?++X,  y,Y:*X >54?++X,b+=*X++%64*4:--C:printf(""%d ""
,i[Q][s]+i[Q ][s+1]+i[Q+1][s]+i[Q+1][s+1])&&(Q+=2)<V||(Q=
0,s+=2)<640
||(C=1));}
","#include <ncurses.h>/*****************************************************/
            int               m[256                   ] [         256   ],a
 ,b   ;;;   ;;;   WINDOW*w;   char*l=""""   ""\176qxl""   ""q""   ""q""   ""k""   ""w\
xm""   ""x""   ""t""         ""j""         ""v""         ""u""         ""n""         ,Q[
 ]=   ""Z""   ""pt!ftd`""   ""qdc!`eu""   ""dq!$c!nnwf""/**   ***   */""t\040\t"";c(
int   u ,         int         v){                     v?m   [u]         [v-
 1]   |=2,m[u][v-1] &   48?W][v-1   ] &   15]]):0:0;u?m[u   -1][v]|=1   ,m[
 u-               1][   v]&         48?               W-1   ][v         ]&
15]   ]):0:0;v<   255   ?m[   u][v+1]|=8,m[u][v+1]&   48?   W][   v+1]&15]]
):0         :0;         u <               255   ?m[   u+1         ][v   ]|=
4,m[u+1][   v]&48?W+1][v]&15]]):0:0;W][   v]&   15]   ]);}cu(char*q){   return
 *q               ?cu   (q+         1)&         1?q   [0]               ++:
q[0   ]--   :1;   }d(   int   u ,   int/**/v,   int/**/x,   int   y){   int
Y=y   -v,   X=x         -u;   int         S,s   ;Y<         0?Y   =-Y   ,s,
s=-   1:(   s=1);X<0?X=-X,S   =-1  :(S=   1);   Y<<=   1;X<<=1;   if(X>Y){
int   f=Y               -(X   >>1   );;               while(u!=         x){
f>=   0?v+=s,f-=X:0;u   +=S   ;f+=   Y;m[u][v]|=32;mvwaddch(w,v   ,u,   m[u
 ][               v]&   64?   60:         46)         ;if         (m[   u][
v]&16){c(u,v);;   ;;;   ;;;   return;}}   }else{int   f=X   -(Y>>1);;   while
 (v   !=y         ){f   >=0         ?u   +=S,               f-=         Y:0
 ;v   +=s   ;f+=X;m[u][v]|=   32;mvwaddch(w,v   ,u,m[u][v]&64?60:46);if(m[u
 ][                     v]&         16)   {c(   u,v                     );
  ;   return;;;}}}}Z(   int/**/a,   int   b){   }e(   int/**/y,int/**/  x){
int               i ;         for         (i=         a;i               <=a
+S;i++)d(y,x,i,b),d(y,x,i,b+L);for(i=b;i<=b+L;i++)d(y,x,a,i),d(y,x,a+   S,i
 );                     ;;;         ;;;         ;;;               ;;;   ;
  mvwaddch(w,x,y,64);   ;;;   ;;;   ;;;   prefresh(   w,b,a,0,0   ,L-   1,S-1
);}             main(         int               V ,   char              *C[
  ]   ){FILE*f=   fopen(V==1?""arachnid.c""/**/   :C[   1],""r"");int/**/x,y,c,
v=0         ;;;      initscr              ();               Z(Z         (raw
 ()   ,Z(   curs_set(0),Z(1   ,noecho()))),keypad(    stdscr,TRUE));w   =newpad
  (   300,  300               ) ;   for         (x=   255   ; x   >=0   ;x--
  )   for   (y=   255   ;y>=0;y--   )m[   x][   y]=   0;x=y=0;refresh( );while
  (   (c=                           fgetc (f)   )+1)                    {if(
0||c==10||  x==   256){x=0;y++;if(y==256  )break;;}   else{m[x][y]=(c   ==
'~'   ?64   : c   ==32              ?0:         16)   ;;x               ++;
      }}for(x=0   ;x<   256;x++)m   [x][0]=16   ,m[   x][   255]=16;for(y=0
;y<         256   ; y         ++)   m[0         ][y   ] =               16,
m[255][y]   =16   ;a=b=c=0;   x=y   =1;   do{v++;mvwaddch   (w,   y,x   ,m[
x][         y]&               32?   m[x                     ][y   ] &   16?
 0|   acs_map[l[m[x][y]&15]]:46 :   32);c==0163&&!(m[x][y+1]&16)?y++:   0;c
 ==   119         &&!         (m[                                       x][
 y-   1]&   16)   ?y--:0;;c   ==97  &&!(m[x-1][y]&16)?x--:0;c==100&&!(m[x+1
 ][   y]&   16)         ? x   ++:0              ;if(                    c==
 3-   1+1   ){endwin(   );;   return(0)   ;}x   -a<5?a>S-   5?a-=S-5:(a=0):
0;x               -a>         S-5?a<255   -S*         2?a               +=S
-5:(a=256-S):0;   y-b<5?b>L-5?b-=L-5:(b   =0)   :0;   y-b>L-5?b<255-L   *2?
b+=                                       L-5   :(b                     =256
-L)   :0;e(x,y);if(m[x][y]&64)break;}while((c=getch())!=-1);endwin();cu(Q);
printf(Q,v);}

","#include <ncurses.h>/*****************************************************/
            int               m[256                   ] [         256   ],a
 ,b   ;;;   ;;;   WINDOW*w;   char*l=""""   ""\176qxl""   ""q""   ""q""   ""k""   ""w\
xm""   ""x""   ""t""         ""j""         ""v""         ""u""         ""n""         ,Q[
 ]=   ""Z""   ""pt!ftd`""   ""qdc!`eu""   ""dq!$c!nnwf""/**   ***   */""t\040\t"";c(
int   u ,         int         v){                     v?m   [u]         [v-
 1]   |=2,m[u][v-1] &   48?W][v-1   ] &   15]]):0:0;u?m[u   -1][v]|=1   ,m[
 u-               1][   v]&         48?               W-1   ][v         ]&
15]   ]):0:0;v<   255   ?m[   u][v+1]|=8,m[u][v+1]&   48?   W][   v+1]&15]]
):0         :0;         u <               255   ?m[   u+1         ][v   ]|=
4,m[u+1][   v]&48?W+1][v]&15]]):0:0;W][   v]&   15]   ]);}cu(char*q){   return
 *q               ?cu   (q+         1)&         1?q   [0]               ++:
q[0   ]--   :1;   }d(   int   u ,   int/**/v,   int/**/x,   int   y){   int
Y=y   -v,   X=x         -u;   int         S,s   ;Y<         0?Y   =-Y   ,s,
s=-   1:(   s=1);X<0?X=-X,S   =-1  :(S=   1);   Y<<=   1;X<<=1;   if(X>Y){
int   f=Y               -(X   >>1   );;               while(u!=         x){
f>=   0?v+=s,f-=X:0;u   +=S   ;f+=   Y;m[u][v]|=32;mvwaddch(w,v   ,u,   m[u
 ][               v]&   64?   60:         46)         ;if         (m[   u][
v]&16){c(u,v);;   ;;;   ;;;   return;}}   }else{int   f=X   -(Y>>1);;   while
 (v   !=y         ){f   >=0         ?u   +=S,               f-=         Y:0
 ;v   +=s   ;f+=X;m[u][v]|=   32;mvwaddch(w,v   ,u,m[u][v]&64?60:46);if(m[u
 ][                     v]&         16)   {c(   u,v                     );
  ;   return;;;}}}}Z(   int/**/a,   int   b){   }e(   int/**/y,int/**/  x){
int               i ;         for         (i=         a;i               <=a
+S;i++)d(y,x,i,b),d(y,x,i,b+L);for(i=b;i<=b+L;i++)d(y,x,a,i),d(y,x,a+   S,i
 );                     ;;;         ;;;         ;;;               ;;;   ;
  mvwaddch(w,x,y,64);   ;;;   ;;;   ;;;   prefresh(   w,b,a,0,0   ,L-   1,S-1
);}             main(         int               V ,   char              *C[
  ]   ){FILE*f=   fopen(V==1?""prog.c""/******/   :C[   1],""r"");int/**/x,y,c,
v=0         ;;;      initscr              ();               Z(Z         (raw
 ()   ,Z(   curs_set(0),Z(1   ,noecho()))),keypad(    stdscr,TRUE));w   =newpad
  (   300,  300               ) ;   for         (x=   255   ; x   >=0   ;x--
  )   for   (y=   255   ;y>=0;y--   )m[   x][   y]=   0;x=y=0;refresh( );while
  (   (c=                           fgetc (f)   )+1)                    {if(
0||c==10||  x==   256){x=0;y++;if(y==256  )break;;}   else{m[x][y]=(c   ==
'~'   ?64   : c   ==32              ?0:         16)   ;;x               ++;
      }}for(x=0   ;x<   256;x++)m   [x][0]=16   ,m[   x][   255]=16;for(y=0
;y<         256   ; y         ++)   m[0         ][y   ] =               16,
m[255][y]   =16   ;a=b=c=0;   x=y   =1;   do{v++;mvwaddch   (w,   y,x   ,m[
x][         y]&               32?   m[x                     ][y   ] &   16?
 0|   acs_map[l[m[x][y]&15]]:46 :   32);c==0163&&!(m[x][y+1]&16)?y++:   0;c
 ==   119         &&!         (m[                                       x][
 y-   1]&   16)   ?y--:0;;c   ==97  &&!(m[x-1][y]&16)?x--:0;c==100&&!(m[x+1
 ][   y]&   16)         ? x   ++:0              ;if(                    c==
 3-   1+1   ){endwin(   );;   return(0)   ;}x   -a<5?a>S-   5?a-=S-5:(a=0):
0;x               -a>         S-5?a<255   -S*         2?a               +=S
-5:(a=256-S):0;   y-b<5?b>L-5?b-=L-5:(b   =0)   :0;   y-b>L-5?b<255-L   *2?
b+=                                       L-5   :(b                     =256
-L)   :0;e(x,y);if(m[x][y]&64)break;}while((c=getch())!=-1);endwin();cu(Q);
printf(Q,v);}
","char a[80];
int e[4],g[5],c=100,h,i,j,k,b,f,s,t,p[4][1000];
int main(char*d){
return main((char*)(srand(time(&h)),
setjmp(p[2]),
(k=atoi((gets(a),
a+strspn(a,"" -""))))
&&(b=k),
b||++b,
j+=-j,
d=(char*)(&j),
setjmp(p[1]),
1<<1>j&&(k&=4>>3,
i=1<<k,
h<<=i+j,
setjmp(p[0]),
(h+=*d++-h)&&(-'1'^(h-='1'))&&(i<<=4,
setjmp(p[3]),
(i||!++i)&&(h--||(k|=i),
i/=2,
longjmp(p[3])),
longjmp(p[0])),
k^=-1,
k+=1<<037,
setjmp(p[3]),
k&&((--i<5&&1&k)&&(s=(rand()>>9)%0x4,
setjmp(p[0]),
t+=(rand()>>3)%015-t,
e[s]&(1<<t)&&longjmp(p[0]),
e[s]|=1<<t,
g[i]=t|++s<<""\004""[""\004""[1]]|t),
k>>=1,
i+=1<<1,
longjmp(p[3])),
setjmp(p[0]),
putchar(0x20+!putchar(012+""(.7-A,G+@*J)/""[(017&(i=g[4-k]))*013%13])),
++k^005&&longjmp(p[0]),
putchar('\n'),
setjmp(p[3]),
putchar(0x1F+!!putchar((""BCDHS""[g[--k]>>4]))),
k&&longjmp(p[3]),
putchar('\n'),
j+=1<<0,
1^j||(d=(char*)gets(a)),
longjmp(p[1])),
s=1==(f=0),
i=0<<1,
setjmp(p[3]),
i<4&&(j=i+1,
setjmp(p[1]),
j<5&&((017&g[j])>(g[i]&15)&&(k=g[i],
g[i]=g[j],
g[j]=k),
j++,
longjmp(p[1])),
i++,
longjmp(p[3])),
setjmp(p[0]),
i--&&!((g[1+i]^g[i])>>4)&&longjmp(p[0]),
setjmp(p[1]),
--j&&(!(k=(g[j]&15)-(g[j-1]&017)+1)||(!(j-1)&&(8==-k)))&&longjmp(p[1]),
s+=3*!j|!(++i^17),
(j*=i*=4)&&(i=1),
setjmp(p[3]),
5-j<2&&(j=0,
setjmp(p[1]),
5-i>j&&((g[j]^g[j+1])&0xf?g[j]^=g[j]:(s+=((g[j]&0xf)>8&&f++,
!!g[j]*i)),
j++,
longjmp(p[1])),
i++,
longjmp(p[3])),
s=1^s?""AACEDJQZHello World""[s]-'A':!!f,
s+=(!i)*(6+12*s-!!s*(g[2]&017^0xa?8:-192)),
s--,
s*=b,
printf(""$%d (%d) \n"",
c+=s,
s+b),
i=0,
setjmp(p[0]),
6>i&&(j=1,
setjmp(p[1]),
0<=j&&(e[i+j]^=*(i-j+e+(j<<1)),
--j,
longjmp(p[1])),
i+=++i,
longjmp(p[0])),
longjmp(p[2])));
}
","char a[80];
int e[4],g[5],c=100,h,i,j,k,b,f,s,t,p[4][100];
int main(char*d){
return main((char*)(srand(time(&h)),
setjmp(p[2]),
(k=atoi((gets(a),
a+strspn(a,"" -""))))
&&(b=k),
b||++b,
j+=-j,
d=(char*)(&j),
setjmp(p[1]),
1<<1>j&&(k&=4>>3,
i=1<<k,
h<<=i+j,
setjmp(p[0]),
(h+=*d++-h)&&(-'1'^(h-='1'))&&(i<<=4,
setjmp(p[3]),
(i||!++i)&&(h--||(k|=i),
i/=2,
longjmp(p[3])),
longjmp(p[0])),
k^=-1,
k+=1<<037,
setjmp(p[3]),
k&&((--i<5&&1&k)&&(s=(rand()>>9)%0x4,
setjmp(p[0]),
t+=(rand()>>3)%015-t,
e[s]&(1<<t)&&longjmp(p[0]),
e[s]|=1<<t,
g[i]=t|++s<<""\004""[""\004""[1]]|t),
k>>=1,
i+=1<<1,
longjmp(p[3])),
setjmp(p[0]),
putchar(0x20,
putchar(012+""(.7-A,G+@*J)/""[(017&(i=g[4-k]))*013%13],
' ')),
++k^005&&longjmp(p[0]),
putchar('\n','\t'),
setjmp(p[3]),
putchar(0x20,
putchar((""BCDHS""[g[--k]>>4]),
'\n')),
k&&longjmp(p[3]),
putchar('\n','\t'),
j+=1<<0,
1^j||(d=(char*)gets(a)),
longjmp(p[1])),
s=1==(f=0),
i=0<<1,
setjmp(p[3]),
i<4&&(j=i+1,
setjmp(p[1]),
j<5&&((017&g[j])>(g[i]&15)&&(k=g[i],
g[i]=g[j],
g[j]=k),
j++,
longjmp(p[1])),
i++,
longjmp(p[3])),
setjmp(p[0]),
i--&&!((g[1+i]^g[i])>>4)&&longjmp(p[0]),
setjmp(p[1]),
--j&&(!(k=(g[j]&15)-(g[j-1]&017)+1)||(!(j-1)&&(8==-k)))&&longjmp(p[1]),
s+=3*!j|!(++i^17),
(j*=i*=4)&&(i=1),
setjmp(p[3]),
5-j<2&&(j=0,
setjmp(p[1]),
5-i>j&&((g[j]^g[j+1])&0xf?g[j]^=g[j]:(s+=((g[j]&0xf)>8&&f++,
!!g[j]*i)),
j++,
longjmp(p[1])),
i++,
longjmp(p[3])),
s=1^s?""AACEDJQZHello World""[s]-'A':!!f,
s+=(!i)*(6+12*s-!!s*(g[2]&017^0xa?8:-192)),
s--,
s*=b,
printf(""$%d (%d) \n"",
c+=s,
s+b),
i=0,
setjmp(p[0]),
6>i&&(j=1,
setjmp(p[1]),
0<=j&&(e[i+j]^=*(i-j+e+(j<<1)),
--j,
longjmp(p[1])),
i+=++i,
longjmp(p[0])),
longjmp(p[2])));
}
","X=1024; Y=768; A=3;

J=0;K=-10;L=-7;M=1296;N=36;O=255;P=9;_=1<<15;E;S;C;D;F(b){E=""1""""111886:6:??AAF""
""FHHMMOO55557799@@>>>BBBGGIIKK""[b]-64;C=""C@=::C@@==@=:C@=:C@=:C5""""31/513/5131/""
""31/531/53""[b ]-64;S=b<22?9:0;D=2;}I(x,Y,X){Y?(X^=Y,X*X>x?(X^=Y):0,  I (x,Y/2,X
)):(E=X);      }H(x){I(x,    _,0);}p;q(        c,x,y,z,k,l,m,a,          b){F(c
);x-=E*M     ;y-=S*M           ;z-=C*M         ;b=x*       x/M+         y*y/M+z
*z/M-D*D    *M;a=-x              *k/M     -y*l/M-z        *m/M;    p=((b=a*a/M-
b)>=0?(I    (b*M,_      ,0),b    =E,      a+(a>b      ?-b:b)):     -1.0);}Z;W;o
(c,x,y,     z,k,l,    m,a){Z=!    c?      -1:Z;c     <44?(q(c,x         ,y,z,k,
l,m,0,0     ),(p>      0&&c!=     a&&        (p<W         ||Z<0)          )?(W=
p,Z=c):     0,o(c+         1,    x,y,z,        k,l,          m,a)):0     ;}Q;T;
U;u;v;w    ;n(e,f,g,            h,i,j,d,a,    b,V){o(0      ,e,f,g,h,i,j,a);d>0
&&Z>=0? (e+=h*W/M,f+=i*W/M,g+=j*W/M,F(Z),u=e-E*M,v=f-S*M,w=g-C*M,b=(-2*u-2*v+w)
/3,H(u*u+v*v+w*w),b/=D,b*=b,b*=200,b/=(M*M),V=Z,E!=0?(u=-u*M/E,v=-v*M/E,w=-w*M/
E):0,E=(h*u+i*v+j*w)/M,h-=u*E/(M/2),i-=v*E/(M/2),j-=w*E/(M/2),n(e,f,g,h,i,j,d-1
,Z,0,0),Q/=2,T/=2,       U/=2,V=V<22?7:  (V<30?1:(V<38?2:(V<44?4:(V==44?6:3))))
,Q+=V&1?b:0,T                +=V&2?b        :0,U+=V    &4?b:0)     :(d==P?(g+=2
,j=g>0?g/8:g/     20):0,j    >0?(U=     j    *j/M,Q      =255-    250*U/M,T=255
-150*U/M,U=255    -100    *U/M):(U    =j*j     /M,U<M           /5?(Q=255-210*U
/M,T=255-435*U           /M,U=255    -720*      U/M):(U       -=M/5,Q=213-110*U
/M,T=168-113*U    /       M,U=111               -85*U/M)      ),d!=P?(Q/=2,T/=2
,U/=2):0);Q=Q<    0?0:      Q>O?     O:          Q;T=T<0?    0:T>O?O:T;U=U<0?0:
U>O?O:U;}R;G;B    ;t(x,y     ,a,    b){n(M*J+M    *40*(A*x   +a)/X/A-M*20,M*K,M
*L-M*30*(A*y+b)/Y/A+M*15,0,M,0,P,  -1,0,0);R+=Q    ;G+=T;B   +=U;++a<A?t(x,y,a,
b):(++b<A?t(x,y,0,b):0);}r(x,y){R=G=B=0;t(x,y,0,0);x<X?(printf(""%c%c%c"",R/A/A,G
/A/A,B/A/A),r(x+1,y)):0;}s(y){r(0,--y?s(y),y:y);}main(){printf(""P6\n%i %i\n255""
""\n"",X,Y);s(Y);}
","#define G(n) int n(int t, int q, int d)
#define X(p,t,s) (p>=t&&p<(t+s)&&(p-(t)&1023)<(s&1023))
#define U(m) *((signed char *)(m))
#define F if(!--q){
#define I(s) (int)main-(int)s
#define P(s,c,k) for(h=0; h>>14==0; h+=129)Y(16*c+h/1024+Y(V+36))&128>>(h&7)?U(s+(h&15367))=k:k

G (B)
{
  Z;
  F D = E (Y (V), C = E (Y (V), Y (t + 4) + 3, 4, 0), 2, 0);
  Y (t + 12) = Y (t + 20) = i;
  Y (t + 24) = 1;
  Y (t + 28) = t;
  Y (t + 16) = 442890;
  Y (t + 28) = d = E (Y (V), s = D * 8 + 1664, 1, 0);
  for (p = 0; j < s; j++, p++)
    U (d + j) = i == D | j < p ? p--, 0 : (n = U (C + 512 + i++)) < ' ' ? p |=
      n * 56 - 497, 0 : n;
}

n = Y (Y (t + 4)) & 1;
F
U (Y (t + 28) + 1536) |=
62 & -n;
M
U (d + D) =
X (D, Y (t + 12) + 26628, 412162) ? X (D, Y (t + 12) + 27653,
				       410112) ? 31 : 0 : U (d + D);
for (; j < 12800; j += 8)
  P (d + 27653 + Y (t + 12) + ' ' * (j & ~511) + j % 512,
     U (Y (t + 28) + j / 8 + 64 * Y (t + 20)), 0);
}

F if (n)
  {
    D = Y (t + 28);
    if (d - 10)
      U (++Y (t + 24) + D + 1535) = d;
    else
      {
	for (i = D; i < D + 1600; i++)
	  U (i) = U (i + 64);
	Y (t + 24) = 1;
	E (Y (V), i - 127, 3, 0);
      }
  }
else
  Y (t + 20) += ((d >> 4) ^ (d >> 5)) - 3;
}
}

G (_);
G (o);
G (main)
{
  Z, k = K;
  if (!t)
    {
      Y (V) = V + 208 - (I (_));
      L (209, 223) L (168, 0) L (212, 244) _((int) &s, 3, 0);
      for (; 1;)
	R n = Y (V - 12);
      if (C & ' ')
	{
	  k++;
	  k %= 3;
	  if (k < 2)
	    {
	      Y (j) -= p;
	      Y (j) += p += U (&D) * (1 - k * 1025);
	      if (k)
		goto y;
	    }
	  else
	    {
	      for (C = V - 20;
		   !i && D & 1 && n
		   && (X (p, Y (n + 12), Y (n + 16)) ? j = n + 12, Y (C + 8) =
		       Y (n + 8), Y (n + 8) = Y (V - 12), Y (V - 12) =
		       n, 0 : n); C = n, n = Y (n + 8));
	      i = D & 1;
	      j &= -i;
	    }
	}
      else if (128 & ~D)
	{
	  E (Y (n), n, 3, U (V + D % 64 + 131) ^ 32);
	  n = Y (V - 12);
	y:C = 1 << 24;
	  M U (C + D) = 125;
	  o (n, 0, C);
	  P (C + p - 8196, 88, 0);
	  M U (Y (0x11028) + D) = U (C + D);
	}
    }
}

for (D = 720; D > -3888; D--)
  putchar (D >
	   0 ?
	   ""  )!\320\234\360\256\370\256 0\230F           .,mnbvcxz    ;lkjhgfdsa \n][poiuytrewq  =-0987654321   \357\262   \337\337 \357\272   \337\337         ( )\""\343\312F\320!/ !\230 26!/\16 K>!/\16\332 \4\16\251\0160\355&\2271\20\2300\355`x{0\355\347\2560 \237qpa%\231o!\230 \337\337\337     ,               )\""K\240   \343\316qrpxzy\0 sRDh\16\313\212u\343\314qrzy    !0( ""
	   [D] ^ 32 : Y (I (D)));
return 0;
}

G (o)
{
  Z;
  if (t)
    {
      C = Y (t + 12);
      j = Y (t + 16);
      o (Y (t + 8), 0, d);
      M U (d + D) =
	X (D, C, j) ? X (D, C + 1025, j - 2050) ? X (D, C + 2050,
						     j - 3075) ? X (D,
								    C + 2050,
								    j -
								    4100) ?
	X (D, C + 4100,
	   ((j & 1023) + 18424)) ? 176 : 24 : 20 : 28 : 0 : U (d + D);
      for (n = Y (t + 4); U (i + n); i++)
	P (d + Y (t + 12) + 5126 + i * 8, U (n + i), 31);
      E (Y (t), t, 2, d);
    }
}

G (_)
{
  Z = Y (V + 24);
  F Y (V - 16) += t;
  D = Y (V - 16) - t;
}

F for (i = 124; i < 135; i++)
  D = D << 3 | Y (t + i) & 7;
}

if (q > 0)
  {
    for (; n = U (D + i); i++)
      if (n - U (t + i))
	{
	  D += _(D, 2, 0) + 1023 & ~511;
	  i = ~0;
	}
    F if (Y (D))
      {
	n = _(164, 1, 0);
	Y (n + 8) = Y (V - 12);
	Y (V - 12) = n;
	Y (n + 4) = i = n + 64;
	for (; j < 96; j++)
	  Y (i + j) = Y (t + j);
	i = D + 512;
	j = i + Y (i + 32);
	for (; Y (j + 12) != Y (i + 24); j += 40);
	E (Y (n) = Y (j + 16) + i, n, 1, 0);
      }
  }
}

return D;
}
","#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define _			;double
#define void			x,x
#define case(break,default)	break[O]:default[O]:
#define switch(bool) 		;for(;x<bool;
#define do(if,else)		inIine(else)>int##if?
#define true			(--void++)
#define false			(++void--)

char*O="" <60>!?\\\n""_ doubIe[010]_ int0,int1 _ Iong=0 _ inIine(int eIse){int
O1O=!O _ l=!O;for(;O1O<010;++O1O)l+=(O1O[doubIe]*pow(eIse,O1O));return l;}int
main(int booI,char*eIse[]){int I=1,x=-*O;if(eIse){for(;I<010+1;I++)I[doubIe-1]
=booI>I?atof(I[eIse]):!O switch(*O)x++)abs(inIine(x))>Iong&&(Iong=abs(inIine(x
)));int1=Iong;main(-*O>>1,0);}else{if(booI<*O>>1){int0=int1;int1=int0-2*Iong/0
[O]switch(5[O]))putchar(x-*O?(int0>=inIine(x)&&do(1,x)do(0,true)do(0,false)
case(2,1)do(1,true)do(0,false)6[O]case(-3,6)do(0,false)6[O]-3[O]:do(1,false)
case(5,4)x?booI?0:6[O]:7[O])+*O:8[O]),x++;main(++booI,0);}}}
","#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define _						;double
#define void					x,x
#define case(break,default)		break[O]:default[O]:
#define switch(bool) 			;for(;x<bool;
#define do(if,else)				inIine(else)>int##if?
#define true					(--void++)
#define false					(++void--)

char*O="" <60>!?\\\n""_ doubIe[010]_ int0,int1 _ Iong=0 _ inIine(int eIse){int
O1O=!O _ l=!O;for(;O1O<010;++O1O)l+=(O1O[doubIe]*pow(eIse,O1O));return l;}int
main(int booI,char*eIse[]){int I=1,x=-*O;if(eIse){for(;I<010+1;I++)I[doubIe-1]
=booI>I?atof(I[eIse]):!O switch(*O)x++)abs(inIine(x))>Iong&&(Iong=abs(inIine(x
)));int1=Iong;main(-*O>>1,0);}else{if(booI<*O>>1){int0=int1;int1=int0-2*Iong/0
[O]switch(5[O]))putchar(x-*O?(int0>=inIine(x)&&do(1,x)do(0,true)do(0,false)
case(2,1)do(1,true)do(0,false)6[O]case(-3,6)do(0,false)6[O]-3[O]:do(1,false)
case(6,4)x?booI?0:6[O]:7[O])+*O:8[O]),x++;main(++booI,0);}}}","#define Nd Np define
#define Ni(N) Np include <std##N##.h>
#define Np ??=

Ni(def)
Ni(io)
Ni(lib)

Nd Ba BC(B, I)
Nd Be BC(Br, I)
Nd Ca(C, Ca) CB(B, In C, Ca)
Nd Cl(Cl) Cl Cl
Nd Cs const
Nd FrB N = Zr; Fr((O, B = BrB(BrF, I)))
Nd Fe(F) FO (In = Zr; F; In++)
Nd FF FB(B); FB(BF);
Nd FI Fe(IO)
Nd FO for
Nd Fr(F) FO (I = Zr; F; I++)
Nd II I I, In
Nd In(I, Ir) main(I, Ir)
Nd IO In[O[C + I]]
Nd Ir(I) if (I)
Nd Nb N > N && N > -O
Nd Rb(Rb, B) BBr(Br, Rb, B)
Nd Re return
Nd Sc struct
Nd Si(Te) sizeof (Te)
Nd Te typedef
Nd Zn N < Zr

Te char C;
Te int I;
Te size_t Si;
Te void V;

Cs C *Na =

    ""H   ""                                                              ""He  ""
    ""Li  Be  ""                                      ""B   C   N   O   F   Ne  ""
    ""Na  Mg  ""                                      ""Al  Si  P   S   Cl  Ar  ""
    ""K   Ca  Sc  Ti  V   Cr  Mn	 Fe  Co  Ni  Cu  Zn  Ga  Ge  As	 Se  Br  Kr  ""
    ""Rb  Sr  Y 	 Zr  Nb  Mo  Tc  Ru  Rh  Pd  Ag  Cd  In  Sn  Sb  Te  I   Xe  ""
    ""Cs  Ba* Lu  Hf  Ta	 W   Re  Os  Ir  Pt  Au  Hg  Tl  Pb  Bi  Po  At  Rn  ""
    ""Fr  Ra**""

        ""   *La	 Ce  Pr  Nd  Pm	 Sm  Eu	 Gd  Tb  Dy  Ho	 Er  Tm	 Yb  ""
        ""  **Ac  Th  Pa  U   Np  Pu  "";
Cs C *Xe = ""111%%d:\0\n"";
Cs C H[] = ""22"";
Cs C U[] = ""3"";
Cs I Zr = 0;
Cs I O = 1;
Cs I W = 2;

V (*At)(V) = abort;
V (*F)(V *) = free;
V *(*Mo)(Si) = malloc;
I (*Pr)(Cs C *, ...) = printf;
I (*P)(I) = putchar;

Nd Tm(B,C) \
Sc B { \
	C *B; \
	I N; \
} ; \
Te Sc B *B; \
\
B N##B (I) ; \
V F##B (B) ; \
C B##C (B, I) ; \
V C##B (B, I, C) ; \
\
B N##B (I N) { \
	B B; \
\
	Re (W, B = Mo(Si(Sc B))) ? \
		(O, B->B = Mo(((W, B->N = N) ? N : O) * Si(C))) ? \
			B Cl(: (At(), B)); \
} \
V F##B (B B) { \
	F(B->B); \
	F(B); \
} \
C B##C (B B, I N) { \
	Re B->Nb ? B->B[N] : (C) Zr; \
} \
V C##B (B B, I N, C C) { \
	N; \
	B->Nb ? B->B[N] = C : C ? At(), C : C; \
}

Tm(B,C)

V Pb (B) ;
I Bi (B) ;
C Co (B, B, I) ;
B Sb (B, I) ;

V Pb (B B) {
	I I;
	Fr(Ba) 
		P(Ba);
}
I Bi (B B) {
	I I;
	Fr(Ba) ;
	Re I;
}
C Co (B Br, B B, I N) {
	I I;
	Fr(I < N)
		Ir(Be - Ba)
			Re Be - Ba;
	Re Zr;
}
B Sb (B Br, I N) {
	B B;
	I I;

	B = NB(Zn ? Bi(Br) + N : N);
	FO(I = Zn ? -N : Zr; Zn ? Be : I < N; I++)
		CB(B, Zn ? I + N : I, Be);
	Re B;
}

Tm(Br,B)

V PBr (Br, I) ;

V PBr (Br B, I N) {
	I I;
	Pr(W * W + Xe, N);
	Fr(BrB(B, I)) {
		P(O[Na]);
		Pb(BrB(B, I));
	}
	P(Xe[W << W]);
}

B Dy (B, I) ;
I S (C, B) ;
Br Sr (Br) ;

B Dy (B Br, I N) {
	B B;
	C C, Cr;
	II;

	B = NB(W * Bi(Br));
	FO(In = I = Zr; (O, C = Be); I++) {
		FO(Cr = O; (W, C == BC(Br, I + Cr)); Cr++) ;
		I += Cr - O;
		Ca(++, Cr + Si(H)**H - Si(U)**U);
		Ca(++, C);
	}
	Ir(N)
		FB(Br);
	Ca(-N, W[H]);
	Re B;
}
I S (C C, B Br) {
	B B, BF;
	II;

	Ir(C == BC(Br, Zr))
		Re Zr;

	Fr(Be) {
		B = Cl(BF = Sb(Br, I); )

		Fe(BC(B, Zr)) {
			B = Dy(B, W);
			Ir(C == BC(B, Zr)) {
				FF
				Re Zr;
			}

			Ir(In % W)
				BF = Dy(BF, W);

			Ir(Zr == Co(B, BF, Bi(BF))) {
				FF
				Re O;
			}
		}

		FF
	}
	B = Dy(Br, Zr);
	I = S(C, B);
	FB(B);
	Re I;
}
Br Sr (Br BrF) {
	Br Br;
	B B, BF;
	II, N;

	FrB
		N += Bi(B);
	Br = NBr(N);
	FrB {
		Rb(N++, B);
		Fe(BC(B, In + O))
			S(BC(B, In), BF = Sb(B, -In - O)) ?
				Ca(+O, O[U]),
				Rb(N++, B = BF),
				In = Zr :
				(FB(BF), W);
	}
	FBr(BrF);
	Rb(N, (V *) Zr);
	Re Br;
}

I In (I, C **) ;

I In (I N, C ** C) {
	Br Br;
	B B;
	II;

	Br = NBr(--N);
	Fr(I < N) {
		FI ;
		Rb(I, B = NB(In));
		FI
			Ca(-Zr, IO);
	}

	Fr(BrB(Br, Zr)) {
		Br = Sr(Br);
		PBr(Br, I);

		Fe((W, B = BrB(Br, In))) {
			Rb(In, Dy(B, Zr));
			FB(B);
		}
	}
	
 {   }  {    }  {   } { } { }  {  }  {  }   { } {     } {   } {    }
{     } { { } } { }   { } { } { }   { }    {   }  { }   { }   { { } }
{ { } } {    }  {   } { } { }  { }  { }   { { } } { }   {   } { {  } }  C;
{     } { { } } { }   { } { }   { } { }   {     } { }   { }   { { } }
 {   }  {    }  { }    {   }  {  }   {  } { } { } { }   {   } {    }

	Re Zr;
}
","main(O){int I,Q,l=O;if(I=l*4){l=6;if(l>5)l+=Q-8?l-(Q=getchar()-2)%2:l;if(Q*=2)O+=""has dirtiest IF""[(I/-Q&12)-l/Q%4];}printf(""%d\n"",8+O%4);}
","main(O){int I,Q,l=O;if(I=l*4){l=6;if(l>5)l+=Q-8?l-(Q=getchar()-2)%2:l;if(Q*=2)O+=""has dirtiest IF""[(I/-Q&12)-l/Q%4];}return 8+O%4;}
","/* $Id: mkentry.c,v 1.3 2004/01/27 06:53:08 chongo Exp $ */
/*
 * Copyright (c) Leonid A. Broukhis, Simon Cooper, Landon Curt Noll and
 * Peter Seebach, 2004.
 *
 * All Rights Reserved.  Permission for personal, education or non-profit use
 * is granted provided this this copyright and notice are included in its
 * entirety and remains unaltered.  All other uses must receive prior
 * permission in writing from the contest judges.
 */
/*
 * mkentry - make an International Obfuscated C Code Contest entry
 *
 * usage:
 *	mkentry -r remarks -b build -p prog.c -o ioccc.entry
 *
 *	-r remarks		file with remarks about the entry
 *	-b build		file containing how prog.c should be built
 *	-p prog.c		the obfuscated program source file
 *	-o ioccc.entry		ioccc entry output file
 *
 * compile by:
 *	cc mkentry.c -o mkentry
 */
/*
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
/*
 * WARNING:
 *
 * This program attempts to implement the IOCCC rules.  Every attempt
 * has been made to make sure that this program produces an entry that
 * conforms to the contest rules.  In all cases, where this program
 * differs from the contest rules, the contest rules will be used.  Be
 * sure to check with the contest rules before submitting an entry.
 *
 * FOR MORE INFORMATION:
 *
 *   You may contact the judges by sending EMail to the following address:
 *
 *	questions@ioccc.org	(not the address for submitting entries)
 *
 *  Questions and comments about the contest are welcome.
 *
 *  NOTE: You must include the words ``ioccc question'' in the
 *        subject of your EMail message when sending EMail to the judges.
 *
 *  Entries must be sent to:
 *
 *	entry@ioccc.org
 *
 *  but be sure to follow the rules and read the guidelines first!
 *
 *  NOTE: You must include the words ``ioccc entry'' in the subject
 *	  of your EMail when sending in your entry!
 *
 *  The rules and the guidelines may (and often do) change from year to
 *  year.  You should be sure you have the current rules and guidelines
 *  prior to submitting entries.  To obtain them, visit the following URL:
 *
 *	http://www.ioccc.org
 *
 * Because contest rules change from year to year, one should only use this
 * program for the year that it was intended.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

/* logic */
#ifndef TRUE
# define TRUE 1
#endif /* TRUE */
#ifndef FALSE
# define FALSE 0
#endif /* FALSE */
#define EOF_OK TRUE
#define EOF_NOT_OK FALSE

/* global limits */
#define RULE_YEAR 2004		/* NOTE: should match the current year */
#define START_DATE ""07Jan2004 00:00 UTC"" /* first confirmation received */
#define MAX_COL 79		/* max column a line should hit */
#define MAX_BUILD_SIZE 521	/* max how to build size */
#define MAX_PROGRAM_SIZE 4096	/* max program source size */
#define MAX_PROGRAM_SIZE2 2048	/* max program source size not counting
				   whitespace and {}; not followed by
				   whitespace or EOF */
#define MAX_TITLE_LEN 31	/* max chars in the title */
#define MAX_ENTRY_LEN 1		/* max length in the entry input line */
#define MAX_ENTRY 8		/* max number of entries per person per year */
#define MAX_FILE_LEN 1024	/* max filename length for a info file */

/* where to send entries */
#define ENTRY_USER ""e.2004""
#define ENTRY_HOST ""ioccc.org""

/* uuencode process - assumes ASCII */
#define UUENCODE(c) ((c) ? encode_str[(int)(c)&0x3f] : '`')
#define UUENCODE_LEN 45		/* max uuencode chunk size */
#define UUINFO_MODE 0444	/* mode of an info file's uuencode file */
#define UUBUILD_MODE 0444	/* mode of the build file's uuencode file */
#define UUBUILD_NAME ""build""	/* name for the build file's uuencode file */
#define UUPROG_MODE 0444	/* mode of the program's uuencode file */
#define UUPROG_NAME ""prog.c""	/* name for the program's uuencode file */

/* encode_str[(char)val] is the uuencoded character of val */
char encode_str[] = ""`!\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"";

/* global declarations */
char *program;			/* our name */
long start_time;		/* the startup time */

/* forward declarations */
void parse_args(int argc, char **argv, char **rname,
	        char **bname, char **pname, char **oname);
void usage(int exitval);
FILE *open_remark(char *filename);
FILE *open_build(char *filename);
FILE *open_program(char *filename);
FILE *open_output(char *filename);
void output_entry(FILE *output, char *oname);
void output_remark(FILE *output, char *oname, FILE *remark, char *rname);
void output_author(FILE *output, char *oname);
void output_info(FILE *output, char *oname);
void output_build(FILE *output, char *oname, FILE *build, char *bname);
void output_program(FILE *output, char *oname, FILE *prog, char *pname);
void output_end(FILE *output, char *oname);
int get_line(char *buf, int siz, int maxcol);
void output_till_dot(FILE *output, char *oname, char *leader);
int col_len(char *string);
void check_io(FILE *stream, char *name, int eof_ok);
void uuencode(FILE *output, char *oname, FILE *infile,
	      char *iname, int umode, char *uname);

int
main(argc, argv)
    int argc;		/* arg count */
    char **argv;	/* the args */
{
    FILE *remark=NULL;	/* open remarks stream */
    FILE *build=NULL;	/* open build file stream */
    FILE *prog=NULL;	/* open program stream */
    FILE *output=NULL;	/* open output stream */
    char *rname=NULL;	/* file with remarks about the entry */
    char *bname=NULL;	/* file containing how prog.c should be built */
    char *pname=NULL;	/* the obfuscated program source file */
    char *oname=NULL;	/* ioccc entry output file */
    struct tm *tm;	/* startup time structure */

    /*
     * check on the year
     */
    start_time = time((long *)0);
    tm = gmtime(&start_time);
    if (tm->tm_year != RULE_YEAR-1900 &&
	(tm->tm_year != RULE_YEAR-1900+1 || tm->tm_mon != 0)) {
	fprintf(stderr,
	""%s: WARNING: this program applies to %d, which may differ from %d\n\n"",
	    argv[0], RULE_YEAR, 1900+tm->tm_year);
    }

    /*
     * parse the command line args
     */
    parse_args(argc, argv, &rname, &bname, &pname, &oname);

    /*
     * open/check the input and output files
     *
     * We open and truncate the output file first, in case it is the same
     * as one of the input files.
     */
    output = open_output(oname);
    remark = open_remark(rname);
    build = open_build(bname);
    prog = open_program(pname);
    if (output==NULL || remark==NULL || build==NULL || prog==NULL) {
	exit(1);
    }

    /*
     * output each section
     */
    output_entry(output, oname);
    output_remark(output, oname, remark, rname);
    output_author(output, oname);
    output_info(output, oname);
    output_build(output, oname, build, bname);
    output_program(output, oname, prog, pname);
    output_end(output, oname);

    /*
     * flush the output
     */
    if (fflush(output) == EOF) {
	fprintf(stderr, ""%s: flush error in %s: "", program, oname);
	perror("""");
	exit(2);
    }

    /*
     * final words
     */
    printf(""\nYour entry can be found in %s.  You should check this file\n"",
	oname);
    printf(""correct any problems and verify that the uudecode utility will\n"");
    printf(""correctly decode your build file and program.\n\n"");
    printf(""This program has been provided as a guide for submitters.  In\n"");
    printf(""cases where it conflicts with the rules, the rules shall apply.\n"");
    printf(""It is your responsibility to ensure that your entry conforms to\n"");
    printf(""the current rules.\n\n"");
    printf(""EMail your entries to:\n"");
    printf(""\t%s@%s\n\n"", ENTRY_USER, ENTRY_HOST);
    printf(""IMPORTANT NOTE: You must include the words:\n"");
    printf(""\tioccc entry\n\n"");
    printf(""in the subject of your EMail when sending in your entry!\n"");
    printf(""Failure to do so may result in the loss of your entry!\n"");
    /* all done */
    return 0;
}

/*
 * parse_args - parse the command line args
 *
 * usage:
 *	argc	arg count
 *	argv	the args
 *	rname	file with remarks about the entry
 *	bname	file containing how prog.c should be built
 *	pname	the obfuscated program source file
 *	oname	ioccc entry output file
 *
 * Given the command line args, this function parses them and sets the
 * required name flags.  This function will return only if the command
 * line syntax is correct.
 */
void
parse_args(int argc, char **argv, char **rname,
	   char **bname, char **pname, char **oname)
{
    char *optarg;	/* -flag option operand */
    int flagname;	/* the name of the -flag */
    int i;

    /*
     * Not everyone has getopt, so we must parse args by hand.
     */
    program = argv[0];
    for (i=1; i < argc; ++i) {

	/* determine the flagname */
	if (argv[i][0] != '-') {
	    usage(1);
	    /*NOTREACHED*/
	}
	flagname = (int)argv[i][1];

	/* determine the flag's operand */
	if (flagname != '\0' && argv[i][2] != '\0') {
	    optarg = &argv[i][2];
	} else {
	    if (i+1 >= argc) {
		usage(2);
		/*NOTREACHED*/
	    } else {
		optarg = argv[++i];
	    }
	}

	/* save the flag's operand in the correct global variable */
	switch (flagname) {
	case 'r':
	    *rname = optarg;
	    break;
	case 'b':
	    *bname = optarg;
	    break;
	case 'p':
	    *pname = optarg;
	    break;
	case 'o':
	    *oname = optarg;
	    break;
	default:
	    usage(3);
	    /*NOTREACHED*/
	}
    }

    /*
     * verify that we have all of the required flags
     */
    if (*rname == NULL || *bname == NULL || *pname == NULL || *oname == NULL) {
	usage(4);
	/*NOTREACHED*/
    }
    return;
}

/*
 * usage - print a usage message and exit
 *
 * usage:
 *	exitval		exit with this value
 *
 * This function does not return.
 */
void
usage(int exitval)
{
    fprintf(stderr,
	""usage: %s -r remarks -b build -p prog.c -o ioccc.entry\n\n"", program);
    fprintf(stderr, ""\t-r remarks\tfile with remarks about the entry\n"");
    fprintf(stderr, ""\t-b build\tfile containing how prog.c should be built\n"");
    fprintf(stderr, ""\t-p prog.c\tthe obfuscated program source file\n"");
    fprintf(stderr, ""\t-o ioccc.entry\tioccc entry output file\n"");
    exit(exitval);
}

/*
 * open_remark - open/check the remark file
 *
 * usage:
 *	filename	remark filename
 *
 * The remark file should be indented by 4 spaces, and should not extend
 * beyond column MAX_COL.  These are not requirements, so we only warn.
 *
 * This function returns NULL on I/O or format error.
 */
FILE *
open_remark(char *filename)
{
    FILE *stream;		/* the opened file stream */
    char buf[BUFSIZ+1];		/* input buffer */
    int toolong=0;		/* number of lines that are too long */
    int non_indent=0;		/* number of lines not indented by 4 spaces */

    /*
     * open the remark input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open remark file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * look at each line
     */
    while (fgets(buf, BUFSIZ, stream) != NULL) {

	/* count lines that do not start with 4 spaces */
	if (buf[0] != '\n' && strncmp(buf, ""    "", 4) != 0) {
	    ++non_indent;
	}

	/* count long lines */
	if (col_len(buf) > MAX_COL) {
	    /* found a line that is too long */
	    ++toolong;
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* note long lines if needed */
    if (toolong > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s extend beyond the 80th column\n"",
	    program, toolong, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* note non-indented lines, if needed */
    if (non_indent > 0) {
	fprintf(stderr,
	    ""%s: WARNING: %d line(s) from %s are not indented by 4 spaces\n"",
	    program, non_indent, filename);
	fprintf(stderr,
	    ""%s:          This is ok, but it would be nice to avoid\n\n"",
	    program);
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_build - open/check the build file
 *
 * usage:
 *	filename	build filename
 *
 * The how to build file must not be longer than MAX_BUILD_SIZE bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_build(char *filename)
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */

    /*
     * open the how to build input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat how to build file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_BUILD_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the how to build file: %s, is %ld bytes long\n"",
	    program, filename, (long) statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_BUILD_SIZE);
	return(NULL);
    }

    /* return the open file */
    return(stream);
}

/*
 * open_program - open/check the program source file
 *
 * usage:
 *	filename	source filename
 *
 * The program source file must be <= 3217 bytes.  The number of
 * non-whitespace and }{; chars not followed by whitespace must
 * be <= 1536 bytes.
 *
 * This function returns NULL on I/O or size error.
 */
FILE *
open_program(char *filename)
{
    FILE *stream;		/* the opened file stream */
    struct stat statbuf;	/* the status of the open file */
    int count;			/* special count size */
    int c;			/* the character read */
    int control_m;		/* 1 ==> warn about trailing ^M's */

    /*
     * open the program source input file
     */
    stream = fopen(filename, ""r"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open program source file: %s: "",
	    program, filename);
	perror("""");
	exit(7);
    }

    /*
     * determine the size of the file
     */
    if (fstat(fileno(stream), &statbuf) < 0) {
	fprintf(stderr, ""%s: cannot stat program source file: %s: "",
	    program, filename);
	perror("""");
	return(NULL);
    }
    if (statbuf.st_size > MAX_PROGRAM_SIZE) {
	fprintf(stderr,
	    ""%s: FATAL: the program source file: %s, is %ld bytes long\n"",
	    program, filename, (long) statbuf.st_size);
	fprintf(stderr,
	    ""%s:        it may not be longer than %d bytes\n"",
	    program, MAX_PROGRAM_SIZE);
	return(NULL);
    }

    /*
     * count the non-whitespace, non {}; followed by whitespace chars
     */
    control_m = 0;
    count = 0;
    c = 0;
    while ((c=fgetc(stream)) != EOF) {

	/* look at non-whitespace */
	if (isascii(c) && !isspace(c) && c != '\r') {
	    switch (c) {
	    case '{':		/* count if not followed by EOF or whitespace */
	    case '}':
	    case ';':
		/* peek at next char */
		c = fgetc(stream);
		if (c != EOF && isascii(c) && !isspace(c) && c != '\r') {
		    /* not followed by whitespace or EOF, count it */
		    ungetc(c, stream);
		    ++count;
		}
		break;
	    default:
		++count;
		break;
	    }

	/* look for trailing ^M's */
	} else if (c == '\r') {
	    /* peek at next char */
	    c = fgetc(stream);
	    if (c != EOF && c == '\n') {
		control_m = 1;
	    }
	    /* put the peeking char back */
	    ungetc(c, stream);
	}
    }

    /* watch for I/O errors */
    check_io(stream, filename, EOF_OK);

    /* look at the special size */
    if (count > MAX_PROGRAM_SIZE2) {
	fprintf(stderr,
	    ""%s: FATAL: the number of bytes that are non-whitespace, and\n"",
	    program);
	fprintf(stderr,
	    ""%s:        that are not '{', '}', ';' followed by whitespace\n"",
	    program);
	fprintf(stderr,
	    ""%s:        or EOF must be <= %d bytes\n"",
	    program, MAX_PROGRAM_SIZE2);
	fprintf(stderr,
	    ""%s:        in %s, %d bytes were found\n"",
	    program, filename, count);
	return(NULL);
    }

    /* warn about trailing ^M's */
    if (control_m) {
	fprintf(stderr,
    	    ""\nWARNING: Trailing Control-M's (\\r or \\015) found.\n""
	    ""\t If these chars result in a compilation failure,\n""
	    ""\t your entry may be rejected\n\n"");
    }

    /* return the open file */
    rewind(stream);
    return(stream);
}

/*
 * open_output - open/check the entry output file
 *
 * usage:
 *	filename	output filename
 *
 * This function returns NULL on open error.
 */
FILE *
open_output(char *filename)
{
    FILE *stream;		/* the opened file stream */

    /*
     * open the ioccc entry output file
     */
    stream = fopen(filename, ""w"");
    if (stream == NULL) {
	fprintf(stderr, ""%s: cannot open ioccc entry file for output: %s: "",
	    program, filename);
	perror("""");
	exit(8);
    }

    /* return the open file */
    return(stream);
}

/*
 * output_entry - output the ---entry--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_entry(FILE *output, char *oname)
{
    char title[MAX_TITLE_LEN+1+1];	/* the entry's title */
    char buf[MAX_COL+1+1];		/* I/O buffer */
    int entry=0;			/* entry number */
    int ret;				/* fields processed by fscanf */
    int ok_line=0;			/* 0 => the line is not ok */
    char skip;				/* input to skip */
    time_t epoch_sec;			/* seconds since the epoch */
    char *p;

    /*
     * write the start of the section
     */
    fprintf(output, ""---entry---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the rule year
     */
    fprintf(output, ""rule:\t%d\n"", RULE_YEAR);
    check_io(output, oname, EOF_NOT_OK);

    /* determine if this is a fix */
    printf(""Is this a fix, update or resubmittion to a "");
    printf(""previous entry (enter y or n)? "");
    while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    if (buf[0] == 'y') {
	fprintf(output, ""fix:\ty\n"");
	check_io(output, oname, EOF_NOT_OK);
	printf(""\nBe sure that the title and entry number that you give\n"");
	printf(""are the same of as the entry you are replacing\n"");
    } else {
	fprintf(output, ""fix:\tn\n"");
	check_io(output, oname, EOF_NOT_OK);
    }

    /*
     * write the title
     */
    printf(""\nThe first character of your title should match [a-zA-Z0-9_=]\n"");
    printf(""The next 0 to %d characters should match [a-zA-Z0-9_=+-]\n\n"",
	MAX_TITLE_LEN-1);
    printf(""It is suggested, but not required, that the title should\n"");
    printf(""incorporate your username; in the case of multiple authors,\n"");
    printf(""consider using parts of the usernames of the authors.\n\n"");
    printf(""enter your title: "");
    do {
	/* prompt and read a line */
	if ((ok_line = get_line(title, MAX_TITLE_LEN+1, MAX_COL-9)) <= 0) {
	    printf(""\ntitle is too long, please re-enter: "");
	    continue;
	}

	/* verify the pattern, not everyone has regexp, so do it by hand */
	if (!isascii((int)title[0]) ||
	    !(isalnum((int)title[0]) || title[0] == '_' || title[0] == '=')) {
	    printf(""\ninvalid first character in the title\n\n"");
	    printf(""enter your title: "");
	    ok_line = 0;
	} else {
	    for (p=(&title[1]); *p != '\0' && *p != '\n'; ++p) {
		if (!isascii((int)*p) ||
		    !(isalnum((int)*p) ||
		      *p == '_' || *p == '=' || *p == '+' || *p == '-')) {
		    printf(""\ninvalid character in the title\n\n"");
		    printf(""enter your title: "");
		    ok_line = 0;
		}
	    }
	}
    } while (ok_line <= 0);
    fprintf(output, ""title:\t%s"", title);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the entry number
     */
    printf(""\nEach person may submit up to %d entries per year.\n\n"",
	MAX_ENTRY);
    printf(""enter an entry number from 0 to %d inclusive: "", MAX_ENTRY-1);
    do {
	/* get a valid input line */
	fflush(stdout);
	ret = fscanf(stdin, ""%d[\n]"", &entry);
	check_io(stdin, ""stdin"", EOF_NOT_OK);
	/* skip over input until newline is found */
	do {
	    skip = fgetc(stdin);
	    check_io(stdin, ""stdin"", EOF_NOT_OK);
	    if (skip != '\n') {
		/* bad text in input, invalidate entry number */
		entry = -1;
	    }
	} while (skip != '\n');

	/* check if we have a number, and if it is in range */
	if (ret != 1 || entry < 0 || entry > MAX_ENTRY-1) {
	    printf(
	      ""\nThe entry number must be between 0 and %d inclusive\n\n"",
		MAX_ENTRY-1);
	    printf(""enter the entry number: "");
	}
    } while (ret != 1 || entry < 0 || entry > MAX_ENTRY-1);
    fprintf(output, ""entry:\t%d\n"", entry);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the submission date
     */
    /* returns a newline */
    epoch_sec = time(NULL);
    fprintf(output, ""date:\t%s"", asctime(gmtime(&epoch_sec)));
    check_io(output, oname, EOF_NOT_OK);

    /*
     * write the OS/machine host information
     */
    printf(
      ""\nEnter the machine(s) and OS(s) under which your entry was tested.\n"");
    output_till_dot(output, oname, ""host:"");
}

/*
 * output_remark - output the ---remark--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	remark		stream to the file containing remark text
 *	rname		name of the remark file
 *
 * Read the needed information form stdin, and write the entry section.
 */
void
output_remark(FILE *output, char *oname, FILE *remark, char *rname)
{
    char buf[BUFSIZ+1];		/* input/output buffer */

    /*
     * write the start of the section
     */
    fprintf(output, ""---remark---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * copy the remark file to the section
     */
    while (fgets(buf, BUFSIZ, remark) != NULL) {
	fputs(buf, output);
	check_io(output, oname, EOF_NOT_OK);
    }
    check_io(remark, rname, EOF_OK);

    /* be sure that the remark section ends with a newline */
    if (buf[strlen(buf)-1] != '\n') {
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);
    }
}

/*
 * output_author - output the ---author--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information from stdin, and write the author section.
 * If multiple authors exist, multiple author sections will be written.
 */
void
output_author(FILE *output, char *oname)
{
    char buf[MAX_COL+1+1];	/* I/O buffer */
    int more_auths;		/* TRUE => more authors to note */
    int auth_cnt=0;		/* number of authors processed */

    /*
     * prompt the user for the author section
     */
    printf(""\nEnter information about each author.  If your entry is after\n"");
    printf(""%s and before the contest deadline, the judges\n"", START_DATE);
    printf(""will attempt to EMail back a confirmation to the first author\n"");

    /*
     * place author information for each author in an individual section
     */
    do {

	/* write the start of the section */
	fprintf(output, ""---author---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* write the author */
	printf(""\nAuthor #%d name: "", ++auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nname too long, please re-enter: "");
	}
	fprintf(output, ""name:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the organization */
	printf(""\nEnter the School/Company/Organization of author #%d\n"",
	    auth_cnt);
	printf(""\nAuthor #%d org: "", auth_cnt);
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter: "");
	}
	fprintf(output, ""org:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the address */
	printf(
	    ""\nEnter the postal address for author #%d.  Be sure to include\n"",
	    auth_cnt);
	printf(""your country and do not include your name.\n"");
	output_till_dot(output, oname, ""addr:"");

	/* write the EMail address */
	printf(
	    ""\nEnter the EMail address for author #%d.  Use an address from\n"",
	    auth_cnt);
	printf(
	    ""a registered domain or well known site.  If you give several\n"");
	printf(""forms, list them one per line.\n"");
	output_till_dot(output, oname, ""email:"");

	/* write the home page URL */
	printf(
	    ""\nEnter the fully qualified home page URL for author #%d\n"",
	    auth_cnt);
	printf(""including the http: part or just enter none: "");
	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0 ||
	       (strncmp(buf, ""http://"", sizeof(""http://"")-1) != 0 &&
		strcmp(buf, ""none\n"") != 0)) {
	      printf(""\nURL too long, does not begin with http:// or\n"");
	      printf(""is not the word none\n"");
	}
	fprintf(output, ""url:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* write the anonymous status */
	printf(""\nShould author #%d remain anonymous (enter y or n)? "",
	    auth_cnt);
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	fprintf(output, ""anon:\t%s"", buf);
	check_io(output, oname, EOF_NOT_OK);

	/* determine if there is another author */
	printf(""\nIs there another author (enter y or n)? "");
	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
	if (buf[0] == 'y') {
	    more_auths = TRUE;
	} else {
	    more_auths = FALSE;
	}
    } while (more_auths == TRUE);
    return;
}

/*
 * output_info - output the ---info--- section(s)
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information from stdin, and write the info section.
 * If multiple info files exist, multiple info sections will be written.
 */
void
output_info(FILE *output, char *oname)
{
    char infoname[MAX_FILE_LEN+1];	/* filename buffer */
    char yorn[1+1];		/* y or n answer */
    char *uuname;		/* name to uuencode as */
    FILE *infile;		/* info file stream */

    /*
     * prompt the user for info information
     */
    printf(""\nInfo files should be used only to supplement your entry.\n"");
    printf(""For example, info files may provide sample input or detailed\n"");
    printf(""information about your entry.  Because they are supplemental,\n"");
    printf(""the entry should not require them to exist.\n\n"");

    /*
     * while there is another info file to save, uuencode it
     */
    printf(""Do you have a info file to include (enter y or n)? "");
    while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	printf(""\nplease answer y or n: "");
    }
    while (yorn[0] == 'y') {

	/* read the filename */
	printf(""\nEnter the info filename: "");
	while (get_line(infoname, MAX_FILE_LEN+1, 0) <= 0) {
	    printf(""\nInfo filename too long, please re-enter: "");
	}

	/* compute the basename of the info filename */
	/* remove the trailing newline */
	uuname = &infoname[strlen(infoname)-1];
	*uuname = '\0';
	/* avoid rindex/shrrchr compat issues, do it by hand */
	for (--uuname; uuname > infoname; --uuname) {
	    if (*uuname == '/') {
		++uuname;
		break;
	    }
	}

	/* attempt to open the info file */
	infile = fopen(infoname, ""r"");
	if (infile == NULL) {
	    fprintf(stderr, ""\n%s: cannot open info file: %s: "",
		program, infoname);
	    perror("""");
	    continue;
	}

	/*
	 * write the start of the section
	 */
	fprintf(output, ""---info---\n"");
	check_io(output, oname, EOF_NOT_OK);

	/* uuencode the info file */
	uuencode(output, oname, infile, infoname, UUINFO_MODE, uuname);

	printf(""\nDo you have another info file to include (enter y or n)? "");
	while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
	    printf(""\nplease answer y or n: "");
	}
    };
    return;
}

/*
 * output_build - output the ---build--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	build		open build file stream
 *	bname		name of the build file
 *
 * Read the needed information from stdin, and write the build section.
 */
void
output_build(FILE *output, char *oname, FILE *build, char *bname)
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---build---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, build, bname, UUBUILD_MODE, UUBUILD_NAME);
    return;
}

/*
 * output_program - output the ---program--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	prog		open program stream
 *	pname		name of program file
 *
 * Read the needed information form stdin, and write the program section.
 */
void
output_program(FILE *output, char *oname, FILE *prog, char *pname)
{
    /*
     * write the start of the section
     */
    fprintf(output, ""---program---\n"");
    check_io(output, oname, EOF_NOT_OK);

    /*
     * uuencode the program file
     */
    uuencode(output, oname, prog, pname, UUPROG_MODE, UUPROG_NAME);
    return;
}

/*
 * output_end - output the ---end--- section
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *
 * Read the needed information form stdin, and write the 'end section'.
 */
void
output_end(FILE *output, char *oname)
{
    /*
     * write the final section terminator
     */
    fprintf(output, ""---end---\n"");
    check_io(output, oname, EOF_NOT_OK);
    return;
}

/*
 * get_line - get an answer from stdin
 *
 * usage:
 *	buf		input buffer
 *	siz		length of input, including the newline
 *	maxcol		max col allowed, 0 => disable check
 *
 * This function will flush stdout, in case a prompt is pending, and
 * read in the answer.
 *
 * This function returns 0 if the line is too long, of the length of the
 * line (including the newline) of the line was ok.  This function does
 * not return if ERROR or EOF.
 */
int
get_line(char *buf, int siz, int maxcol)
{
    int length;			/* the length of the input line */

    /* flush terminal output */
    fflush(stdout);

    /* read the line */
    if (fgets(buf, siz+1, stdin) == NULL) {
	/* report the problem */
	check_io(stdin, ""stdin"", EOF_NOT_OK);
    }

    /* look for the newline */
    length = strlen(buf);
    if (buf[length-1] != '\n') {
	int eatchar;		/* the char being eaten */

	/* no newline found, line must be too long, eat the rest of the line */
	do {
	    eatchar = fgetc(stdin);
	} while (eatchar != EOF && eatchar != '\n');
	check_io(stdin, ""stdin"", EOF_NOT_OK);

	/* report the situation */
	return 0;
    }

    /* watch for long lines, if needed */
    if (maxcol > 0 && (length > maxcol || col_len(buf) > maxcol)) {
	/* report the situation */
	return 0;
    }

    /* return length */
    return length;
}

/*
 * output_till_dot - output a set of lines until '.' by itself is read
 *
 * usage:
 *	output		entry's output file stream
 *	oname		name of the output file
 *	leader		the lead text for the first line
 *
 * This routine will read a set of lines until (but not including)
 * a single line with '.' is read.  The format of the output is:
 *
 *	leader:\tfirst line
 *	\tnext line
 *	\tnext line
 *	   ...
 *
 * This routine will not return if I/O error or EOF.
 */
void
output_till_dot(FILE *output, char *oname, char *leader)
{
    char buf[BUFSIZ+1];		/* input buffer */
    int count;			/* lines read */
    int done=FALSE;		/* TRUE => finished reading input */

    /* instruct the user on how to input */
    printf(""\nTo end input, enter a line with a single period.\n"");

    /* read lines until '.' or EOF */
    count = 0;
    while (!done) {
	/* issue the prompt */
	printf(""%s\t"", (count>0) ? """" : leader);
	fflush(stdout);

	/* get the line */
	if (get_line(buf, BUFSIZ, MAX_COL-9) <= 0) {
	    printf(""\nline too long, please re-enter:\n\t"");
	    continue;
	}

	/* note if '.' was read */
	if (strcmp(buf, "".\n"") == 0) {
	    done = TRUE;
	}

	/* write line if we read something */
	if (!done) {
	    fprintf(output, ""%s\t%s"", (count++>0) ? """" : leader, buf);
	    check_io(output, oname, EOF_NOT_OK);
	}
    }

    /* if no lines read, at least output something */
    if (count <= 0) {
	fprintf(output, ""%s\t.\n"", leader);
	check_io(output, oname, EOF_NOT_OK);
    }
    return;
}

/*
 * col_len - determine the highest that a string would reach
 *
 * usage:
 *	string		the string to examine
 *
 * Given a string, this routine returns that a string would reach
 * if the string were printed at column 1.  Tab stops are assumed
 * to start at 9, 17, 25, 33, ...
 */
int
col_len(char *string)
{
    int col;	/* current column */
    char *p;	/* current char */

    /* scan the string */
    for (col=0, p=string; *p != '\0' && *p != '\n'; ++p) {
	/* note the column shift */
	col = (*p=='\t') ? 1+((col+8)/8*8) : col+1;
    }
    if (*p == '\n') {
	--col;
    }

    /* return the highest column */
    return col;
}

/*
 * check_io - check for EOF or I/O error on a stream
 *
 * usage:
 *	stream		the stream to check
 *	name		the name of this stream
 *	eof_ok		EOF_OK or EOF_NOT_OK
 *
 * Does not return if EOF or I/O error.
 */
void
check_io(FILE *stream, char *name, int eof_ok)
{
    /* test for I/O error */
    if (ferror(stream)) {
	fprintf(stderr, ""%s: error on %s: "", program, name);
	perror("""");
	exit(1);

    /* test for EOF */
    } else if (eof_ok == EOF_NOT_OK && feof(stream)) {
	fprintf(stderr, ""%s: EOF on %s\n"", program, name);
	exit(1);
    }
    return;
}

/*
 * uuencode - uuencode a file
 *
 * usage:
 *	output		output file stream
 *	oname		output filename
 *	infile		input file stream
 *	iname		input filename
 *	umode		the mode to put on the uuencode file
 *	uname		name to put on the uuencode file
 *
 * Perform the uuencoding process identical to the process performed
 * by the uuencode(1) utility.
 *
 * This routine implements the algorithm described in the uuencode(5)
 * 4.3BSD Reno man page.
 */
void
uuencode(FILE *output, char *oname, FILE *infile,
	 char *iname, int umode, char *uname)
{
    char buf[UUENCODE_LEN+1];	/* the uuencode buffer */
    int read_len;		/* actual number of chars read */
    int val;			/* 6 bit chunk from buf */
    char filler='\0';		/* filler uuencode pad text */
    char *p;

    /*
     * output the initial uuencode header
     */
    fprintf(output, ""begin %o %s\n"", umode, uname);
    check_io(output, oname, EOF_NOT_OK);

    /*
     * clear out the input buffer
     */
    for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	*p = '\0';
    }

    /*
     * We will process UUENCODE_LEN chars at a time, forming
     * a single output line each time.
     */
    while ((read_len=fread(buf,sizeof(buf[0]),UUENCODE_LEN,infile)) > 0) {

	/*
	 * the first character is the length character
	 */
	fputc(UUENCODE(read_len), output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * We will convert 24 bits at a time.  Thus we will convert
	 * 3 sets of 8 bits into 4 sets of uuencoded 6 bits.
	 */
	for (p=buf; read_len>0; read_len-=3, p+=3) {

	    /* bits 0 to 5 */
	    val = (p[0]>>2)&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 6 to 11 */
	    val = ((p[0]<<4)&0x30) | ((p[1]>>4)&0x0f);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 12 to 17 */
	    val = ((p[1]<<2)&0x3c) | ((p[2]>>6)&0x03);
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);

	    /* bits 18 to 23 */
	    val = p[2]&0x3f;
	    fputc(UUENCODE(val), output);
	    check_io(output, oname, EOF_NOT_OK);
	}

	/* end of UUENCODE_LEN line */
	fputc('\n', output);
	check_io(output, oname, EOF_NOT_OK);

	/*
	 * clear out the input buffer  (don't depend on bzero() or memset())
	 */
	for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
	    *p = '\0';
	}
    }

    /* check the last read on the input file */
    check_io(infile, iname, EOF_OK);

    /* write end of uuencode file */
    fprintf(output, ""%c\nend\n"", UUENCODE(filler));
    check_io(output, oname, EOF_NOT_OK);
}
","#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#define t(x) typedef x
#define G return
#define Y(x) x;x
#define e(s) exit(s);
#define b(x,o) x o x
#define Z while
#define y fclose
#define end static

t(signed)char U;t(struct) b(O,);

t(						    U*)
H;						    t(O
*)						    *o;
struct O{ O* l, **h; void* L; } ; t(int)i; i P(U g) { G
isspace(g); } H D(H s){H p,r;if(!s)G 0;for(p=(H)s;*p &&
!P(*p); p++); if(r=malloc(p-s))for(p=r; *s&&! P(*s);p++
,s++)b(*,p=) s; G r;} void l(o p,O*x){*(o)x=* p; *p=x;}
#define m(x) do{ if(!(q = malloc(sizeof(O)))) e(1)q->l\
=0						    ;q\
->						    L=\
		    x ; } while (0)
		i(*R)(i) =putchar;i h(
	    o f,H d,U c){O*q; f+=c;Z(d&&*d)
	  { m(D(d)); l(f++, q); Z(*d && !P(*d
	)) d++; Z(*d && P(*d)) d++; } G b(,0);}
     void k() { static U b(c,;) ?R(c):(c='\n'); }
     i main (i Q,		     H *l){static o
   X;i t,j;				   switch (Q
 ){ case				       1: { H
 *p, I						 [] ={
""aH""						   "" ""
""B""						    ""0""
"" ""						    ""B""
""""						    ""B""
""""						    "" ""
""B""						    "",""
"" ""						   "",""
 "" `""						  ""0 ""
 ""b0 ""						 ""@, ""
  ""0 Hb,""				      "" B2 ""
   ""H0 b, B b""				""H HB b`, ""
     ""H, @ 2 `, ""		     ""@2 H2 BH Bb""
      "" b@"",""AH B0 BB B, , `0 b0 @, 0 Hb, B2 H0""
	"" b, B bH HB b`, H, @ 2 `, @2 H2 BH Bb""
	  "" b@"",""0bHb, HbH `H2 @b, @H @0 B@ ""
	      ""b@ bH0 bHB"","".HHH"",""?`H0"",
		"",b@b,"","" +"", 0}; p=I;

		    if (!(X=calloc(
		6<<6,sizeof(O*))))e(1)
	    do{h(X,(*p)+1,**p);} Z(*(++p));
	  D: if ((t = getchar()) >= 0) { k();
	goto u;}e(0)}case 2:{U *p,e[33]; b(i, )
     ,w;for(i=0;i<34;i++)i[e]=b(0,;w=);p=e; Z(1){
    t = (w == 200) ?		     10:getchar();
   switch(t) {				   case 0xa:
 case EOF:				       if(w--
 ){R(1[l					 ][0])
;for(i						   =0,
p=e;i						    <=w
;i+=						    6){
R (						    *p+
'+'						    );*
p++						    =0;
 ;}						    R(
 0xa						   );w
  =-1						 ;}p=
    e-					      1;case
      32:				    if (t<0) e(
	0)				    break; /*/*
	  /*/				    default : *
	    p
		    |=(001<<(w%6));
		}if((++w%6)==0)p++;}e(
	    0)}case 3:{O*u,*q,*x;U s[0400];
	  i i;FILE*F; j:j=1;if(!(X=calloc(6<<
	6,sizeof(O*)))) e(1) if(!(F=fopen(j[l],
     ""r"")))e(1)Z(fgets(s,j<<8,F))(*s)&&h(X,s+j,*s
    );j=b(i,=)&0xff;		     i:u=0;x=X[i];
   Z(x){q=Y(*(				   o)x)=Y(u)
 =Y(x)=q;}				       i[X]=u
 ;i=(i-2					 +9)%(
sizeof						   (s))
;if(i						    ^j)
goto						    i;;
y(F)						    ; }
case						    4:{
end						    i i
 ;if						    (!
 X){						   i=j
  =1;						 goto
    j;}					      if(i){O
      **x				    ,*m=*(x=X);
	do*				    x=1[x];Z(++
	  x<X				    +255);*x=m;
	    }		
		    }default:if(!(t
		=*2[l]++))break;case 0
	    :{H p;i i,c,n;O *a;u:c=n=0;Z(c<
	  10){c++b(;,n:n++)}if(n<='&'){c-=(n%
	7);goto n;}else n++;a=*(X+t);Z(a){p=(H)
     a->L;Z(*p>=n){i=(*p++)-n;for(c=0;c<6;c++,i=i
     >>1){ if(b(!, i		     &&)(*p >= n))
   break;R(32+				   (i&1)*3);
 }}R(10);a				       =a->l;
 }if(Q<2					 )goto
D;if(*						   l[2
]){R(						    10)
;main						    (4,
l);						    }}}
Z(Q						    ++<
1){						    X+=
 t;						    if
 ((t						   &7)
  >3)						 goto
    i;					      else {
      t--				    ;putchar(t)
	;t				    =(t&7)?t:t-
	  '*'				    ;}}exit(0);
	    }
","#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#define t(x) typedef x
#define G return
#define Y(x) x;x
#define e(s) exit(s);
#define b(x,o) x o x
#define Z while
#define y fclose
#define end static

t()char U;t(struct) b(O,);

t(						    U*)
H;						    t(O
*)						    *o;
struct O{ O* l, **h; void* L; } ; t(int)i; i P(U g) { G
isspace(g); } H D(H s){H p,r;if(!s)G 0;for(p=(H)s;*p &&
!P(*p); p++); if(r=malloc(p-s))for(p=r; *s&&! P(*s);p++
,s++)b(*,p=) s; G r;} void l(o p,O*x){*(o)x=* p; *p=x;}
#define m(x) do{ if(!(q = malloc(sizeof(O)))) e(1)q->l\
=0						    ;q\
->						    L=\
		    x ; } while (0)
		i(*R)(i) =putchar;i h(
	    o f,H d,U c){O*q; f+=c;Z(d&&*d)
	  { m(D(d)); l(f++, q); Z(*d && !P(*d
	)) d++; Z(*d && P(*d)) d++; } G b(,0);}
     void k() { static U b(c,;) ?R(c):(c='\n'); }
     i main (i Q,		     H *l){static o
   X;i t,j;				   switch (Q
 ){ case				       1: { H
 *p, I						 [] ={
""aH""						   "" ""
""B""						    ""0""
"" ""						    ""B""
""""						    ""B""
""""						    "" ""
""B""						    "",""
"" ""						   "",""
 "" `""						  ""0 ""
 ""b0 ""						 ""@, ""
  ""0 Hb,""				      "" B2 ""
   ""H0 b, B b""				""H HB b`, ""
     ""H, @ 2 `, ""		     ""@2 H2 BH Bb""
      "" b@"",""AH B0 BB B, , `0 b0 @, 0 Hb, B2 H0""
	"" b, B bH HB b`, H, @ 2 `, @2 H2 BH Bb""
	  "" b@"",""0bHb, HbH `H2 @b, @H @0 B@ ""
	      ""b@ bH0 bHB"","".HHH"",""?`H0"",
		"",b@b,"","" +"", 0}; p=I;

		    if (!(X=calloc(
		6<<6,sizeof(O*))))e(1)
	    do{h(X,(*p)+1,**p);} Z(*(++p));
	  D: if ((t = getchar()) >= 0) { k();
	goto u;}e(0)}case 2:{U *p,e[33]; b(i, )
     ,w;for(i=0;i<34;i++)i[e]=b(0,;w=);p=e; Z(1){
    t = (w == 200) ?		     10:getchar();
   switch(t) {				   case 0xa:
 case EOF:				       if(w--
 ){R(1[l					 ][0])
;for(i						   =0,
p=e;i						    <=w
;i+=						    6){
R (						    *p+
'+'						    );*
p++						    =0;
 ;}						    R(
 0xa						   );w
  =-1						 ;}p=
    e-					      1;case
      32:				    if (t<0) e(
	0)				    break; /*/*
	  /*/				    default : *
	    p
		    |=(001<<(w%6));
		}if((++w%6)==0)p++;}e(
	    0)}case 3:{O*u,*q,*x;U s[0400];
	  i i;FILE*F; j:j=1;if(!(X=calloc(6<<
	6,sizeof(O*)))) e(1) if(!(F=fopen(j[l],
     ""r"")))e(1)Z(fgets(s,j<<8,F))(*s)&&h(X,s+j,*s
    );j=b(i,=)&0xff;		     i:u=0;x=X[i];
   Z(x){q=Y(*(				   o)x)=Y(u)
 =Y(x)=q;}				       i[X]=u
 ;i=(i-2					 +9)%(
sizeof						   (s))
;if(i						    ^j)
goto						    i;;
y(F)						    ; }
case						    4:{
end						    i i
 ;if						    (!
 X){						   i=j
  =1;						 goto
    j;}					      if(i){O
      **x				    ,*m=*(x=X);
	do*				    x=1[x];Z(++
	  x<X				    +255);*x=m;
	    }		
		    }default:if(!(t
		=*2[l]++))break;case 0
	    :{H p;i i,c,n;O *a;u:c=n=0;Z(c<
	  10){c++b(;,n:n++)}if(n<='&'){c-=(n%
	7);goto n;}else n++;a=*(X+t);Z(a){p=(H)
     a->L;Z(*p>=n){i=(*p++)-n;for(c=0;c<6;c++,i=i
     >>1){ if(b(!, i		     &&)(*p >= n))
   break;R(32+				   (i&1)*3);
 }}R(10);a				       =a->l;
 }if(Q<2					 )goto
D;if(*						   l[2
]){R(						    10)
;main						    (4,
l);						    }}}
Z(Q						    ++<
1){						    X+=
 t;						    if
 ((t						   &7)
  >3)						 goto
    i;					      else {
      t--				    ;putchar(t)
	;t				    =(t&7)?t:t-
	  '*'				    ;}}exit(0);
	    }
","
             /*                                     ,*/
            #include                              <time.h>
             #include/*                     _  ,o*/  <stdlib.h>
             #define  c(C)/*     -      . */return      ( C); /*    2004*/
              #include   <stdio.h>/*.   Moekan           ""'   `\b-'     */
                typedef/*  */char   p;p* u                     ,w       [9
                  ][128] ,*v;typedef  int _;_   R,i,N,I,A               ,m,o,e
             [9],  a[256],k    [9], n[               256];FILE*f       ;_ x   (_ K,_ r
        ,_ q){;   for(;                                         r<     q    ; K       =((
     0xffffff)   &(K>>8))^                                        n[255     &        ( K
   ^u[0        +                                     r  ++      ]     )]);c          (K
  )}        _ E                           (p*r,    p*q  ){     c(          f         =
          fopen                     (r  ,q))}_   B(_ q){c(    fseek        (f,      0
        ,q))}_ D(){c(  fclose(f ))}_  C(  p    *q){c(  0-    puts(q    )   )}_/*   /
      */main(_ t,p**z){if(t<4)c(   C(""<in""       ""file>""    ""\40<l""   ""a""  ""yout> ""
     /*b9213272*/""<outfile>""   ) )u=0;i=I=(E(z[1],""rb"")) ?B(2)?0 :   (((o   =ftell
    (f))>=8)?(u     =(p*)malloc(o))?B(0)?0:!fread(u,o,1,f):0:0)?0:  D():0      ;if(
   !u)c(C(""      bad\40input  ""));if(E(z[2],""rb"" )){for(N=-1;256> i;n[i++] =-1   )a[
   i]=0;       for(i=I=0;   i<o&&(R  =fgetc(   f))>-1;i++)++a[R] ?(R==N)?( ++I>7)?(n[
  N]+1       )?0:(n [N   ]=i-7):0:   (N=R)    |(I=1):0;A =-1;N=o+1;for(i=33;i<127;i++
  )(        n[i   ]+  1&&N>a[i])?    N= a     [A=i]     :0;B(i=I=0);if(A+1)for(N=n[A];
 I<       8&&   (R  =fgetc(f ))>    -1&& i   <o        ;i++)(i<N||i>N+7)?(R==A)?((*w[I
 ]             =u [i])?1:(*w[I]=   46))?(a             [I++]=i):0:0:0;D();}if(I<1)c(C(
              ""  bad\40la"" ""yout  ""))for(i            =0;256>(R=  i);n[i++]=R)for(A=8;
             A  >0;A --)   R  = ( (R&1)==0)          ?(unsigned int)R>>(01):((unsigned
            /*kero  Q'        ,KSS  */)R>>         1)^        0xedb88320;m=a[I-1];a[I
            ]=(m           <N)?(m=   N+8):        ++        m;for(i=00;i<I;e[i++]=0){
           v=w         [i]+1;for(R                      =33;127  >R;R++)if(R-47&&R-92
           &&       R-(_)* w[i])*(                   v++)=    (p)R;*v=0;}for(sprintf
                  /*'_  G*/  (*w+1,              ""%0""     ""8x"",x(R=time(i=0),m,o)^~
                0)   ;i<       8;++           i)u      [N+ i]=*(*w+i+1);for(*k=x(~
                  0,i=0     ,*a);i>-        1;      ){for (A=i;A<I;A++){u[+a [ A]
                ]=w[A       ][e[A]]  ;     k     [A+1]=x (k[A],a[A],a[A+1]
              );}if     (R==k[I])      c(      (E(z[3  ],""wb+""))?fwrite(
             /* */   u,o,1,f)?D          ()|C(""  \n    OK.""):0    :C(
            ""  \n  WriteError""            ))  for  (i  =+I-
           1  ;i >-1?!w[i][++                 e[+ i]]:0;
             ) for( A=+i--;                 A<I;e[A++]
             =0); (i <I-4                 )?putchar
             ((_   )  46)                  | fflush
            /*'      ,*/                  ( stdout
            ):       0&                    0;}c(C
           (""       \n                   fail"")
           )      /*                    dP' /
                 dP                    pd  '
                '                      zc
                                      */
                                     }
","#include  <stdio.h>
#define   l ""==================================================""
#define   m ""                                                  ""
int       _(
float     x,
float     y){
return    x>=0&&x<50&&y>=0&&y<20;}
int main  (){
char      a[2][20][51],c[9][4][51][51],d[100];
int       e,f,g,h=0,i,j=0,k,b=0,n[9],o[9],p[9],x[9],y[9],q[9],r,s,t;
float     u[9],v[9],w[9],z[9];
printf    (""i%s\033Yppppppppppppppppppp1G0"",l);
do sprintf(a[0][j],""%s"",m,
sprintf   (a[1][j],""%s"",l));
while     (++j<20);
scanf     (""%d %d\n"",&r,&s);
gets      (d);
do        {
sscanf    (d,""%d %d %f %f %f %f %d %d %d"",&o[b],&p[b],&u[b],&v[b],&w[b],&z[b],&x[b],&y[b],&q[b],j=n[b]=i=0);
do do     c[b][i][j][x[b]]=!
gets      (c[b][i][j]);
while     (++j<y[b]);
while     (++i<q[b]+(j=0)||!++b);}
while     (
gets      (d)||(i=t=e=f=0));
do        {
do strncpy(a[h][i],m,50);
while     (++i<20||(i=0));
do if     (t>=o[i]&&t<=p[i]&&!(k=j=0))
do do if  (_(u[i]+k,v[i]+j))a[h][(
int       )v[i]+j][(
int       )u[i]+k]=c[i][n[i]][j][k];
while     (++k<x[i]);
while     (++j<y[i]+(k=0)||((++n[i]-q[i]||(n[i]=0)),u[i]+=w[i],v[i]+=z[i],0));
while     (++i<b||(k=j=g=0));
do do if  (a[1-h][j][k]!=a[h][j][k]){f-j&&
printf    (""%dG0"",j+1,e=0,g+=4);k&&e>k&&
printf    (""0%d "",k,g+=4);k&&e<k&&k-e>1&&
printf    (""%d "",k-e,g+=3);k&&e<k&&k-e==1&&
printf    ("" "",g++);
printf    (""r%c"",a[h][j][k],g+=2,e=k,f=j);}
while     (++k<50);
while     (++j<20+(k=0));
do printf (""1G0"",g+=3,e=f=0);
while     (g<s);h=1-h;}
while     (++t<=r+(i=0));
return    !
puts      ("""");}
","#include<stdio.h>

 	 /* 

 	O
  		b  
 	f   		u  			s	 
 	c
 
 	a 
 
 t	
 		e

 		d	 
 	*/ 

 	int 	 		m	 
	 (
	
 	int

 
 c	 	  )	
	
 {	 

 int		

 x 
	
 = 
		 3	
	 	+
	 
 (  
 	c
	
 	-	
	 	1 
 		)
	 	 *

	 	9

		 +  
 	(

		 c
 
 	-

		 1 	
 	)

		 *		
 	27

		 +
	
 	(

		 c 
		 -


 	1	
 
 )	
 	 *
	 	 (
 	 	

 		(
 	 	993
  		-	
 	 '!'

		 * 	
 	c
	 
 )	  		/	
	 	320 

 	)
  		+				 ( 

 	c
  		-

 		'9'
	 	 +	
	 	'8' 
 		)		
 	*  
 	c

		 +  
 	(
	
 	c	
	 	- 
 		1
	 	 ) 
		 *	
	 	243 
 		/		
 	9;	 				 	 	return 		 	c
			 - 
			32	
	 	?	
 
 c 	
 	- 	 		9		 		?
 
 	c
  		-				 10	
	 	? 
 		x		
 	%	 			x	 	 	:	 	  3		
	 : 		 	2

		 :	
 	 1 
 		;	
 	 }
			 
	 
 int 	
 	a 	 		, 
 		b				 ,
	 
 c
	 
 ,
			 d 
			,  
 	e	
 
 		
 	,
 
 	v,

 		f  
 	;
	
 	int	
	 	main 
 		/*				 n
			 (
	 
 c 

 	) 	
 	{				 return  
 	c	
 
 ++	
 
 - 
	
 32	


 ?	
	
 c
 		 -
 		 9
 
 	?	
 
 c	
 
 - 
	
 10	


 ?	
	
 0
			 :
 
 	3 				: 

 	2

 		:				 1 	
	 ;
			 }
	 
 x
 
 	(   		)	
 		{
 
 	int
	 	 a 

 	, 	
 	b				 ,  
 	c	
 
 ,	
 
 d 
	
 ,	


 e	
	
 ,
			 v  
 	;	
 
 while 

	 (
	
	 (
	 
 v 

 	= 	
 	putchar				 (

	 	d	 	  ) 
 	 )	
 
 != 			 EOF
 	 	)
 	 	{ 			 if
 		 (
 		 (

	 	a 
 	 =	
 
 m 			 */
 	 	( 			 ) 			 {
 		 while
 		 (  
 	(	
 
 e	
 
 = 			 d	
 	 = 			 c
			 = 	
 	b	
 
 =		
	 v  
	 = 	
 	getchar
	 
 ( 

 	) 	
 					 ) 
 	 - 	
 	EOF
 		 )
 		 {				 for 
 	 (				 ;  
 	d  
	 < 

	 0
	
	 ;
			 d	
			++	
			) 
 	 {				 f  
 	=  
	 f 	 
 /
			 getchar	
			(	
			) 
 	 ;				 a  
 	<<=  
	 f		
	 ; 	
	 (
			 v
			 *
 		 v
 		 *				 v
 
 	-	
 
 v		
 	||
 
 	e

 		*  
 	e				 *	
	 	e
			 -
			 e 
 	 )	
 
 &&	 	  ( 
	
 e	


 -	
	
 2
			 || 
			(		 		d 
 		& 

 	f
  		)

 		- 	
 	4				 ||	
 	 (	 		 a  
 	>>	 		 v  
 	!=	 		 (  
 	e	 		 -  
 	1	 		 ?  
 	f	
 	 :

		 0


 	)	 	 	)
 
 	)	 		 ; 

	 } 		 	if

		 (


 	(	 	 	v				 %
 
 	v  
	 +
 
 	f	 		 * 

	 --f
			 +
 
	 v 

	 )	 		 && 

	 ( 		 	v

		 <


 	f	 	 	?				 v				 /
 
 	v  
	 -
 
 	992	 		 * 

	 b
			 :
 
	 v 

	 *  
	 v				 )				 &&
 
 	/*  
	 o
 
 	(	 		 c 

	 )
			 {
 
	 return 

	 c	 		 - 

	 32
			 ?
			 c
 
	 - 

	 9	 		 ? 

	 c	 	  - 		 	10

		 ?


 	0	 	 	:				 3				 :				 2
 
 	:  
	 1
 
 	;	 		 } 

	 y
			 (
 
	 ) 

	 {  
	 int				 a				 ,
 
 	f  
	 ,
 
 	b	 		 , 

	 c
			 ,
 
	 d 

	 ,	 		 e 

	 ,
			 v
			 ;
 
	 while 

	 (  
	 (				 v				 =				 getchar
 
 	(  
	 )
 
 	)	 		 != 

	 EOF
			 )
 
	 { 

	 if  
	 (				 (				 a
 
 	=  
	 m
 
 	(	 		 c 

	 )
			 ;
 
	 */ 

	 (	 		 a 

	 =
			 m
			 (
 
	 b 

	 +	 		 ++ 

	 f
			 *
			 3888
 
	 ) 

	 )	 		 && 

	 ( 		 	b

		 =


 	m	 	 	(				 getchar				 (				 )				 )
 
 	-	 	  f  
	 /
 
 	243	 		 ) 

	 &&
			 (
 
	 c 

	 =  
	 m				 (				 getchar
 
 	(  
	 )
 
 	)	 		 + 

	 f
			 )
 
	 && 

	 	 		 ( 

	 f
			 ==
			 1
 
	 ? 

	 124  
	 -				 (				 (				 c
 
 	<  
	 8
 
 	&&	 		 ( 

	 (
			 c
 
	 & 

	 b  
	 )				 !=				 e
 
 	||  
	 (
 
 	c	 		 >> 

	 d
			 )
 
	 != 

	 3888	 		 ) 

	 )
			 )
			 :
 
	 1 

	 )	 		 && 

	 (
			 d
			 =
 
	 m 

	 (  
	 getchar				 (				 )				 +				 f
 
 	)  
	 )
 
 	&&	 		 ( 

	 e
			 =
 
	 m 

	 (  
	 getchar				 (				 )
 
 	)  
	 )
 
 	)	 	  putchar	 		 ( 

	 f
			 +
 
	 a 

	 -	 		 1 

	 +
			 (
			 b
 
	 - 

	 1  
	 )				 *				 (				 (
 
 	993  
	 -
 
 	'!'	 		 ) 

	 /
			 (
 
	 '(' 

	 *  
	 8				 )				 )
 
 	+  
	 (
 
 	c	 		 - 

	 f
			 -
 
	 '9' 

	 +	 		 '8' 

	 )
			 *
			 9
 
	 - 

	 4	 		 + 

	 (
			 d
			 -
 
	 1 

	 )	 		 * 

	 243
			 /
			 9
 
	 + 

	 f 		 	+
			 11
	 
 +

			(
 
 	e   		-	
 		1
 
 	)
	 	 *		 		3888  			/

 		'0'  
 	-
	
 	7	
	 	) 
 		;				 }  
 	return
			 (
	 
 f

	 	&&	
 
 getchar  
 	(
	 
 )

			)

			;	 	  }
","#include                 <stdio.h>
#include                 <sys/time.h>
#include                 <X11/Xlib.h>
#include                 <X11/keysym.h>

#define                  Z(a)main(a,T)
                         Window L;
#define                  J (K,
                         GC N;
#define                  I ; for(
                         int g,h,i,j,k,l,m,n,p,q,r,v,w,x,y,z,
#define                  W(a)(y/v*!w+((S+1)>>a&255)*(D+y/(z|w-2))/D)<<a|
                         o,b,f,u,s,c,a,t,e,d, C
#define                  U (struct timeval*)H
                         [1<<18],A=100,B=4,D=200,E=53300,F=65793,H[4];
#define                  V(a)#a"": %1d'%02d\""%02d          ""
                         Display*K; Pixmap M; char P[99]; int main
#define                  Y(a,b)(a<b?a:b)
                         (int S,char**T){
#define                  X(a)\
XDrawLine                J M,N,D+l a m,o,D+l a n,o),
XEvent                   O I p=E/5; --S&~1?
XSetForeground           J N,W(0)W(8)W(16)0),X(-)X(+)gettimeofday(U,0):S?z=97
                         == ** ++ T,w=A==z[*T],B-=w[z+*T]%3,S:++S;
XCopyArea                J M,L,N,0,0,e,D,0,0),
XSync                    J 0),
XFlush                   (K),select(0,0,0,0,U+1)){ I 3[H]=F; p==++r?K=
XOpenDisplay             (0),N=
XCreateGC                J L=
XCreateSimpleWindow      J RootWindow(K,0),0,0,e=D*2,D,0,0,0),0,0),
XSelectInput             J L,KeyPressMask|KeyReleaseMask),
XMapWindow               J L),M=
XCreatePixmap            J L,e,d=D,DefaultDepth(K,0)),u=h=q=E:r<p?a=r/D%6,r[C
                         +p]=(l+=!a|a%2?g:a-3)/4,r[C]=2*r<=p?(n+=(i-=(i+34&&r
                         /149%B)-(i-34&&r/353%3)))/55:C[p-r],v=4-3*z:
XPending                 (K)?C[F+
XLookupKeysym            (&O.xkey,0&
XNextEvent               J&O))]^=O.type==KeyPress||O.type==KeyRelease,p:0;









                            /* Some more code */


 )I k=C[F+XK_Right]-C[F+XK_Left],j=k?j+v*k*(j*k<8):j*.9,u+=(s=Y(C[F+XK_space]*
 3+s-!!s,a))/9,c=u>p?q=Y(h,q),u%=p,Z(c=0):c,t+=j*(s+A)/e-s/i*(C[u+4]-C[u]),s=t
 *t>p?t*=.97,s*.8:g>a&&b*b<D*9?i:s,i=k=l=0,o=n=e;  i-5; Z((k/17?o++==y?m=n=D,f
 -=A,o=30+9*i++:0,n-=2,m+=3,l=f/.7,y*F+A-i*k:k|!o?f=l=C[u]/-2-t,k+=17*w,o=k+++
 20,n=k+k-k*k/9,F*p:o--<a?y=135,A*F|D:0)))I x=g=m=f=0,a=i=u+D,d+=9; o<f?n=2*e,
 Z(z?r+k*F*8:E-k*A*A),n=9+x/D,Z(!k+z?r=D*F+9:A<<17),n-=x/9/D,Z(i%p>6?h=r*(3+z)
 /5:r),n=x/13/e,Z(k?h:r),o++:(f=x/D+70+C[i+p]-C[u+p],o=x?o:f,k=2*i/41%2,l=C[--
 i]-C[u]-t,x+=D-(y=i-u),g=(d-i)%410?g:(a=o,b=l+B*x/e,x)/A,i>u);  )I k=i=0,x=g,
 l=b; ++i==41+!f&&k?f=k=i=l=0,x=190,a=163:i==42?i=9,k=r:!k|i-41; n=(Y(Y(Y(75,A
 -i)/3,95-2*i),r-k+2*i)-k/r)*x/D,m=i<9?x*14/D:k?(i-31)/5*(i%12)?0:n-1:0,o=a-i*
 x/D,y=D-o,h=Z(k*r+k*f/F))I  B=g?B:1-h%3,i=60,y=n=m,XDrawString  J M,N,30,x,P,
 sprintf(P,V(Time)V(High)""Speed: %03dmph"",h/A/i,h/A%i,h%A,q/A/i,q/A%i,q%A,s,Z(
 A<<17))),x=h; ++f<2*z*e; l=(x*=3)%e,o=x*x%a,Z(-1)); } return A**H+1[H]/p-c; }
","#define O \
#ifdef
#define Q \
#undef
#define C \
#define
#define G \
#else
#define D \
#ifndef
#define l \
#include FNAME
#define I \
#endif



O  i
O  o
O  c
Q  c
I
O  d
Q  d
I
O  e
Q  e
I
O  f
Q  f
I
O  g
Q  g
I
O  h
Q  h
I
O  Z
Q  Z
I
O  j
Q  j
I
O  k
Q  k
I
O  m
Q  m
I
O  n
Q  n
I
Q  o
G
O  E
O  t
Q  t
I
O  s
Q  s
I
O  u
Q  u
I
O  v
Q  v
I
O  w
Q  w
I
O  x
Q  x
I
O  y
Q  y
I
O  z
Q  z
I
O  A
Q  A
I
O  B
Q  B
I
O  r
Q  r
I
Q  E
G
O _L
O  a
O  b
D  q
Q  a
C  q
I
G
O  q
Q  a
I
I
G
O  b
D  q
C  a
I
G
O  q
C  a
Q  q
I
I
I
O  p
Q  p
I
O  a
C  p
Q  a
I
O  b
Q  b
I
G
O  F
O  q
Q  q
I
C _L
O  c
Q  c
C  a
I
O  t
C  b
I
l
O  p
C  c
I
O  d
Q  d
C  a
I
O  s
C  b
I
l
O  p
C  d
I
O  e
Q  e
C  a
I
O  u
C  b
I
l
O  p
C  e
I
O  f
Q  f
C  a
I
O  v
C  b
I
l
O  p
C  f
I
O  g
Q  g
C  a
I
O  w
C  b
I
l
O  p
C  g
I
O  h
Q  h
C  a
I
O  x
C  b
I
l
O  p
C  h
I
O  Z
Q  Z
C  a
I
O  y
C  b
I
l
O  p
C  Z
I
O  j
Q  j
C  a
I
O  z
C  b
I
l
O  p
C  j
I
O  k
Q  k
C  a
I
O  A
C  b
I
l
O  p
C  k
I
O  m
Q  m
C  a
I
O  B
C  b
I
l
O  p
C  m
I
O  n
Q  n
C  a
I
O  r
C  b
I
l
O  p
C  n
I
Q _L
Q  F
G
O  H
C  E
l
C  s
C  F
l
Q  s
Q  H
G
O _u
O  t
Q  t
G
C  t
I
O  s
Q  s
G
C  s
I
O  u
Q  u
G
C  u
I
O  v
Q  v
G
C  v
I
O  w
Q  w
G
C  w
I
O  x
Q  x
G
C  x
I
O  y
Q  y
G
C  y
I
O  z
Q  z
G
C  z
I
O  A
Q  A
G
C  A
I
O  B
Q  B
G
C  B
I
O  r
Q  r
G
C  r
I
C  F
l
O _v
Q _v
I
O  q
C _v
I
C  E
l
C  t
C  F
l
O _v
O  q
Q  q
G
C  q
I
I
Q _u
G
O _w
O  J
Q  J
I
O _q
Q _q
I
C _u
l
D  c
D  d
D  e
D  f
D  g
D  h
D  Z
D  j
D  k
D  m
D  n
C  J
I
I
I
I
I
I
I
I
I
I
I
D  q
C _q
I
Q _w
G
O _x
O  K
Q  K
I
O  \
STOP
C  K
I
O _r
C  K
I
D  K
D _s
C _s
D  L
C  L
I
D  M
C  M
I
D  N
C  N
I
D  P
C  P
I
D  R
C  R
I
D  S
C  S
I
D  T
C  T
I
D  U
C  U
I
D  V
C  V
I
D  W
C  W
I
D  X
C  X
I
D  Y
C  Y
I
D _i
C _i
I
D _a
C _a
I
D _b
C _b
I
D _c
C _c
I
D _d
C _d
I
D _e
C _e
I
D _f
C _f
I
D _g
C _g
I
I
C  E
l
C  t
O _h
C  s
I
O _t
C  u
I
O _3
C  v
I
O _4
C  w
I
O _5
C  x
I
O _6
C  y
I
O _7
C  z
I
O _8
C  A
I
O _9
C  B
I
O _r
C  r
I
C _w
l
C  o
l
D  J
O _q
C  c
O  X
Q  X
C  d
I
O  Y
Q  Y
C  e
I
O _i
Q _i
C  f
I
O _a
Q _a
C  g
I
O _b
Q _b
C  h
I
O _c
Q _c
C  Z
I
O _d
Q _d
C  j
I
O _e
Q _e
C  k
I
O _f
Q _f
C  m
I
O _g
Q _g
C  n
I
C  H
l
C  E
l
C  t
O  d
C  X
C  s
I
O  e
C  Y
C  u
I
O  f
C _i
C  v
I
O  g
C _a
C  w
I
O  h
C _b
C  x
I
O  Z
C _c
C  y
I
O  j
C _d
C  z
I
O  k
C _e
C  A
I
O  m
C _f
C  B
I
O  n
C _g
C  r
I
G
C  c
O  L
Q  L
C  d
I
O  M
Q  M
C  e
I
O  N
Q  N
C  f
I
O  P
Q  P
C  g
I
O  R
Q  R
C  h
I
O  S
Q  S
C  Z
I
O  T
Q  T
C  j
I
O  U
Q  U
C  k
I
O  V
Q  V
C  m
I
O  W
Q  W
C  n
I
C  H
l
C  E
l
C  t
O  d
C  L
C  s
I
O  e
C  M
C  u
I
O  f
C  N
C  v
I
O  g
C  P
C  w
I
O  h
C  R
C  x
I
O  Z
C  S
C  y
I
O  j
C  T
C  z
I
O  k
C  U
C  A
I
O  m
C  V
C  B
I
O  n
C  W
C  r
I
I
I
C  o
l
O _y
Q _y
C  c
I
O _z
Q _z
C  d
I
O _A
Q _A
C  e
I
O _B
Q _B
C  f
I
O _C
Q _C
C  g
I
O _D
Q _D
C  h
I
O _E
Q _E
C  Z
I
O _F
Q _F
C  j
I
O _G
Q _G
C  k
I
O _H
Q _H
C  m
I
O _I
Q _I
C  n
I
O  J
C  o
l
O _s
C  c
I
O  L
C  d
I
O  M
C  e
I
O  N
C  f
I
O  P
C  g
I
O  R
C  h
I
O  S
C  Z
I
O  T
C  j
I
O  U
C  k
I
O  V
C  m
I
O  W
C  n
I
C  H
l
C  E
l
O _M
C  t
I
O  X
C  s
I
O  Y
C  u
I
O _i
C  v
I
O _a
C  w
I
O _b
C  x
I
O _c
C  y
I
O _d
C  z
I
O _e
C  A
I
O _f
C  B
I
O _g
C  r
I
C _w
l
O  J
Q  i
l
O _h
|  2
I
O _t
|  4
I
O _3
|  8
I
O _4
| 16
I
O _5
| 32
I
O _6
| 64
I
O _7
|128
I
O _8
|256
I
O _9
|512
I
)
;
I
C  o
l
C  c
O _h
Q _h
C  d
I
O _t
Q _t
C  e
I
O _3
Q _3
C  f
I
O _4
Q _4
C  g
I
O _5
Q _5
C  h
I
O _6
Q _6
C  Z
I
O _7
Q _7
C  j
I
O _8
Q _8
C  k
I
O _9
Q _9
C  m
I
O _r
Q _r
C  n
I
C  H
l
O  d
C _h
I
O  e
C _t
I
O  f
C _3
I
O  g
C _4
I
O  h
C _5
I
O  Z
C _6
I
O  j
C _7
I
O  k
C _8
I
O  m
C _9
I
O  n
C _r
I
C  o
l
Q _s
G
O _q
C  F
G
C _u
I
l
O  c
C _y
I
O  d
C _z
I
O  e
C _A
I
O  f
C _B
I
O  g
C _C
I
O  h
C _D
I
O  Z
C _E
I
O  j
C _F
I
O  k
C _G
I
O  m
C _H
I
O  n
C _I
I
I
I
G
O _J
C _x
l
l
l
l
l
l
l
l
l
l
Q _x
G
O _K
C _J
l
l
l
l
l
l
l
l
l
l
Q _J
G
C _K
l
l
l
l
l
l
l
l
l
l
Q _K
D  K
l
I
I
I
I
I
I
I
I
I
I
I
G
C  i
O _N
pri\
ntf(
""%d""
""\n""
,
1
G
#  \
inc\
lud\
e<s\
tdi\
o.h>
int\
 ma\
in()
C _N
C _h
C _M
Q  i
{
l
+
1
)
;
l
}
I
I
","#include <stdio.h>
#include <stdlib.h>

#define N(I,l) s l]=(I?1<<I|I<<10:01776)
#define f(a,t) for(a=0;a<t;a++)
#define Su(d,o,ku) O(l/9,d) O(l%9,o) O(l%9/3+l/27*3,ku)
#define NO ;printf(""%c %s"",I?I|48:46,++l%3?"""":l%9?""| "":l%27?""\n"":l%'Q'?z:""\n"");
#define Ba(k,a) {O||printf(""!!! "" #a "" %i\n"",k+1);goto l;}
#define O(o,k) f(l,9) c[l]= *#k?0x3fe:-1;\
  f(l,81) if(*#k){\
    if(!(s]&c[o])) Ba(o,k) c[o]&=~(1<<(s]>>10));\
  } else if((s]>>l0)&1) c[o]=c[o]+1?-2:l;\
  if(*#k) { f(l,81) if(s]>>10||(s]&=c[o]),!s]) Ba(o,k) }\
  else f(l,9) l[c]<0||s[c]]>>10||(N(l0,[c]),C++);

struct{ int s[81],I,l,O; } S[0123];
int I, l, l0, o, C, O=0, w=0, c[10], L; long i;
char z[] = ""\007      &       &      \n"";

#define s S].s[l

int main(int n,char**N) {
    S->O=0; L=n>1?*N[1]-85?1:6:0; i=L&1?atol(N[1]):123;
#define i (int)(81.0*(i=1103515245*i+12345&0x7fffffff)/2147483648.0)
    for(l=C=0;l<81;) {
	I=L&1?0:getchar()^48; i; I=I-30?I:0;
	if(I<10) {
		#define S S[O
		if(C<22) z[C++]^=13; N(I,)NO
	}
    }

    for(;;) {
	l0:
        Su(row,col,box) C=l0=0;
	f(l,81) if(!(s]>>10&&++l0)) {
	  o=s]&1022; for(I=0;~o&1&&(o/=2);I++); o-1||(s]|=I<<10,C++);
	} if(l0==l) {
	  if(O&&L&2) { O--; goto l0; } goto O; 
	} for(l0=1;10>l0;l0++) { Su(,,) }

	if(!C) {
	    l=(o=S].O)?S].I:0; I=o?S].l%9+1:(S].O=i%9+1);
	    for(;l<81;l++,I=S].O,o=0) if(!(s]>>10)) {
		for(;;I=I%9+1,o=1) {
		    l0=0; if(o&&I==S].O) goto O;
		    if(s]>>I&1) {
			S].l=I; S++].I=l; S]=S-1];
			N(I,); O>w&&(w=O); goto lO;
		    }
		}
	    }
	}
	lO: S].O=0; goto l0; l: if(!(l0=O)) { L=0; goto O; } O--;
	s,S].I] &=~ (1<<S].l);
    }

    O: switch(L) {
	case 2: if(l0) {
	case 3: O=82;
	    for(S].l=l=i%81;l0||S].l-l;l=(l+1)%81)
     	     O1: if(l0=0,S].O=s]>>10,~s]&1) {
		s]=1023; S].I=l; S&0]=S]; w=O=0; L=2; goto lO;
	    }
	    L=0; l0=1;
	} else {
	    l=S=82].I; N(S].O,)|1; goto O1;
	}
    }

    printf(""\n\n""); for(l=0;l<81;) {I=s]>>10 NO}
    printf(""\n%s (stk %i %i)\n"",l0?""Done"":""No way!"",O,w);
    L|=2; if(L-3||!l0) return!l0; S,82]=S]; goto O;
}
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>


/* Defines */

#ifndef NO_STTY
#define S1 system(""stty cbreak -echo"")||
#define S2 system(""stty sane"")||
#else
#define S1
#define S2
#endif

#define A(i) (((q*)R(8))[i])
#define B p(b)
#define C p(&a)
#define H(i) sscanf(A(i),""%ld"",&R(i+11))&0 ||
#define P q*
#define M(a,b) main((i)(a),(P)(b))

#define p(x) ((i*)(x))
#define D T(B-C,C-B)
#define T(x,y) ((a&1)*((i)(x))+(~a&1)*((i)(y)))
#define R(x) (*(B+x))
#define q char*
#define Q(x) ((q)(x))
#define W(x,y) ((B[x]=(i)(y))&0)||
#define BS (w*l*h)
#define do(x,y) (a-x||y)&&
#define f(x) M(x,b)
#define if(p,q,r,s) ((p)&&!(q)||(s))&&(r)||
#define i long
#define I (int)

#define while(x,y,z) do(x, y && !(z) && f(a))
#define for(s,i,x,y,z,Z) W(i,x)f(s)||Z) && while(s,R(i)-y,z||W(i,R(i)+1)0)(s
#define return return do
#define w R(12)
#define l R(13)
#define h R(14)
#define X(i) (R(i)%w)
#define Y(i) ((R(i)%(w*l))/w)

#define Z(i) (R(i)/(w*l))
#define pr !printf
#define switch(x) (W(32+R(15),R(32+x+R(15))) W(32+x+R(15),0) (B[15]+=x)|1)
#define case(k,x,y) R(a)==k && x && switch(y) && f(13)||
#define TL(i) R(32+R(i))


/* Main program */

int main(int a, P b) {
	return(1>>1^1, M(6+!!M(5,C),C))

	do(
		13,
		pr(""\x1b[;H"")||

		for(14,4,0,BS,!X(4)&&pr(
			""%*s"",
			I(l-Y(4)),
			""""
		)

		||

		if(TL(4),pr(
			""%*ld"",I
			R(31),
			TL(4)),0,
                	pr(""%*.*s"",I
			R(31),
			I R(31),""#####"")
		)
		if(X(4)==w-1 , pr(""\n""),0 , pr(""%*s"", I(l+1), """")) (
			(R(4)+1)%(w*l)==0 && l>1)&&
			pr(""\n""),0))
			do(
				1&~1,
				pr(""Syntax: %s <x> <y> [<z>]\n"", b[0])||f(15)
			)((a&~1)

			-6||D>>12
			&&(*(p(T(C,b))+8)=*p(Q(b)+(Q(&b)-Q(C)))
		)
			
		&&(*(p(T(C,b))+9) = *p(b))&&M(
			8,T(C,b))
		||

		f( a) )&&do(
			8,
			if(R(9)&1,H(1)H(
				2 ) 0,W(14,
				l)W(13,1)0,
				H(1
			)

			H(2)
			H(3)
			0)(srand(time(0)),0
		) ||for(9,4, 0,BS, f(16)

	|| W(R(4)+32,R(0))!R(0) && W(15,R(4) )0,
	
	W(
		31,
		snprintf(A(0),1,""%ld"",BS))
		S1 pr(""\x1b[2J"") ||
			f(13)
		||
	
		f(18) ||
			f(15)
		))

		do(
			16,W(0,rand()%BS
		) W(1,0)

		for(17, 5, 0,R(4),! (
			TL(
				5)-R(0))&&! (
				W(1,1)
				W(5,R(4)-1)
				0),R(1)&&f(16))
			)

			do(
				18,W(0,0
			) for(19,4,0,BS, TL(4)-(R(4)+1)
			
			%BS&& (
				W(0,1)
				W(4,BS-1
			) 0)||0,!R(0) &&

			pr(
				""You win!\n""
			)
			||
			R(0)&& (
				W(a,getchar())
				case('i',
					0<Z(15),
					-w*l)
				case('j',
					0<X(15),
					-1)
				case('k',
					Z(15)<h-1,
					w*l)
				case('l',
					X(15)<w-1,
					1)
				case('n',
					Y(15)<l-1,
					w)
				case('o',
					0<Y(15),-w
			)
			R(a)=='q'&&!
			
			pr(
				""You lose :-)\n""
			)
			&&f(15)||f(a))
		)
	)

	do(
		15,S2 
		(exit(0),a)
	) (a-5||C<p(b));
}
","#define F 0xF
#define U 512

#define std(x,y)                                     (*x)(const char *,...)=y##f
#define str(l,e,x)                                                       l e,l x
#define mx(p,v1,v2)                                p[3]=v2,p[1]=v1,p[2]=v2,*p=v1
#define vi(n)                                                        q+2,n,q+3,n
#define rt                                                                return

                                                             #include <stdlib.h>
                                                              #include <stdio.h>

                          typedef double n; n *d,*b,*f; typedef unsigned char c;
char _[ ]=""    <?%s version=\""1.0\""?>\n<%s %s=\""%d\"" %s=\""%d\"">\n"", q [7][7] = {
""ivory"",""black"",""width"",""height"",""text""};int v,std(i,scan),std(o,print);

int cc(str(const void*,x,y))
{
        rt(*(n*)x>*(n*)y)-(*(n*)x<*(n*)y);
                                                                               }
        n t(n f,n g,str(n*,x,y))
                                                                               {
        f=*x++-f,g=g-*x,*y=f*f;rt *y+g*g;
                                                                               }
        c*ln(n*p)
                                                                               {
        c*f=((c*)(d+2*(2+v))+2*(p-d)); while(!*f) mx(f,rand(),rand());rt f;
                                                                               }
        n*put(str(n*,f,l),n z)
                                                                               {
        int r=(l-f)/4,p=*(f+(r*=2))<z;rt r>0?put(f+p*r,p?l:f+r,z):f;
                                                                               }
        n*g(n u,n w)
                                                                               {
        n y=u/(U-1),*s=put(d,d+v+2,y),z=w/(U-1),k,l=t(y,z,s,&k),
        m=l,*r[4],g[4],*f; c p; for(mx(r,s,0),mx(g,k,l);
        p=*(1+g)<*g,(m>*(g+1))+(*g<m);s=*f<m?m=*f,*(r+p):s)*(f=g+p+2)=t
        
        (y,z,*(r+p)+=p?-2:2,p+g);rt s;
                                                                               }
        c*a(str(n*,x,r))
                                                                               {
        n*y; int i=0,j=0,k=0,u;for(u=0;y=g(*x+u/4/4.,*r+u%4/4.),16>u;++u)
        i+=*ln(y),j+=*(1+ln(y)),k+=*(ln(y)+2);
        *_=i/u,*(1+_)=j/u,*(_+2)=k/u;rt(c*)_;
}

void tr(n x,n y,n i)
{
        c*h,w;n*m=g(y,i); for(w=4*(x<2);++w<4&&m==g(w/2*x+y,i+w%2*x););       
        for(w=4*(w>3&&(h=x>1?ln(m):a(&y,&i))&&o(""<rect style=\""fill:rgb(%d,%d,%d\
        );\"" x=\""%f\"" y=\""%f\"" %s=\""%f\"" %s=\""%f\""/>\n"",*h,*(1+h),*(2+h),str(F+,
        y,i),vi(x))),x/=2;x>0&&w<4;++w)tr(x,y+w/2*x,w%2*x+i);
}

int main()
{
        long k,r=1e6,h;d=calloc(r,k=sizeof(n)),f=d+r,b=d;

        while(0<(h=i(""%lf"",b)))*--f=*b++;v=b-d;if

        (!h+v%2+!v&&(r=0x630C65u)){o(""\n0x7"");while(r-->0)o(""F"");rt -1;}
        mx((d+v),-r,r);qsort(d,2+(v/=2),2*k,cc);
        tr(U,0&o(4+_,""xml"",""svg"",vi(2*F+U)),0);

        for(b=d-1+r,k=0;r=1,v>k++;b-=2)
        str(o(""<%s x=\""%f\"" y=\""%f\"" fill=\""%s\"" %s-anchor=\""end\"">%d</%s>\n"",
        4+q,str(F+r/2.-5+U**,b,(b-1)),q+r,q+4,k+!o
        (""<circle style=\""fill:%s;\"" cx=\""%f\"" cy=\""%f\"" r=\""3\""/>\n"",
        r+q,str(F+r/4.+U**,b,(b-1))),4+q),&&r--,);

        free(d);rt o(""</svg>\n"")-7;
}
","
#define F 0xF
#define U 512

#define std(x,y)                                     (*x)(const char *,...)=y##f
#define str(l,e,x)                                                     l##e,l##x
#define mx(p,v1,v2)                                p[3]=v2,p[1]=v1,p[2]=v2,*p=v1
#define mov(x,y)                                                      y=*f<m?x:y
#define vi(n)                                                        q+2,n,q+3,n
#define rt                                                                return

                                                             #include <stdlib.h>
                                                              #include <stdio.h>

                           typedef float n; n *d,*b,*f; typedef unsigned char c;
char _[ ]=""    <?%s version=\""1.0\""?>\n<%s %s=\""%d\"" %s=\""%d\"">\n"", q [7][7] = {
""ivory\0"",""black\0"",""width\0"",""height\0"",""text""};int v,std(i,scan),std(o,print);

int cc(str(const void*,x,y))
{
        rt(*(n*)x>*(n*)y)-(*(n*)x<*(n*)y);
                                                                               }
        n t(n f,n g,str(n*,x,y))
                                                                               {
        f=*x++-f,g=g-*x,*y=f*f;rt *y+g*g;
                                                                               }
        c*ln(n*p)
                                                                               {
        c*f=((c*)(d+2*(2+v))+2*(p-d)); while(!*f) mx(f,rand(),rand());rt f;
                                                                               }
        n*put(str(n*,f,l),n z)
                                                                               {
        int r=(l-f)/4,p=*(f+(r*=2))<z;rt r>0?put(f+p*r,p?l:f+r,z):f;
                                                                               }
        n*g(n u,n w)
                                                                               {
        n y=(.5+u)/U, *s=put(d,d+v+2,y),z=(w+.5)/U,k,l=t(y,z,s,&k),
        m=l,*r[4],g[4],*f; c p; for(mx(r,s,0),mx(g,k,l);
        p=*(1+g)<*g,(m>*(g+1))+(*g<m);mov(*(r+p),s),mov(*f,m))*(f=g+p+2)=t
        (y,z,*(r+p)+=p?-2:2,p+g);rt s;
                                                                               }
        c*a(str(n*,x,r))
                                                                               {
        n*y; int i=0,j=0,k=0,u;for(u=0;y=g(*x+u/4/4.,*r+u%4/4.),16>u;++u)
        i+=*ln(y),j+=*(1+ln(y)),k+=*(ln(y)+2);
        *_=i/u,*(1+_)=j/u,*(_+2)=k/u;rt(c*)_;
}

void tr(n x,n y,n i)
{
        c*h,w;n*m=g(y,i); for(w=4*(x<=1);++w<4&&m==g(w/2*x+y,i+w%2*x););
        w=4*(w>=4&&(h=x>1?ln(m):a(&y,&i))&&o
        (""<rect style=\""fill:rgb(%d,%d,%d);\"" x=\""%f\"" y=\""%f\"" %s=\
        \""%f\"" %s=\""%f\""/>\n"",*h,*(1+h),*(2+h),str(F+,y,i),vi(x)));
        for(x/=2;x>0&&w<4;++w)tr(x,y+w/2*x,w%2*x+i);
}

int main()
{
        long k,r=1e6,h;d=calloc(r,k=sizeof(n)),f=d+r,b=d;

        while(0<(h=i(""%f"",b)))*--f=*b++;v=b-d;if

        (!h+v%2+!v&&(r=0x630C65u)){o(""\n0x7"");while(r-->0)o(""F"");rt -1;}
        mx((d+v),-r,r);qsort(d,2+(v/=2),2*k,cc);
        tr(U,str(0,*o(4+_,""xml"",""svg"",vi(2*F+U)),0));

        for(b=d-1+r,k=0;v>k++;b-=2)for(r=1;0<=r;--r)
        o(""<%s x=\""%f\"" y=\""%f\"" fill=\""%s\"" %s-anchor=\""end\"">%d</%s>\n"",
        4+q,str(F+r/2.-5+U**,b,(b-1)),q+r,q+4,k+!o
        (""<circle style=\""fill:%s;\"" cx=\""%f\"" cy=\""%f\"" r=\""3\""/>\n"",
        r+q,str(F+r/4.+U**,b,(b-1))),4+q);

        free(d);rt o(""</svg>\n"")-7;
}
","/*
 * Sun's Java is often touted as being ""portable"", even though my code won't
 * suddenly become uber-portable if it's in Java. Truth is, Java's one of
 * the most ugly, slow, and straitjacketed languages ever. It's popular
 * mainly because people hear the word ""portable"" and go ""ewww"".
 *
 * This program, then, is dedicated to bringing about the death of Java. We
 * good coders have been oppressed for too long by the lame language
 * decisions of pointy-haired bosses and academics who should know better. 
 * It's time we stand up against this junk, and bring back the fun in
 * programming! Viva La Revolution!
 */

#define aSet c
#define BufferedReader(x)1
#define byte Y[I][_^1]?do(:):_&1?do(.):do(`):8;++y;}
#define class int N=0,_,O=328,l=192,y=4,Y[80][64]={0},I;struct
#define do(c)a(#c ""\b"")
#define err c,c
#define getAllStrings(x));q()
#define if(x)b(#x)
#define IOException
#define line c
#define main(a)b(char*x){write(1,""\033["",2),null}main()
#define new
#define null a(x);}a(char*x){write(1,x,strlen(x));try;try;try;try;
#define out c,c
#define println(x)c
#define private int d(int
#define public short c;}c;typedef int BufferedReader;char*F=""JF>:>FB;;BII"";
#define return {return
#define static f(x){N=(N+x)%6,y--?f(0),f(1),f(4),f(1):++Y[(I=O+N[F]-66)
#define String
#define System c
#define this if(D):1,O=I,I/=16,l<_/32?if(B):l>_/32?if(A):2,l=_,_/=16,byte
#define throws
#define toArray(x)c
#define try for(;--c.c;)
#define void /16][(_=l+N[6+F]-66)/16]?O/=16,l/=32,O<I/16?if(C):O>I/16?this
#define while(k)if(2J),if(7;21H),f(0),f(4),f(4),if(H),/*

import java.io.*;
import java.util.*;

/**
 * A lame Java program.
 * @author	J. Random Worker
 */
class LameJavaApp
{

	/** The infamous Long-Winded Signature From Hell. */
	public static void main(String[] args)
	    throws IOException
	{
		/* Don't get me started on this. */
		BufferedReader reader =
		    new BufferedReader(new FileReader(args[0]));

		/* What, this long incantation just to print a string? */
		System.err.println(""Hello world!"");

		/* At least this is sane. */
		String line;
		while ((line = reader.readLine()) != null)
			System.out.println(line.length());
	}

	/**
	 * Method with a needlessly long name.
	 * @param	aSet		a set (!)
	 */
	private String[] getAllStrings(Set<String> aSet)
	{
		/*
		 * This dance is needed even in J2SE 5, which has type
		 * templates. It was worse before that.
		 */
		return aSet.toArray(new String[0]);
	}

}
","                          #define/**/F/***/for/*A*/
                          #define/***/H()f=*E<<4|*\
                          E,f=~(f|f<<1|E[3]|E[1]|E\
                          [1]<<4|E[2]|E[(2)]<<(1));
                          #define/***/I(x,d)F(;s;C\
                          ()){s=s^(b=s&s-1^s);F(N[\
                          4]=q=0;q<4;q++)N[q]=E[q]\
                          ;N[5]=E-B;N[d]^=+b^(b)x;}
                          #define/**/o(p,t,i,m,a,l\
\
)u=(f&p)i(m) ;s=u&E[3];I(t(m),3)s=(u)a &E[l];I(t(m\
),l)u=u>>5-m &u;s=u&E[3-l];I(t(m),3-l) s=(u)a&*E;I\
(t(m),(0));; /*echo/Line/%d;sed/-n/-e/ %d,%dp/%s>*/
/*c.c;cc/c.c /-c*/;;char*A=0,*_,*R,*Q, D[9999],*r,l
[9999],T=42, M,V=32;long*E,k[9999],B[1 <<+21],*N=B+
1234567,q=0, h=3,j=2,O,b,f,u,s,c,a,t,e ,d;C(){F(h=N
[3];(B[h]&&+ memcmp(N,B+B[h],16));h=B[ h]+4);B[h]||
(B[h]=N-B,N= N+6);}main(char*U,int*w[] ){;;F(_=A=D+
6666,A[fread (A,1,3333,fopen(__FILE__, ""r""))]=0;*++
_;h||(*_=V)) 
*_-59|_[1]-* _||(h&&(*_=+ 35),h---2||(_[9]=V));;F(_
=A;*_;_++)10 -*_&&*_-V&&( *_-92)&&(k[q]=isalnum(l[q
]=*_),q++);M =47;*(E=N-6) =64;E[1]=289;E[2]=270336;
F(E[3]=32782 ;E<N;E=E+6){ H()o(1048560,<<,>>,4,>>4,
1)o(+489335, >>,<<,1,,2)o (978670,<<,>>,1,>>1,2)o(+
65535,>>,<<, 4,,1)if(8192 &*E){F(N=B;E>B;E=B+E[5])*
N++=E-B;F(;N >B;){h=*(E=B +*--N);H()s=~(E[1]|h|h<<1
);u=~(E[2]|h |h<<4);r=l;_ =D;d=1;a=2;O=8;F(q=74;q;q
--){F(b=0;b< 72;b++){h=+1 <<(q-1)/14*4+(b-1)/18;j=b
             ?(!(b%18)&&u &h)|h&f|(!(q%14)&&s&h)?1:
0:2;if(O<3)O ?j?j-1&&(O-2 &&d--,*R=34,O=2):(*_++=O-
2?l[d]?l[d++ ]:(d=t,O=e=3 ,34):(O=1,34)):j||(*_++=d
<t?l[d++]:(O =1,d=0,34)); else{if(O<6)if(j){j-2|e||
(_=R,O-4?d-- :M-_[-1]||(_ [-1]=l[d++],O=3));c=0;if(
k[d]&k[d-1]) F(;k[d-1];++ c)d--;!d||((h=l[d])^l[d-1
])+k[d]||!(+ 40-(h&62)&&h -125)||(c=1,d--);c-1||(c=
2,d--);c&&(_ [-c]=M,_[1-c ]=T,O=4);j-2|e||(*_++=+92
);}else{h=*_ ++=O-4?O-5?l [d++]:(O=3,M):(O=5,T),(_[
-1]&&(35-h|| !(a=+1)))||( O=7,*(R=Q=_-(1))=M);}else
{j?O-7||(O=6
,_[-1]=59):( *_++=a-2?O-6 ?O-7?126&*++ r:(O=8,T):(O
=7,M):(a=0,l [d]-100?(e=1 ,O=0):(e=0,O =3,35)));if(
e==1){F(r=A= l+d;35-*A;++ A)*A-M&&*A-T ||U-1&&(*A=V
);d=d+A-r;if (U-1){*A=0;F (j=2;13499>j &&(sprintf(l
,r+1,j,j,O=j +75,w[1]),j= O,!system(l) ););exit(j<+
13499);}t=d+ 9;_[-1]=l[++ d];}a-1|+j-2 ||(R-Q<3?(*(
Q<R?R-1:R)=* Q=*R=59):(*R =M,R[-1]=T), a=2);}}j?(*_
++=j-2?V:10, R):(R=_-1);} }R[-1]=T;*R= M;*_++=10;F(
R=D;putchar( *R)&&_>++R;) ;}}};O-b-f-u -s-c-a-t-e;}
","#include <math.h>
#include <stdlib.h>
#include <string.h>
#include ""SDL.h""

#define X2(a) a a
#define X4(a) a a a a
#define S1(a,b,c) #a""..""#b""..""#c"".""
#define S14(a,b,c) X4(S1(a,b,c))
#define S2(a) #a"".""#a"".....""
#define S24(a) X4(S2(a))
#define S4(a) #a#a#a#a
#define S3(a,b,c) S1(a,b,c)S4(..)
#define SE X4(X4(S4(..)))

char l[]=SE SE X2(S3(J,H,M)S3(J,H,E)S3(F,E,A)S3(F,E,J)S3(H,E,O)S3(H,E,C)S3(H,F,
x)S3(H,F,L)),b[]=SE X2(S4(j.jv.j.v)S4(f.fr.f.r)S4(e.eq.e.q)S4(h.ht.h.t))SE,*r[3
]={S14(v,v,q)S14(r,r,m)S14(q,q,l)S14(t,t,o),S24(J)S24(F)S24(E)S24(H),S24(M)S24(
J)S24(H)S24(L)};

#define B int
#define C double
#define S static
#define I(a,b,c,d,f,g) a=(f-d)/10.,b=1e-2*(d*(28-g)-f),c=1e-2*(d*f-8*g/3);\
d+=a,f+=b,g+=c;
S C T;typedef float A;S B D,R,U,p=0;S A F[5][0100000]={{0},{0}};

void AA(void*u,Uint8*_,B L){u=u;while(L>0){B M=p&037777,s=p>>12,u=(s%R)[
l],J=(s%U)[b],w=0,a=0,n;A v,q,m,E=(0x2000-(p&017777))/8192e0f;v=q=0;
#define EF_(x) F[w][1638##x+M
#define EF(l,s,ms) ((s*ms+EF_(4)-l]*(1-ms))/2.f+EF_(3)]/2.f)
#define FQ(s) (A)sin((0.12*pow(2,n/12.))*p*s)
#define IZ(v,c) v*=v c?v:0;
#define BF F[w][M]=F[w][M+16384]=q;v+=q;++w
#define IP(n,x,y,z,c) if(n!=46){x}q=EF(y,q,z);c;BF;
#define IS(s,c) if(q c s 0.75f)q=s 0.75f;
#define NQ(x,a,m) n=x-(x>=97?121:65)+a;q=FQ(m);
IP(u,NQ(u,12,1)m=FQ(1.01f);IZ(q,>6e-1)IZ(m,>6e-1)q+=m;q*=5e-1f*(E+1);,12288,
0.2f,;)for(;a<3;++a){char sn=(s%D)[a[r]];q=0;IP(sn,NQ(sn,12,0.25f)IZ(q,<0.3),
12288,0.2f,;)}q=0;IP(J,NQ(J,0,1/8.f)X4(q*=q;)q=(A)fmod(q*20,4)*4;,6144,0.25f,IS
(-,<)IS(+,>)q*=E)v*=0.6f;*(Sint16*)_=(Sint16)(v*32767);_++,++_,++p,--L,L--;}}

B main(B c,char**a){SDL_AudioSpec f,d;c=c,a=a;D=strlen((!!c&24)[r]),R=strlen(l)
,U=strlen(b);if(SDL_Init(16)<0)exit(1);atexit(SDL_Quit);f.freq=22050,f.format=\
AUDIO_S16,f.channels=1,f.samples=4096,f.callback=AA,f.userdata=0;if(SDL_OpenAu\
dio(&f,&d)<0)exit(2);T=0;SDL_PauseAudio(0);getchar();SDL_CloseAu\
dio();return 0;}
","typedef unsigned char B;char*x[]={
#include ""dict.h""
0};typedef struct L{B*s;struct L*n;}L;
L*h[128],*l[128],*s[128],Z[sizeof x/sizeof*x],*F=Z;int c[256],m,a=1;
int k(B*q){int g=0;B*p=q;while(*p)g|=!c[*p++]--;return g-1&p-q;}
void u(B*p){while(*p)c[*p++]++;}
void S(int N,int r,int t,L*W){L*w;int i,n;
 for(n=r<N?r:N;n>0;n--)for(w=n==N?W:h[n];s[t]=w;u(w->s),w=w->n)if(k(w->s))
  if(n==r){if(t==m-1)for(i=a=0;i<=t;i++)printf(""%s%c"",s[i]->s,i<t?' ':'\n');}
  else if(t<m-1)S(n,r-n,t+1,s[t]=w);}
int main(int C,B**A){int i=0,g,n=0;B*p;while(--C)for(p=*++A;n<127&&*p;)c[*p++]++,n++;
 for(;p=x[i++];u(p))if(g=k(p))(l[g]=*(l[g]?&l[g]->n:&h[g])=F++)->s=p;
 while(++m<128)S(127,n,0,h[127]);
 return a;}
","typedef unsigned char B;B*x[]={
#include ""dict.h""
0};typedef struct L{B*s;struct L*n;}L;
L*h[128],*l[128],*s[128],Z[sizeof x/sizeof*x],*F=Z;int c[256],m,a=1;
int k(B*q){int g=0;B*p=q;while(*p)g|=!c[*p++]--;return g-1&p-q;}
void u(B*p){while(*p)c[*p++]++;}
void S(int N,int r,int t,L*W){L*w;int i,n;
 for(n=r<N?r:N;n>0;n--)for(w=n==N?W:h[n];s[t]=w;u(w->s),w=w->n)if(k(w->s))
  if(n==r){if(t==m-1)for(i=a=0;i<=t;i++)printf(""%s%c"",s[i]->s,i<t?' ':'\n');}
  else if(t<m-1)S(n,r-n,t+1,s[t]=w);}
int main(int C,B**A){int i=0,g,n=0;B*p;while(--C)for(p=*++A;n<127&&*p;)c[*p++]++,n++;
 for(;p=x[i++];u(p))if(g=k(p))(l[g]=*(l[g]?&l[g]->n:&h[g])=F++)->s=p;
 while(++m<128)S(127,n,0,h[127]);
 return a;}
",";typedef char n;typedef n*m;int C;n c[11];n y[]={37,100,0};n b[2048];int i
;int A(void){return C=getchar();}int B(m s){return strlen(s)
;}n w[2048];typedef m defvar;m R(void){do A();while(isblank(C) || C == '\n')
;if(C<0) return 0;i=0;if(C==';'){for
(defvar q=
"";typedef char n;typedef n*m;int C;n c[11];n y[]={37,100,0};n b[2048];int iY;int A(void){return C=getchar();}int B(m s){return strlen(s)Y;}n w[2048];typedef m defvar;m R(void){do A();while(isblank(C) || C == '\n')Y;if(C<0) return 0;i=0;if(C==';'){forY(defvar q=Y~sY;C!='\n';A()Y);R();}else if(C=='('||C==')')b[i++]=C;else if(C==34)do b[i++]=CY;while(A()!=34);else do b[i++]=C;while(!isblank(A())&&C!='\n')Y;b[i] = 0;return b;}typedef defvar*format;m E(void){Y;m a=R();if(!a) return 0;if(*a==34)return aY;if(*a=='#'){c[0]=a[2]=='N'?'\n':a[2];return c;}if(*a=='q')return wY;if(*a=='('){a=R();if(*a=='d'){R();strcpy(w,E());R();return wY;}else if(*a=='f'){R();m f = strdup(E());*strchr(f,126)=37Y;m s=E();s[B(s)+1]=0;s[B(s)]=34;printf(f+1,s);R()Y;}else if(*a=='s'){n p=*E();n o=*E();m r=strdup(E());a=r;forY(format t ;*a;a++)*a=*a==o?p:*aY;R();return r;}else if(*a=='c'){c[0]=*E()-32/*Y(substitute #\Newline (char-upcase #\y ) q= )q= );*/Y;R();return c;}else{n z=*a;int d=atoi(E()),e=atoi(E())Y;sprintf(c,y,z-'+'?z-'-'?z-'*'?d/e:d*e:d-e:d+e);R();return cY;}}return a;}int main(void){while(C+1)E();return 0;}Y""
;C!='\n';A()
);R();}else if(C=='('||C==')')b[i++]=C;else if(C==34)do b[i++]=C
;while(A()!=34);else do b[i++]=C;while(!isblank(A())&&C!='\n')
;b[i] = 0;return b;}typedef defvar*format;m E(void){
;m a=R();if(!a) return 0;if(*a==34)return a
;if(*a=='#'){c[0]=a[2]=='N'?'\n':a[2];return c;}if(*a=='q')return w
;if(*a=='('){a=R();if(*a=='d'){R();strcpy(w,E());R();return w
;}else if(*a=='f'){R();m f = strdup(E());*strchr(f,126)=37
;m s=E();s[B(s)+1]=0;s[B(s)]=34;printf(f+1,s);R()
;}else if(*a=='s'){n p=*E();n o=*E();m r=strdup(E());a=r;for
(format t ;*a;a++)*a=*a==o?p:*a
;R();return r;}else if(*a=='c'){c[0]=*E()-32/*
(substitute #\Newline (char-upcase #\y ) q= )q= );*/
;R();return c;}else{n z=*a;int d=atoi(E()),e=atoi(E())
;sprintf(c,y,z-'+'?z-'-'?z-'*'?d/e:d*e:d-e:d+e);R();return c
;}}return a;}int main(void){while(C+1)E();return 0;}
","#define I int
#define c char *
#define G fscanf(f,
#define W while(
#define k return
#define Q if(
#define Z			512
#include <errno.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
FILE *f;
short w[4] = { 24, 80 };
I L, B, r, H;
c l[Z], b[Z], s[Z], S[Z][10], T[Z], h[Z];
I
e(c s)
{
	I n = 0;
	Q *s == '#')	
		k (I) strtol(s+1, 0, 0);
	W n < Z) {
		Q *S[n] && !strcmp(s, S[n]+1))
			k *S[n];
		n++;
	}
	k '?';
}
void
P(I x)
{
	Q x == '\n' || w[1] - 3 < B) {
		b[B] = 0;
		b[B+1] = 0;
		B = printf(""%s"", b);
		B = snprintf(
			b, Z,
			""\n   %s"", 
			b + B + 1
		);
		r++;
	}
	Q b[B-1] != ' ' || !isspace(x)) {
		b[B++] = isspace(x) ? ' ' : x;
		Q w[1] - 3 < B)
			*strrchr(b, ' ') = 0;
	}
}
void
p(c t, ...)
{
	va_list x;
	va_start(x, t);	
	vsnprintf(s, Z, t, x);
	t = s;
	W *t)
		P(*t++);
	va_end(x);
}
I
X(c s)
{
	I x;
	c t = s;
	long m = ftell(f);
	W *t && (x = fgetc(f)) != EOF) {
		Q *t == '*')
			s = t++;
		Q tolower(x) != *t) {
			Q *s != '*')
				break;
			t = s;
		}
		t++;
	}
	Q *t)
		fseek(f, m, SEEK_SET);
	k !*t;
}
void
d(c s)
{
	Q 4 < B)
		P('\n');
	P('\n');
	Q *s == 'h')
		B = 1;
}
void
a(c s)
{
	*T = 0;
	G 
		ungetc(fgetc(f), f) == '""' 
			? ""\""%511[^\""]"" 
			: ""'%511[^']"", 
		T
	);
	Q *s == 'a' || *s == 'f' || s[1] == 'f') {
		free(l[++L]);
		l[L] = strdup(T);
		p("" [%d] "", L);
	} 
	Q *s != 'a')
		p(""%s%s\n"", T, *s == 'b' || s[1] == 'h' ? """" : ""\n"");
	X(""*>"");
}
void *Y[] = {
	""!--*-->""	,	0	,
	""a *href=""	,	a	,	
	""ifr*src=""	,	a	,
	""fra*src=""	,	a	,
	""img*src=""	,	a	,		
	""p*>""		,	d	,	
	""bl*>""		,	d	,
	""br""		,	a	,
	""hr""		,	a	,
	""h*>""		,	d	,	
	""/h""		,	a	,
	""/tr""		,	a	,
	""/dt""		,	a	,
	""/dd""		,	a	,
	""li*>""		,	d	,	
	""*>""		,	0	,	
	0		,	0
};
I
main(I V, c *v)
{
	I x, n = 0;
	c t = v[1];
	ioctl(0, TIOCGWINSZ, w);
	f = fopen(""entities.txt"", ""r"");
	Q f) {
		W G ""%s %d"", S[n]+1, &x) == 2)
			*S[n++] = x;
		fclose(f);
		n = 0;
	}	
	W t) {
		I m = 0;
		struct hostent *y;
		struct sockaddr_in A;
		L = 0;
		B = 1;
		Q !sscanf(t, ""http://%255[^/]%n"", h, &n) && !*h) {
			Q !(f = fopen(t, ""rb"")))
				k 1;
			goto e;
		}
		Q 0 < sscanf(h, ""%*[^:]%n:%d"", &x, &H))
			h[x] = 0;
		else
			H = 80;
		y = gethostbyname(h);
		Q !y)
			k 1;
		memcpy(&A.sin_addr.s_addr, y->h_addr, y->h_length);
		A.sin_port = htons( (short) H);
		A.sin_family = y->h_addrtype;
		f = tmpfile();
		Q !f)
			k 1;
		W 
			connect(
				m = socket(
					A.sin_family, SOCK_STREAM, 0
				), (void *) &A, sizeof A
			)
			|| errno == EINTR
		)
			;
		n = snprintf(
			b, Z, 
			""GET %s%s HTTP/1.0\r\nHost: %s:%d\r\n\r\n"", 
			t[n] == '/' ? """" : ""/"", t+n, h, H
		);
		Q send(m, b, n, 0) == n) {
			W 0 < (n = recv(m, b, Z, 0)))
				fwrite(b, 1, n, f);
		}
		close(m);
		rewind(f);
		 X(""*\r\n\r\n"");
e:
		r = 3;
		*b = ' ';
		W r < *w && (x = fgetc(f)) != EOF) {
			Q x == '<') {
				void **p = Y;
				W *p) {
					Q X(*p)) {
						Q p[1])
							(* (void (*)(c ))
							p[1])(*p);
						break;
					}
					p += 2;
				}		
			} else {
				Q x == '&') {
					G ""%9[^;];"", T);
					x = e(T);
				}
				P(isspace(x) ? ' ' : x);
			}
		}
		printf(""\n? "");
		fflush(stdout);
		fgets(T, Z, stdin);
		Q *T == '\n')
			goto e;
		t = l[strtol(T, 0, 0)];
		fclose(f);
	}
	k 0;
}
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define H 20

#define X for
#define F(v,b) X(k = 0; k < 3; k++) v[k] = b;

typedef double R, V[3], U[4], (*J)(R);
typedef void Z;
typedef int _;

V o, d, v;
R (*q)[H][6], C[4*H][H][6], sr = 15, br = 25, A, s, t;
_ P, Q, g, S, k, e = 256, (*u)(_) = putchar, D[64];
J f = cos, Y = sin;
char B[256];

Z
T(_ *p, _ k, _ n)
{
	_ g;

	*p = n;

	X(g = 0; k && g < 4; g++)
		T(p + (9 & (g * 4|g))*(1<<k - 1), k - 1,
		  n + (1<<6-2 * k)*(4 - g&3));
}

Z
O(_ c)
{
	B[++S] = c,

	(S > e-2 || c==129) && (*B = S, S = fwrite(B, S+1, 1, stdout) - 1);
}





    
					                       Z N
					                  (R*v){R w=sqrt
					                (*v**v +1[v]*v[1]
					              +v[2]*2[v]);F(v,v[k]
					             /w)}Z         K(_ j){V
					             n,p            ;R*b=(*
					            q)              [j],w=f
					                             (A),x=
					                             Y(A);
					                             F(p,
					                           br*o[
						                 k]+sr
		      * (n[                  k]               =f(t)*k[v]+
		Y(t)*(v[(k+1)%3]*           d[(            k+2)%3]-v[(k+2)%
	     3]*d[(k+1)%3])))*b++=p[1      ]+e/                2,*b++=-*p*x+
	   p[2]*w-e*e,*b++=(*p*w+p[2]*x)+e/2;F(                    b,fabs(*n
	  *!!k+n[1]*(        k<2)+n[2])/sqrt(2+                      !(k-1)))
	}Z M(R*a,_                s,Z(*m)(_)){_                        i;R d=
       pow(25/log                   (36),4)/s/                         377;X(
     *a=i=0;i<s                      ;i++,*a+=d                        )m(i);
      }Z G(_ i                         ){R w=-Y                        (P*s),
     x=f(P*s),                          y=Y(Q*s                        ),z=f
     (Q*s);F(                            v,k[o]                       =(k<2
    )*(x+3)*(                            k?y:z)     -!(k-2          )*w)N(
    v);F(d,P*                             (k?k-    1?x:w*y:w*z   )+Q*(k?
    k-1?0:*o:-                            o[1])     )N(d),w=*d**v+d[1]
    *v[1]+d[2]                             *v[2       ];F(v,k[v]-w
    *d[k])N(v),q                           =&C[
    i],M(&t,H,K);                          }Z W
     (char*s){*s&&(                         W(s
     +1),u(*s-98*(*s>
      97)));}Z E(_ z){R
       *r,*a,*b;U*q,l,x,d
	,I[256];_ i,j,m,c,y,
	 w,h,Y=sizeof l;fputc(
	  46,stderr),M(&s,4*H,G),
	    W(""ibcbcbbbbb,""),g=130,
	     O(e/2);X(y=0;y<e;y++){X(i
		=e;i;)*(I[--i])=0;X(;i<4
		  *H*H;i++)X(*l=k=0;k-5;k++
		     ,a=b)if(b=C[(i/H+((k^k/
		       2)&1))%(4*H)][(i+(k/2&1
			 ))%H],k&&y<*a^y<*b){X(
			    h=0;h<4;h++)h[x]=a[h
			      +2]+(b[h+2]-a[h+2])
				*(y-*a)/(*b-*a),h?
				   *l&&(d[h]=(l[h]
     -h                             [x])/w):(w=1+
     fabs                            (*l-(*x=(_)*x)
     ) );                              X(q=I+(_)*x;
     *l&&                                w--;q+=2*(
     *x<*                                l)-1)X(**q
     >C[i                                /H][i%H][1
     ]&&(                                memcpy(*q,
     x,Y),*                              *q=C[i/H][
     i%H][1                              ]),h=1;h<
     4;h++)x                            [h]+=h[d];
     memcpy(l                           ,x,Y);}X(
     i=0;i<e;i++                        ,O(*r?c:
     127),g=g<e-1                    ?g+1:(O(e/
     2),130))X(r=&I[               i][3],c=0,j
     =2;j+1;j--,r--)k=3|!(    j-1)*4,m=*r*k+
     (63*( *r*k-(_)(*r*k))>D[(y*8&56)+(i&7)
     ]),        c<<=k/4+2,c|=(m|-(m>k))&
     k;}            O(129);u(0);}_
    
    
	
main(_ c, char **v)
{
	if (c < 3)
		return fprintf(stderr, ""Usage: %s P Q [F]\n"", *v), 1;

	P = atoi(v[1]),
	Q = atoi(v[2]),

	T(D, 3, 0);

	W(""bb\346cbcba98FIG"");

	X(; k < 384; k++)
		u(k / 3<<(""gdb""[k%3] - 97) | 31 | (k % 3!=1)<<5);

	W(""bbbce0.2EPACSTEN\x0b\xff!""),

	M(&A, c > 3 ? atoi(v[3]) : 40, E),

	u(59);
	
	return 0;
}

/* vi:set ts=8: */
","#include <stdio.h>
#include <string.h>
#include <curses.h>
#define P *p
#define E (s?s-1?s-2?
#define T (s=fgetc(g))
#define _ m[n&
#define L R(
#define b ):L
#define G ):(
#define r =t&
#define F _++k+O]
#define W t--?t--?
#define Y _ k--+O]=
#define M W W W W W W W
#define J *E&D:&V:&I:&C)
#define q C|Z|I|D|B|V|S|32
#define H E Z:C:V:S)&&(d+=P&l?P-O:P)
#define U(z,w)(t=w,d+=z,_ t]+_ t+1]*O)
int d,C,Z,I,D,B,V,S,i=49152
,t,s,o,h,z,O=256,n=65535,l=128,f=255,e,w; unsigned char*p,m[65536],a,x,y,k,*u,
*j="" ./  p/ 7 ] . 6 6 p     t7      r(0)1*+2,4WgcovGn^f_NVO>F?T\\swldiHZYI9QJ""
""RCKSL[b<D8AP:;a@`BXq3j=- HZYI9QJRCKSL[b<D8AP:;a@`BX   57  ;  ;      ;   ;   ""
""     ;                                                                      ""
""                                )<   <% ><%  <% '<   <% +<   <% 7$  ($A @$A ""
""($A &$   $A *$   $A C2   2; =2; 62; '2   2; +2   2; D#   #B ?#B 6#B &#   #B ""
""*#   #B  F  HFG 1 L HFG 'F  HFG NFM  F  :89 :89 J8I :89 &8  :89 +8K :89 .,  ""
"".,/ 5,0 .,/ ',   ,/ +,   ,/ -E  -E3 4E  -E3 &E   E3 *E   E3 2133024425660788""
; R(x){ Z=x?0:2; S=x&l; } K(x){ R(x-P); C=x<P?0:1; } A(){ R(t=F); C r 1; Z r 2
; I r 4; D r 8; B r 16; V r 64; } X( ){ Y d/O; Y d; } N( ){ X( ); Y q; I=4; d=

                      U(0,n-1); } main(int c,char*v[])
                     { FILE*g ; _ z]=time(0); g=fopen(
                     c>1?v[1]:"""", j+32); t=i; if(g) { ;
                    for(;                          T+1;
                    _ t++                          ]=s);
                   w r /* ### COMMODORE BASIC ###  */n ;
                   d=w?i:                          U(C, n
                  -3); /* READY.                   */z=c>
                  2?atoi(                          v[2])+1
                  :4; c=z                          ? n * z
                 / 4 : n;                          nodelay(
                 initscr(                          ), 1 ) ;
                 curs_set(I); cbreak(); noecho( ) ; for (; ;
                ) { o++ % ( c *4) ?h :( h= getch () ,h-ERR?(_
                      162]=h|l):0); if(!w){ s=(_ 59408]
           |=z?l:0)&15; _ 59410]=~(h-ERR?(s^8?0:j[h|l]&1)|(j[h]/8
          -5-s?0:1<<j[h]%8):0); } o%c|I||N(); p=m +O+O+ _ l-9]; t
          =d%65493; i=_ d++]; if(w+t<4){ if(P&&(u=strchr(++p,34)))
          { *u=0; _ l-9]=u-m+1; if(g=fopen(p,t?j+61:j+32)){ i=1025
         -t; if(!t){ T; for(T; T+1; _ i++]=s); for(p=m+42; p<m+47 ;
        ){ P++=i%O; P++=i/O; } } for(; t; fputc(_ i],g))t=_++i]?3:t
        -1; fclose(g); } } i=96; } t=j[i/2&14|i&1|O+O]&15; e=W W W W
       U(2,d)+(i-190?x:y):U(2,d)+y:f&_ d++]+(i-150&&i-182?x:y):U(1,_ d
      ])+y:U(2,d):_ d++]:d++:U(1,  _  d  ]  +  x  &  f  ):&a  -  m; p=e
     +m; s=i>>6; t=j[i+O]-35; M M  M  W  0  :  L  a  =  y G  k  =  x G L
    a=x)G L x  =  k  )  G L y=a)G   L  x  =  a  )  G  P  =y G P  =  x G P
   =a G t=a-P-1+C,C r O?0:1,V=((a^  P   )  &  (  a  ^  t )&l)/2   ,  L a r
  f)G d=F,d+=F*O+1 G A(),d=F,d|=F*O G t=P,L P=P/2|C*l),C r 1 G t=P,L P=P*2|
 C),C=t/l):A(b a=F G Y q G Y a G L a|=P)G C=P&1,L P/=2)G L y=P)b x=P b a=P G
 s=U(1,--d),X(),d=s G d=i&32?U(0,e):e b++y b++x b++P b a^=P b--y b--x b--P):
      K(y):K(x):K(a G J=0 G J=E 8:8:4:1)G d--,B=16,N() G L a&P),V=P&64
      ,S=P&l):!H:H:(C=P/l,L P*=2)b a&=P G t=a+P+C,C r O?1:0,V=(~(a^P)&

(a^t)&l)/2,L a r f)); t=e^O*O/2; if(t<1000){ s=P%l; i=A_REVERSE; P>s?attron(i)
:attroff(i); mvaddch(t/40,t%40,s+w<32?s+64:s>95+w?s-32:s); } } } perror(*v); }
","#include <stdio.h>
#include <string.h>
#include <curses.h>
#define P *p
#define E (s?s-1?s-2?
#define T (s=fgetc(g))
#define _ m[n&
#define L R(
#define b ):L
#define G ):(
#define r =t&
#define F _++k+O]
#define W t--?t--?
#define Y _ k--+O]=
#define M W W W W W W W
#define J *E &D:&V:&I:&C)
#define q C|Z|I|D|B|V|S|32
#define H E Z:C:V:S)&&(d+=P&l?P-O:P)
#define U(z,w)(t=w,d+=z,_ t]+_ t+1]*O)
int d,C,Z,I,D,B,V,S,i=49152
,t,s,o,h,z,O=256,n=65535,l=128,f=255,e,w; unsigned char*p,m[65536],a,x,y,k,*u,
*j="" ./  p/ 7 ] . 6 6 p     t7      r(0)1*+2,4WgcovGn^f_NVO>F?T\\swldiHZYI9QJ""
""RCKSL[b<D8AP:;a@`BXq3j=- HZYI9QJRCKSL[b<D8AP:;a@`BX   57  ;  ;      ;   ;   ""
""     ;                                                                      ""
""                                )<   <% ><%  <% '<   <% +<   <% 7$  ($A @$A ""
""($A &$   $A *$   $A C2   2; =2; 62; '2   2; +2   2; D#   #B ?#B 6#B &#   #B ""
""*#   #B  F  HFG 1 L HFG 'F  HFG NFM  F  :89 :89 J8I :89 &8  :89 +8K :89 .,  ""
"".,/ 5,0 .,/ ',   ,/ +,   ,/ -E  -E3 4E  -E3 &E   E3 *E   E3 2133024425660788""
; R(x){ Z=x?0:2; S=x&l; } K(x){ R(x-P); C=x<P?0:1; } A(){ R(t=F); C r 1; Z r 2
; I r 4; D r 8; B r 16; V r 64; } X( ){ Y d/O; Y d; } N( ){ X( ); Y q; I=4; d=

                      U(0,n-1); } main(int c,char*v[])
                     { FILE*g ; _ z]=time(0); g=fopen(
                     c>1?v[1]:"""", j+32); t=i; if(g) { ;
                    for(;                          T+1;
                    _ t++                          ]=s);
                   w r /* ### COMMODORE BASIC ###  */n ;
                   d=w?i:                          U(C, n
                  -3); /* READY.                   */z=c>
                  2?atoi(                          v[2])+1
                  :4; c=z                          ? n * z
                 / 4 : n;                          nodelay(
                 initscr(                          ), 1 ) ;
                 curs_set(I); cbreak(); noecho( ) ; for (; ;
                ) { o++ % ( c *4) ?h :( h= getch () ,h-ERR?(_
                      162]=h|l):0); if(!w){ s=(_ 59408]
           |=z?l:0)&15; _ 59410]=~(h-ERR?(s^8?0:j[h|l]&1)|(j[h]/8
          -5-s?0:1<<j[h]%8):0); } o%c|I||N(); p=m +O+O+ _ l-9]; t
          =d%65493; i=_ d++]; if(w+t<4){ if(P&&(u=strchr(++p,34)))
          { *u=0; _ l-9]=u-m+1; if(g=fopen(p,t?j+61:j+32)){ i=1025
         -t; if(!t){ T; for(T; T+1; _ i++]=s); for(p=m+42; p<m+47 ;
        ){ P++=i%O; P++=i/O; } } for(; t; fputc(_ i],g))t=_++i]?3:t
        -1; fclose(g); } } i=96; } t=j[i/2&14|i&1|O+O]&15; e=W W W W
       U(2,d)+(i-190?x:y):U(2,d)+y:f&_ d++]+(i-150&&i-182?x:y):U(1,_ d
      ])+y:U(2,d):_ d++]:d++:U(1,  _  d  ]  +  x  &  f  ):&a  -  m; p=e
     +m; s=i>>6; t=j[i+O]-35; M M  M  W  0  :  L  a  =  y G  k  =  x G L
    a=x)G L x  =  k  )  G L y=a)G   L  x  =  a  )  G  P  =y G P  =  x G P
   =a G t=a-P-1+C,C r O?0:1,V=((a^  P   )  &  (  a  ^  t )&l)/2   ,  L a r
  f)G d=F+F*O+1 G A(),d=F+F*O G t=P,L P=P/2|C*l),C r 1 G t=P,L P=P*2|C),C=t
 /l):A(b a=F G Y q G Y a G L a|=P)G C=P&1,L P/=2)G L y=P)b x=P b a=P G s=U(1
 ,--d),X(),d=s G d=i&32?U(0,e):e b++y b++x b++P b a^=P b--y b--x b--P):K(y):
      K(x):K(a G J=0 G J=E 8:8:4:1)G d--,B=16,N() G L a&P),V=P&64,S=P&
      l):!H:H:(C=P/l,L P*=2)b a&=P G t=a+P+C,C r O?1:0,V=(~(a^P)&(a^t)

&l)/2, L a r f)); t=e^O*O/2; if (t<1000) { s=P%l; i=A_REVERSE; P>s ? attron(i)
:attroff(i); mvaddch(t/40,t%40,s+w<32?s+64:s>95+w?s-32:s); } } } perror(*v); }
","#include <stdio.h>
#define _ main(
#define _l ___l ___l ___l ___l ___)
#define __l int
#define ___l ___)*(
#define ____l (_l],
#define ____ 1
#define ___ __+_____
#define __ ____+____
#define _____ __+____
#define ______1 *(l__
#define _____1 *__1%(__
#define ____1 )?(
#define ___1 _1&(__
__l __I[____l _I[____l*l__=_I,*l_=__I;__l _ __l _1,__l*__1){__l _l_;
return ___1+ __ ____1 ___1 ____1*__1 = getchar()):__ ____1*__1<____?
____:_____1+___ ____1 _____1+_____ ____1 _____1+____)____1 ___1+___+
____ ____1 _____1 +__)____1 _____1 )____1 *l__)++:_____1+____)-____?
______1 ++) :_____1+_____) -____?__:printf(""%d\n"",*l__):_____1+____+
___ ____1 *l__) =*(l_++ ):__:___l ____- ____):_____1 +_____)-3?__-2:
____:(___1+____+___ ____1 _____1)____1*l__)-- :_____1+__)?__:______1
--):___l 0))?__:_ _1,__1+____)+____:(___1+____+___ )) &&* l__?_ ___1
+___+___+__),__1+____)?_ ___1+11 )|(___1)?____:__- 2),__1):____-1 :(
_l_=_ ___1 -____+___l ____),__1+____ )) ?_l_+_ ___1 )?_1 :___1+10)|(
___1-____ ____1 __):0),__1+_l_):0):__:_1%(__ ____1 _1/(__)) ?_ scanf
(""%i"",__1 ____1 _____):(___l _____)-____,__1 +____):_ _____,l_):__;}
","#define    F getchar())
 #define H(z)*n++=z;
       #include        <setjmp.h>
    #define v main(0,0,0
           #define Z while(
                                                 #define _ if(
#define o(d) (u[l]=0,l[d]=6^e,q=1e4>v,0),l[d]=0,u[l]=e^6,q)
#define I(H,n) { _ r=l[x=H],!r|(r^e)<-1){ _ j=u[l],-7==r|6==r\
){ n; e=~e; return 1e5- f; } u[l]=0,t=j+1,i=j-1; _!i&89<x)i\
=j,t=6; _-1==t&30>x)t=j,i=-7; Z++i<t){ b=S; d=0; S&=63; \
a=((j^e)!=1?6!=(j^e)?O[32+x/10]-O[u/10+32]-q:(S|=6!=j?8\
:1,2==u-x)*9+9*(x-u==2):(d=1==j?x-u:u-x)/8+!(!((x-u)%\
10)|r)*99+(j==1?90<x:29>x)*(9*O[28+i]-288))+O[r+28\
]*9-288+O[x%10+33]-f-O[33+u%10]; x[l]=i; S|=(21=\
=u|21==x)*2+(u==28|28==x)*4+(91==u|x==91)*16+32\
*(u==98|x==98)+(20==d)*64*x; a-=k>f?main(a,f+1\
,M,k):0; _ i==c&u==h&!f&N&a>-1e4&x==y)longjm\
p(z,1); S=b; _!N|f&&(a>M||!f&a==M&&1&rand()\
)){ _!f){ _ k){ c=i; h=u; y=x; } } else _ \
L-a<N){ n; e=~e; u[l]=j; x[l]=r; return\
 a; } M=a; } } x[l]=r; u[l]=j; n; } }
typedef int G; char J [ 78 ], O [ ]
=   ""HRQAMS#-smaqrh[UTZYTU[|TBA(""
""$#(ABT|ba`gg`ab8>GK[_`fFDZXEYR""         ""L\t####""
""##B#A#@#G#F#E#D#K\t\3Zlv#tjm""         ""\3J#tjm\3Pwb""
""ofnbwf\3Joofdbo\3)&`&`.&`&`""         ""#+&g*\t""; G y,
c,h,e,S,*s,l[149]; jmp_buf z         ; G main(G L,G f,
G N,G k){ G u=99,p,q,r,j,i,x         ,t, a, b,d,M=-1e9
; char *n; if( *l){ e=~e; Z       u >21){ q= l[--u]^e;
_!-- q){ _!l[p=e?u-10:u+10]){   I(p,)_ e?u>80   & !l[p
-=10]:u<39&!l[p+=10])I(p,)} _ l[p=e?u-11:9+u]   )I(p,)
else _ u-1==S>>6){ l[u-1]=0; I(p,l[u-1]=-2^e);  } _ l[
p=e?u-9:11+u])I(p,)else _ S>>6==1+u){ l[1+u]=0; I(p,l
[1+u]=e^-2); } } _!--q){ n=O+41; Z++n<50+O)I(u+80-*n,
)} _ 0<q&4>q){  n=q==2?53+O:O+49; Z++n<O+(q!=1)*4+54
){ p=u; do I(p-=*n-80,)Z!p[l]); } } _ 4==q){ n=49+O
 ; Z++n<O+58)I(u-*n+80,)_ e&!(S&24)|!e&!(S&3)&&k&&
 !l[u-2]&!l[u-1]&!l[u-3]&&o(u)&o(u-1)){ l[u-1]= 4
  ^e; l[u-4]=0; I(u-2,l[u-1]=0; l[u-4]=e^4); } _
  e&!(S&40)|!e&!(S&5)&&k&&!l[u+1]&!l[2+u]&&o(u)&
   o(1+u)){ l[u+1]=e^4; l[3+u]=0;   I(u+2,l[1+u
   ]=0; l[u+3]=4^e); } } } e=~e;   return M; }
    Z h<130){l[h]=-(21>h|98<h|2       >(h+1 )%
    10); O[h++]^=3; } n=O +14;       s=20+l; Z
     ++s<29+l){ 10[s]=1; 70[s]=~    ( * s = *
      n++ -+84); 60 [ s] =-2; } Z  n=J){ puts
       (58+O); u=19; Z++u<100){ H(32)_!( u%10
       ))H(32)H(O[7+l[u]])_(9+u)%10>7){ H(58
        -u/10)H(32)_ u&1)puts(n=J); } } puts
         (O+58); _-1e4 >v , 1)){ e=~e; puts
          (O+(v,0)> 1e4?e?90:82:96)); break
           ; } _ 1<L&e) { d=v,2+L); printf
            (O+114,h%10+64,58-h/10,y%10+64
             ,58 -y/10,d); } else{ putchar
              (62 ) ; h= (95 & F-44; c=l[h
                +=(56-F *10]; y=(95&F-44; y
                   +=(56-F*10; Z 10!=(u=(95
                    &F)){ c=5; Z--c>1&&u!=c
                      [O]); c=e^c-7; } } _!
                         setjmp(z)){ v+1,1);
                               puts(   106+
                                O); }   } Z
                                 10!=
                                  F; }
","#define    F getchar())
 #define H(z)*n++=z;
       #include        <setjmp.h>
    #define v main(0,0,0
           #define Z while(
                                                 #define _ if(
#define o(d)(S=63,l[d]=6^e,q=1e4>v,u[l]=0),l[d]=0,u[l]=e^6,S=b,q)
#define I(H,n) { _ r=l[x=H],!r|(r^e)<-1){ _ j=u[l],-7==r|6==r\
){ n; e=~e; return 1e5-443*f; } u[l]=0,t=j+1,i=j-1; _!i&89<\
x)i=j,t=6; _-1==t&30>x)t=j,i=-7; Z++i<t){ d =0; S&= 63; \
a=((j^e)!=1?6!=(j^e)?O[32+x/10]-O[u/10+32]-q:(S|=6!=j?8\
:1,2==u-x)*9+9*(x-u==2):(d=1==j?x-u:u-x)/8+!(!((x-u)%\
10)|r)*99+(j==1?90<x:29>x)*(9*O[28+i]-288))+O[r+28\
]*9-288+O[x%10+33]-f-O[33+u%10]; x[l]=i; S|=(21=\
=u|21==x)*2+(u==28|28==x)*4+(91==u|x==91)*16+32\
*(u==98|x==98)+(20==d)*64*x; a-=k>f?main(a,f+1\
,M,k):0; _ i==c&u==h&!f&N&a>-1e4&x==y)longjm\
p(z,1); S=b; _!N|f&&(a>M||!f&a==M&&1&rand()\
)){ _!f){ _ k){ c=i; h=u; y=x; } } else _ \
L-a<N){ n; e=~e; u[l]=j; x[l]=r; return\
 a; } M=a; } } x[l]=r; u[l]=j; n; } }
typedef int G; char J [ 78 ], O [ ]
=   ""HRQAMS#-smaqrh[UTZYTU[|TBA(""
""$#(ABT|ba`gg`ab8>GK[_`fFDZXEYR""         ""L\t####""
""##B#A#@#G#F#E#D#K\t\3Zlv#tjm""         ""\3J#tjm\3Pwb""
""ofnbwf\3Joofdbo\3)&`&`.&`&`""         ""#+&g*\t""; G y,
c,h,e,S,*s,l[149]; jmp_buf z         ; G main(G L,G f,
G N,G k){ G u=99,p,q,r,j,i,x         ,t,a,b=S,d,M=-1e9
; char *n; if( *l){ e=~e; Z       u >21){ q= l[--u]^e;
_!-- q){ _!l[p=e?u-10:u+10]){   I(p,)_ e?u>80   & !l[p
-=10]:u<39&!l[p+=10])I(p,)} _ l[p=e?u-11:9+u]   )I(p,)
else _ u-1==S>>6){ l[u-1]=0; I(p,l[u-1]=-2^e);  } _ l[
p=e?u-9:11+u])I(p,)else _ S>>6==1+u){ l[1+u]=0; I(p,l
[1+u]=e^-2); } } _!--q){ n=O+41; Z++n<50+O)I(u+80-*n,
)} _ 0<q&4>q){  n=q==2?53+O:O+49; Z++n<O+(q!=1)*4+54
){ p=u; do I(p-=*n-80,)Z!p[l]); } } _ 4==q){ n=49+O
 ; Z++n<O+58)I(u-*n+80,)_ e&!(S&24)|!e&!(S&3)   &&
 !l[u-2]&!l[u-1]&!l[u-3]&&o(u)&o(u-1)){ l[u-1]= 4
  ^e; l[u-4]=0; I(u-2,l[u-1]=0; l[u-4]=e^4); } _
  e&!(S&40)|!e&!(S&5)   &&!l[u+1]&!l[2+u]&&o(u)&
   o(1+u)){ l[u+1]=e^4; l[3+u]=0;   I(u+2,l[1+u
   ]=0; l[u+3]=4^e); } } } e=~e;   return M; }
    Z h<130){l[h]=-(21>h|98<h|2       >(h+1 )%
    10); O[h++]^=3; } n=O +14;       s=20+l; Z
     ++s<29+l){ 10[s]=1; 70[s]=~    ( * s = *
      n++ -+84); 60 [ s] =-2; } Z  n=J){ puts
       (58+O); u=19; Z++u<100){ H(32)_!( u%10
       ))H(32)H(O[7+l[u]])_(9+u)%10>7){ H(58
        -u/10)H(32)_ u&1)puts(n=J); } } puts
         (O+58); _-1e4 >v , 1)){ e=~e; puts
          (O+(v,0)> 1e4?e?90:82:96)); break
           ; } _ 1<L&e) { d=v,2+L); printf
            (O+114,h%10+64,58-h/10,y%10+64
             ,58 -y/10,d); } else{ putchar
              (62 ) ; h= (95 & F-44; c=l[h
                +=(56-F *10]; y=(95&F-44; y
                   +=(56-F*10; Z 10!=(u=(95
                    &F)){ c=5; Z--c>1&&u!=c
                      [O]); c=e^c-7; } } _!
                         setjmp(z)){ v+1,1);
                               puts(   106+
                                O); }   } Z
                                 10!=
                                  F; }
","#define    F getchar())
 #define H(z)*n++=z;
       #include        <setjmp.h>
    #define v main(0,0,0
           #define Z while(
                                                 #define _ if(
#define o(d)(S=63,u[l]=0,l[d]=6^e,q=1e4>v,0),l[d]=0,u[l]=e^6,S=b,q)
#define I(H,n) { _ r=l[x=H],!r|(r^e)<-1){ _ j=u[l],-7==r|6==r\
){ n; e=~e; return 1e5-443*f; } u[l]=0,t=j+1,i=j-1; _!i&89<\
x)i=j,t=6; _-1==t&30>x)t=j,i=-7; Z++i<t){ d =0; S&= 63; \
a=((j^e)!=1?6!=(j^e)?O[32+x/10]-O[u/10+32]-q:(S|=6!=j?8\
:1,2==u-x)*9+9*(x-u==2):(d=1==j?x-u:u-x)/8+!(!((x-u)%\
10)|r)*99+(j==1?90<x:29>x)*(9*O[28+i]-288))+O[r+28\
]*9-288+O[x%10+33]-f-O[33+u%10]; x[l]=i; S|=(21=\
=u|21==x)*2+(u==28|28==x)*4+(91==u|x==91)*16+32\
*(u==98|x==98)+(20==d)*64*x; a-=k>f?main(a,f+1\
,M,k):0; _ i==c&u==h&!f&N&a>-1e4&x==y)longjm\
p(z,1); S=b; _!N|f&&(a>M||!f&a==M&&1&rand()\
)){ _!f){ _ k){ c=i; h=u; y=x; } } else _ \
L-a<N){ n; e=~e; u[l]=j; x[l]=r; return\
 a; } M=a; } } x[l]=r; u[l]=j; n; } }
typedef int G; char J [ 78 ], O [ ]
=   ""HRQAMS#-smaqrh[UTZYTU[|TBA(""
""$#(ABT|ba`gg`ab8>GK[_`fFDZXEYR""         ""L\t####""
""##B#A#@#G#F#E#D#K\t\3Zlv#tjm""         ""\3J#tjm\3Pwb""
""ofnbwf\3Joofdbo\3)&`&`.&`&`""         ""#+&g*\t""; G y,
c,h,e,S,*s,l[149]; jmp_buf z         ; G main(G L,G f,
G N,G k){ G u=99,p,q,r,j,i,x         ,t,a,b=S,d,M=-1e9
; char *n; if( *l){ e=~e; Z       u >21){ q= l[--u]^e;
_!-- q){ _!l[p=e?u-10:u+10]){   I(p,)_ e?u>80   & !l[p
-=10]:u<39&!l[p+=10])I(p,)} _ l[p=e?u-11:9+u]   )I(p,)
else _ u-1==S>>6){ l[u-1]=0; I(p,l[u-1]=-2^e);  } _ l[
p=e?u-9:11+u])I(p,)else _ S>>6==1+u){ l[1+u]=0; I(p,l
[1+u]=e^-2); } } _!--q){ n=O+41; Z++n<50+O)I(u+80-*n,
)} _ 0<q&4>q){  n=q==2?53+O:O+49; Z++n<O+(q!=1)*4+54
){ p=u; do I(p-=*n-80,)Z!p[l]); } } _ 4==q){ n=49+O
 ; Z++n<O+58)I(u-*n+80,)_ e&!(S&24)|!e&!(S&3)   &&
 !l[u-2]&!l[u-1]&!l[u-3]&&o(u)&&o(u-1)){ l[u-1]=4
  ^e; l[u-4]=0; I(u-2,l[u-1]=0; l[u-4]=e^4); } _
  e&!(S&40)|!e&!(S&5)  &&!l[u+1]&!l[2+u]&&o(u)&&
   o(1+u)){ l[u+1]=e^4; l[3+u]=0;   I(u+2,l[1+u
   ]=0; l[u+3]=4^e); } } } e=~e;   return M; }
    Z h<130){l[h]=-(21>h|98<h|2       >(h+1 )%
    10); O[h++]^=3; } n=O +14;       s=20+l; Z
     ++s<29+l){ 10[s]=1; 70[s]=~    ( * s = *
      n++ -+84); 60 [ s] =-2; } Z  n=J){ puts
       (58+O); u=19; Z++u<100){ H(32)_!( u%10
       ))H(32)H(O[7+l[u]])_(9+u)%10>7){ H(58
        -u/10)H(32)_ u&1)puts(n=J); } } puts
         (O+58); _-1e4 >v , 1)){ e=~e; puts
          (O+(v,0)> 1e4?e?90:82:96)); break
           ; } _ 1<L&e) { d=v,2+L); printf
            (O+114,h%10+64,58-h/10,y%10+64
             ,58 -y/10,d); } else{ putchar
              (62+e); h= (95 & F-44; c=l[h
                +=(56-F *10]; y=(95&F-44; y
                   +=(56-F*10; Z 10!=(u=(95
                    &F)){ c=5; Z--c>1&&u!=c
                      [O]); c=e^c-7; } } _!
                         setjmp(z)){ v+1,1);
                               puts(   106+
                                O); }   } Z
                                 10!=
                                  F; }
","#include<math.h>
#include<stdio.h>
#include<stdlib.h>
#include<sys/time.h>
#include<X11/Xlib.h>
#include<X11/keysym.h>
Window L;
GC N;
Display *K;
XEvent O;
XImage *Q;
float w, x, y[7 << 16];
struct timeval S, U;
int a, b, c, d =
  92, e, f, g, h, i, j, k, l, m, n, o, p, *q[96], r[7 << 16], s[96], *t,
  *u = r, *v, P = 256, R[64], T, J = 12288;
struct
{
  int a, b, c, d, e;
} A[9999], *B, *G, *H;
unsigned char C, D[9999], *E = D, F[] = "" .bmp"";
FILE *I;

#define Q(o,X,Y,C)B->b=b+32*o,B->c=c+32*X,B->d=Y,B->e=C,B++->a=l,
#define D(o,X)(int)((X*(B->b-e)-o*(B->c-f))/(x*B->e-w*B->d))

int
main (int X, char **Y)
{
  for (j = J << 8, x = y[i], w = y[i + 32], B = A; k = D (x, w), B->b;
       k >> 8 ? 0 : (l = D (B->d, B->e), l > 0
		     && l < j) ? j = l, h = k, g = B->a : 0, B++);
  for (;
       X
       && (p =
	   1 | 3 * (o = (--X < 2 || 119 - 1[Y[1]] ? 320 : atoi (2[Y]))) / 4);)
    {
      for (e = f = J / 2, K = XOpenDisplay (0); m < o << 8;
	   y[m] =
	   sin ((m & 255) / 20.4 + asin ((m / P - o / 2) / 3.2 / o)),
	   D[m & 511] = 10 + d * !(1 & (m >> 3 & m)), r[m++] =
	   m / 18 << (16 & (m >> 6 ^ m)));
      for (N =
	   XCreateGC (K, L =
		      XCreateSimpleWindow (K, RootWindow (K, 0), 0, 0, o, p,
					   0, 0, 0), 0, 0), ((I =
							      fopen (X ?
								     Y[X]
								     : """",
								     ""r"")) ?
							     fread (E + 1,
								    1,
								    1 << 15,
								    I),
							     fclose (I) :
							     0), B = G =
	   A + J / 3; *++E; f = l == 32 ? e = b + 99, c + 99 : f)
	for (l = *E - 10, *F = *E, k = !l, b *= !k, c += P * k, b += P;
	     l > 54 && l < 96
	     && (Q (0, 0, 1, 0) Q (8, 0, 0, 1) Q (8, 8, -1, 0)
		 Q (0, 8, 0, -1)
		 ! q[l] && (s[l] = 1, q[l] = u, I = fopen (F, ""r""))); l = J)
	  for (q[l] = ++u + 19, m = 2;
	       n = (m++ % 3 ? n : 0 ** ++u) >> 8 | C << 16, *u =
	       n, 0 < fread (&C, 1, 1, I)
	       || (m /= J, s[l] = m ? m : 1) * fclose (I););
      for (XMapWindow (K, L),
	   XSelectInput (K, L, KeyPressMask | KeyReleaseMask), H = A; G->b;
	   *H = *G++, H += !B->b)
	for (B = A + J / 3;
	     B->b && !(B != G && B->b == G->b - 128 * (B->d - G->d)
		       && B->c == G->c - 128 * (B->e - G->e)); B++);
      for (Q =
	   XCreateImage (K, DefaultVisual (K, 0), DefaultDepth (K, 0),
			 ZPixmap, 0, (char *) (v =
					       malloc (4 * o * p)), o, p,
			 32, 0);
	   d = (d + R[19] - R[17]) & 127, n = R[18] - R[20], n ? (i =
								  o * 128 +
								  d + (n <
								       0) *
								  64, main (0,
									    Y)
								  >
								  200) ? e +=
	   (int) (y[i] * 64), f += (int) (y[i + 32] * 64) : 1 : 1;
	   XSync (K, 0), gettimeofday (&S, 0), m = T - S.tv_usec)
	{
	  for (T -=
	       (m > 0
		&& m < J * 4 ? U.tv_usec =
		m, select (0, 0, 0, 0, &U) : m) - 4 * J, a =
	       a + 1 & -1 >> 1, m = 0;
	       k =
	       1 +
	       (int) (p * 512 /
		      ((i = m * P + d, g = n =
			0, main (0, Y)) * y[m * P + 32])), m < o; m++)
	    for (t = g ? c =
		 64 * s[g], q[g] + h / 4 + 64 * (a / 3 % s[g]) : t;
		 l = 32 - (17 << (k < 2)) * (2 * n - p) / k, n < p;
		 v[m + o * n++] = l >> 6 ? 4477904 << (l < 0) : t[c * l]);
	  for (XPutImage (K, L, N, Q, 0, 0, 0, 0, o, p); XPending (K);
	       R[63 & XLookupKeysym (&O.xkey, 0 & XNextEvent (K, &O))] ^=
	       O.type == KeyPress || O.type == KeyRelease);
	}
    }
  return j;
}
","#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <GL/glx.h>
#include <GL/glu.h>
#define E(x) { printf(""%i\n"",x); goto l; }
#define G fgetc(F)
#define H glEnable(
#define I glMaterialfv(GL_FRONT,
#define J glMatrixMode(
#define L (y
#define M 640,480
#define N NULL
#define O GL_DIFFUSE , i
#define P glCallList(u);
#define T glTexCoord2i
#define U glLightfv(GL_LIGHT0,
#define V R(); glVertex3i(c,m,n);
#define X GL_TEXTURE_2D
#define Z(x) G; x=G; x=x<50-(x==59); 

void Y()
{ { { { { { { { { { { { { { { {
                               
  { {     { { {   { { {   { { {
      {   {   {   {   {   {    
  { {     {   {   {   {     { {
  {       {   {   {   {       {
  { { {   { { ;   { } }   } } }
                               
                               
  }   } } }     }     }     }  
  }   }   }   }     }     }    
  }   }   }   }     }     }    
  }   }   }   }     }     }    
  }   } } }     }     }     }  
                               
} } } } } } } } } } } } } } } }

void Q()
{ { ; { { { {   {     {   { {
  { {     {         {     { {
{   { {   { {               {
; { { } } } } }   }     }   }
} ; }   } }   }   } }   } } }
} }     }         }     } }   



		 FILE *F; int u,t,l,m,n,x=0,a=0,b[]={ GLX_DOUBLEBUFFER,
	       GLX_RGBA , GLX_DEPTH_SIZE , 16, None},o,n,c ; void R() {
	     Z(c); Z(m); Z(n); } int main( int _, char **A) { char   f[
	  BUFSIZ ] ;  GLXContext r  ; XVisualInfo * v ; Display     *y; 
	XEvent e ; GLfloat g=0, h=10, i[ ]= { 1,1, 1, 1, 5,5,       100
     ,0, .6, .6, .6 ,1 } ; XSetWindowAttributes s; GLubyte          j[1
   <<10] ; Window w; if(! L= XOpenDisplay ( N ) ) ) E(1)            ;if
								    ( !
glXQueryExtension L , N , N ) ) E (2); v=glXChooseVisual            L ,
DefaultScreen (y ) , b  ) ; s.colormap = XCreateColormap            L ,
RootWindow (y,v -> screen), v -> visual, AllocNone ); if            (!(
r= glXCreateContext L, v, N, 1) ) ) E (3) ; strcpy(f, *A            ) ;  
s.event_mask=KeyPressMask; strcat(f,"".c""); F=fopen(f,""r""            ) ; 
w= XCreateWindow L, RootWindow( y, v -> screen ), M , M,            0,v
->depth,InputOutput, v->visual , CWColormap|CWEventMask,            &s)
;glXMakeCurrent L , w , r ); H GL_DEPTH_TEST ); if ( ! F            )E(
4 ) ; glShadeModel ( GL_SMOOTH ) ; while ( a != 89 ) a =            G ; 
G; G ; glGenTextures( 1, & t ); while ( x< 1024 ) { G; a            =G;
j[ x++ ] = 128; j[ x++ ] = 128 & - ( a<33 ); j [ x ]= j[            x-1
]; x++; j[x++] =-1;} glBindTexture(X,t); glTexParameteri            (X,
GL_TEXTURE_MIN_FILTER , GL_NEAREST ) ;   glTexImage2D( X	    ,0,
GL_RGBA, 16 ,  16 , 0 ,  GL_RGBA, GL_UNSIGNED_BYTE , j ) 	    ; J 
GL_PROJECTION ) ; gluPerspective( 60 , 1.333 , 1 ,  100)    	    ; J 
GL_MODELVIEW); u=glGenLists(1); glNewList(u,GL_COMPILE);	    H X
) ; while ( a != 81 ) a = G ; G ; G ; for (x=0; x<6; x++	    ) {
glBegin(GL_QUADS); R(); glNormal3f( c, m,n); T(1,1); V T            (1,
0  )  ;  V  T (  0  , 0 ) ; V T( 0 , 1 ) ;  V  glEnd ( )	    ; } 
glEndList( ) ; XMapWindow L , w ) ; c = 0; for ( ; ; ) {	    if( 
XPending L ) ) { XNextEvent L , &e ) ; if((XLookupKeysym	    ( (
XKeyEvent *)&e,0))&1<<5){ h=10; i[c]=!i[c]; c++; c&=3; }           else        
E(0)} glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT          ) ;  
glLoadIdentity(); gluLookAt ( -2 ,0 ,5 ,0,0 ,0,0 ,0 ,1 )        ; H 
GL_LIGHTING); H GL_LIGHT0 ); U GL_POSITION, i + 4); U O)      ; U 
GL_SPECULAR,i); glLightModelfv( GL_LIGHT_MODEL_AMBIENT,i    +8)
; I GL_AMBIENT, i+8); I O + 8 ) ; glRotatef( g, 1, 1, 1)  ; P 
glTranslatef(-h,0,0); P usleep (4000); g+=.07*x; if (g>360) 
g-=360.0; h-=x /100.0; glFlush(); glXSwapBuffers L ,w);} 

l: 
return 0; 
}
","#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <GL/glx.h>
#include <GL/glu.h>
#define E(x) { printf(""%i\n"",x); goto l; }
#define G fgetc(F)
#define H glEnable(
#define I glMaterialfv(GL_FRONT,
#define J glMatrixMode(
#define L (y
#define N NULL
#define O GL_DIFFUSE , i
#define P glCallList(u);
#define T glTexCoord2i
#define U glLightfv(GL_LIGHT0,
#define V R(); glVertex3i(c,m,n);
#define X GL_TEXTURE_2D

void Y()
{ { { { { { { { { { { { { { { {
                               
  { {     { { {   { { {   { { {
      {   {   {   {   {   {    
  { {     {   {   {   {     { {
  {       {   {   {   {       {
  { { {   { { ;   { } }   } } }
                               
                               
  }   } } }     }     }     }  
  }   }   }   }     }     }    
  }   }   }   }     }     }    
  }   }   }   }     }     }    
  }   } } }     }     }     }  
                               
} } } } } } } } } } } } } } } }

void Q()
{ { ; { { { {   {     {   { {
  { {     {         {     { {
{   { {   { {               {
; { { } } } } }   }     }   }
} ; }   } }   }   } }   } } }
} }     }         }     } }   



                 FILE* F; void Z (int* x) { G; *x=G; *x=*x<50- (*x==59); }
	       int u,t,l,m,n,x=0, a=0,b[]={ GLX_DOUBLEBUFFER, GLX_RGBA   ,
	     GLX_DEPTH_SIZE,16, None},o,n,c; void R() { Z(&c); Z(&m     );
	  Z(&n ) ; } int main( int _, char **A) { char f [BUFSIZ       ] ;
	GLXContext r; XVisualInfo* v ; Display *y; GLfloat g=0         ,h=
     10, i[]= { 1,1, 1,1, 5,5, 100, 0, .6,.6,.6,1 } ; XEvent           e ;
   XSetWindowAttributes s; GLubyte j[ 1<<10] ; Window w,u;             if(
	                                                               ! L
=XOpenDisplay ( N ) ) ) E( 1 ) ; if ( ! glXQueryExtension              L,N
,N ) ) E( 2 ) ; v =  glXChooseVisual L , DefaultScreen (y              ),b
); s. colormap = XCreateColormap L , u = RootWindow ( y ,              v->
screen),v->visual, AllocNone ); if ( !(r=glXCreateContext              L,v
,N , 1 ) ) ) E ( 3 ) ; strcpy (f , * A) ; strcat (f, "".c""              ) ;
F =  fopen ( f ,  ""r"" ) ; s . event_mask = KeyPressMask ;              w =
XCreateWindow L,u, 0,0,640, 480,0,v -> depth, InputOutput              , v
-> visual , CWBorderPixel  | CWColormap  | CWEventMask ,&              s);
glXMakeCurrent L , w , r ) ; H GL_DEPTH_TEST ) ; if ( ! F              )E(
4 ) ; glShadeModel ( GL_SMOOTH ) ; while ( a  != 89 ) a =              G ;
G; G ; glGenTextures( 1, & t ) ; while ( x< 1024 ) { G; a              =G;
j[ x++ ] = 128; j[ x++ ] = 128 & - ( a<33 ); j [ x ]= j [              x-1
]; x++; j[x++] = -1;} glBindTexture(X,t); glTexParameteri              (X,
GL_TEXTURE_MIN_FILTER , GL_NEAREST ) ;   glTexImage2D ( X	       ,0,
GL_RGBA, 16 ,  16 , 0 ,  GL_RGBA,  GL_UNSIGNED_BYTE , j ) 	       ; J
GL_PROJECTION ) ; gluPerspective ( 60 , 1.333 , 1 ,  100)    	       ; J
GL_MODELVIEW); u=glGenLists(1); glNewList (u,GL_COMPILE);	       H X
); while(a!=81)a=G; G;G;for(x=0;x<6;x++){glBegin(GL_QUADS              ) ;
R(); glNormal3f(c,m,n); T(1,1); V T(1,0); V T(0,0); V T(0              ,1)
; V glEnd(); } glEndList(); XMapWindow L, w) ; c=0; for(;              ; ) 
{ if (XPending L)){ XNextEvent L, &e); if ((XLookupKeysym              ( (
XKeyEvent *)&e,0))&1<<5){ h=10; i[c] =!i[c]; c++; c&=3; }             else 
E(0) } glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT            ) ;
glLoadIdentity (); gluLookAt ( -2 ,0 ,5 ,0,0 ,0,0 ,0 ,1 )          ; H
GL_LIGHTING); H GL_LIGHT0 ); U GL_POSITION, i + 4 ); U O)        ; U
GL_SPECULAR, i); glLightModelfv( GL_LIGHT_MODEL_AMBIENT,i      +8)
; I GL_AMBIENT, i+8 ); I O + 8 ) ; glRotatef( g, 1, 1, 1)    ; P
glTranslatef (-h,0,0); P usleep (4000); g+=.07*x; if (g >  360)
g-=360.0; h-=x / 100.0; glFlush () ; glXSwapBuffers L, w); }

l:
return 0;
}
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define PI 314
#define Z if
#define P a->b
#define Q else
#define W =f();
#define X char
#define J while
#define N return
#define V struct e

#define  g(_,a)((_&&a)?!strcmp(_,a):0)
typedef V*d; V{ d o,_; X*b; int c; };
d f() { d _=(d)malloc(sizeof(V)); _
->b=0; _->o=_->_=0; _->c=1>>1>1;
N _; } d k,l,m,n,o,p,q,r; d j
() { d _=l; d a W a->o W
l->o=a; l W l-> _=_;
N a; } d u(d _,
X*a){ J(_){
Z(g(a,_
->b)
){
 N
_;
} _=
_->_; }
N 0; } d s
(X*q){ d _=n; Z
(g(""q"", q)){ N o; }  
J(PI){ _=u(_,""cde""); _=_
-> _ ; Z ( g (q, _->b) ){ N _
->_ ; } } } void t(d a, d _) { d 
  S,I,M,U,L,A,T,O,R  ; Z(a==o){ S W
S->o W m->o=S; I=m; m W m->_=I; _=_->
_; J(_) { S->o->o=_->o; I=S->o; S->o W
S->o->_=I; _->o->o->o=S; I=_->o->o; _
->o->o  W _->o->o->_=I; _=_->_; } } 
Q { M W _=_->_; J(57-*P){ U=M; U
->b=P; U->o=_->o; M W M->_=U;
_=_->_; a=a->_; } a=a->_
; J(a&&!g(""qtm"",P)&&
!g(""cde"",P)){ L
=s (P); a=a
->_; A=
L; T
 W
O=
T;
J(*L
->b-57){ R
=g(""/"",P)?j():g
(P,""0"")?p:g(""b"",P)?
q:g(P,""j"")?r:0; Z(!!!R){
R=u(M,P); Z(!R) { R=j(); U=M;
U->b=P; U->o=R; M W M->_=U; } Q{
R=R->o; } } O=O->_ W O->o=R; O->b=L
->b; L=L->_; a=a->_; } t(A, T); } } }
void h(d e){ d _,a,c, z=e->o->_; J(z){ 
_=z->o; c=_->o->_; a= c->_->_->o; c=_
->c?c->_->o :c->o; Z(c->c<a->c) { c
->c++; h(c); } Q Z(a->c<c->c){ a
->c++; h(a); } z=z->_; } } X*
v(X*_,int O){ X*s=(X*)m\
alloc(strlen(_)*siz\
eof(X)); X*l=s;
J((*l++=*_?
*_-O:0)
)_++
;N
s;
 }
/**/
int ma\
in(){d a,_
,b;d    T,O,F,U
,    R,  E, L, A, Y
; X c[PI],x[PI],w[PI],*y
,*B,*d,*K=v(""Cvjme!dpnqmfuf;\
!&e!dpnqpofout-!&e!opeft/\x0b"",1
),*e=v(""&e;!&t\x0b\0nbjo)*|jou!j>1\
<gps)<j=51<j,,*qsjoug)#&e!#-j+j,j,52\
*<~"",1); int i,z,C,G,H,D,I ; k W l W m
W n W o W p W q W r W b=o; for(*x=D=I
=i=0; 5-i; i++){ b->b=i&4?v("";"",2):
v(""s"",2); b=b->_ W } H=p->c=1; p
->o W r->o W q->o W a=n; J(g\
ets(c)){ d=c; J(*d){ *d=
*d<65||*d>90 ?*d:*d+
32; d++; } y=s\
trchr(c,35)
; Z(y){
*y=0
 ;
 }
 B
=st\
rtok(c,
"" ""); J(B)
{ a=a->_ W P=v(
B,1); Z(g(""qtm"",P))
{ _=a; } B=strtok(0,"" "")
; } } _=_->_; z=atoi(v(_->b,-
1)); _=_->_; C=atoi(v(_->b,-1));
G=C; _=_->_; T=s(_->b); _=_->_; O W
F=O; U=k; J(_&&!g( ""cde"",_->b)){ i=*_
->b; R=i-47?48-i?i-98?106-i?0:r:q:p:j(
); Z(!R){ R=j(); U=U->_ W U->o=R; } F
= F->_ W F->o=R; _=_->_; } t(T, O); 
E=m->_; J(E){ D++; E=E->_; } L=l
->_; J(L){ I++; L =L->_; } p\
rintf(K,D,I); for(i='\''
/'\''; z>i; i++){ J(
!--G){ G=C; H=1
-H ; break;
} r->c=
! (q
->
c=
H)
; L=
l->_; J
(L) { L->o
->c=!1; L=L->_;
} h(p); Z(q->c){ h(
q); } Q{ h(r); } E=m->_;
J(E){ A=E->o; A->c=A->o->_->_
->_->_->o->c; E= E->_; } Y=k->_; 
d=w; J(Y){ *d++=48+Y->o->c; Y=Y->_;
} *d=0; Z(!g(w,x)){ strcpy(x,w); pri\
ntf (e,  i,  w   ) ;  }  }   N  0  ; }
","#include <pthread.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#undef D
#undef E
#undef U
#ifndef C
#define I int n,r;
#define D(N) void*N(void*);
#define C pthread_create
#define E int l;char *ak(char *u){return (*u=(l+=6,*u)=\
='@'?'K':*u=='.'?'P':*u=='-'?'M':tolower(*u))?ak(u+1)-1:u;}
#define U int
#elif ! defined J
#define H ""x\0\b\0\200\1\0\0\0\0\377\377\377,\0\0\0\0x\0\b\0\0\3""
#define E tn; char h[30]=""GIF87a"" H;void *(*fn[25])(void*)={
#define U };
#define D(N) N,
#define L return fwrite(""\1\t\0;"",1,4,stdout)!=4;
#define K {I for(r=0;r<8;r++)for(n=0,putchar(l);n<l;n++)putchar(B[r][n]|8)
#define J h[6]=h[24]=l=l-3;fwrite(h,1,30,stdout);K
#else
#define T pthread_t
#define E char B[8][256];
#define U int main(int c,char **a) { bdefhklmnprtuvwxyz57(ak(a[1]));J;}L}
#define D(N)  void *N(void *y) {\
    static I char *x=y;\
    T t=0;\
    if(!n && (r=tn)<24) C(&t,NULL,fn[++tn],y);\
    if(*x&&strchr(# N,*x))  B[2+r/5][2+n*6+r%5]=16;\
    n++;\
    if(*x) N(x+1);\
    if(t) pthread_join(t,&y);\
    return y;\
}
#endif

E

D(bdefhklmnprtuvwxyz57)
D(bcdefgiopqrstz23567890K)
D(abcdefgjopqrstz123567890K)
D(cefghkoqstz23457890K)
D(mntuvwxyz7)

D(bcdefghklmnopqrsuvw256890K)
D(aimnxy1)
D(jkt14)
D(abdhmprxyz0)
D(mnoquvw237890K)

D(abcdefghklmnopqruvw560K)
D(befhikprs45689MK)
D(befghjmnqprstwxyz156890MK)
D(dghs234789M)
D(amnoquvw90K)

D(abcdefghjklmnopqruw4680K)
D(aivxz40PK)
D(ajkrtwy1247PK)
D(abdghnqvx456K)
D(amnosuw34890K)

D(abdefhklmnprxz25_)
D(bcdegijloqsuwz12356890_PK)
D(bcdegloqstuvyz123567890_PK)
D(cehklorsuwz1234890_K)
D(amnqxz2_K)

U

#ifndef T
#include __FILE__
#endif
","#include<stdio.h>
#include<X11/Xlib.h>
#include<stdlib.h>
#include<sys/time.h>
#include<time.h>
#include<string.h>

static 
Display 
*b;static 
Window d; static GC e;
static int f,g,i;static 
double j,k;static void l
(int m){int _=00,__,x;double 
y,_x;y=m/j*02.0;_x=k/j*02.0;(void)
XSetForeground(b,e,BlackPixel(b,DefaultScreen
(b)));(void)XFillRectangle(b,d,e,00,00,(unsigned 
int)g,(unsigned int)f);if(m==00){for(__=0x0;__<g;__++)
for(x=0;x<f;)(void)XDrawPoint(b,d,e,__,x),x++;return;}(void)XSetForeground
(b,e,WhitePixel(b,DefaultScreen(b)));for(x=00;x<f;x++){__=0x0;if(((int)
(_*y)%2)==0)for(;__<g;__++){if(((int)(_*_x)%2)==1)(void)XDrawPoint(b,
d,e,__,x);_++;}_+=i-__;}}int main(int __x,char* ___[]){if(__x!=4)
fprintf(stderr,""usage:%spixelclockcarrier_freqhorizontal_total""
""\n"",___[00]),exit(EXIT_FAILURE);j=atof(___[1]),k=atof(
___[(1+1)]),i=atoi(___[(1+1+1)]),b=XOpenDisplay("""");
if(!b)exit(EXIT_FAILURE);{XSetWindowAttributes X;
X.event_mask=ExposureMask|ButtonPressMask,
X.override_redirect=True,
g=WidthOfScreen(ScreenOfDisplay
(b,DefaultScreen(b))),f=HeightOfScreen
(ScreenOfDisplay(b,DefaultScreen(b))),d
=XCreateWindow(b,RootWindow(b,DefaultScreen(b)),
00,00,(unsigned int)g,(unsigned int)f,00,CopyFromParent,
InputOutput,(Visual*)CopyFromParent,(unsigned long int)CWOverrideRedirect
|CWEventMask,&X);}(void)XMapWindow(b,d),(void)XRaiseWindow(b,d),e=
XCreateGC(b,d,0,0);{static int _X_[0377];int _x_;_X_[061]=948,
_X_[0x32]=01763,_X_[043]=0x4b9,52[_X_]=0x3dd,_X_[063]=1082,
_X_[0x36]=02143,_X_[42]=02063,_X_[070]=1094,065[_X_]=0x41d,
_X_[48]=02162,_X_[0x39]=02214,55[_X_]=0x406;while((_x_=
getchar())!=EOF){l(_X_[_x_]);{static struct timespec 
_l;_l.tv_nsec=03563262400,nanosleep(&_l,00);}}}
(void)XDestroyWindow(b,d),(void)XCloseDisplay
(b),exit(EXIT_SUCCESS);}
","#define			      q [v+a]
#define			     c b[1]
#define			    O 1 q
#define			   o 0 q
#define			  r(v,a\
)v<0&&(			 v*=-1,		a*=-1);
#define			p(v,m,	    s,w)*c==*#v?2 q\
<m?(c++		       ,d=1,3	   q=0,5      q=m,main\
(a+3,b)		      ,o=o*s	 q,O=O*		 w q):0:
static		     d,v[99	];main		  (int a,
char**b		    ){d=7;     if(*c?!		  (p(+,3
,4 q+O*		   3,4)p(			   -,(o?3
:(O=1,6		  )),4 q			  -O*3,4)
p(*,4,3		 ,4)p(/				  ,5,4,3)
p((),d,		0+3,0+				 04)*c==
')'?2 q	       <02?(c				++,0):0
:(o=012	      *o+*c-			      '0',c++
,O=1)):	     2 q?3-			   2:printf(
""%d/%d""	    ""\n"",o		       ,O))return
1;d=a,r    (o,d)r		     (O,d)3 q
=o<O?(4	  q=o,O)		   :(4 q=O,
	 o);r(d,		 o)a+=3;O?
				 1:(O=1,2
				q=1);while
				(2 q=o%1 q)a++;v[d]/=O;d[
				v+1]/=O;return main(d,b);}
","
#include <stdlib.h>
#include <stdio.h>

#define JF 0
#define JG 1
#define JH 2
#define JI 3

#define a(p,q,r,s) s=(p<r)?s:(p=q,s+1)
#define b(p,q,r,s,t,u,v) a(p,q,r,s),a(s,t,u,v)
#define c(p,q,r) for(p=q; p<r; p++)
#define d(p,q,r,s,t,u) for(p=q,s=t; s<u; p++,a(p,q,r,s))
#define e(p,q,r,s,t,u,v,w,x) for(p=q,s=t,v=w; (v<x); p++,b(p,q,r,s,t,u,v))

#define f
#define g(p) ,p
#define h(p) j(p,f,f)
#define i(p,q) j(p,q r,g(r))
#define j(p,q,r) p* N##p(q) { p* s=(p*)malloc(sizeof(p)); s->M=L[J##p]; ((p##0)s->M[0])(s r); U s; }
 
#define k(p, q) C struct { K* M; q } p
 
#define l(p) printf(O+p

#define m(p, q) (_->P+(q<<4&0360))[017&p]

#define n void
#define o int

#define A char
#define B const
#define C typedef

#define D C n
#define E C o

#define U return
#define V(p) (p<3)?0:(p<6)?3:6
#define W(p,q,r) ((p)q->M[r])(q)

B A* B O = ""  %c%s\0\n0 1 2  3 4 5  6 7 8\n\n\0%s\n\0you win\0you: \0%1s\0%d %d\0you lose\0cpu: %c %d %d\n\0  \0"";
 
D (*K)(n);

k(F, o P[00400]; );
k(G, F* Q; B A* R; );
k(H, F* Q; B A* R; );
k(I, F* Q; B A* R; );

D (*F0)(F*);
E (*F1)(F*);
D (*F2)(F*, o, o, o);
E (*F3)(F*, o, o, o);
D (*F4)(F*);
D (*G0)(G*, F*);
E (*G1)(G*);
E (*G2)(G*, o*, o*, o*);
E (*G3)(G*);
D (*H0)(H*, F*);
D (*I0)(I*, F*);

n OOOO(F* _) {
  o p;
  c(p, 0, 0xFF) _->P[p] = 0;
}

o OOOl(F* _) {
  o p, q, r;
  e(p, 0, 9, q, 0, 9, r, 1, 10) if(((F3)_->M[3])(_, p, q, r)) U 1;
  U 0;
}

n OOlO(F* _, o p, o q, o r) {
  m(p,q) = r;
}

o OOll(F* _, o r, o s, o t) {
  o u = 0;
  if(t > 0 && t < 10 && r >= 0 && r < 9 && s >= 0 && s < 9 && m(r,s) == 0) {
    o p, q;
    o w = V(r);
    o x = V(s);
    c(p, 0, 9) if(m(p,s) == t || m(r,p) == t) goto v;
    d(p, w, w+3, q, x, x+3) if(m(p,q) == t) goto v;
    u = 1;
    v: U u;
  }
  goto v;
}

n OlOO(F* _) {
  o p, q;
  for(q = 0, l(28)), p = 0; q < 9; p++, q = (p < 9)?q:(p=0,l(0), q+'a', O+((q == 2 || q == 5) ? 27 : 28)),q+1)) {
    l(2), m(p,q) == 0 ? '.' : '0' + m(p,q), O+((p == 2 || p==5) ? 82 : 83));
  }
  l(7));
}

n lOll(G* _, F* p) {
  _->Q = p;
  _->R = O+6;
}

o OlOl(G* _) {
  o p, q, r;
  if(((G2)_->M[2])(_, &p, &q, &r)) {
    ((F2)_->Q->M[2])(_->Q, p, q, r);
    U 1;
  }
  U 0;
}

n OllO(G* _) {
  l(30), _->R);
}

n Olll(H* _, F *p) {
  lOll((G*)_, p);
  _->R = O+34;
}

o lOOO(H* _, o* p, o* q, o* r) {
  do {
    A s[3];
    l(42));
    fflush(stdout);
    scanf(O+48, s);
    if(*s == 'q') U 0; else *q = (*s >= 'a' && *s <= 'i') ? *s - 'a' : 9;
    scanf(O+52, p, r);
  } while(!((F3)_->Q->M[3])(_->Q, *p, *q, *r));
  U 1;
}

n lOOl(I* _, F* p) {
  lOll((G*)_, p);
  _->R = O+58;
}

o lOlO(I* _, o* p, o* q, o* r) {
  o s, t, u;
  o v = 0;
  o w[01331];
  e(s, 0, 9, t, 0, 9, u, 1, 10) if(((F3)_->Q->M[3])(_->Q, s, t, u)) w[v++] = s | (t << 5) | (u << 10);
  s = rand() % v;
  *p = w[s] & 0x1f;
  *q = (w[s] & 0x3e0) >> 5;
  *r = (w[s] & 0x7c00) >> 10;
  l(67), *q + 'a', *p, *r);
  U 1;
}

K M[17] = {
  (K)OOOO,
  (K)OOOl,
  (K)OOlO,
  (K)OOll,
  (K)OlOO,
  (K)0000,
  (K)OlOl,
  (K)0000,
  (K)OllO,
  (K)Olll,
  (K)OlOl,
  (K)lOOO,
  (K)OllO,
  (K)lOOl,
  (K)OlOl,
  (K)lOlO,
  (K)OllO
} ;

K* L[4] = {
  M+0x0,
  M+0x5,
  M+0x9,
  M+0xD
} ;


h(F)
i(G, F*)
i(I, F*)
i(H, F*)

o main(o s, A** t) {
  o p = 42;
  
  F* q = 0;
  G* r[2] = { 0, 0} ;

  if(s-- > 1) {
    srand(atoi(t[s]));
    U main(s, t);
  }
  
  q = NF();
  r[0] = (G*)NH(q);
  r[1] = (G*)NI(q);

  for(p&=1; !(p&4); p&=5) {
    W(F4,q,4);
    if(W(G1,r[p],1)) {
      if(!W(F1,q,1)) {
        W(F4,q,4);
        W(G3,r[p],3);
        p = 4;
      }
    } else {
      p = 4;
    }
    p++;
  }

  free((n*)q);
  free((n*)r[0]);
  free((n*)r[1]);

  U 0;
}
","#include <stdlib.h>
#include <SDL.h>

#include <sys/mman.h>
#define M(a) mmap(0, a, PROT_EXEC|PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0)

#define W 400
#define H 300
#define I 128

#define L char*
#define _ Sint32
#define h(a,b) for(a=0; a<b; a++)
#define O while(
#define b D[j][i][
#define J(b) a(#b)

										 SDL_Event
										   e;
										SDL_Surface
									    *F; float f, m,
									     n,d,D[H][W][6],
									    v; L A; L X; L
									     V,G[H][W]; L
							     E	 ;            L Q; double
							      R=2/(    W-1. ),T=2/(H-1.),c,g, z=2	 ,*
							       K,*Z,*S; _ B, C, o,i,j,q,k,l,x,y,*u,Y=512; P(
							      L f){ *(u=V)=f-X-5; V+=4; } a(L e){ O l=*e++)
								l-38?l==36?s(2),o--:l-37?*V++=l==35?k=*e++
							 ,k*  16+*e++-81:l^128:o>7?J(Yv]#JJ), P(S++):o++
							  :s(4); } s(_ n){ O o<n){ J(]#IB); P(--S); J(]);
			       *V			  ++=217+o++; } } p(L e,_ q,L *t){ _ x=9; do{ A=""%]#IB""
			       ; _	  i     	=*e; 5==q?*K=strtod(e,t),e-*t?e=*t,a(A),P(K++), J(%Yn)
				 : i<6	  ?p   (	e+1,4,t),i-5||J(Y`YIY`YI), e=*t:i>96?a(A),P(Z+i-97),a
				  (A),P (Z+*e++-71)	:(p(index( e, 40)+1,1,t), i^82?i^73?i^65?i^69?i^76?1:J
				 (%YhY`%YmY}]YYB%YBXHYIXH$^A$YqYJ$Ys):J(%Y{YJ%Yj^IY@Y|\\iYIYp%Yh$^AY}$]Y\\J$^I)
			       : J(XHYIXH^AYn):J(]YYn)	: J (]XYn),e= index( *t,41 )+ 1): p ( e , q+ 1, &e); A
			 =	""&%YCXJYLXIYK\\J$^I$^k$^A""; (x -=3)<1?J(&]X]Y),1L <<31<0? J(Zi_`#JO):J(_i]X),x
			 ?J	(#HH):J(#HC),J(#AD#IJPC) ,o-=4:--x?--x?--x?x-3?J(&%YA%YAXHYIXH^AYh$^q\\J$^IY`)
	 ,		  a(A):  1:a(A):J(&$^j$^j):J(&$^B$^B); } O q==(x=*(*t=e++))/2); } main(_ r,L*U){
  X    =V=(Z  =(S=(K=M(Y*32))+Y)+ Y)+Y; J(h#AA#AA#AA#AA#FJ:+-*/); h(q,2){ A =E =Q=U[ q+1]; O * A=*A^B++
	 [	       "";<>+-*/"" ]?*A:B,(B%=7)||(isspace(*E=*A)||++E,*A++)); E=V; O B=*Q){ if(Q[1]-61)p(
			 Q,1,&Q); else{ p(Q+2,1,&Q); h(j,2){ J(]#JJ); P(Z+B-71-j*26); o--; } } *Q&&Q++; }
			 }	J(#PPJ#AP#IF); P (E -V+X +1); J(#IJPC); 0[u =X+7] =I; SDL_Init( 32 ); F=
				SDL_SetVideoMode(W,H,8 ,0); A=F->pixels; B=F->pitch; O 1){ C^=3; h(j,H)h(i,
			       W   )b C+2]=9; if(r=(k	=SDL_GetMouseState(&x,&y))&5){ f=z/50; f=k&1 ?f:-f ;
				  c+=(x*T-T/R)*f; g	+= f*y*T-f; z*=f=1-f/z; v=1/f; h(j,H)h(i,W)h(q,4){ k=
				   x+(i-   x)* f       +q/2; l=y+(j-y)*f+q%2; if(k>=0&k<W&l>=0&l<H){ m=x+(k+D[
				l][k	  ][    	3-C]-x)*v-i; n=y+( l+D[l][k][4 -C]-y)*v-j; d= m*m+ n*n;
			       if	  (		 d<b C+2]){ b C]=m; b C+1]=n; b C+2]=d; G[j][i]=A[l*B+
			       k			 ]; } } } }  h(j,H)h(i,W)if(q=b C+2]){ Z[2]=(i *T-T /
							 R)*z+c; Z[28]=z-j *T*z-g; Z[8]= 0; Z[34]=1; q =((_(*
							   )(  ))X)(); A[j* B+i]=q? *u-q:0; h(q,3)b C+q]=0;
								} else A[j*B+i]=G[j][i]; SDL_UpdateRect(F,
							       0,0,W,H); O(r?SDL_PollEvent:SDL_WaitEvent)(&e
							     )) { k=e.type; l=e.key.keysym.sym; if  (	k==
							     12|k==    2&  l  ==27)return;    if(
									      e.type-5?k==
									     2&(l==270|l==
									      269)?*u=l-270
									    ? *u/2:*u*2:0:1
									      )  break;
										    }
										   }  }
","#include <stdlib.h>
#include <SDL.h>

#include <sys/mman.h>
#define M(a) mmap(0, a, PROT_EXEC|PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0)

#define W 400
#define H 300
#define I 128

#define L char*
#define _ Sint32
#define h(a,b) for(a=0; a<b; a++)
#define O while(
#define b D[j][i][
#define J(b) a(#b)

										 SDL_Event
										   e;
										SDL_Surface
									    *F; float f, m,
									     n,d,D[H][W][6],
									    v; L A; L X; L
									     V,G[H][W]; L
							     E   ;            L Q; double
							      R=2/(    W-1. ),T=2/(H-1.),c,g, z=2	 ,*
							       K,*Z,*S; _ B, C, o,i,j,q,k,l,x,y,*u,Y=512; P(
							      L f){ *(u=V)=f-X-5; V+=4; } a(L e){ O l=*e++)
								l-38?l==36?s(2),o--:l-37?*V++=l==35?k=*e++
							 ,k*  16+*e++-81:l^128:o>7?J(Yv]#JJ), P(S++):o++
							  :s(4); } s(_ n){ O o<n){ J(]#IB); P(--S); J(]);
			       *V			  ++=217+o++; } } p(L e,_ q,L *t){ _ x=9; do{ A=""%]#IB""
			       ; _	  i     	=*e; 5==q?*K=strtod(e,t),e-*t?e=*t,a(A),P(K++), J(%Yn)
				 : i<6	  ?p   (	e+1,4,t),i-5||J(Y`YIY`YI), e=*t:i>96?a(A),P(Z+i-97),a
				  (A),P (Z+*e++-71)	:(p(index( e, 40)+1,1,t), i^82?i^73?i^65?i^69?i^76?1:J
				 (%YhY`%YmY}]YYB%YBXHYIXH$^A$YqYJ$Ys):J(%Y{YJ%Yj^IY@Y|\\iYIYp%Yh$^AY}$]Y\\J$^I)
			       : J(XHYIXH^AYn):J(]YYn)  : J (]XYn),e= index( *t,41 )+ 1): p ( e , q+ 1, &e); A
			 =	""&%YCXJYLXIYK\\J$^I$^k$^A""; (x -=3)<1?J(&]X]Y),1L <<31<0? J(Zi_`#JO):J(_i]X),x
			 ?J	(#HH):J(#HC),J(#AD#IJPC) ,o-=4:--x?--x?--x?x-3?J(&%YA%YAXHYIXH^AYh$^q\\J$^IY`)
	 ,		  a(A):  1:a(A):J(&$^j$^j):J(&$^B$^B); } O q==(x=*(*t=e++))/2); } main(_ r,L*U){
  X    =V=(Z  =(S=(K=M(Y*32))+Y)+ Y)+Y; J(h#AA#AA#AA#AA#FJ:+-*/); h(q,2){ A =E =Q=U[ q+1]; O * A=*A^B++
	 [	       "";<>+-*/"" ]?*A:B,(B%=7)||(isspace(*E=*A)||++E,*A++)); E=V; O B=*Q){ if(Q[1]-61)p(
			 Q,1,&Q); else{ p(Q+2,1,&Q); h(j,2){ J(]#JJ); P(Z+B-71-j*26); o--; } } *Q&&Q++; }
			 }	J(#PPJ#AP#IF); P (E -V+X +1); J(#IJPC); 0[u =X+7] =I; SDL_Init( 32 ); F=
			        SDL_SetVideoMode(W,H,8 ,0); A=F->pixels; B=F->pitch; O 1){ C^=3; h(j,H)h(i,
			       W   )b C+2]=9; if(r=(k   =SDL_GetMouseState(&x,&y))&5){ f=z/50; f=k&1 ?f:-f ;
				  c+=(x*T-T/R)*f; g     += f*y*T-f; z*=f=1-f/z; v=1/f; h(j,H)h(i,W)h(q,4){ k=
				   x+(i-   x)* f       +q/2; l=y+(j-y)*f+q%2; if(k>=0&k<W&l>=0&l<H){ m=x+(k+D[
				l][k      ][    	3-C]-x)*v-i; n=y+( l+D[l][k][4 -C]-y)*v-j; d= m*m+ n*n;
			       if	  (		 d<b C+2]){ b C]=m; b C+1]=n; b C+2]=d; G[j][i]=A[l*B+
			       k			 ]; } } } }  h(j,H)h(i,W)if(q=b C+2]){ Z[2]=(i *T-T /
							 R)*z+c; Z[28]=z-j *T*z-g; Z[8]= 0; Z[34]=1; q =((_(*
							   )(  ))X)(); A[j* B+i]=q? *u-q:0; h(q,3)b C+q]=0;
    								} else A[j*B+i]=G[j][i]; SDL_UpdateRect(F,
							       0,0,W,H); O(r?SDL_PollEvent:SDL_WaitEvent)(&e
							     )) { k=e.type; l=e.key.keysym.sym; if  (   k==
							     12|k==    2&  l  ==27)return;    if(
								              e.type-5?k==
									     2&(l==270|l==
									      269)?*u=l-270
									    ? *u/2:*u*2:0:1
									      )  break;
										    }
										   }  }
","#include <ncurses.h>

#define T typedef unsigned
T long G;
T short CT;
#define ATG srand(time(0)); initscr(); cbreak(); noecho(); start_color();
#define GG(T,C) attrset(A_BOLD*!(T)|COLOR_PAIR(C%2+1));
#define AC(G) init_pair(G/2,G,nodelay(stdscr,G/3));
#define TCT(A,G,C) mvaddch(A+CTT*6+4,CGA*12+G,C)
#define AGG A&2?119:115:A&1?100:97
#define CAT mvprintw(2,40,""%d"",TC)
#define GAT int main()
#define AAA refresh()
#define TAG endwin()
#define GCA clear()
#define TCA clock()
#define CCC rand()
#define CC getch()
#define GA return
#define T(T) #T#T#T#T#T#T T
#define G(G) while(G)
#define A(A) A { A }

G AA[1<<16]; G GT[1<<16];
G CAA, CA, CTG, TA, CG, CTT, CGA, TC, T, GTC;
char *ACG=""HXXTP02^OCBHL\\XP``T^NDP800SQSW\\X@@@0c13RZLLH<WWWWWWWW  .jW       Wq. '9W       WP'  jb  WW  7F  WWWWWWWWBjPWWbo^^WW^^9WWP^__WW__6,D:^HRioV;:VztZ"", *GCC,*AGT,GTT[]=T(

    ; G AG;                                    G TG;
   G AC;                                      G C; G
  A=0; G AAG; G TT; G GG; G AT(CT A){ GA A%4>>A%4-1
 ; } CT GC(){ AC=!(AAG&(CA/=2)); CTG=15*CA*CA/4; G
 A=TG;                                 GA AC||A&&
 AT(A                               /CA/CA); }
 CT GTCA                          (G C,G A,G
  CG){ GG(C>=A,C)G(!A)GA (C&&CC,CG^TAG); CG
   +=(C<A)<<20; G T=TCT(0,C%16*3-34,302
    [C%16*2+            GTT]); AAA; G(
      CG>TCA)A;      GA CG^GTCA(C+
       3,A-1,CG  ); } G CGAC(CT
          T,G  A,G C,G AA,G
             AG){ GA(AA&&
          (CA=4)&& (   CGAC(
        1+T,1+A,C,  --AA, AG)?
      CGAC(ACG[     T],AG,0,C,A):
     ACG[T]&&TCT(AG,A,ACG[T])),C); }
    CT TGA(G A){ CT T=1; CT C=-T; *AA=A;
   *GT=3;                     G(++C^T){ G(
  (TA=AA                         [C])/2&!(TT
 =(TG=                              GT[C]+16)&
 15))GA TG>>4; CA=4; AAG=TA>>2*TT; A(GC()&&(AA[T
 ]=TA^1<<2*TT<<AT(AAG),GT[T++]=TG^CTG>>AC); )} GA
  0 ; }                                    G ACC(){
  G T=4;                                     G A=1;
   G C=1;                                     TC=TGA
    (GG=CCC); G((A*=2)<C||(C<<=A=1)<T||(T*=C=2)){ G (
      TGA(AG=GG^T^C^A)>TC) { G((TC=TGA(GG=AG))>CAA) {
        CAA=TC; CAT;                            } G (
          TC>>6)GA 1;                          C = 1;
            T=2; } G(1+                       CC) GA
               1; } GA 0; } GAT{ AGT=GCC=GTT; G(T=*
                  ++GCC)72&T^64||(*AGT^=T/4%2<<A%8
                    ,7&(A+=5))||(      *++AGT=CAA
                       =C=0); ATG   AC(4); G(!
                          ACC   ()); AC(2); G
                              (C+1){ G(!C){
                           C=TG=3; CG=  1; TA
                        =GG; TC=CAA; }  GCA; TT=
                     TG; A(A(A(A(      ++TT; A=CG
                  ^=(TT&=15)&3?           1:2; CTT
               =TT/4 ; CGA=CTT%2*3^3^TT%4 ; AAG=TA>>
            2*TT; A=CG^AAG; GG(TT^TG,GTC=TT) CGAC(GTC
          &&A&2?134:                           138,TT
        &0,6,6,A&1                              ?0 :5)
      ; CGAC(128                                |A %2*
     3,A&2?3:0,11,3,0) ; ))))CAT ; G(TA/2&!TG)GA GTCA(
    GCA,CAA/4&16, TCA); )C=CC-114; TT=0;  A(G(GC()&&TC
   &&C+114                                    ==( CA&
  2?AGG)                                   ) { --TC;
 TG&1&&                                 (A^=2-AT(A
 )); C=TCA; A(A(T=0; { GG(1,TG); G C; A(A(A(A(A(
 A(TCT(T%6,T%11,32+55*(ACG[11*AT(TT)+22*AT(A)+(
 (A^2)&                          (C=TT/2^TG&
  1?2:1)                      ?65-T:T)%11]
   >>(3-A&3               -C?65-T:T)%6&
    1)); T++; ))))))TT++; AAA; } C+=1
      <<16; G(C>TCA); ))CG^=CA; TA
        ^=1<<AT   (AAG)+TG*2; TG
           ^=   CTG>>AC; } )
             } GA TAG; }
","_,x,y,o       ,N;char       b[1920]       ;p(n,c)
{for(;n       --;x++)       c==10?y       +=80,x=
o-1:x>=       0?80>x?             c       !='~'?b
[y+x]=c       :0:                         0:0;}c(
       q,l,r)       char*l,*r;{while             (q>=0)q
       =(""E""    ""?yYrIxC{e^}KhE>[|LXbj}""         ""dOVsJ""
       ""@""    ""idOV{Yab[bW}[bW}\\qFywyv{D""       ""ma\\A""
       """"   ""Ztq?Lyw>e{|Zq>Y\\gq\\qI[tYBe{w""     ""yvDZE\
vBA[`_""    ""Lo>}KcqdYrWqKxzKtW]|DXRwsfcUaT\\\
KXw{Y""   ""RsFwsFwsFw{zaqyaz|FmMpyaoyI\\]cuUw{J""
[_/6]   -62>>_++%6&1?r[q]:l[q])-99;return q;}E(a
){for   (o=x=a,y=0,_=0;_        <1006;)a="" /\\\n""
       ""~|_.""[c(6,""b""              ""cd\\a[g"",""^`""   ""_e""
       ""]fh"")+8], p(   ""#$%""        ""&'()*+,-.1""[   c(11
      ,""_ac[]\\YZi""   ""jkm"",         ""`bd^efghXWlV"" )+13
      ]-34,a);}main   (k,Z){         float z[1920]  ,A=0
,B=0  ,i,j; puts(""""         ""\x1b""   ""[2J"");for(;;
)  {  float e=sin(A         ),  n=   sin(B),g=cos(
A),m   =cos(B);for(k        =0;k<   1840;k++)y=-k
/80-   10,o=41+(k%80-              40)*1.3/y+n,N=
        A-100.0/y, b[k]=        "".#""[o+N&1],z[k]   =0;E(
        80-(int)(9*B)%250);for(j=0;6.28>j;j+=0.07  )for(
         i=0;6.28>i;i+=0.02) { float c=sin(i),d   =cos(j
           ),f=sin(j),h=d+2,D=15/(c*h*e+f*g+5    ),l=cos
(i),t=c     *h*g-f*e;x=40+2*D*(l*h*m-t*n),y=   12
+D*(l*h       *n+t*m),o=x+80*y,N=8*((f*e-c    *d*
g)*m-c*         d*e-f*g-l*d*n);if(D>z[o]    )z[o]
=D,b[o]             ="" ..,,-++=#$@""[      N>0?N:0
       ]  ;  }                                   printf(
       ""\x1b[""       ""H""           );for(k       =1;1841
       >k;k++)       putchar       (k%80?b       [k]:10)
       ;  A +=       0.053;B       +=0.037       ;  }  }
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define P printf
#define F(x,y) ((FILE*)Z(x,y))
#define U(x,y) ((unsigned char*)Z(x,y))
#define X(x,y,z) ((double*)x+y+7*z)
#define Y(x,y) ((double*)x+y)
#define Z(x,y) *(long*)Y(x,y)
#define R(x,y) (x=y,y^=(y<<11),y^=(y>>15),y^=(y<<3),(x+y)&0x7fffffff)

int main(int c,char**o)
{
   void* v=malloc(0170UL);
   memset(v,0,0170UL);
   if(c!=4)P(""bad args\n""),exit(1);
   Z(v,2)=atoi(o[1]);
   Z(v,1)=atoi(o[2]);
   Z(v,0)=Z(v,2)*Z(v,2)>>3;
   Z(v,6)=(long)malloc(Z(v,0));
   memset((void*)Z(v,6),0,Z(v,0));
   Z(v,13)=(long)fopen(o[3],""r"");
   fscanf(F(v,13),""%ld"",(long*)Y(v,3));
   Z(v,8)=(long)malloc(050+Z(v,3)*070);
   Z(Z(v,8),0)=Z(v,3);
   fscanf(F(v,13),""%lf %lf %lf %lf"",Y(Z(v,8),1),Y(Z(v,8),2),Y(Z(v,8),3),Y(Z(v,8),4));
   for(Z(v,3)=0;Z(v,3)<Z(Z(v,8),0);
       fscanf(F(v,13),""%lf %lf %lf %lf %lf %lf %lf"",X(Z(v,8),5,Z(v,3)),
              X(Z(v,8),6,Z(v,3)),X(Z(v,8),7,Z(v,3)),X(Z(v,8),8,Z(v,3)),
              X(Z(v,8),9,Z(v,3)),X(Z(v,8),10,Z(v,3)),X(Z(v,8),11,Z(v,3))),
           ++Z(v,3));
   fclose(F(v,13));
   Z(v,14)=8675309;
   for(Z(v,3)=0;Z(v,3)<Z(v,1);++Z(v,3))
   {
      *Y(v,7)=(R(Z(v,4),Z(v,14))/(double)0x7fffffff),Z(v,5)=0;
      for(Z(v,4)=0;Z(v,4)<Z(Z(v,8),0);++Z(v,4),++Z(v,5))
         if(*Y(v,7)<*X(Z(v,8),11,Z(v,5)))
            break;
         else
            *Y(v,7)-=*X(Z(v,8),11,Z(v,5));
      *Y(v,11)=*X(Z(v,8),5,Z(v,5))**Y(v,9)+*X(Z(v,8),6,Z(v,5))**Y(v,10)+*X(Z(v,8),9,Z(v,5));
      *Y(v,12)=*X(Z(v,8),7,Z(v,5))**Y(v,9)+*X(Z(v,8),8,Z(v,5))**Y(v,10)+*X(Z(v,8),10,Z(v,5));
      *Y(v,9)=*Y(v,11);
      *Y(v,10)=*Y(v,12);
      if(Z(v,3)>10)
         if((*Y(v,9)>=*Y(Z(v,8),1))&&(*Y(v,9)<=*Y(Z(v,8),3))&&(*Y(v,10)>=*Y(Z(v,8),2))&&(*Y(v,10)<=*Y(Z(v,8),4)))
            *Y(v,11)=(*Y(v,9)+-*Y(Z(v,8),1))/(*Y(Z(v,8),3)-*Y(Z(v,8),1)),
      *Y(v,12)=(*Y(v,10)+-*Y(Z(v,8),2))/(*Y(Z(v,8),4)-*Y(Z(v,8),2)),
      *(U(v,6)+((((long)(Z(v,2)-*Y(v,12)*Z(v,2))*Z(v,2))+(long)(*Y(v,11)*Z(v,2)))>>3))|=
      1<<((((long)(Z(v,2)-*Y(v,12)*Z(v,2))*Z(v,2))+(long)(*Y(v,11)*Z(v,2)))&7);
   }
   P(""#define x_width %ld\n#define x_height %ld\nstatic char x_bits[] = {\n"",Z(v,2),Z(v,2));
   for(Z(v,3)=0;Z(v,3)<Z(v,0);++Z(v,3))
   {
      if(Z(v,3))
         P("","");
      P(""0x%02x"",*(U(v,6)+Z(v,3)));
   }
   P(""};\n"");
   free(Y(Z(v,6),0));
   free(Y(Z(v,8),0));
   free(v);
   return 0;
}
","                            /* <body  bgcolor  = 0 >
                          <img src= cube.gif><!-- */
                        #define _ ] [ /* ; ; ; ;  */
                      #include <string.h>  /* ; ; */
                    #include  <stdio.h>  /* ; ; ; */
                    #define K(o,O) L o=0; o<O ; o++)
                    #define  H  unsigned  long  long
                    #define /* ; ; ; ; ; ; } */ W ]=
                    #define /* ; ; ; ; ; ; */ L for(
                    #define /* ; ; ; ; ; ; */ J if (
                    #include <stdlib.h> /*; ; ; ; */
                    #define Z (j*3+j/9*3+2)%10+j/9*9
                    int s[ ] = { 186, 94, 1426, 3098
                    ,1047 , 122 , 1082 , 3083 , 1039
                    , 569 , 527 , 1054 ,  531  } ;
                    #define P( o , O ,l) K(C,o)\
                    fputc ( ( O )[ C ] -l, G);
                    #define Y strncpy( /* */

        int j,k,l,v,c,C,O[64],n[
      64],*o,q[13 _ 13],u,d,f,g[
    W{ 8,7,6,6,6,6 } ; H p [13 _
  #define M memset(E[c]+j*298+v\
*a+88-u*5+586*( u*5+152-i/16*a+C
13 _ 432],r,w,t,b,S[13]; FILE*G;
char E[13 _ 168840],*A=""||||||"",
*D=""   {   ;   wb;  aa; aaaa}a \
0z00Zzz} { z0z}      "",Q[64 _ 60
],*F =""+    +"",T [43]; int main(
int I,char**V){ int i,h,B,a,m; H
#define R(z){ x=h=0; K(j,27)h|=\
(c>> j&1 )<<z ; ; ; } c=h; ; ; ;
x; J I>1)B=C=atoi(V[1]); J !d)K(
v,13){ h=s[v]; J B<0){ k=h>>18
^h&511; h^= k<<18|k; C=-C; }
K(k,7){ J k==4)R(Z)R(j+(j-
"" /@""[j/9]+38)/3*6-6)K(l

                            ,4){ R(Z)K(a,9) x|=((H)c
                          >>a*3&7)<<a*4 +a/3*4; K(a,
                        96){ m=a-37; r=m<0?x>>-m:x<<
                      m; J!(x!=(m<0?r<<-m:r>>m)||r&r
                    /2&0x888888888888888ULL||r&r>>4&
                    0xF000F000F000ULL)){ p[0 _ v _ q
                    [v _ 0]++W r; K(j,q[v _ 0]-1)J p
                    [0 _ v _ j]==r)q[v _ 0]--; } } }
                    } } h=d; x=w; m=q[f _ h]; a=f; u
                    |=1<<a; B=u; K(i,m){ w|=S[a W p[
                    d _ a _ i]; r: d++; v=*s; t=w; L
                    j=1; j<13; j++){ J u>>j&1^1){ b=
                    c=k=0; l=q[j _ h]; L; k<l; k++){
                    r=p[h _ j _ k]; J!(w&r))b|=p[d _
                    j _ c++W r; } J!c) goto n; J c
                    ==1){ w|=S[j W b; u|=1<<j; J
                    d==12){ J--C<1){ K(c,64)O[
                    c W-1; x=0; K(c,13){ r=~

        0; K(j,13)J S[j]<r&&S[j]
      >x)r=S[j]; K(i,64){ n[i W-
    1; memset(Q[i],32,59); } K(i
  ,64){ J r>>i&1)O[i W n[i W c ;
K(j,2){ o=j?O:n; k=o[i]; u=i&d ;
v=i&3; a=48; J k+1){ C=k==c; Y T
,""+----+/    /|+----+ ||    | +\
|    |/+----+"",43); J!C&&v&&o[i-
1]==k)T[6 W T[21 W T[29 W 32 ; J
u&&o[i-4]==k){ Y T,C?""//////"":F,
6); J v==3||o[i-3]<0)T[d W T [20
W C?47:32; } J i&a&&o[i-16]==k){
J u==d||o[i-d]<0)Y T+36,C?A:F,6)
; J!C)J v==3|| o[i-15]<0) T[35 W
32; } J C){ Y T+7,""////"",4); T
[19 W T[27 W 47; Y T+22,A,4)
; Y T+30,A,4); } K(C,6)Y Q
[9-i/16*3+u/2+C]+v*5-u/2

                            +j*30+g[C],T+""06=EMT""[C]
                          -a,20-g[C]-g[5-C]); K(C,a)
                        { M)+28,m=k+33,h=20); M+h)-h
                      ,k+49+u/4*16,a); } K(C,h){ M)-
                    C,k+17,a); M)+a-C,m,C); M+a)+28,
                    m,h-C); } } } } K(i,21)puts(Q[i]
                    ); x=r; } G=fopen(""cube.gif"", D+
                    11); P(13,""qspbc\213t,J+ **"",42)
                    K(i,8)P(a,D,h+"" H Zbjm ""[i]+C)P(
                    19,""F$0sjyxhfujWSU(&%%%"",37)K(i,
                    13){ P(19,""K#.3 ***V****t,J+*1"",
                    42)K(j,1340){ P(2,"" !"",161)P(126
                    ,E[i]+j*126,0)}P(3+i/d,""!\241 [""
                    ,32 ) } exit(0); } goto n; }else
                    goto r; } J c<v) { f=j; v=c; }
                    q[j _ d W c; t|=b; } } J!~t)
                    main(0,0); n:u=B; w=x; d=h
                    ; } u^=1<<a ; } /*--> */
","main(_){_^448&&main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8]["">'txiZ^(~z?""-48]>>"";;;====~$::199""[_*2&8|_/64]/(_&2?1:8)%8&1:10);}
","char    *e,t    [366    ],*f
,*g,    *h,*    i;d,    m  ;
    main    (c,b)   char    **b;{
    for(    ;d[t]   =d%3    ?60<d
&300    >d&6    <d %    30?0 
:32:    d%30    ?32:    10 ,    
    366>    ++d;)   ;for    (g=3*
    atoi    (*++    b) +    34+t;
i=f=    ""\1""    ""\7""    ""(d""
""\177""  ""yX""    ""\34""   ,e=g
    ;  )    for(    *e++    =++m/
    10 +    48,g    =c=0    ,*e =    
48+m    %10;    h=e-    65+*    
i,d=    *h,*    i++;    f-=8    
    ,g=d    <c?c    =d,h:   g)for
    (; d    -=!!    h[*f    ++-64
    ],*f    ;) ;    puts    (t);}
","                               #include <stdio.h>
           #define n(o,p,e)=y=(z=a(e)%16 p x%16 p o,a(e)p x p o),h(
                                #define s 6[o]
             #define p z=l[d(9)]|l[d(9)+1]<<8,1<(9[o]+=2)||++8[o]
                                #define Q a(7)
           #define w 254>(9[o]-=2)||--8[o],l[d(9)]=z,l[1+d(9)]=z>>8
                               #define O )):((
                  #define b (y&1?~s:s)>>""\6\0\2\7""[y/2]&1?0:(
                               #define S )?(z-=
                    #define a(f)*((7&f)-6?&o[f&7]:&l[d(5)])
                               #define C S 5 S 3
                       #define D(E)x/8!=16+E&198+E*8!=x?
                             #define B(C)fclose((C))
                       #define q (c+=2,0[c-2]|1[c-2]<<8)
                          #define m x=64&x?*c++:a(x),
                         #define A(F)=fopen((F),""rb+"")
                    unsigned char o[10],l[78114],*c=l,*k=l
                          #define d(e)o[e]+256*o[e-1]
#define h(l)s=l>>8&1|128&y|!(y&255)*64|16&z|2,y^=y>>4,y^=y<<2,y^=~y>>1,s|=y&4
+64506; e,V,v,u,x,y,z,Z; main(r,U)char**U;{

     { { { } } }       { { { } } }       { { { } } }       { { { } } }
    { { {   } } }     { { {   } } }     { { {   } } }     { { {   } } }
   { { {     } } }   { { {     } } }   { { {     } } }   { { {     } } }
   { { {     } } }   { { {     } } }   { { {     } } }   { { {     } } }
   { { {     } } }   { { {     } } }   { { {     } } }   { { {     } } }
    { { {   } } }    { { {     } } }    { { {   } } }    { { {     } } }
      { { ; } }      { { {     } } }      { { ; } }      { { {     } } }
    { { {   } } }    { { {     } } }    { { {   } } }    { { {     } } }
   { { {     } } }   { { {     } } }   { { {     } } }   { { {     } } }
   { { {     } } }   { { {     } } }   { { {     } } }   { { {     } } }
   { { {     } } }   { { {     } } }   { { {     } } }   { { {     } } }
    { { {   } } }     { { {   } } }     { { {   } } }     { { {   } } }
     { { { } } }       { { { } } }       { { { } } }       { { { } } }

                                   for(v A((u A((e A((r-2?0:(V A(1[U])),""C"")
),system(""stty raw -echo min 0""),fread(l,78114,1,e),B(e),""B"")),""A"")); 118-(x
=*c++); (y=x/8%8,z=(x&199)-4 S 1 S 1 S 186 S 2 S 2 S 3 S 0,r=(y>5)*2+y,z=(x&
207)-1 S 2 S 6 S 2 S 182 S 4)?D(0)D(1)D(2)D(3)D(4)D(5)D(6)D(7)(z=x-2 C C C C
C C C C+129 S 6 S 4 S 6 S 8 S 8 S 6 S 2 S 2 S 12)?x/64-1?((0 O a(y)=a(x) O 9
[o]=a(5),8[o]=a(4) O 237==*c++?((int (*)())(2-*c++?fwrite:fread))(l+*k+1[k]*
256,128,1,(fseek(y=5[k]-1?u:v,((3[k]|4[k]<<8)<<7|2[k])<<7,Q=0),y)):0 O y=a(5
),z=a(4),a(5)=a(3),a(4)=a(2),a(3)=y,a(2)=z O c=l+d(5) O y=l[x=d(9)],z=l[++x]
,x[l]=a(4),l[--x]=a(5),a(5)=y,a(4)=z O 2-*c?Z||read(0,&Z,1),1&*c++?Q=Z,Z=0:(
Q=!!Z):(c++,Q=r=V?fgetc(V):-1,s=s&~1|r<0) O++c,write(1,&7[o],1) O z=c+2-l,w,
c=l+q O p,c=l+z O c=l+q O s^=1 O Q=q[l] O s|=1 O q[l]=Q O Q=~Q O a(5)=l[x=q]
,a(4)=l[++x] O s|=s&16|9<Q%16?Q+=6,16:0,z=s|=1&s|Q>159?Q+=96,1:0,y=Q,h(s<<8)
O l[x=q]=a(5),l[++x]=a(4) O x=Q%2,Q=Q/2+s%2*128,s=s&~1|x O Q=l[d(3)]O x=Q  /
128,Q=Q*2+s%2,s=s&~1|x O l[d(3)]=Q O s=s&~1|1&Q,Q=Q/2|Q<<7 O Q=l[d(1)]O s=~1
&s|Q>>7,Q=Q*2|Q>>7 O l[d(1)]=Q O m y n(0,-,7)y) O m z=0,y=Q|=x,h(y) O m z=0,
y=Q^=x,h(y) O m z=Q*2|2*x,y=Q&=x,h(y) O m Q n(s%2,-,7)y) O m Q n(0,-,7)y)  O
m Q n(s%2,+,7)y) O m Q n(0,+,7)y) O z=r-8?d(r+1):s|Q<<8,w O p,r-8?o[r+1]=z,r
[o]=z>>8:(s=~40&z|2,Q=z>>8) O r[o]--||--o[r-1]O a(5)=z=a(5)+r[o],a(4)=z=a(4)
+o[r-1]+z/256,s=~1&s|z>>8 O ++o[r+1]||r[o]++O o[r+1]=*c++,r[o]=*c++O z=c-l,w
,c=y*8+l O x=q,b z=c-l,w,c=l+x) O x=q,b c=l+x) O b p,c=l+z) O a(y)=*c++O r=y
,x=0,a(r)n(1,-,y)s<<8) O r=y,x=0,a(r)n(1,+,y)s<<8))));
system(""stty cooked echo""); B((B((V?B(V):0,u)),v)); }
","#include <windows.h>
#define main ma
#define Display int
#define XOpenDisplay(a)1
#define BlackPixel(a,b)2
#define WhitePixel(a,b)3
#define XCreateGC(a,b,c,d)4
#define Window HWND
#define XCreateSimpleWindow(a,b,c,d,e,f,g,h,i)CreateWindowEx(0,""a"",""Chess"",\
0xcf0000,c,d,e+8,f+32,0,0,aa,0)
#define XSelectInput(a,b,c)
#define XMapWindow(a,b)ShowWindow(b,dd)
#define XCreateBitmapFromData(a,b,c,d,e)CreateBitmap(d,e,1,1,c)
#define XNextEvent(a,b){ MSG m; if(!GetMessage(&m,0,0,0))return \
m.wParam; TranslateMessage(&m); DispatchMessage(&m); *b=oo; oo.type=0; }
#define XCopyPlane(a,b,c,d,e,f,g,h,i,j,k)(h1=GetDC(c),h2=CreateCompatibleDC\
(h1),h3=SelectObject(h2,b),BitBlt(h1,i,j,g,h,h2,e,f,0xcc0020),SelectObject\
(h2,h3),DeleteDC(h2),ReleaseDC(c,h1))
#define XFlush(a)
typedef struct{ int foreground; } XGCValues;
typedef struct{ int type,x,y; } XButtonEvent;
HDC h1,h2,h3; XButtonEvent oo; HINSTANCE aa; int dd; LRESULT CALLBACK
WP(HWND h,UINT m,WPARAM w,LPARAM l){ if(m==513)oo.type=4,oo.x=LOWORD(l)
,oo.y=HIWORD(l); else if(m==15)oo.type=12; else if(m==2)PostQuitMessage(0);
else return DefWindowProc(h, m, w, l); return 0; } int WINAPI WinMain
(HINSTANCE a,HINSTANCE b,LPSTR c,int d){ static WNDCLASSEX w;
char*z[]={0,""1"",0}; return aa=a,w.hInstance=a,w.lpszClassName=""a"",
w.lpfnWndProc=WP,w.cbSize=sizeof(WNDCLASSEX),dd=d,w.hIcon=LoadIcon(0,32512),
w.hIconSm=LoadIcon(0,32512),w.hCursor=LoadCursor(0,32512),w.hbrBackground=1,
RegisterClassEx(&w),main(2,z); }
","#include <X11/Xlib.h>
char *l=""dbcefcbddabcddcba~WAB+  +BAW~              +-84HLSU?A6J57IKJT576,"",
*F=""          ,>>,>  xl~w/?  ,>>>,s  m\177>>\177\177  mm2>>>  >uk>>> "",*f;y,u;
#define v for (i=0,b=0;b>511?b=0,i+=64:0,i<512;b+=64) A=i/64*10+b/64+21,XCopy\
Plane(d, r[I[A]+7+14*(i+b>>6&1)+28*(A==z)],w,C,0,0,64,64,b,i,1); XFlush(d);
#define _(a) *f++=a&*F?-(z%14<7):""U\252U\0DDDD""[z/14*2|u&1],
#define G(p) p##Pixel(d,DefaultScreen(d))
#define R(a) |(a==O|p==a)*
#define P return y=~y,
#define a X(0,0,0,
#define H while(
#define D ;if(

I[304],b,i,z;main(x,W)                   char**W; { Display *d =
 XOpenDisplay(""""); Window               w = XCreateSimpleWindow
  (d, DefaultRootWindow(d),            64,64,512,512,2,G(Black)
   ,G(Black)); XGCValues g;           XButtonEvent e; int A,r
    [56],Z,* m = I , C ,Y;           XSelectInput(d,w,32772);
     XMapWindow( d, w); g.          foreground = G(White);
      C=XCreateGC(d,w,4,&g);       F+=48; H f=I,i=0,z<56){
       H u=0,i++<8){ H _(0)_(     64)_(16)_(8)_(4)_(2)_(1
       )_(0)++u<8); F++; } F-=   z%7-6?z%14<6?16:0:8; r[
        z++]=XCreateBitmapFromData(d,w,I,64,64); } srand(
       time(z=u=0)); H I[z]=-(   z>98|z<21|(z+1)%10<2),
      ++z<120); H ++m<9+I) 80     [m]=-2,90[m]=~(20[m]=7&*
     l++),30[m]=1; D 1<x) Z=       *W[1]-45; D 2<x){ a u,1
   ,Z); a u,0,1); z=0; } H          1){ XNextEvent(d,&e); D
  e.type==12){ v } D e.              type==4){ b=e.y/64*10+e
.x/64+21; D(b[I]^y)<-1)               { z=b; v} else{ i=(b<29
|b>90)&((z[I]^y)==-2)?-                6^y:z[I]; Y=y; a u,0,1);
z=0; v D 1<x&&Y-y){ a u                ,1,Z); a u,0,1); } z=0;
v Y=y,XStoreName(d,w,-                  1e6>a u,1,1)?y=~y,a u,1,
0)>1e6?y?""Black's wins"":                 ""White's wins"":""Stalemate""
:""Chess""),y=Y,z=0;} } } }


                             X(w,c,h,e,S,s)


{ int p,O=          *l,t,d,o,C          ,*g,E,n,*m          =I,N=-1e8,
          A,L,r,x =           10,q; y=~y          ; H--O>20)
{ o=I[p=O]          D q=o^y,q>          0){ q+=(q<          2)*y,C=q
         [""51#/+++""],       A=q[""95+3/33""];       do { m=0,
r=I[p+=C[l          ]-64] D !w          |p==w&&q>1          |C+2<A|!r)
          { d=abs(O-          p) D g=q<2          &e>>6==p+(
y?x:-x)?I+          (e>>6):0,           !r&(q>1|d%          x<1||g)|(r
          ^y)<-1){ n          =o,t=q<2&(          89<p|30>p)
?n+=y|1,6^          y:o+(y|1)           D (r^y)<-6          ) P 1e7-811
          *h; H n-t)          { O[I]=0,p          [I]=n,m?*g
=*m,*m=0:g          ?*g=0:0;            E=e&63 R(           91)16 R(28)
          4 R(21)2 R          (98)32; L=          (q>1?6-q?l
[p/x-1]-l[          O/x-1]-q+2          :(E|=y?8:1          ,!!m)*9:(E
          |=20-d?0:           64*p,n-o?(          l[15+n]-' '
)*9:d/8+!!          g*99))+(l[          r+15]-' ')          *9+l[p%x]-
          h-l[O%x];           L-=s>h||s==         h&L>49&1<s
?X(s>h?0:p          ,L,h+1,E,N          ,s):0 D !(          z-O|i-n|h|
          p-b|S|L<-           1e6))return         u=E; O[I]=
o,p[I]=r,m          ?*m=*g,*g=          0:g?*g=-2^          y:0 D S|h&&
          (L>N||!h&N          ==L&&rand(          )&4)){ N=L
D !h&&s) i          =n,z=O,b=p          D h&&c-L<S          ) P L; } q
          >5&d<2&C+6          <A&&(g=I+p          ,r=I[p+=p-
O],m=p<O?g          -3:g+2,!(e          &(p<O?3:5)          <<3*-y|*g|
          r|m[p<O?1:          -1])&&L>-           1e6&&1e6>a
63,1,0))?d          ++:(n+=y|1          );} } } C           +=q<2&C+3>
          A&((y?O<80          :39<O)||r)          ; } H!r&q>
2&q<6||(p=          O,++C<A))           ; } } P N+          1e8?N:0; }

","char *l=""dbcefcbddabcddcba~WAB+  +BAW~              +-84HLSU?A6J57IKJT576,"";
#define F (getchar()&15)
#define R(a) |(a==O|p==a)*
#define P return y=~y,
#define a X(0,0,0,
#define H while(
#define D ;if(

           I [
           304]
        ,b,i,z,*m=I,
        u,p,x   =10,y;
        main(      W ) {
        srand(       time(
        0)) ;           H I
        [z]             =-(z>
        98                |z<
       21|                 (z+
       1)                  %x<2
      ) ,  ++z               <
      120 );  H              ++m
     <9+  I)80               [m]
     =-                       2 ,
    90[                        m]=
    ~(             m           [20
   ]=              7           & *l
  ++      ) ,    30[            m]=
 1; H     z=19){ H++             z<
 100 )     putchar(z             %x-        9?""KQRBNP .pnbrqk""
 [7   +z [I]]    :x             )  D
 x - (  z =     F )              ) {
  i =  I [     z+=               100
    -F* x]    ; b                =F;
             b+=                 100
            -F*                  x ;
           H x                   -(p
           =F)                   ) i
          =-p                    ^y
          ; } else a u, 1, 3+W); a
            u , 0 , 1  ) ;  }  }

                             X(w,c,h,e,S,s)


{ int p,O=          *l,t,d,o,C          ,*g,E,n,*m          =I,N=-1e8,
          A,L,r,x =           10,q; y=~y          ; H--O>20)
{ o=I[p=O]          D q=o^y,q>          0){ q+=(q<          2)*y,C=q
         [""51#/+++""],       A=q[""95+3/33""];       do { m=0,
r=I[p+=C[l          ]-64] D !w          |p==w&&q>1          |C+2<A|!r)
          { d=abs(O-          p) D g=q<2          &e>>6==p+(
y?x:-x)?I+          (e>>6):0,           !r&(q>1|d%          x<1||g)|(r
          ^y)<-1){ n          =o,t=q<2&(          89<p|30>p)
?n+=y|1,6^          y:o+(y|1)           D (r^y)<-6          ) P 1e7-811
          *h; H n-t)          { O[I]=0,p          [I]=n,m?*g
=*m,*m=0:g          ?*g=0:0;            E=e&63 R(           91)16 R(28)
          4 R(21)2 R          (98)32; L=          (q>1?6-q?l
[p/x-1]-l[          O/x-1]-q+2          :(E|=y?8:1          ,!!m)*9:(E
          |=20-d?0:           64*p,n-o?(          l[15+n]-' '
)*9:d/8+!!          g*99))+(l[          r+15]-' ')          *9+l[p%x]-
          h-l[O%x];           L-=s>h||s==         h&L>49&1<s
?X(s>h?0:p          ,L,h+1,E,N          ,s):0 D !(          z-O|i-n|h|
          p-b|S|L<-           1e6))return         u=E; O[I]=
o,p[I]=r,m          ?*m=*g,*g=          0:g?*g=-2^          y:0 D S|h&&
          (L>N||!h&N          ==L&&rand(          )&4)){ N=L
D !h&&s) i          =n,z=O,b=p          D h&&c-L<S          ) P L; } q
          >5&d<2&C+6          <A&&(g=I+p          ,r=I[p+=p-
O],m=p<O?g          -3:g+2,!(e          &(p<O?3:5)          <<3*-y|*g|
          r|m[p<O?1:          -1])&&L>-           1e6&&1e6>a
63,1,0))?d          ++:(n+=y|1          );} } } C           +=q<2&C+3>
          A&((y?O<80          :39<O)||r)          ; } H!r&q>
2&q<6||(p=          O,++C<A))           ; } } P N+          1e8?N:0; }

","#include <X11/Xlib.h>
char *l=""dbcefcbddabcddcba~WAB+  +BAW~              +-84HLSU?A6J57IKJT576,"",
*F=""          ,>>,>  xl~w/?  ,>>>,s  m\177>>\177\177  mm2>>>  >uk>>> "",*f;y,u;
#define v for (i=0,b=0;b>511?b=0,i+=64:0,i<512;b+=64) A=i/64*10+b/64+21,XCopy\
Plane(d, r[I[A]+7+14*(i+b>>6&1)+28*(A==z)],w,C,0,0,64,64,b,i,1); XFlush(d);
#define _(a) *f++=a&*F?-(z%14<7):""U\252U\0DDDD""[z/14*2|u&1],
#define G(p) p##Pixel(d,DefaultScreen(d))
#define R(a) |(a==O|p==a)*
#define P return y=~y,
#define a X(0,0,0,
#define H while(
#define D ;if(

I[304],b,i,z;main(x,W)                   char**W; { Display *d =
 XOpenDisplay(""""); Window               w = XCreateSimpleWindow
  (d, DefaultRootWindow(d),            64,64,512,512,2,G(Black)
   ,G(Black)); XGCValues g;           XButtonEvent e; int A,r
    [56],Z,* m = I , C ,Y;           XSelectInput(d,w,32772);
     XMapWindow( d, w); g.          foreground = G(White);
      C=XCreateGC(d,w,4,&g);       F+=48; H f=I,i=0,z<56){
       H u=0,i++<8){ H _(0)_(     64)_(16)_(8)_(4)_(2)_(1
       )_(0)++u<8); F++; } F-=   z%7-6?z%14<6?16:0:8; r[
        z++]=XCreateBitmapFromData(d,w,I,64,64); } srand(
       time(z=u=0)); H I[z]=-(   z>98|z<21|(z+1)%10<2),
      ++z<120); H ++m<9+I) 80     [m]=-2,90[m]=~(20[m]=7&*
     l++),30[m]=1; D 1<x) Z=       *W[1]-45; D 2<x){ a u,1
   ,Z); a u,0,1); z=0; } H          1){ XNextEvent(d,&e); D
  e.type==12){ v } D e.              type==4){ b=e.y/64*10+e
.x/64+21; D(b[I]^y)<-1)               { z=b; v} else{ i=(b<29
|b>90)&((z[I]^y)==-2)?-                6^y:z[I]; Y=y; a u,0,1);
z=0; v D 1<x&&Y-y){ a u                ,1,Z); a u,0,1); } z=0;
        v } } } }


                             X(w,c,h,e,S,s)


{ int p,O=          *l,t,d,o,C          ,*g,E,n,*m          =I,N=-1e8,
          A,L,r,x =           10,q; y=~y          ; H--O>20)
{ o=I[p=O]          D q=o^y,q>          0){ q+=(q<          2)*y,C=q
         [""51#/+++""],       A=q[""95+3/33""];       do { m=0,
r=I[p+=C[l          ]-64] D !w          |p==w&&q>1          |C+2<A|!r)
          { d=abs(O-          p) D g=q<2          &e>>6==p+(
y?x:-x)?I+          (e>>6):0,           !r&(q>1|d%          x<1||g)|(r
          ^y)<-1){ n          =o,t=q<2&(          89<p|30>p)
?n+=y|1,6^          y:o+(y|1)           D (r^y)<-6          ) P 1e7-811
          *h; H n-t)          { O[I]=0,p          [I]=n,m?*g
=*m,*m=0:g          ?*g=0:0;            E=e&63 R(           91)16 R(28)
          4 R(21)2 R          (98)32; L=          (q>1?6-q?l
[p/x-1]-l[          O/x-1]-q+2          :(E|=y?8:1          ,!!m)*9:(E
          |=20-d?0:           64*p,n-o?(          l[15+n]-' '
)*9:d/8+!!          g*99))+(l[          r+15]-' ')          *9+l[p%x]-
          h-l[O%x];           L-=s>h||s==         h&L>49&1<s
?X(s>h?0:p          ,L,h+1,E,N          ,s):0 D !(          z-O|i-n|h|
          p-b|S|L<-           1e6))return         u=E; O[I]=
o,p[I]=r,m          ?*m=*g,*g=          0:g?*g=-2^          y:0 D S|h&&
          (L>N||!h&N          ==L&&rand(          )&4)){ N=L
D !h&&s) i          =n,z=O,b=p          D h&&c-L<S          ) P L; } q
          >5&d<2&C+6          <A&&(g=I+p          ,r=I[p+=p-
O],m=p<O?g          -3:g+2,!(e          &(p<O?3:5)          <<3*-y|*g|
          r|m[p<O?1:          -1])&&L>-           1e6&&1e6>a
63,1,0))?d          ++:(n+=y|1          );} } } C           +=q<2&C+3>
          A&((y?O<80          :39<O)||r)          ; } H!r&q>
2&q<6||(p=          O,++C<A))           ; } } P N+          1e8?N:0; }

","                                       /*
                                      +
                                     +
                                    +
                                    +
                                    [         >i>n[t
                                     */   #include<stdio.h>
                        /*2w0,1m2,]_<n+a m+o>r>i>=>(['0n1'0)1;
                     */int/**/main(int/**/n,char**m){FILE*p,*q;int        A,k,a,r,i/*
                   #uinndcelfu_dset<rsitcdti_oa.nhs>i/_*/;char*d=""P%""   ""d\n%d\40%d""/**/
                 ""\n%d\n\00wb+"",b[1024],y[]=""yuriyurarararayuruyuri*daijiken**akkari~n**""
          ""/y*u*k/riin<ty(uyr)g,aur,arr[a1r2a82*y2*/u*r{uyu}riOcyurhiyua**rrar+*arayra*=""
       ""yuruyurwiyuriyurara'rariayuruyuriyuriyu>rarararayuruy9uriyu3riyurar_aBrMaPrOaWy^?""
      ""*]/f]`;hvroai<dp/f*i*s/<ii(f)a{tpguat<cahfaurh(+uf)a;f}vivn+tf/g*`*w/jmaa+i`ni(""/**
     */""i+k[>+b+i>++b++>l[rb"";int/**/u;for(i=0;i<101;i++)y[i*2]^=""~hktrvg~dmG*eoa+%squ#l2""
     "":(wn\""1l))v?wM353{/Y;lgcGp`vedllwudvOK`cct~[|ju {stkjalor(stwvne\""gt\""yogYURUYURI""[
     i]^y[i*2+1]^4;/*!*/p=(n>1&&(m[1][0]-'-'||m[1][1]  !='\0'))?fopen(m[1],y+298):stdin;
      /*y/riynrt~(^w^)],]c+h+a+r+*+*[n>)+{>f+o<r<(-m]    =<2<5<64;}-]-(m+;yry[rm*])/[*
       */q=(n<3||!(m[2][0]-'-'||m[2][1]))?stdout /*]{     }[*/:fopen(m[2],d+14);if(!p||/*
       ""]<<*-]>y++>u>>+r >+u+++y>--u---r>++i+++""  <)<      ;[>-m-.>a-.-i.++n.>[(w)*/!q/**/)
    return+printf(""Can ""  ""not\x20open\40%s\40""    """"       ""for\40%sing\n"",m[!p?1:2],!p?/*
  o=82]5<<+(+3+1+&.(+  m  +-+1.)<)<|<|.6>4>-+(>    m-        &-1.9-2-)-|-|.28>-w-?-m.:>([28+
 */""read"":""writ"");for  (   a=k=u= 0;y[u];  u=2    +u){y[k++   ]=y[u];}if((a=fread(b,1,1024/*
,mY/R*Y""R*/,p/*U*/)/*          R*/ )>/*U{  */   2&& b/*Y*/[0]/*U*/=='P' &&4==/*""y*r/y)r\}
*/sscanf(b,d,&k,& A,&           i,  &r)&&        !   (k-6&&k -5)&&r==255){u=A;if(n>3){/*
]&<1<6<?<m.-+1>3> +:+ .1>3+++     .   -m-)      -;.u+=++.1<0< <; f<o<r<(.;<([m(=)/8*/
u++;i++;}fprintf   (q,    d,k,           u      >>1,i>>1,r);u  = k-5?8:4;k=3;}else
  /*]>*/{(u)=/*{   p> >u  >t>-]s                >++(.yryr*/+(    n+14>17)?8/4:8*5/
     4;}for(r=i=0  ;  ;){u*=6;u+=                (n>3?1:0);if    (y[u]&01)fputc(/*
      <g-e<t.c>h.a r  -(-).)8+<1.                 >;+i.(<)<     <)+{+i.f>([180*/1*
      (r),q);if(y[u   ]&16)k=A;if                               (y[u]&2)k--;if(i/*
      (""^w^NAMORI; {   I*/==a/*""                               )*/){/**/i=a=(u)*11
       &255;if(1&&0>=     (a=                                 fread(b,1,1024,p))&&
        "")]i>(w)-;} {                                         /i-f-(-m--M1-0.)<{""
         [ 8]==59/* */                                       )break;i=0;}r=b[i++]
            ;u+=(/**>>                                     *..</<<<)<[[;]**/+8&*
            (y+u))?(10-              r?4:2):(y[u]         &4)?(k?2:4):2;u=y[u/*
             49;7i\(w)/;}             y}ru\=*ri[        ,mc]o;n}trientuu ren (
             */]-(int)'`';}             fclose(          p);k= +fclose( q);
              /*] <*.na/m*o{ri{                       d;^w^;}  }^_^}}
               ""   */   return  k-                -1+   /*\'   '-`*/
                     (   -/*}/   */0x01        );       {;{    }}
                            ;           /*^w^*/        ;}
","d b,x,h;o q[9802],f[9802];void w(d i){fflush(stdout);printf(
""%c""  ,   (  i>b)?(i%b>0?q[i-b-1]:10):5*(b==i?2:9));if(i<x+b
-      1     )w(i+1) ; } d p(o*e,d i ) { e +=i;n h = ( - b-1
)         [                 e ] %         2 + ( -          b
)  [ e  ] %     2                                          +
(-b+1)[ e            ]  % 2         +(       -     1  ) [  e
]  %  2+  e  [1   ]% 2 +b [  e   -  1]% 2  +    b[ e ]% 2  +
b     [      e+1 ]     %2      ;}d m (  d      i     ){    n
(  i  == x -       1      )      ?0     :(  f    [      i  +
1  ]=m                 (i +       1) ) ,32           +3 /  (
(    p( q  ,   i  )>  3      ||    h <  2       )?  7      :
( ( h                   ==        2 &&q[ i ]          ==  32
      )?    8 :             1 )     );}d                   y
(       d                          i ){ d   j , s , t ,a  ,u
;if (     x - 1== i ) n 1 ;if ( f            [i]==2)       {
f [i ]     <<=4;if(y( i))n 1;f[i           ]-=- 3 ; if     (
y(i )       )n 1;n  0 ; };if((i % b              )     ==   
             0 ||(       i % b          )   ==            b-
1         )               n        y (i+1           )     ;j
=    -1 ; l           :           ;    j   =j     + 1 ;     
if   (  j    >=    (  i  -      i   /  b +        2         
   == b          ? 1 :   i       >     2       * b ?i%   b!=
    1    ?2       :    2          *   1<<     1 :8 ))   goto
c;     u       =   p(  f,   i  ) ; if  (        i          <
x  - 2*b - 1   )  { a =( s       =((  t=i       %   b==     
       1)           ?    1      :    i % b          !=     b
   - 2     )   )      &&     i   <            2 * b;u+=    (
a                ? (                                j& 4   )
>>    2 : 0 ) +  (t  ?    ( j & 2 ) / 2 : 0)  +            (
s? (   j&1):0);}else a =t=s=0;if((u&2)+(u&4)!=          2 &&
(q[   i]& 2 ) ==2||u==2&& (f[i]+q[i]) % 2   ==1          ||u
== 3            && ( q [   i]&2)== 0                    )   
                             goto             l      ;     b
[i        +   f          ]     ^=       !          t ?     0
 :   b[ i +       f ]  ^ (         10 + (      j &      2  )
/    2  )     * 3+2;b[ i    + f    +  1    -    b  ]  ^=   !
a  ?0 :           b  [i  +  f    +1 -          b]^   (10+  (
j   &    4)          /            4    )*  3   +2 ;    b [ i
+f     +       1  ]  ^= ! s   ?0     :       b  [i+ f  +   1
]  ^ (10 + (   j  &1)            ) *3+ 2 ;      if  ( y (  i
+      1)           ){ n  1  ;       };          (  a      ?
i  + 1     :     0 )             [ f     ]            =(   t
?                    i+                           b       :0
)       [ f                 ] =       (     s ?           i 
   + b +1:0) [ f ] =     2 ;goto l ;       c:n 0 ; }       d
  main(d c,o**v){d i; x=b=0;while((q[x++]=getchar()   )   !=
  EOF ){x-=(q[x-1]==10)? b+=1,1:0;q[x-1]^= (q[x-1]        ==
32)? 0  :  q [   x  -        1 ] ^ 35  ; } ; w (   0      );
for                           (                        ;   ;
)       {         z    ( f            ,         2 ,  x *    
     k  (  o       )  )  ;   for   (  i  =    0;i<=x -    1;
i  = i +   b  )q [   i /    b]   = q [   x      -  b+  i  /b
]   =    q       [ i  ]=  q       [    i           -       (
(i   ==  0)           ?            0:  1)       ]  =f [ i  /
b   ] = f[ x      -b -1+ i/  b]   = f [i ]      =f[         
      i    -          (             (    i        == 0  )  ?
0       :1        ) ]  =        32;   if       ( c        ==
1           ) m (         0                        );   else
if          (y (     b                      +             1)
==0)n 1;f[0]<<=1<<2;memcpy(q,f,x*k(o));w(0);sleep(1);};n 0;}
","#     include                              <math.h>
#     include                              <stdio.h>
#     define                               d double
d     a,s;int     n;p(d t                  ,d M,d x)
{     return      x>0?x>1     &&!fork(     )?p(t,s+=
a     ,x-1):0     :scanf(     ""%lf"",&x     )-1?a=(M-
t     )/22,s=     pow(10,     (int)(       log10(a))                /*It is
a     simple      tool to     quickly      analyze                  data. */
-     2),s=t-     (a =s*(     int)(a/s     ))/2,p(t,                s,(int)(
(     a+M-t)/     a)):p(t     >M|x<t?x     :t,t>M|x     >M?x:M      ,--n)+(x
>     s&&x <=     s+a); }     main(j){     j==1?j=p     (1,0,0)     ,printf(
""%+12g %4d"",s+a/2,j,wait(NULL)),main(j*400/n):putchar(35-25*!j)&' '&&main(j+1);}
","#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <stdio.h>
#include <math.h>
#include <time.h>
#define _ float

                  _ CRUSH(_*LEG,int ARM,_*FINGER) {
         _ GORE; for(GORE=0,--ARM; ARM>=0; --ARM)GORE+=FINGER[ARM]*ARM
     [LEG]; return GORE; } _*BITE(){ _*BRAIN=calloc(sizeof(_),1<<17);int TOE
  =getc(stdin),EYE,SKULL=0; while((EYE=getc(stdin))!=EOF){ ++BRAIN[(TOE<<8) +
 EYE]; ++SKULL; TOE=EYE; } if(SKULL)for(TOE=0; TOE<8<<13; ++ TOE)BRAIN [TOE]/=
 SKULL; return BRAIN; } _ CHEW(_*GUT,_ BONE[][1<<16]){ int GRR; for(GRR=0; GRR<
 6; ++GRR){ GUT[GRR+256*256]=powf(1+expf(-CRUSH(BONE[GRR],1<<16,GUT)),-1); BONE
 [6][50+GRR]=GUT[256*256+GRR]*(1.-GUT[(8<<13)+GRR]); } BONE[6][81]=1/(1 +expf(-
 CRUSH(GUT+(1<<16),6,BONE[6]))); return BONE[6][82]=BONE[6][81]*(1.-BONE[6][81]
 ),BONE[6][81]; } _ GNAW(_ FLESH,_ LEG[][2<<15],_*EYE){ int UG,MMM; LEG[6][13]=
 FLESH-CHEW(EYE,LEG); LEG[6][14]=LEG[6][ 82]*LEG[6][13]; for(UG=0; UG<6; ++UG){
 LEG[6][34]=LEG[6][UG+(1<<7)-14]*LEG[6][7<<1]*LEG[6][UG]; for(MMM=0; MMM<4<<14;
 ++MMM)LEG          [UG][MMM]+=LEG[6][34]*.3*EYE[MMM]; LEG[6][UG]+=.3*LEG[6][14
  ]*EYE[               256*256+UG]; } return powf(LEG[6]          [13],2); } _
  **EAT(               char*TOMB){ DIR*BONE = opendir(               TOMB); int
  BRAIN=               0; struct dirent*TOOTH; _**BODY               =0; while
 (BONE?(TOOTH=        readdir(BONE)):0){ if(  TOOTH->                d_name[0]
 !=46){ char*MOAN=malloc(strlen(TOMB)+strlen(TOOTH->d_name       )+1); sprintf(
 MOAN, ""%s%s"",TOMB,TOOTH ->d_name); if(freopen(MOAN, ""r"",stdin)){ BODY=realloc(
 BODY,sizeof(_*)*(BRAIN+1)); BRAIN ++ [BODY]=BITE(); } } } return BODY=realloc(
 BODY,(1+BRAIN)*sizeof(_*)),BODY[BRAIN]=0,BODY; } int main(int GRR,char **UGH){
 _ BRAINS[7][1<<16],***CORPSES; int PUS,OOZE,UG; for(srand(time(0)),PUS=0; PUS<
  7; ++PUS)for(OOZE=0; OOZE<4<<14; ++OOZE)BRAINS[PUS][OOZE]=rand()/(_)RAND_MAX
   -.5;fread(BRAINS,sizeof(BRAINS),1,stdin); if(*UGH[1]==45){ GRR-=2; CORPSES
    =malloc(                                                         sizeof(_
    **)*GRR                                                           ); for(
     PUS=0;                                                             PUS<
    GRR; ++             PUS)CORPSES[PUS]=EAT(UGH[2+PUS]);             for(UG=
     0; UG<atoi       (&(UGH[1][1])); ++UG){ BRAINS[6][97]=       0; for(PUS
      =0; PUS<GRR; ++PUS)for(OOZE=0; CORPSES[PUS][OOZE]; ++OOZE)BRAINS [6][
        97]+=GNAW(1.-(_) PUS/(GRR-1),BRAINS,CORPSES[PUS][OOZE]); fprintf(
         stderr,""%d: %f\n"",UG,BRAINS[6][97]); } fwrite( BRAINS, sizeof(
          BRAINS),1,stdout); } else for(UG=1; UG<GRR; ++UG)if(freopen(
              UGH[UG],""r"",stdin))fprintf(stderr,""%s %f\n"",UGH[UG],
                       CHEW(BITE(),BRAINS)); return 0; }
","#include <stdio.h>
#include <math.h>
#include <unistd.h>
#include <sys/ioctl.h>

             main() {
         short a[4];ioctl
      (0,TIOCGWINSZ,&a);int
    b,c,d=*a,e=a[1];float f,g,
  h,i=d/2+d%2+1,j=d/5-1,k=0,l=e/
 2,m=d/4,n=.01*e,o=0,p=.1;while (
printf(""\x1b[H\x1B[?25l""),!usleep(
79383)){for (b=c=0;h=2*(m-c)/i,f=-
.3*(g=(l-b)/i)+.954*h,c<d;c+=(b=++
b%e)==0)printf(""\x1B[%dm "",g*g>1-h
*h?c>d-j?b<d-c||d-c>e-b?40:100:b<j
||b>e-j?40:g*(g+.6)+.09+h*h<1?100:
 47:((int)(9-k+(.954*g+.3*h)/sqrt
  (1-f*f))+(int)(2+f*2))%2==0?107
    :101);k+=p,m+=o,o=m>d-2*j?
      -.04*d:o+.002*d;n=(l+=
         n)<i||l>e-i?p=-p
             ,-n:n;}}
","#include<stdio.h>
void exit(int);
int(*Q)(int,char**),b['['+']']={'-'-'-'},i,j,s,t,D['C'*' '-'-'],z,system(char*);
char O['C'*' '-'-'],p[]=""@cs                                                              \""$ | ,&    |& (&)x ) &,(   ,(| ,(    ,{      |,},;   ,( ;,>   ,(  ,( ,;,       );g cgt3odt  -  <~+<+-       +            ~ <&~<~+ <&+~+  ~ <=-  =       (  -                                                              !()  c  !(&(                                                              !                                                              \n$P    & m& )P )o )e')\"")\""' ) w_ 'w)e ')x') ')q 'a_ )x'\""up)q                                 &]v\"")    &t  &t-k[]t\\.nivc -:l O   CI:OnO lCl  ={ -: =(-      +[=+        =C         =]\\.[-       & -   ~ -(|,g& -&-        <- ( ~ -g()=  Q| b)  *,t,       Q-            ( -   (\n& ~  &      Q  \n &\n,&g r& \n&   \n  ,&~\nt &=\n &n) rt)+=\n&  (~  &k=  &g(-&=  (Q -(  P  ) \n )\n  ) \""+\""' )z\""ujlpx)\""*bgQ Px )(\"")x)\"" P     \""P\""'i x  )\"")m') axP            \"")\""  Pv    pP)e  )O\""_\""apvP(t(c  )d) \"")\""pqpmpleP  \""*te\"" t\n \""]   \""O_\""  g c *P      )\"" =+   *   r\n&r\nr     \n! *  (*  (*      +      *.            )x      ')+)      +)*    ,\n )&* +  ma +) 'j     )d)' m)O )e)nc  )m )n         ) ')\""'jl   _) _)_  )nps' )cix'iml )tit_eqp)m )rcnMm+wnhdl)esakn )\"")ryPiam)O)v} no)zdOui   =(  \""    '+'= ~(=(= (\n= ()=(@_& ~@'                   (        = '%; go. PO  'x )p)g                   <h  )kh    )      \""k\""  M ai)  <eu  +    =z q   =x    =eowe  =v+kO= c=  !    =dMe ij lmp         c     p      _) c_O    |tp=^ c sz^o ^sibnj^jis <^q^e aQ ^ thug^eiawyq=!=a<]= vhyh >      '@  =\n   '= &=,-\n=,=\n (&  [ ()*        ,  *  ,*= )& (\n, \n  , \n   ,& ,*('l'c )    l \\  's 'l' ci lcad eilm nq_dkv<=-^      (@,       \n(&  !\n=, (  , (/\n @ m       h =*(.c. (&'  ( =,(=(|  (|(|(|\n&(,&  [g(, (,\n tni^-,=(=(u t&(=)(~,=d(,( = ,sep wpg\n@\nan,\n&,*  n  a,$=,=|\n.(       c'=~,~,=(,\n=(,[(o ad#( \n    (d x=~,\n,='e,  ( =   '~),~=(,        O=\n  ( oc -~= ,\n =<, <=,(@='\\i|~ i~, =\n =i   o       i=-\n,i(=v t   l t l      *   ,+ *+     *, p u=\n!=,\n(=,(   e       a*=, \n=\n[f(< n~('n i   n,n \n,eu s(  ,|&^,(=l op='&|,\n ,+\n^\n !,(= o, =/-=(/=%+ , e, (= ,()=               |     ]   |OtvO)\n    )      \n)k   ')n\n'                   -   (=( | - ( >      - =("";
FILE*f;
int main(int _,char**v){
_>(_^_)&&(t=_,i='C'*' '-'-'+~!!"""",Q=main,Q(-!!"""",v),i^=i,Q(~!!"""",v),i=s^=s,Q(~-~!!"""",v),i='C'*' '-'-',j=-~('('*'('),Q((-~!!""""*~!!""""),v),
f=fopen(O,""w""),fprintf(f,O+~-(~-~!!""""*~!!""""),'C'*' '-'-'-((~!!""""*~!!"""")*''+-~-~!!""""),O+((~!!""""*~!!"""")*''+-~-~!!"""")),fclose(f),
sprintf(p,O+(~-(~-~!!""""*~!!"""")<<!!"""")),i=!!"""",Q(~-(-~!!""""*~!!""""),v),exit(system(p)),'r')
||
_==~!_&&i>=(i^i)&&
((p[i]==' '&&(p[i]=(-~i)[p])||p[i]=='@'&&(p[i]=' ')||p[i]=='$'&&(p[i]^=p[i])),i=~-i,Q(_,v))
||
_==~!!""""&&i<'C'*' '-'-'&&(D[i]=~-(i[p][b]=-~i[p][b]),i=-~i,Q(_,v))
||
_==~-~!!""""&&i<(!!""""<<-~(~-~!!""""*~!!""""))&&(z=b[i],i[b]=s,s+=z,i=-~i,Q(_,v))
||
_==(-~!!""""*~!!"""")&&-~(i=~-i)&&(i[O]=p[j],j=D[j]+j[p][b],Q(_,v))
||
_==~-(-~!!""""*~!!"""")&&i<t&&(sprintf(p,""%s %s"",p,i[v]),i=-~i,Q(_,v));
}
","typedef unsigned char t;t*F=""%c"",l[]=""|\\/=_ \n](.\0(),*(.(=(}*.)[[*."",N='\n',*
r;typedef(*H)();extern H Ar;Q(a){return(a|-a)>>31;}H S(c,a){return(H)(a&~c|(int
)Ar&c);}extern t*ist;V(t*u){*u^=*u&2^(*u>>7)*185;}Z(t*u,t n){*u-=n;}e(t c,H h){
R(h,Q(*                                                                 r^c));}
I(){r=l                                                                 +7-4*Q(
getchar                                                                 ()^*l);
}R(H h,                int                                              c){Ar=S
(c,h);-                main()                                           ;}P(){r
++;}z()                {                                                O(&N);}
O(t*c){                    printf(                                      F,+*c);
}T(){r=                        ""This is not a function\n""               ;}w(U){
U=Z(r,8                    );                                           r-=~Q(*
r/8-4);	                   return 0;                                    }M(){r=
ist-68;                }                                                h(){t G
=r[1]-r                                                                 [2]^*r;
G^=30;V                                                                 (&G);e(
0,(O(&G                                                                 ),P(P(*
r++)),z));}g(){M();R(h,0);}f(){P(O(r));e('f',g);}p(){P();e('a',f);}d(){P(O(r));
e('n',p);}c(u){u=r[-2];T(Ar=d);R(f,Q(u^'""'));}n(){e(w(O(l+*r%8)),c);}a(){I();R(
n,0);}main(){S(Q(Ar),a)();}H              Ar;t*ist=""Rene Magritte""-(1898-1967);
","#include<stdint.h>//       4                                                
#include<stdio.h>/*      76.                               1                
                         ..2321     1       57             3                
                         21....     .       ..             .11         1   2
                    1  88..1321  2  33    5512      1      277        14   1
                    099..12....  .  ..    ....    1 4 11111...111 122 5.1  .
                  11...221.821112411123455676489  51.176543232666 902 .27  1
                  10111...1.....................11.417...........1...21..11.
                  ..2239921176566156225563322299887...6533233233182469196894
                  22...............................111......................
*///              3269548556987776665556662131223412347543332334543322223456
/*                                                                          
          13.3.37 */char C[120]  [60   ];int R[120][60],W,H,J,K,B[61][61],/*
          12.2.39 */r,i,j,c,*q  =&   H,t=7200,x,y,k;int64_t*U,T[28800],*S=/*
          11.2.40 */T,O[120],  Z[   120],v,z;void D(){for(k=-1;7200>++k;S[/*
            10.39 */k]=v)r=!         ~(v=U[k])&&*R[k/60]?2:S[k]-v?1:r;;;;}/*
             9.36 */void L(             ){for(r=1;r==1;){r=3;;for(i=0;120>/*
             9.31 */i;i++){                  for(k=z=1,j=0;v=R[i][j];j++)O/*
           8.3.32 */[i]|=(  1LL             <<v)-1<<k,k+=v,0,Z[i]=z|=1LL<</*
           7.3.30 */k++;;  v=~                (3LL<<k-2);for(j=-61;++j<60;/*
           5.3.29 */v=(   v|~                  z)&(j<0?v>>1:v<<1|1))v=S[60/*
       3.1.3.1.28 */*         i    +(j        < 0?~j:j)]|=j?v:~3;}for(z=0;/*
         1.2.4.31 ;         */    7200       >z;z++)i=z/60,j=z%60,(B[i<60?/*
           7.5.31     */i:j][   i<60?        j:i-60]=~S[z]&O[i]?~S[z]&Z[i]/*
         1.6.5.30 ;  */?r=0    :(U=O          ,1):(U=Z,2))?k=i<60?j+60:j,S/*
       5.10.12.16 */[i%    60+60*k]|=         ~U[k]:0;U=S;  S-=t*=-1;D();z/*
    5.11.5.4.12.4 */*9;  }}int main(          ){for  (;K=  scanf(""%d"",R [*/*
    15.2.4.4.11.5 */q+c*60]+j)<1?          q= &W,j  --,2   >++c:'\n';j =-K/*
   16.3.4.2.2.5.5 */+getchar()?j+1        :++ *q*0   );     L(   );;if (!r/*
         14.8.7.3 */)for(K=0;K<W          *60;K++)              if(K%60  </*
     12.1.4.1.6.2 */W&!B[K/60]          [ K%60 ]                  ){for(  /*
       11.3.4.6.1 */c=64;c--;         )if (!(1                     &S[K/*  ;
     10.1.8.8.5.1 */]>>c))U=        S ,000,S+=         J=14400,     D()/*  ;
         9.8.11.5 */,S[K]=~         (1LL<<c)         ,L(),S-=J,S    [K]/*   
    9.5.6.1.2.4.1 */|=r==2?          1LL<<          c:0;L(  ) ;}     q=/*  ;
        9.3.5.1.5 */&K;;for           (J=          K=i=0       ;    120/*   
        3.2.6.5.1 */>    i;                       Z[i]=k            --,/*  ;
        2.6.3.5.1 */                             i>59?q    =&J     :0,/*   ;
    2.1.2.6.3.6.1 */ *     q<                    k?*q=k    :0,    0,C[/*   ;
2.1.2.2.1.5.2.5.1 */ i  ++  ][                k  ]=' '     ){     j=k/*    ;
    2.1.2.5.5.6.3 */ =  0;  for(;         x=R[i  ][j++]            ;/*      
      4.1.9.7.5.1 */0)  k  +=sprintf   ((00,C[    i]+/*                    ;
       5.19.6.1.2 */k), ""%d."",x);}i=~J;;r&1       ||puts        (         /*
         24.6.3.3 */r?""invalid"":""failed"");         for(;i      <H;       i/*
     24.1.2.9.7.4 */++,puts(""""))for(j=~K;j  <  W;  )putchar( i<0?j<0    ||/*
        25.1.2.25 */(k=i+Z[j+60])<0?' ':C[j +  60  ][k]:j<00?(k=j+Z[i])<0?/*
          28.1.26 */' ':C[i][k]:""?X ""[B[i][j]]  ) ,j++;return 0;} /* 2012 */
","#include <stdio.h>
#include <math.h>
#define clear 1;if(c>=11){c=0;sscanf(_,""%lf%c"",&r,&c);while(*++_-c);}\
  else if(argc>=4&&!main(4-(*_++=='('),argv))_++;g:c+=
#define puts(d,e) return 0;}{double a;int b;char c=(argc<4?d)&15;\
  b=(*_%__LINE__+7)%9*(3*e>>c&1);c+=
#define I(d) (r);if(argc<4&&*#d==*_){a=r;r=usage?r*a:r+a;goto g;}c=c
#define return if(argc==2)printf(""%f\n"",r);return argc>=4+
#define usage main(4-__LINE__/26,argv)
#define calculator *_*(int)
#define l (r);r=--b?r:
#define _ argv[1]
#define x

double r;
int main(int argc,char** argv){
  if(argc<2){
    puts(
      usage: calculator 11/26+222/31
      +~~~~~~~~~~~~~~~~~~~~~~~~calculator-\
      !                          7.584,367 )
      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
      ! clear ! 0 ||l   -x  l   tan  I (/) |
      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
      ! 1 | 2 | 3 ||l  1/x  l   cos  I (*) |
      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
      ! 4 | 5 | 6 ||l  exp  l  sqrt  I (+) |
      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
      ! 7 | 8 | 9 ||l  sin  l   log  I (-) |
      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(0
    );
  }
  return 0;
}
","main(_,l)char**l;{6*putchar(--_%20?_+_/21&56>_?strchr(1[l],_^""pt`u}rxf~c{wk~zyHHOJ]QULGQ[Z""[_/2])?111:46:32:10)^_&&main(2+_,l);}
","#ifdef AH
#include<alloca.h>
#endif
#include<setjmp.h>
#include<stdio.h>
#if !NM
#include<sys/mman.h>
#endif
#define vo volatile
#define A(x,y,z) O(x,y,z##1)O(x,y,z##2)O(x,y,z##3)
#define B(x,y) A(x,y,1)A(x,y,2)A(x,y,3)
#define C(x,y) B(x,y##1)B(x,y##2)B(x,y##3)
#define D(x) C(x,1)C(x,2)C(x,3)
#define E(x) D(x##1)D(x##2)D(x##3)
#define G E(1)E(2)E(3)
#define S d->
#define M S a
#define R(x) ; S r(#x);
#define L(x,y) S l[x](d)R(y)
#define F(x) void l##x(vo dt d) {
#define Q(x); M--; *M=*M x M[1]; R(x)
#define O(x,y,z) x##y##z,
#define q typedef
#define H 9<<16
#define I case
#define J(i) calloc(i,1)
#define W(c) e=(k*)memcpy(e,x[(u)c],y[(u)c])+y[(u)c];
#define N break; I
q char k;
q void o;
q int u;
q o(*f) (vo o *);
q struct {
    u *a, **R, *m, h, c;
    k **s;
    f *l, *j, r;
} *dt;
u m[] = { G 0 } ;

u n[H];
dt st;
u sk[H];
k *w;
o *x[H];
u y[H];
k *j, *e;
u l=256;
o g(u v)
{
    if (v > l) {
        g(v / l);
        g(l);
        W('*') g(v % l);
    W('+')} else {
    W(m[v])}
}

f K(k * p, dt d)
{
    k c, n = 0;
    f r = (f) e;
    W(1) while ((c = *p)) {
        switch (c) {
          I '#':
            while (*++p != 10);
          N '[':c = 1;
            S s[S c] = ++p;
            for (; c; p++) {
                if (*p == '[')
                    c++;
                else if (*p == ']')
                    c--;
            }
            p[-1] = 0;
            g(S c++);
          N '!':n = 1;
            c = *++p;
            if (!(c & 1))
              I '<': I '>':
                c ^= 2;
          I '=':W(c) if (n) {
                W('!') n = 0;
            }
            g(*++p);
            W('|') p++;
          N 's': I 'S': I 'l':
          I 'L':g(*++p);
            W(c) p++;
          N '_':p++;
        default:
            if (isdigit(*p)) {
                g(atoi(p));
                while (isdigit(*p))
                    p++;
            } else
                p++;
        W(c)}
    }
    W(2) return r;
}

o t(vo dt d)
{
    S r(""\01"") Q(+)Q(-)Q(*) * M = -*M;
    R(_)Q( ==) Q(<)Q(>) * M = !*M;
    R(!)M[-1] ^= *M;
    *M ^= M[-1] R(r) M[1] = *M;
    M++ R(d) * S R[*M] = M[-1];
    M--;
    R(s) * ++S R[*M] = M[-1];
    M--;
    R(S) * M = *S R[*M];
    R(l) * M = *S R[*M]--;
    R(L) L(1, /)L(2, p) L(3, x) L(4, |)
#undef O
#define O(x,y,z) *++M=S m[(x*S h+y)*S h+z]; S r("""");
    G S l[0] (d);
}

o T()
{
}

o rd(u v)
{
    k *a = 0, **b = &a, **c = b + 32;
    x[v] = w;
    for (; b < c && (*b < w || *b > (k *) T || *b == (k *) (long) v); b++);
    if (b == c) {
        jmp_buf *j = alloca(sizeof(*j));
        setjmp(*j);
        rd(v);
    } else {
        y[v] = *b - w;
        w = *b;
    }
}

q o(*rt) (u);
vo rt rs = rd;
o re(vo k * rec)
{
    static u i = 0;
    *(st->a = sk + 9) = 0;
    rs(*rec ? *rec : m[i++]);
} F(d) M--;

*M /= M[1];
} F(p) printf(""%d\n"", *M);
} F(x) u n = *M--;

if (!S j[n])
S j[n] = K(S s[n], d);
S j[n] (d);
}

F(1) M -= 2;
if (M[1])
{
M++;
*M = *S R[M[1]];
lx(d);
}
}
o *lib1[] = { T, T, T, T, T } ;
o *lib2[] = { T, ld, lp, lx, l1 } ;

u main()
{
    u i;
    k *b;
    dt d = st = J(sizeof(*st));
    M = sk + 9;
    S R = J(l * sizeof(k *));
    for (i = 0; i < l; i++)
        S R[i] = J(H);
    S m = n;
    S s = J(H);
    S l = (f *) lib1;
    S j = J(H);
    S r = (f) re;
    for (i = 0; m[i]; i++)
        n[m[i]] = i;
    w = (k *) t;
    t(d);
    x[2] = w;
    y[2] = (k *) T - w + 8;
    S h = 100;
    S l = (f *) lib2;
    S r = (f) T;
    j = e =
#if NM
        malloc(H);
#else
        mmap(0, H, -1, MAP_PRIVATE | MAP_ANON, -1, 0);
#endif
    while (b = fgets(malloc(999), 999, stdin))
        ((f) K(b, d)) (d);
}
","/*
** Translation layer to make my 3D Tanks game (20th IOCCC, best non-chess game)
** to work in Windows
**
** by Oscar Toledo G.
** http://nanochess.110mb.com/
**
** From the original game replace:
**    #include <X11/Xlib.h>
**    #include <X11/keysym.h>
**
** with this:
**    #include ""layer.c""
**
** Only tested with Dev-C++ 4.9.9.2
**
** Creation: Feb/10/2012.
*/

#include <windows.h>            /* Windows headers */

extern int L[];                 /* Keyboard table from game */

/*
** Original makefile translated
** Choose your keys if you like
*/
#define A VK_UP:0x57
#define B VK_LEFT:0x41
#define C VK_RIGHT:0x44
#define D VK_DOWN:0x53
#define E VK_BACK:VK_TAB
#define Q XFillRectangle(W,X,Y,

/*
** Some X11 definitions translated
*/
#define main ma
#define Display int
#define GC HDC
#define Pixmap HBITMAP
#define Window HWND
typedef struct{ int foreground; int line_width; } XGCValues;
typedef struct{ int type,X; } XEvent;

/* XNextEvent, read Windows messages */
#define XNextEvent(a,b)(GetMessage(&mm,0,0,0),TranslateMessage(&mm),\
  DispatchMessage(&mm),*b=oo,oo.type=0)
/* XOpenDisplay, not needed */
#define XOpenDisplay(a)NULL
/* XSelectInput, only needs to process second argument */
#define XSelectInput(a,b,c)b
/* XCreateSimpleWindow */
#define XCreateSimpleWindow(a,b,c,d,e,f,g,h,i)CreateWindowEx(0,""a"",""3D Tanks"",\
  0xcf0000,c,d,e+8,f+32,0,0,aa,0)
/* XMapWindow, activate window and get DC to draw */
#define XMapWindow(a,b)(ShowWindow(b,dd),h1=GetDC(b),h3=CreateCompatibleDC(h1))
/* XPending, check for pending windows messages */
#define XPending(a)PeekMessage(&mm,O,0,0,PM_NOREMOVE)
/* XFlush, not needed */
#define XFlush(a)
/* XLookupKeysym, argument processing and returns key index */
#define XLookupKeysym(a,b)(b,(a)->X)
/* DefaultDepth, not needed */
#define DefaultDepth(a,b)0
/* XCreatePixmap, creates a double-buffer bitmap */
#define XCreatePixmap(a,b,c,d,e)CreateCompatibleBitmap(h1,c,d)
/* XCreateGC, instead selects bitmap for drawing */
#define XCreateGC(a,b,c,d)(SelectObject(h3,b),h3)
/* XChangeGC, selection of color and line width, all this is required */
#define XChangeGC(a,b,c,d)(rr!=INVALID_HANDLE_VALUE?DeleteObject(rr):0,\
  (d)->foreground=((d)->foreground&0xff0000)>>16|((d)->foreground&0xff)<<16|\
  (d)->foreground&0xff00,\
  rr=CreateSolidBrush((d)->foreground),\
  e2=CreatePen(PS_SOLID,(d)->line_width,(d)->foreground),\
  SelectObject(b,e2),\
  e1!=INVALID_HANDLE_VALUE?DeleteObject(e1):0,e1=e2)
/* XCopyArea, copies double buffer into main for non-flickering display */
#define XCopyArea(a,b,c,d,e,f,g,h,i,j)BitBlt(h1,i,j,g,h,h3,0,0,SRCCOPY)
/* Some windows variables required */
HBITMAP bb;
HBRUSH rr = INVALID_HANDLE_VALUE;
HPEN e1 = INVALID_HANDLE_VALUE, e2;
PAINTSTRUCT pp;
HDC h1, h2, h3;
XEvent oo;
HINSTANCE aa;
int dd;
MSG mm;
/* Main message processing */
LRESULT CALLBACK WP(HWND h,UINT m,WPARAM w,LPARAM l)
{
  if (m==WM_KEYDOWN&&L[w]==0)oo.type=2,oo.X=w;
  else if (m==WM_KEYUP&&L[w]==1)oo.type=3,oo.X=w;
  else if (m==WM_PAINT)BeginPaint(h,&pp),EndPaint(h,&pp);
  else if (m==15)oo.type=12;
  else if (m==2)exit(1);/*PostQuitMessage(0);*/
  else return DefWindowProc(h, m, w, l);
  return 0;
}
/* Main function */
int WINAPI WinMain(HINSTANCE a,HINSTANCE b,LPSTR c,int d)
{
  static WNDCLASSEX w;
  return aa=a,w.hInstance=a,w.lpszClassName=""a"",
  w.lpfnWndProc=WP,w.cbSize=sizeof(WNDCLASSEX),dd=d,
  w.hIcon=LoadIcon(0,IDI_APPLICATION),
  w.hIconSm=LoadIcon(0,IDI_APPLICATION),
  w.hCursor=LoadCursor(0,IDC_ARROW),
  w.hbrBackground=GetStockObject(BLACK_BRUSH),
  RegisterClassEx(&w),
  main();
}
/* XFillRectangle, note that X uses size and Windows uses coordinates */
void XFillRectangle(int *a, HBITMAP b, HDC c, int d, int e, int f, int g)
{
  RECT rect;

  rect.left = d;
  rect.top = e;
  rect.right = f + d;
  rect.bottom = g + e;
  FillRect(c, &rect, rr);
}
/* XDrawLine */
void XDrawLine(int *a, HBITMAP b, HDC c, int d, int e, int f, int g)
{
  MoveToEx(c, d, e, NULL);
  LineTo(c, f, g);
}
","#include <X11/Xlib.h>
#include <X11/keysym.h>
#define I XDrawLine(W,X,Y,
#define l rand()%
#define R while(
#define n *h++
#define x _ c].
#define S if(
#define _ _[
			    *h ;
			M=512; i; N=
		    288; e; d; u; p; L[1
		<<28]; float w=11.46; m; a ;
	    P; k[9304]; *j=k; c; f; q; r; t; v ;
	* z; K(N,i) { t=u*+cos(N/w)-i*sin(N/w); p=i*
    cos(N/w)+u*sin(N/w); u=t; } Display*W; GC Y;  Pixmap
X; s(o,t,g,w,v) { h=v+k; q=2*n; R u=n, r=12+n, K(t,n), K(o,+
    p+w,u+=g), d=1>p?1:p, u=u*N/d+M/2, d=N/2+r*N/d, u=u>
-M*2	?u<M*2?u:2*M:-2*M, 1&q?i>0|p>0?I f,e,u,d):0:	(i=p
,e=d,f=u    ), --q); } struct{ int c,o,m,f,u,s,i    ,e,r;  }
_   21	]  ;	Window O; b(y) { XGCValues g	;     g    .
foreground=y; g.    line_width	=  2   ;    XChangeGC(W,Y,20
,&g); } G(o) { z=x f	+ k; h=(x f=	381+193*c)+k; i=2*(n
=*z++); R--i&1?d=l 9-4,e    =l 9    -4*(8>o):0,n=*z+++d,0<(n
=*z+++e)?h[-1]=0:0,n=*z+++d,	i); } g(o) { u=0; K(x s,o<<9
); x u-=u; x r-=p; } F(m,c )	{  f=5120*c; c=12; R +c--&&m
==+c |abs(x u-_ m].u)>f |x i	<1|x c>2 |abs(x r-_ m].r)>f)
; return c+1; } T(o) { c=11;	S!P){ a=++a%72; S!a){ P=1; R
c--){ x c=x m=0; x i=c>2?2:1	; R x u=l 978-499<<8, x s= l
71, x r=l 979-501<<8, F(c,2)	); x f=c>2?l +2*+73:147; x o
=2>c?249<<16-c*8:64987<<8*(c	>2); } } } S P){ c=11; R 4&x
i? ++x m-64&&x m-71? o=1,64>	x m?(d=F(c,1))?x m=64,d<4?j[
x e]++,++_ --d].c:0:g(7):G(x	m -65) :_ x i=0,x e].e-- :0,
20>++c); c=3; R c--) { S 1&x	i) { o++; S x c>2) x m>15? x
i=0:G(x m++); else { S x m )	S x m-->6) g(4); S c<2) {  x
s=(72+x s+L[c?B]-L[c?C])%72;	S d=4*L[c?A]-L[c?D]*4) { g(d
); S F(c,2)) g(-d); } S L[c?	E]&!x m&x e<3) { d=10; R _++
d].i) ; g(-4); _ d]=_ c];  _	d].e=c; x e++; x m=7; c=d; x
f = 122 ; x i=4; g(19); x o=	4092<<12; c=x e; } } } } } P
-=o<2; } v=2; R v--){ m=(108	- _  v].s)%72; b(3^_ v].c?0:
128); Q c=0,0,M,N); S!P) s(+	36,54-a,0,-120,-+-+-+-+147,b
((1<<16)-1)); S P) { b(255);	I 0,N/2,M,N/2); t=-.889*m; h
=k+340; R u=(t+=q=n)*M/32,d=	n*N/48,q?I f,e,u,d):0,f=u,e=
+d,k+378>h); R x i&&c-v?s(m,	x s,x u-_ v].u>>8,x r-_ v].r
>>8,x f,b(x o)):0,20>c++); c	=0; R e=16+32*c,Q v^c?16:8,e
    ,(c^v?68:76)+c[b(x o),j]	, 16), b(0,d=20*x c),  Q
	80-d,4+e,d,8),2>c++)	; } b(255); I M,0,M,
	    N); XCopyArea(W,	X,O,Y,0,0,M,N,v*
		M,0); } }
char*o=""{	} {}		{{ }	;      	{ }	;  	{;      	{;	 { ;	{ }	;      	{ }	;  	{;      	{;	}		; 	 { ;	{ }	}		; 	 { ; 	}		{ }	;	 { ;	{}		; 	 { ;	} {}		{{ }	;      	{ }	;  	{;      	{;  	}		 { }		{ }	}		{}		 { }		{ }	}		{ }	}		 { }		{}		{ }	}		 { }		{		 }		{ ;     	  ;   		;     		 ;	 }{;	}	{	{ }	;      	}	}	;  	{;      	}	{	;	}  	{	{ }	;      	{	};  	{;      		{	;	}		}	{	;	}  	{	{ }	}		}	{	;	}  	{	; 	{	};	}		}	}	{}  {	};	}		}	}	}  }  {	 };      		} ;  	}  ;      	{	 } {	   } ;      	{} ;  	} ;      	  }  }  {	 } {	   }}  {	 } {	   }}  	} } {	 {} }  }  	} } {	 {} } 		 { ; 	{{	}	;	{ ; 	{{	;	  { ; 	{{	} 	;	{ ; 	{{	;		 ;	}	;     	  ;   	} 	;     		 ;	}		}{{		} {{ } { 	{{	{	} }	}  } }	{{{	{} { }{{		} {{ } { 	{{	{	} }	"";
main(){
XEvent e; W=
XOpenDisplay(k);
XSelectInput(W,O=
XCreateSimpleWindow(W,DefaultRootWindow(W),64,64,M*2,N,2,P,r),3);
XMapWindow(W,O); srand(time(0)); Y=
XCreateGC(W,X=
XCreatePixmap(W,O,M,N,DefaultDepth(W,r)),P,r); R*o){ S*o^59)d=64&*o?'{'^*o++:3,
 32^*o?d+=*o^9?2:1:0,*j+=P?d*9-43:d,j+=P,P=!P; else R*j=j[-3],j++,*++o^9); o++;
 } R 7){ T(0);
XFlush(W); usleep(33367); R
XPending(W)) L[
XLookupKeysym(&e,
XNextEvent(W,&e)&0)]^=1==e.type/2; } }
","#include <stdio.h>

char E[1<<25]=""              ; } }     { { } { { ; ; {     } } { { ;   { { {       { { } ; }   { { ; {   { { ;     { } ; ; ; {     ; ; ; }   } ;   } { { ;   } }   ; } } ; ; }     { ; } } { } } }       } }   ; { { } } } ;   } } } {   }   ; ; ; {     } ; { { {   ; {   ; } } {   { { } { { ; ; { {   } } { { ;   { { {       { { } ; }   { { ; {   { { ;     { } ; ; ;       ; ;   }   } ;   } { { ;   } }   ;   } ; ; }     { ; }   } } } }       } }   ; { { }   ; ;   }   ; {   }   ; ; ; {     } ; {   {   ; {   ; } } {   { { } {   ; ; { {   } } { {   { { { {       { {     ;   {   ; {   {   ;     {         {     ; ;     { } ;     "",
*a[40],*q=E+20,*T=E+1080;
int i=1,j,k,l,u,w,I,J,K,h,H,G,R=4,U,e[999],*p=e+5,*r,*s,*v,b[999],L[1<<16],
F=882,n[99];
FILE*f;

#define Y(a,b) (a)<(b)?(a):(b)
#define Z(a,b) (a)>(b)?(a):(b)
#define X(x,a,b)Z(a,Y(b,x))
#define O      [s]
#define N      [v]
#define M      [r]
#define C      ++
#define m      :0
#define g      m,
#define d      u==
#define z(o)   32 O?n[X(32 O+o+(35 O-24)/256,0,59)]m
#define y(o)   32 O?8 O=z(o)m
#define x      (p=e+5*34 O,2 M-3 && 2 M-5?y(0),l=p[4],a[i]=a[8+34 O],3 N=l>1?\
               2*(p[3]+l):2*p[0],4 N=l>1?2*l:1,0 N=Y(2 M-9?0:9 O<<8,3 N-1) m)
#define W(t,i) (u=t[i]>>4,w=t[i]&15),
#define Q(e)   ((1 N+=13200)>=5 N?1 N-=5 N, C 0 N>=3 N?0 N-=4 N m g e*6 N*q[0\
               N]/34)+
#define D(b,i) T[i]==*#b&&T[i+2]==#b[1]
#define A      ((unsigned char*)q)
#define V      *p C=
#define S(a)   V(A[a]<<8)|A[a+1],
#define P      2 M==
#define B      ,putchar
#define o      for(

int main(int t,char**c)
{
    o; w=E[u]; C u)n[u/10]+=(w-59?w-125?w-32?1 m:2:3)<<u%10;
    o t=fread(E,i,1<<24,f=fopen(c[i],""rb"")),
        t=D(FT,0)?R=T[3]-48,32:D(CN,1)?R=*T-48,32:D(MK,0)?32:16;
        i C<t;
        S(0)V(A[2]&7)-2*(A[2]&8),V A[3],S(4)S(6)q+=8) q+=22;
    o H=*A,T=q+=2,q+=t>15?132:128;
        k<128;
        k C) G=X(G,T[k]+1,128);
    o p=L; j C<R*64*G; q+=4)
        o W(A,2)V*A&240|u,V i=0,V w,V A[3],k=((*A&15)<<8)|A[1],l=9<<19;
            k&&i C<60;
            u=k-n[i],u*u<l?p[-3]=i,l=u*u:l);
    o i=1; i<t; a[8+i]=q,q+=2*e[5*i C]);
    o t=6; !U; ) {
        o i=0; i<R;
            v=b+7*i,r=L+4*(R*(64*T[K]+J)+i),s=e+200+50*i,j=3 M&15,
            I?
                W(s,2 M)P 5||P 6||P 10?0 O =u?Y(0 O+u,64):Z(0 O-w,0) g
                P 0?W(r,3)(u|w)?y((I%3-1?I%3-2?0:w:u)) m g
                8 O=P 1?Z(113,8 O-1 O):P 2?Y(856,8 O+2 O):8 O,
                P 5||P 3?l=z(0),8 O>l?8 O=Z(8 O-3 O,l):8 O<l?Y(8 O+3 O,l) m g
                U|=P 11&&I==t-1,
                P 13&&I==t-1?W(r,3)K C,J=10*u+w-1 g
                P 14?
                    W(r,3)
                     d 6?j?I==t-1?38 O=38 O<j?J=37 O-1,38 O+1 m m:(37 O=J) g
                     d 9&&C 39 O==25 O?39 O=0,x g
                     d 12&&I==28 O?0 O=0 g
                     d 13&&I==e[29]?x m
                     m
            :(
                0 M?34 O=0 M,p=e+5*34 O,35 O=p[1],0 O=p[2] g
                3 M?2 M O=3 M g
                1 M&&(2 M-14||((3 M>>4)-13))?32 O=1 M,x g
                0 O=P 12?X(3 M,0,64) m O ,
                P 15?(l=3 M)?l<33?t=l:(F=110250/l) m g
                P 14?
                    W(r,3)
                    j?(16+u) O=j g
                    8 O=d 1?Z(113,8 O-17 O):d 2?Y(856,8 O+18 O):8 O,
                    d 5?35 O=(j&7)-2*(j&8) g
                    d 9?39 O=25 O&&!1 M?x,0 m g
                    0 O=d 10?Y(0 O+26 O,64):d 11?Z(0 O-27 O,0):0 O,
                    d 14?h=30 O m m),
            6 N =X(0 O,0,64),
            5 N =999*8 O,
            i C);
        o C I>=t+t*h?I=h=0,C J>=64?J=0,U|=C K>=H m g j=F; j--; 0
            B(u)B(u>>8)B(w)B(w>>8))
            o i=u=w=0; i<R;
                v=b+7*i,q=a[i C],q?l=Q(1)Q(4)Q(12)Q(12)Q(4)Q(1)0,
                  k=1<<(i&2),u+=l/k,w+=l/(k^5) m);
    }
    return 0;
}
","#include <stdio.h>
#include <math.h>
#define E return
#define S for
char*J=""LJFFF%7544x^H^XXHZZXHZ]]2#( #@@DA#(.@@%(0CAaIqDCI$IDEH%P@T@qL%PEaIpBJCA\
I%KBPBEP%CBPEaIqBAI%CAaIqBqDAI%U@PE%AAaIqBcDAI%ACaIaCqDCI%(aHCcIpBBH%E@aIqBAI%A\
AaIqB%AAaIqBEH%AAPBaIqB%PCDHxL%H@hIcBBI%E@qJBH#C@@D%aIBI@D%E@QB2P#E@'C@qJBHqJBH\
%C@qJBH%AAaIqBAI%C@cJ%""   ""cJ""   ""CH%C@qJ%aIqB1I%PCDI`I%BAaICH%KH+@'JH+@KP*@%S@\
3P%H@ABhIaBBI%P@S@PC#"",     *j   ,*e;typedef float x;x U(x a){E a<0?0:a>1?1:a; }
typedef struct{x c,a,t;      }   y;y W={1,1,1},Z={0,0,0},B[99],P,C,M,N,K,p,s,d,h
;y G(x t,x a,x c){K.c=t   ;      K.t=c; K.a=a;E K;}int T=-1,b=0,r,F=-111,(*m)(i\
nt)=putchar,X=40,z=5,o,   a,     c,t=0   ,n,R;y A(y a,y b,x c){E G(a.c+b.c*c,a.a
+c*b.a,b.t*c+a.t);}x H=   .5,Y   =.66     ,I,l=0,q,w,u,i,g;x O(y a,y b){E q=a.t*
b.t+b.c*a.c+a.a*b.a;}x Q(){E A(P,M,T       ),O(K,K)<I?C=M,I=q:0;}y V(y a){E A(Z,
a,pow(O(a,a),-H));}x D(y p){S(I=X,P         =p,b=T; M=B[++b],p=B[M.c+=8.8-l*.45,
++b],b<=r;Q())M=p.t?q =M_PI*H,w=atan2(   P.a-M.a,P.c-M.c)  /q,o=p.c-2,a=p.a+1,t=
o+a,w=q*(w>t+H*a?o:    w>t?t:w<o-H*a?t   :w<o?o:w),A(      M,G(cos(w),sin(w),0),
1):A(M,p,U(O(A(P,M,T)    ,p)/O(p,p)));   M=P;M.a=-         .9;o=P.c/8+8;o^=a=P.t
/8+8; M=Q        ()?o&1    ?G(Y,0,0):W   :G(Y,Y,1);E       sqrt        (I)-.45;}
int main(   int    L,char    **k){ S(e   =L>1?1[z=    0,   k]:J   ;*e   &&l<24 ;
++e)S(o=a   =0,j   =J+9;(c=    *++j)&&   !(o&&c<    X&&(q=l+=w)   );o   ?o=*j++/
32,b++[B]   =G(q   +=*j/8&3,*    j&7,0   ),B[r    =b++]=G((c/8&        3)*( o<2?
T:1), (c&   7)+    1e-4,o>2),1:    (o    =(a    =(c-=X)<0?w=c+6   ,t=   a+1:c?(t
?0:m(c),a        ):*++j)==((*e|32        )    ^z)&&1[j]-X));S(z   =3*(   L<3);++
F<110;)S(L=-301;p=Z,++L<300;m(              p.c),m(p.a),m(p.t))S(c=T;++c<=z;)S(h
=G(-4,4.6,29),d=V(A(A(A(Z,V(G(5,0         ,2)),L+L+c/2),V(G(2,-73,0)),F+F+c%2),G
(30.75,-6,-75),20)),g=R=255-(n=z)*64;    R*n+R;g*=H){S(u=i=R=0;!R&&94>(u+=i=D(h=
A(h,d,i)));R=i<.01);S(N=V(A(P,C,               T)),q=d.t*d.t,s=M,u=1;++i<6*R;u-=
U(i/3-D(A(h,N,i/3)))/pow(                             2,i));s=R?i=pow(U(O(N,V(A(
M=V(G(T,1,2)),d,T))))                                     ,X),p=A(p,W,g*i),u*=U(
O(N,M))*H*Y+Y,g*=                                             n--?Y-Y*i:1-i,s:G(
q,q,1); p=A(p,s                                                 ,g*u);h=A(h,N,.1
);d=A(d,N,-2*O                                                     (d,N));}E 0;}
","#define o(a,b,c,d) a##f b##f c##f d; a##g b##g c##g d;q--
#define Z(z)if(*j==z)
#define c(z,p) Z(z){y;v p##=r;o(b,[q-1]=b,[q] p b,[q]);}
#define y q+=t;t=0
#define r w[q]
#define v w[q-1]
#define w(a,m,f) Z(a){y;r=m(r);q++;o(b,[q-1] = -b,[q-1]*f(r)+0*b,[0]);}
#define A(p,w,o) for(p=0;p<w;p++)_(o)
#define P(a) for(a=Z;a<Z;a++)
#define _ putchar
typedef double o;
typedef char z;
o A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y, E_, w[20], bf[20], bg[20],x=-1.3/8,p,d,l=0,h=4e-3,f,m;
z e[17] = ""FKE<<gMAQUDIYO9\""="", *k, *j; o g(o p, o d){int q =-1,t=0;j=k;while( *j ){c(45,-);Z(100){y;q++;r=v;q[bf]=bf[q-1];q[bg]=bg[q-1];}Z(42)
     {y;v*=r;o(b,[q-1]=r*b,[q-1] + v*b,[q]);}Z(44){t=0;q++;}Z(116){f=v;v=r;r=f;f=bf[q];q[bf]=bf[q-1];bf[q-1]=f;f=q[bg];bg[q]=(q-1)[bg];bg[q-1]=f;



      }c(43,+);Z(47){y;v/=r;              o(b,[q-1]=b,[q-1]/r-v/                (r*r)*b,[q]);}Z(121){y;q++                        ;r=d; bf[ q]=0;bg[q]=1;}
      Z(94){y;f=v;v=pow(v,r)              ;o(b,[q-1]=r*b,[q-1]*                 pow(f,r-1)+0*b,[q]);}w(115                        ,sin,cos);w(99,cos,sin);
      Z(120){y;q++;r=p;bf[q]              =1;bg[q]=0;}if(*j>=48                 &&*j<58){q++;t=1;r=*j-48 ;                        bf[q] = 0;(q--)[bg] = 0;
                             }j++;}H=bf[0]                                                                ;K= bg[ 0]; return w[0];}
                             void s(){int                                                                 e=0;X=Q*8;f=g (Y*8, L*8 )
                             ;e=(f-X<0)?1:                                                                -1;l=0;while((l+=h)<8)  {
      V=Y*8+l*R;W=L* 8+l*D;X=             Q*8+l*U;f=g(V,W);if((f                                          -X)*e>0){if(V>-1&&V<1&&W>                   
      -1&&W<1){p=V;d=W;return            ;}else e/=-1;}}p=d=-10                                           ;}int main(int argc, z **
      argv){int c, f;z b[2],Z            ;S=0,C=1;k=argv[1];Z =                                           atoi(argv[2])>>1;b[1]=Z*2


      &255;b[0]=Z>> 9;J= 3.1415/Z;A(f,6,f[e]^f+1);while(--f>1)_(
      (f%2)[b]);_(246);A(c,384,c/3%2?c/6<<2:0);_(_(0));_(_((_(33)
      <<3)-9)/23);for(f+=5;f < c/22 ; f++) _(e[f] ^ f - 3);for(;f
                                           > c/29;f--)_(f>15?2*f-
                                           31:c);_(0);for(f=0;f<=
                                           Z*2 ; f++){N = S;E_=1-
                        J*J/2;T=J*(1-J*J/6);
                        S=S*E_+C*T;C=C*E_-N*
                        T;A=-(C*C-S*S);P=-A*
     C;E=A*S;G=S*C*2;I=-
     G*S;F=G*C;_((_(e[10
     ]/2-1)<<3)-18);for(
     c=-1;c<5;c++)_((c+1)%2?0:-2*c*c+3*c+9);_(44);A(c,9,c&4?(1-c%2
     )[b]:0);_(7);for(B=-Z ; B<Z ; B++){_(Z+2);for(O=-Z;O<Z;O++){Y
     = (E - P*B/Z - G*O/Z)*x;L = (I - F*B/Z - A*O/Z)*x;Q = (-C +S*

     B/Z)*x;R = - Y + E; D =-L+I; U =-Q-C;s();3[w] = sqrt(R*R + D*D + U*U);m=p==-10?1:(4[w]=sqrt(H*H+K*K+1)*w[3],H/=-4[w],K/=-4[w],
     fabs(H*R + K*D + U/4[w])*exp(-l*l/2) );_((z)(m * 63)*2 + ((z)((p+1)*6) % 2 + (z)((d+1)*6) % 2 == 1 ? 1 : 0));O?l:(_(128),_(B!=
     Z-1 ? Z : Z+1));}_(128);}_(_(129)-129);}_(0x3b);}
","#include<stdio.h>
#define c(C) printf(""%c"",C)
#define C(c) ((int*)(C[1]+6))[c]
main(int c,char    
*C[])         {(C[c]=C[
1]+2   )[0]=   c(52*c(\
'C'+  '4'/4)    );for(c
=0;  c<491;++   c)for(*
*C=  C[1]['c'    +c]  =
0;*   C[0]<8;(    **  C
)++    )C[1][c+   'c']=
*(C[  1]+c+'c')+  C[1][
99+    c]+(C[1    ][**C
+8*c  +99]==32    );  (
*C)[4]=*C[2]==    75  ?
*((C[2]+=3)-2    )==70?
1:0:0;C(0)=C(    1)=c=0
;while(*C[2]?   C[2][1]
?*(C[2]+2)?1    :0:0:0)
{if( *C [2      ]>'w'){
C(1)=0;C[1]    [2]++;*C
[2]=0;}else   C(1)+=*C[
2]==58?2+(    C[2][3]&&
*(C[2]+3)<   'x'):*C[2]
=='s'?(C[   2][1]-=48):
*C[2]>=65  ?3-(*C[2]==\
'm'?1:0)  :1;C(0)=C(1)>
C(0)?C(1  ):C(0);c+=3;*
(C+2)+=3;}printf(""  %d\
          %d\n"",        56+8*C(    0),80**(C[3]    ++))
         ;*C[2]=0       ;C[2]       -=c;*C[3]       =0;
        while(C[3]      [1,-         1]--){;   for(  **
        C=0     ;*      *C<          80;(**   C)++)  {C
       [2]      -=3     **           C[3];   *C[3]   ++
       =0;      *C[     3]          =**C>=  51||*   *C<
       18       ||*     *C         %8!=2?0  :255   ;c(1
       -1       );c     (*C       [3]);for(       (*C)[
       1]      =0;(     *C)[    1]<3;(*C)[1]    ++)c(*C
       [3      ]|((     *C)[  4]?**C>18&&* *C<42 ?C[1][
       42     +*(*      C+1)    +3***C]:0: **C>=  11&&*
       *C     <64?      ~C[1 ][   7***C+97 +(*C)[  1]]:
        0)   );c(       *C[3 ]++)   ;for(C (1)=0;   (C(
        2)   =C(1       ))<C (0);)   {(*C) [2]=C   [2][
        1]  -49;        c=(* C[2]<=   63); c=(*   C)[0]
        -4  *(C[        3][0 ]=105-  C[2][ c]   -7*(*(C
        [2]+c)<         'c') -18*(  C[2][c    ]<77)+2*(
         *C)[4          ]-7* (C[2] [c]<'C'  ))-6;for(C(
        3)=0;                                          
       C(3)<                                (*C[2]?*C[2
      ]>'r'                             ?C[    2][1]:(1
     +2*(*C             [2]>   64)    +(2-!C[2    ][3])
    *(58 ==             (*(C         +2))[0])-         
    (C[2] [0            ]=='m'   )  ):C(2)?C(0     )-C(
  2):0  );C(3)++)       C(1)+=c(C  [1][4]|(*     C[2]&&
 *C[2  ]<'s'?*C[2]      ==58?C(3)  ==1?**C     >17&&**C
 <51  ?C[ 2]    [1]     ==59?39:  C[2][1     ]==58?9:1:
0:0  :63  >*     C[2    ]?(c<7&&  c>-9?C[1    ][(*C[2]<
45?  'c'  *5     +2*    '%':*C[   2]<  61?570    :571)+
3*c  ]:   0)      :*C   [2]>'o'  ?**C>26&&**C<29    &&!
(*C  )[    2]     ||(   *C)[2]  ==1&&(&*C[0])       [0]
 <34  &&   31     <**   C?C(3)  <2?15+225*C(3     ):0:(
 *C)[  2]  ==     3?C   (3)<2  &&**C>22&&**C     <45&&C
 (3)<      2?     C[    1][7*  *(*C)+151+C      (3)]:0:
  7==(     *C    )[2    ]&&*  *C>26&&**C       <42&&C(3
  )<2?C    [1   ][7     ***C  +135+C(3)]       :0:*C[2]
   <'k'?    (c >-5                      &&      c<5?C(3
    )<2?C   [1][(                       (*C)     [2]<3?
     207:205)+7*                        c+C(3     )]:C[
      2][2]==46               &&        (c==-2||   c==-
            1-                          2*(*C[3]%2  ))?
            96                          :0:0)|((*C)[2  
             ]?                                        
             C(         3      )        ?C(3)< 2       
             &&                        *C[3]>  7   &&  
             c<           1&&c  >-24  ?8:0:*   C       
             [3         ]<8&&c  >1   &&c<24    ?   ' ' 
        :0   :0)        |(C(3) <2     &&(  **  C       
       ==66   &&        *C[3   ]>14   ||*  C[  3       
       ]>12   &&        58   ==**C||   *               
       C[3    ]<        2  &&**C==10   )            ?  
        5*  51:                       0)|(7==  (       
         *C)[                        2]?*C[3]  <       
8?c>13&& c<23&&C(3)<2?C
[1][144+ 7*c+C(3)]:0:C(
3) && c< -14&&c>- 24?C[
1] [7 *c +400+C(3 )]:0:
0) :! C  (3)?**C> 21&&C
[0 ][    0]   <32      
?C     [ 1 ]   [(      
*   C )    [2   ] +323 
   +7     **   *C ]:36 
 + 1   < **   C&& '0'> 
*     *C ?  C[1][      
   C[ 2]  [2]+162      
 + 7* **C]:0:0:0));C[1 
][ 3] ++;C[2]+=3;}c(0) 
;C [3 ]-=2;}*C[3]=0;}} 
","#include    <X11/Xlib.h>
#include  <X11/keysym.h>
#include      <stdlib.h>
#include      <unistd.h>
#include        <time.h>
#include       <stdio.h>
#define B(x, y)(x *48+y)

#define L for( d=0; d<48                               ; ++d)for(e=0; e<48; ++e)
#define  C(x  ,  y  )  (                               1 << B ((x) , (y) ) % 8 )
#define A(x,y )((c.c.c[B                               ((x),(y))/8]&C(x,y))?1:0)
#define  R(d  )  freopen                               ( d , ""r"" , stdin ) ;  f\
read  (   &   c  .  c  ,                               288  ,  1  ,  stdin  )  ;
#define S( b ) ( b ) ? (                               c.d.c [ B( d , e) / 8 ]|\
=C ( d , e ) ) : ( c.d.c                               [B(d,e)/ 8]&= ~(C (d,e)))

int a,b,d,e,f,s; struct{   struct{ char c[288]; } c,
d; int f, g, a, b ; } c;   void h(int a,int b){ if(!
(a==(f=b)||(a%2&&b%2))){   if(b==2){ R(""splash.d"") }
else if ( b == 4 ) { R (   ""dead.d"" )} else{ L S(0);
c.c=c.d; } c.f=1000; c.b   =240; c.g =1; c.a =0; } }
int main (){ Display *i=   XOpenDisplay(0); Window q
= XCreateSimpleWindow(i,   RootWindow  (  i  ,  s  =

DefaultScreen(i)),40,40,   640,480,3,0,0); Pixmap u=
XCreatePixmap (i,q ,640,   480,a=DefaultDepth(i,s)),
p=XCreatePixmap (i,q,20,   100,a); GC g=DefaultGC(i,
s ) ;  XGCValues  W, B ;   XEvent   v  ;  long  k  ;
XSelectInput  (  i , q ,   KeyPressMask|KeyReleaseM\
ask ); XMapWindow (i,q);   W.foreground = WhitePixel
(i, s) ; B. foreground =   BlackPixel ( i, s ) ; R (

                           ""sprites.d"") L{ XChangeGC   (i,g,GCForeground,A(d,e)?
                           &B:&W); if(e<20) if(d<20)   XDrawPoint(i, p,g, d,e );
                           else  if   (  d  <  25  )   XFillRectangle(i,p,g,4*(d
                           -20) ,20 + 4*e, 4, 4 ); }   srand( time(0 )); h(0,2);
                           while(usleep (16666), f){   while ( XPending ( i) ) {
                           XNextEvent (i,&v); h(f,v.   type == KeyPress ? (( k =
                           XLookupKeysym(& v.xkey,0)   )==XK_q?0:(k==XK_Up?(f==4

                                                       ?f:3):(k== XK_Down?(f==4?
                                                       f:5):(f==2?1:( f==4?2:f))
                                                       ))):( v.type==KeyRelease?
                                                       (( k = XLookupKeysym( &v.
                                                       xkey,0))== XK_Up?(f==3?1:
                                                       f): (f==5?1:f)):f)); } if
                                                       (!c.g){ L{ for(k=0, a=-1;

a<2; ++a)if(d+a>=0&&d+a<   48)for(b=-1; b<2; ++b)if(   e+b>=0&&e+b< 48)k+=(a||b)
&&A(d+a,e+b); S(A(d,e)?k   ==2||k==3:k==3); } c.c=c.   d; } c.g= ++c.g% (f%2?30:
120); c.f +=2; c.a+=f%2?   c.f/1000:0; c.b+=f==3?-2:   (f==5?2:0); a=c.a>159?-8:
0; b=c.b>399?-8:(c.b<81?   8:0); c.a=a?0:c.a; c.b=b?   240:c.b; L S(((d-a>=0)&&(
d-a<48)&&(e-b>=0)&&(e-b<   48))?A(d-a,e-b):((rand()%   8 ) == 1 )) ; c.c = c.d ;
XFillRectangle(i,u,g,0,0   ,640, 480); L{ if A( d,e)   XCopyArea(i,p,u,g,0,0,20,
20,d*20-c.a,e*20-c.b); }   if( f%2){ for(d=c.a+ 100;   d<c.a+120; ++d)for(e=c.b+

                           248 ; e < c.b +268; ++e)
                           if A (d/20, e/ 20) h( f,
                           4 ); XCopyArea( i, p, u,
                           g, 0,20 *(c .g /8+1),20,
                           20  ,  100 , 248  )  ; }
                           XCopyArea( i,u, q,g,0,0,
                           640, 480, 0, 0 ) ;  }  }
","#  include<stdio.h>//  .IOCCC                                         Fluid-  #
#  include <unistd.h>  //2012                                         _Sim!_  #
#  include<complex.h>  //||||                     ,____.              IOCCC-  #
#  define              h for(                     x=011;              2012/*  #
#  */-1>x              ++;)b[                     x]//-'              winner  #
#  define              f(p,e)                                         for(/*  #
#  */p=a;              e,p<r;                                        p+=5)//  #
#  define              z(e,i)                                        f(p,p/*  #
## */[i]=e)f(q,w=cabs  (d=*p-  *q)/2-     1)if(0  <(x=1-      w))p[i]+=w*/// ##
   double complex a [  97687]  ,*p,*q     ,*r=a,  w=0,d;    int x,y;char b/* ##
## */[6856]=""\x1b[2J""  ""\x1b""  ""[1;1H     "", *o=  b, *t;   int main   (){/** ##
## */for(              ;0<(x=  getc (     stdin)  );)w=x  >10?32<     x?4[/* ##
## */*r++              =w,r]=  w+1,*r     =r[5]=  x==35,  r+=9:0      ,w-I/* ##
## */:(x=              w+2);;  for(;;     puts(o  ),o=b+  4){z(p      [1]*/* ##
## */9,2)              w;z(G,  3)(d*(     3-p[2]  -q[2])  *P+p[4      ]*V-/* ##
## */q[4]              *V)/p[  2];h=0     ;f(p,(  t=b+10  +(x=*p      *I)+/* ##
## */80*(              y=*p/2  ),*p+=p    [4]+=p  [3]/10  *!p[1])     )x=0/* ##
## */ <=x              &&x<79   &&0<=y&&y<23?1[1  [*t|=8   ,t]|=4,t+=80]=1/* ##
## */, *t              |=2:0;    h="" '`-.|//,\\""  ""|\\_""    ""\\/\x23\n""[x/** ##
## */%80-              9?x[b]      :16];;usleep(  12321)      ;}return 0;}/* ##
####                                                                       ####
###############################################################################
**###########################################################################*/
","#  include<stdio.h>//  .IOCCC                                         Fluid-  #
#  include <unistd.h>  //2012                                         _Sim!_  #
#  include<complex.h>  //||||                     ,____.              ||||||  #
#  define              c y+=(                    x=ctanh(            -cabs/*  #
#  */(4[t              ]-=20)                     /2+9)*             3+3)*//  #
#  define              f(p,e)                                        for(p/*  #
#  */=a;e              ,p<r;p                                        +=5)///  #
#  define              z(e,i)                                        f(p,p/*  #
## */[i]=e)f(q,w=cabs  (d=*p-  *q)/2-     1)if(0  <(x=1-      w))p[i]+=w*/// ##
   double complex a [  97687]  ,*p,*q     ,*r=a,  w=0,d;    char b[97687]=/* ##
## */""GO\x1b[2J\x1b[""  ""1;1H""  ,*o=b,     *t;int  x,y,j;   void h(int e){/** ##
## */for(              t=b;b+  24045>     (t+=12  );c 6,  sprintf     (t,/** ##
## */""%c""              ""[48%""  ""c5;%""     ""03dm""  ""%c"",3  *9,e,c      36,e/* ##
## */?(t-              b)%960  ?(15-t     [11])[  ""\x23""  ""/\\_""      ""\\""/* ##
## */""||""              "",//|""  "".-`'      ""]:10:  0)) y=  0020,c      01;}/* ##
## */void              g( int  i){7[t     +=i]|=  x/=2;*  t+=y=p      [2];/* ##
## */}int              main()  {for(;(    x=getc  (stdin  ))>0;)w     =10</* ##
## */x?32              <x?4[*   r++=w,r]=w+1,*r=  r[5]=x   ==35,r+=9:0,w-I/* ##
## */:(x=              w+02);    for(;;puts(o),o  =b+6){    z(p[1]*9,2)w;z/* ##
## */(G,3              )(d*(3      -p[2]-q[2])*P  +p[4]*      V-q[4]*V )/p/* ##
####                                                                       ####
###############################################################################
**###########################################################################*/

         [2];h(0       );f(p,*     p+=           p[4]+=p     [3]/10*!p
       [1]     )(t   =b+     16+   (x=         *p*     I)*   12+     960
       *(y           =*p     /2)   ,x=         0<=     x&&   79>     x&&
       0<=           y&&     23>   y?x         =16     ,g(   0),g(12),
       g(+     948   ),g     (12   ),0         :0)     ;h(   59)     ;;;
         usleep(       12321);     }return 0;}   /*IOCCC     '12     **/
","#include <stdio.h>//  .IOCCC                                         Fluid-  #
#include <unistd.h>  //2012                                         _Sim!_  #
#include <complex.h>  //||||                     ,____.              IOCCC-  #
double complex	a[97687], *p, *q, *r = a, w = 0, d;
int		x         , y;
char		b         [6856] = ""\x1b[2J"" ""\x1b"" ""[1;1H     "", *o = b, *t;
int
main()
{

	for (; 0 < (x = getc(stdin));)
		w = x > 10 ? 32 < x ? 4[*r++ = w, r] = w + 1, *r = r[5] = x == 35, r += 9 : 0, w - I : (x = w + 2);;
	for (;; puts(o), o = b + 4) {
		for (p = a; p[2] = p[1] * 9, p < r; p += 5)
			for (q = a; w = cabs(d = *p - *q) / 2 - 1, q < r; q += 5)
				if (0 < (x = 1 - w))
					p[2] += w * w;
		for (p = a; p[3] = G, p < r; p += 5)
			for (q = a; w = cabs(d = *p - *q) / 2 - 1, q < r; q += 5)
				if (0 < (x = 1 - w))
					p[3] += w * (d * (3 - p[2] - q[2]) * P + p[4] * V - q[4] * V) / p[2];
		for (x = 011; 2012 - 1 > x++;)
			b[x] = 0;
		for (p = a; (t = b + 10 + (x = *p * I) + 80 * (y = *p / 2), *p += p[4] += p[3] / 10 * !p[1]), p < r; p += 5)
			x = 0 <= x && x < 79 && 0 <= y && y < 23 ? 1[1[*t |= 8, t] |= 4, t += 80] = 1, *t |= 2 : 0;
		for (x = 011; 2012 - 1 > x++;)
			b[x] = "" '`-.|//,\\"" ""|\\_"" ""\\/\x23\n""[x % 80 - 9 ? x[b] : 16];;

		usleep(12321);
	} return 0;
}
","#include<stdio.h> /******** SpigotQuine -- usage: ./spigot [pi or e] ********/
char*s=""G1%%xJ{;Q7wunmuGuu%%uu#include<stdio.h>/*Spigot_Quine*/#include<stdli""
""b.h>/*_IOCCC2012_*/int*e,""    ""i,j,k,n""     "";char*q""    "",*a,*d,*z,*p=%s%c;""
""int"" ""%cmain(){a=calloc(""                                 ""1,1e4+n*2);;for(*""
""a=\0@3,z=d=a+n+1,j=n*8-7;""    ""k=0,j-1""     "";j-=2){""    ""for(a[1]+=2;--z-a;""
""*z=k%%10,k/=10)k+=j/2**z;;for(;k=k%%j*""     ""10+*++z,z<d;*z=k/j"" "");;\0@2,z=""
""d=a+n*2,*z=1,j=0;++j<n;){for(;k=k%%""           ""j*10+*z,a-z;*z""   ""--=k/j)a+""
""+;for(k=0;z-d;*a--=k%%10,k/=10)k+""               ""=*++z+*a\0""     ""@;}d+=spr""
""intf(q=d-20,p,p,34,32,n+1)+2;;;;""                 ""for(n=n*2""     ""0-400;k<n""
"";++k%%n?j=+puts(""                                                 ""d)<0:(d++""
""[j]=47,d[j-2""                                                     ""]=42),k%%""
""20<1?puts(d""                                                      ""-1),a++:0""
""){for(i=-1""                                                       "";i++<32;!""
""*z?q[662]""          ""=0,z=q+207:""                 ""*z+z[1]<6""     ""5?z+=11:*""
""z==34?p=0""         "":0)d[i]=((k/2""               ""0-1?275*q[""     ""*a+10]-8*""
""q[*a+0]-8""         "":128)>>(i/11+k/""           ""4%%5*3))&1?k""     ""/3*!j&&p?""
""j=34:(j=""           ""i+1,*z++):32;k/3*""     ""j--&&p?d[z--,j]=3""   ""4:0;}}int""
""*y,n=%d;/*..~"",*f=""nnLa5~z23~|22t$q(s82r&q(s82q'q(s8;q(s8;q(s8:"" ""r(s8:r(s8:""
""q)s89r)sLr#t+"" ""sLx,uJw-yGu/wnnnU"",*g=""nnLa<z::t$u88t(u67t*u57s,t56t,t56~v56""
""tF6tF6tF8t1p""   ""Nu/qOv+rS}Xxnng"";int main(int m,char**v){char a[2012],b[2012
],*p=a,*r=m>1     &&*v[1]=='e'?g:f,*q=b,*t=r;;sprintf(a,""%s%s%s"",s,r==g?s+281:
s+168,s+386);     sprintf(b,a+22,a,34,32,24);for(sprintf(a,""%.33s/*%.28s*/%.3""
""3s/*%.28s*/%""   "".33s\""%s*/"",b,b+66,b+33,b+76,b+66,b+99);*r;r++){;for(m=0;m++
<(*r-34)%77;*q++=*r>111?32:*p++)(q-b)%66<1?*q++=10:0;*r-110&&*r-126&&r-t<(t-g?
62:45)?*q++=34,((q-b)%66<1?*q++=10,*q++=34:0):0;}*q=0;puts(b+1);}/*IOCCC2012*/
","#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>

int u,z,q[0400],O[0x101],o[0401],I[257],w[258][0403],W[0x100],Z[0x103],c[0403],k
,i,j,n,l,p,m;const char*J[0416],*M[0400];FILE*K[280],*s[0x102];void f(char*n,int
a){char*e=n;while(*e!='\0'){if(tolower((int)*e)!=*e)fputc(040,stderr);fputc((*e)
-a,stderr);e+=1;}(void)fputc('\n',stderr);}int y(int a,int b);int t(int i,int j)
{int k=i&j,l=i^j,n,m=1;for(n=1;k>=n;n<<=1)if(k&n)m=y(m,1<<n|1<<(n-1));return m>1
?y(m,1<<l):1<<l;}int y(int a,int b){int n,i=0x0,j;if((n=w[a][b]))return n;for(;a
>>i;++i)for(j=0x0;b>>j;j++)if(((a>>i)&1)&&((b>>j)&1))n^=t(i,j);return w[a][b]=w[
b][a]=n;}void a(void){for(i=0;i<z;i++){n=0;if(!i[I]){for(j=0;j<u;++j)if(i[O]==q[
j])n=Z[j];}else for(j=0;j<u;j++)n^=w[Z[j]][w[I[i]][W[w[o[j]][O[i]^q[j]]]]];c[i]=
n;}}void X(int v,int u){char*y=0;v-=1;switch(v){case(0x2):y =""HckngfVqQrgpKprwv""
""Hkng""; BC(4):y=""JempihXsStirMrtyxJmpi""; BC(0):y=""PointValueTooLarge""; BC 0x1:y=
""EvqmjdbufJoqvuQpjou"";BC(6):y=""TuOtv{zLorky"";BC(3):y=""WrrPdq|RxwsxwSrlqwv"";BC(5)
:y=""GfiFwlzrjsyX~syf}""; BC(07):y=""UvV|{w|{Mpslz"";}if(u)exit(0); f(y,v);exit(1);}
int main(int t,const char*T[]){for(i=00;i<0x100;++i)for(j=0;j<=i;++j)if(1==y(i,j
))W[i]=j,W[j]=i;for(k=0x1;k<t;k++){p=0;for(l=0;(T[k][l]>=toupper('0'))&&(T[k][l]
<=tolower('9'));l++){p=p*10+(T[k][l]-'0');if(p>=256)X(1,0);}if(T[k][l]=='-'){for
(m=0;m<u;m++)if(q[m]==p)X(2,0);q[u]=p;J[u]=T[k]+l+1;K[u]=fopen(J[u],""r"");if(!u[K
])X(3,0);u++;}else if(T[k][l]=='+'){if(z>=256)X(4,0); O[z]=p;M[z]=T[k]+l+1;s[z]=
fopen(M[z],""w"");if(!s[z])X(5,0);z++;}else X(6,0);}if(!(u!=0))X(7,0);if(!(z!= 0))
X(8,0);for(i=0;i<u;i++){n=1;for(j=0;j<u; j+=1)if(j!=i)n=w[n][q[i]^q[j]];o[i]=n;}
for(i=0;i<z;i++){n=1;for(j=0;j<u;j++)n=w[n][O[i]^q[j]];I[i]=n;}while(!(0)){for(k
=0;k<u;k++){int n;n=getc(K[k]); if(n==EOF)X(42,1); Z[k]=n;}a();for(k=0;k<z;k++)(
void)putc(c[k],s[k]);}X(11,1);}
","#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>

static const int x[010][8]={{01,02,04,0x8,020,32,0x40,128,},{02,03,0x8,12,32,48,
128,192,},{04,0x8,06,11,64,128,96,176,},{0x8,12,11,13,128,192,176,208,},{020,32,
64,128,24,44,75,141,},{32,48,128,192,44,52,141,198,},{64,128,96,0260,75,141,103,
185,},{0200,192,176,208,0x8D,0306,0271,0xDE,},};static int u,z,q[0400],O[0x101],
o[0401],I[257],w[258][0403],W[0x100],Z[0x103],c[0403],k,i,j,n,l,p,m;static const
char*J[0416],*M[0400];static FILE *K[280],*s[0x102];static void f(char *n,int a)
{char *e=n;while(*e!='\0'){if(tolower((int)*e)!=*e)(void)fputc(040,stderr);fputc
((*e)-a,stderr);e+=1;}(void)fputc('\n',stderr);}static int y(int a,int b){int n=
0,i=0x0,j;for(;a>>i;++i)for(j=0x0;b>>j;j++)if(((a>>i)&1)&&((b>>j)&1))n^=x[i][j];
return n;}static void a(void){for(i=0;i<z;i++){n=0;if(!i[I]){for(j=0;j<u;++j)if(
i[O]==q[j])n=Z[j];}else for(j=0;j<u;j++)n^=w[Z[j]][w[I[i]][W[w[o[j]][O[i]^q[j]]]
]];c[i]=n;}}static void X(int v,int u){char*y;v-=_STDIO_H;switch(v){case(0x2):y=
""H""""c""""k""""ngfVqQrgpKprwvHkng"";break;case(4):y=""J""""e""""m""""p""""ih""""XsStirMrtyxJmpi"";
break;case(EXIT_SUCCESS):y=""P""""o""""i""""ntValueTooLarge"";break;case 0x1:y=""E""""v""""q""
""m""""j""""d""""b""""u""""f""""J""""o""""q""""v""""u""""Q""""p""""j""""o""""u"";break;case(6):y=""T""""u""""O""""t""""v""
""{""""z""""L""""o""""r""""k""""y"";break;case(3):y=""WrrPdq|Rx""""w""""sx"" ""wSrlqwv"";break;case(5)
:y=""GfiFwlzrjsyX~syf}"";break;case(07):y=""U""""v""""V""""|""""{""""w""""|""""{""""M""""p""""s""""l""""z"";
}if(u)exit(EXIT_SUCCESS);f(y,v);exit(EXIT_FAILURE);}int main(int t,const char*T[
]){for(i=00;i<0x100;++i)for(j=0;j<=0xff;++j)w[i][j]=y(i,j);W[0]=0;for(i=1;i<256;
i+=1){for(j=1;w[i][j]!=1;j+=1);i[W]=j;}for(k=0x1;k<t;k++){p=0;for(l=0;(T[k][l]>=
toupper('0'))&&(T[k][l]<=tolower('9'));l++){p=p*10+(T[k][l]-'0');if(p>=256)X(1,0
);}if(T[k][l]=='-'){for(m=0;m<u;m++)if(q[m]==p)X(2,0);q[u]=p;J[u]=T[k]+l+1;K[u]=
fopen(J[u],""r"");if(!u[K])X(3,0);u++;}else if(T[k][l]=='+'){if(z>=256)X(4,0);O[z]
=p;M[z]=T[k]+l+1;s[z]=fopen(M[z],""w"");if(!s[z])X(5,0);z++;}else X(6,0);}if(!(u!=
0))X(7,0);if(!(z!=0))X(8,0);for(i=0;i<u;i++){n=1;for(j=0;j<u;j+=1)if(j!=i)n=w[n]
[q[i]^q[j]];o[i]=n;}for(i=0;i<z;i++){n=1;for(j=0;j<u;j++)n=w[n][O[i]^q[j]];I[i]=
n;}while(!(0)){for(k=0;k<u;k++){int n;n=getc(K[k]);if(n==EOF)X(42,1);Z[k]=n;}a()
;for(k=0;k<z;k++)(void)putc(c[k],s[k]);}X(11,1);}
","                          #define  \
                        D(s)""<<""#s"">>""
                      #define  q(s)p(#s)
                     #define S "" endobj ""
                    #define Y ""endstream""S
                    #include     <stdio.h>
                    #define  o(s) b[s]=_;\
                     p(""%u    0  obj"",s);
#define E for         (c=d;c  < 123;c++)
  #define DANCE         ""trailer   ""D\
    (/Root 3 0            R /Size %d)            ""\nstartxref %u %%%%EOF\n*/""
      #define              p(s, ...)             _+=printf(s,  ##__VA_ARGS__)
       #define C         ""<</Type/Page         /Parent %d %d R /Resources <<\
        /ProcSet[       /PDF/Text]/Font       <</U""D(/Subtype/Type1/BaseFont\
          /Courier) ""  /T<</Subtype/Type3   /FontBBox[0 0 10 10]/FontMatrix[\
           %f 0 0 %f 0 0]/FirstChar %d/LastChar %d/Encoding<</Differences[%d""
            typedef int N;typedef char*Nyan;typedef char A;N a,b[64],d=65,_,v
              [32]={84,0,64,282,90,74,330,85,93,173,167,176,80,208,81,13,7,87
                ,160,346,32,128,170,218,16,26}; Nyan w[]={""+*-(,&-&"",""+*,&-&""
                  ,""+*.&/&"",""+*/*/+"",""+*())'('""  ,""+**&)&"",""+*(&'&"",""+*'*'+"",
                    """",""+,./"",""+,-,./"",""+--,+*""  ,"""",""+,(/"",""+,),(/"",""+-),+*""
                     ,""10 0 d0 "",""8 7 2 2 re ""   ,""+*+.'`'@'mi +/+/(mi""};Nyan
                       nyan(Nyan _,N y,A n){
                        N g=v[~-y%32];Nyan
                         s=w[g>>n&3|n*2];
                         for(a=0;*_=*s++;
                         a++,_++,*_++=32)
                         {*_+=*_-32?10:0;
                         if(a%2&&*_/16==3
                         ){if(g>>8)*_=105-*_;
                        _++;*_++=32;*_=~-a&&a-13
                        ?108:109;}}return n?n-9?nyan
                       (_,y,n-2):_:nyan(_+=~y&' '?sprintf
                      (_,17[w]):0,y,9);}N main(N c){A e[256];
                     p(""/*%%PDF-1.3%%*/"")-2;q(#include<stdio.h>\n);
                    q(#define o *_++&& *_-41\n#define);p("" endstream "");q
                   (main(){for(;*_++;      *_-40?:putchar(o?*_:o?10:41));\n)
                  ;q(#define  endobj          return 0;}\n);q(typedef int ET;/)
                 ;q(*);o(1)*b=~(p(D                 (/Length 2 0 R)""stream\n""))
                ;for(p(""BT 12 818""                    "" Td/%c 12 Tf 12 TL%%%c/""
               ""static char*_=\""""                       "" \\\n"",7[v],*v/2);c=
              getchar(),~c;c-10?                         p(""/%c 12 Tf(\\%o)""
             ""Tj"",v[~-c%' '<25[                         v]&&!~-(~-c/'@')?0
            :7],c):(p(""()'"")))                         ;p(""%%\"";\nET "");*
           b-=~_;p(Y""/*"");E{a                         =nyan(e+sprintf(e,
          16[w]),c,6)-e;o(c-                         59)p(D(/Length %d)
         ""stream\n%s""Y,a,e)                         ;}o(2)p("" %u""S,*b);
        o(3)p(D(/Pages 4 0                         R)S);o(4)p(D(/Count
       1/MediaBox[0 0 595                         842]/Kids[5 0 R])S)
      ;o(5)p(C,4,0,6e-2,                         6e-2f,d,122,d);E p(
     ""/%c"",~-c/6+~14?c:                         d);q(]>>/CharProcs<<)
    ;E if(~-c/6+~14)p(                           ""/%c %d 0 R"",c,c+~58);
   for(q(>>/Widths[),                             c=59;--c;p("" 10""));a=p
  (""]>>>>>>/Contents 1                              0 R>>""S);for(p(""xref\
 0 %d "",--d);c<d;p(""%010u\
 %05d n  "",*(c+++b),NULL));
  return!(p(DANCE,d,a));}
","                          #define  \
                        D(s)""<<""#s"">>""
                      #define  q(s)p(#s)
                     #define S "" endobj ""
                    #define Y ""endstream""S
                    #include     <stdio.h>
                    #define  o(s) b[s]=_;\
                     p(""%u    0  obj"",s);
#define E for         (c=d;c  < 123;c++)
  #define DANCE         ""trailer   ""D\
    (/Root 3 0            R /Size %d)            ""\nstartxref %u %%%%EOF\n*/""
      #define              p(s, ...)             _+=printf(s,  ##__VA_ARGS__)
       #define C         ""<</Type/Page         /Parent %d %d R /Resources <<\
        /ProcSet[       /PDF/Text]/Font       <</U""D(/Subtype/Type1/BaseFont\
          /Courier) ""  /T<</Subtype/Type3   /FontBBox[0 0 10 10]/FontMatrix[\
           %f 0 0 %f 0 0]/FirstChar %d/LastChar %d/Encoding<</Differences[%d""
            typedef int N;typedef char*Nyan;typedef char A;N a,b[64],d=65,_,v
              [32]={84,0,64,282,90,74,330,85,93,173,167,176,80,208,81,13,7,87
                ,160,346,32,128,170,218,16,26}; Nyan w[]={""+*-(,&-&"",""+*,&-&""
                  ,""+*.&/&"",""+*/*/+"",""+*())'('""  ,""+**&)&"",""+*(&'&"",""+*'*'+"",
                    """",""+,./"",""+,-,./"",""+--,+*""  ,"""",""+,(/"",""+,),(/"",""+-),+*""
                     ,""10 0 d0 "",""8 7 2 2 re ""   ,""+*+.'`'@'mi +/+/(mi""};Nyan
                       nyan(Nyan _,N y,A n){
                        N g=v[~-y%32];Nyan
                         s=w[g>>n&3|n*2];
                         for(a=0;*_=*s++;
                         a++,_++,*_++=32)
                         {*_+=*_-32?10:0;
                         if(a%2&&*_/16==3
                         ){if(g>>8)*_=105-*_;
                        _++;*_++=32;*_=~-a&&a-13
                        ?108:109;}}return n?n-9?nyan
                       (_,y,n-2):_:nyan(_+=~y&' '?sprintf
                      (_,17[w]):0,y,9);}N main(N c){A e[256];
                     p(""/*%%PDF-1.3%%*/"")-2;q(#include<stdio.h>\n);
                    q(#define o *_++&& *_-41\n#define);p("" endstream "");q
                   (main(){for(;*_++;      *_-40?:putchar(o?*_:o?10:41));\n)
                  ;q(#define  endobj          return 0;}\n);q(typedef int ET;/)
                 ;q(*);o(1)*b=~(p(D                 (/Length 2 0 R)""stream\n""))
                ;for(p(""BT 12 818""                    "" Td/%c 12 Tf 12 TL%%%c/""
               ""static char*_=\""""                       "" \\\n"",7[v],*v/2);c=
              getchar(),~c;c-10?                         p(""/%c 12 Tf(\\%o)""
             ""Tj"",v[~-c%' '<25[                         v]&&!~-(~-c/'@')?0
            :7],c):(p(""()'"")))                         ;p(""%%\"";\nET "");*
           b-=~_;p(Y""/*"");E{a                         =nyan(e+sprintf(e,
          16[w]),c,6)-e;o(c-                         59)p(D(/Length %d)
         ""stream\n%s""Y,a,e)                         ;}o(2)p("" %u""S,*b);
        o(3)p(D(/Pages 4 0                         R)S);o(4)p(D(/Count
       1/MediaBox[0 0 595                         842]/Kids[5 0 R])S)
      ;o(5)p(C,4,0,6e-2,                         6e-2f,d,122,d);E p(
     ""/%c"",~-c/6+~14?c:                         d);q(]>>/CharProcs<<)
    ;E if(~-c/6+~14)p(                          ""/%c %d 0 R"",c,c+~58);
   for(q(>>/Widths[),                             c=';';--c;p("" 10""));*b
  =q(]>>>>>>/Contents 1                             0 R>>);for(p(""xref 0 ""
 ""%d "",--d);c<d;)p(""%010""
 ""u %05d n  "",*(c+++b),0);
 return!(p(DANCE,d,*b));}
","#include <stdio.h>
#include <string.h>

#define Q(B,q,b) s=j[B]; e=*s; *s=0; printf(q,b,b,b); *s=e; H=s;
#define W(a,b) r[O].c=a,r[O].f=b,O++
#define X(B) { int y=A; B; A=y; }
#define R return
#define M 1<<18
#define If char
#define fi ""%s""
#define IF for
#define FI ""r""
#define long
#define do










typedef  struct { int c,(*f)(); If*t,*h; } T; T*a,*r; int I[M],c[M]={'\0'} ,n
,N,i do,p ; char*s,*H,*z[M],f[M],o[M ],*_ [M ],**l =_ ,e ; int O=6,A='\5',x=5
,y='\0',g=2;k(p){a[p+2].h=H; R p+2; } S(p){ a[I[n++]=a[p].c>>8].h=H; return ~
p-'\1';}J(p){R~a[p].c>>8;}C(){ A=O; W(O+1<<8,J); } B(p){ c[g+'\1']=O;C(do);c[
g+='\2']='\0';R 1;}h(p){ Z(p); r[O-3].c+=256; R 1; } V(){ *I=n='\1'; for(; *a
->t; do ){do a->t=a[1].h=s; IF(i=N=0; i<n; i++){ p=I[i]; H=a[p ]do.h;for(; p>
0&&a[do p].t-s;){a[p].h&&a[p].h-H>0&&(H=a[p].h);e=a[p].c;a[p].t=s;p=do e&&e-*
s?p+'\1':~a[p].f(p);}p<0&&(I[N++]=~p);}n=N;s++;}}U(p){X(D(p)); c[g+='\2']=O ;
 return Z(p); } d(p){ C(); W(0,k); W(0,J); R 1 ; } q (p ){ C (); X (for(;*++s
!='\""'; )F(p); ); return 1; } Z(p){ r[A].c =O +1 <<'\10'; r [A ].f  =do J   ;
 { int y=A; W(O+*""\2void""<<8 ,J ); C (); W (y*1 + ""signed"" [ 6 ] +1 <<'\10',S
  do   )do ; } return  '\1';} F(p){ R*s?C(),*s==*""\\&""  long&&*++do s  do  ==
 'n'&&(*do s  =*""\nextern""),W (*s ,k ),W ( (4+5)[""volatile*""],J),'\1'  :'\0'; 
} E(p){ int V =*""\0float""; C (); X(s++;V=(*s++==*""^double"");c[g+=long 2]long=
0;s-=!V;for(; *s!=""]int""[0];s++){e=*s;s+=2*(s[1]==*""-for"" ); s=s;for(;e<=do*s
; e++){long C(); V?W(e,J):(W(e,k),W(0,J),U(p)); } } d(p); V||(W('\0',J)); D(p
); ); return 1; } j(p){ If*r=z[a[p].c>>8],**D=l; IF(; l-_&&l [-*""\2$""]-H>=0&&
(l [-*""\1do""]!=s||l[-2]!=H||r-l[-3]<=0); )l -=3 ; l ==_ ||l [-*""\1if(""] -H <=
0 * !""\0auto""?*l++=r,*l++=H,*l++=s,l:(l=D); R 0; } L(p){ W(A +*""\1for""<<8,S);
R 1+*""\0while""; } Y (p ){ z [y ]do=++do s  do; s=strchr (s ,*""\nshort"");W(y++
<< *""\btypedef"",j); r [x ].c =O  long<<'\10'; r [x ].f =S ; do x =O do ; C  (
); return   '\1'; } D (p ){ r [c [g ]].c =O <<8 ; c [g ]='\0';A=c[--do g]; --
g; return *""\1switch""; } T  b [ 12 + (M) + 321 ]={ {'\0','\0',""-""},{'*',Z } ,
{ '+',L},{ '\""',q} ,{ '['long ,E } ,{ 70-94+ do '@'do ,B } ,{ ')',D } do,{124

                  ,U},
                 {46,d}
                  ,{32
                  ,Y},
                {63,h},{
               0,F},{0,0,          ""Make a contract with me""
              },{'('*32,S}
             ,{'\0',k},{0,J,     ""and become a magical girl! ""
            },{'@'*4,J},{0,J
            },{'@',0} };main
           (  int B,If**j){ a
           =b;if(B>=3){s=f;r=
          b+'\14'; f[fread(f,1,
          M,fopen(j[1],FI))]=0;
          V(); W(0,J); IF(i=0;
          i<y;i++){*strchr(z[i
           ],10)=0;}o[fread(s
            =o,1,M,fopen(j[2
             ],FI))]=0; a=r
               ;V(); H=o;
         IF( j=_;j!=l; j+=3 ){Q
         (1,fi,H);Q(2,*j,j[1]);
          }printf(fi,H);}R 0;}
","long long n,u,m,b;main(e,r)char **r;{f\
or(;n++||(e=getchar()|32)>=0;b=""ynwtsflrabg""[n%=11]-e?b:b*8+
n)for(r=b%64-25;e<47&&b;b/=8)for(n=19;n;n[""1+DIY/.K430x9\
G(kC[""]-42&255^b||(m+=n>15?n:n>9?m%u*~-u:~(int)r?n+
!(int)r*16:n*16,b=0))u=1ll<<6177%n--*4;printf(""%llx\n"",m);}
","long long n,u,m,b;main(e,r){f\
or(;n++||(e=getchar()|32)>=0;b=""ynwtsflrabg""[n%=11]-e?b:b*8+
n)for(r=b%64-25;e<47&&b;b/=8)for(n=19;n;n[""1+DIY/.K430x9\
G(kC[""]-42&255^b||(m+=n>15?n:n>9?m%u*~-u:~r?n+
!r*16:n*16,b=0))u=1ll<<6177%n--*4;printf(""%llx"",m);}
","int _;main(O,l,o)char**l,**o;{_++>>9||main(1&(o?(int)o:O)|O*2,l,putchar(_%32?atoi(1[l])>>(7&O<<!o>>!o+29)&32<_|_==16?35:32:10)%10);}
","int _;main(O,l,o)char**l;{_++>>9||main(1&(o?o:O)|O*2,l,putchar(_%32?atoi(1[l])>>(7&O<<!o>>!o+29)&32<_|_==16?35:32:10)%10);}
","int count;
main(argc, argv, env)
    char **argv, **env;
{
    if (count++ < 512) {
	main(1 & (env ? (int) env : argc) | argc * 2, argv, putchar(count % 32 ? atoi(1[argv]) >> (7 & argc << !env >> !env + 29) & 32 < count | count == 16 ? '#' : ' ' : '\n') % 10);
    }
}
","                                                      #include<stdio.h>
                                                typedef unsigned int _;_ d,b,
                                           #define i(I1,Il,lI)if(Il){lI;}else{I1;}
                                         I[256],			n,y,a,r,u,k,o
                                       ,L,l[					256],O,K[
                                      /**/					    #define\
                                      q(g)						g char\
                                      *C,						   *Q,c[\
                                      ]=						      ""KfW""\
                                      """"							""Ww|""\
                                       /*							   'UU!\
                                        %							     NYA!\
                                        */							       ""Z}""\
                                 "";fRo?JtJaV<x4@*?R?&JV1""						 "".s""\
                             ""{Fyj2_;khB1xQ5oxm~mS@B|(pa>oRU""						  ""Ro""\
                          ""nB}h@o?)d.X)NSTIUCz7@%"",*s[]={c,""#en""					    ""di""\
                       ""f/*}||1;\n__DATA__\40*/\n\n#ifndef\40q\n#d""					     ""ef""\
                      ""ine\x20q\n#include<stdio.h>\ntypedef\40unsign""					       ""e""\
                    ""d\x20int\x20_;_\x20K[]={\n#include\40__FILE__\n#u""						""n""\
                   ""def q"",""0},L,O,l[256],I[256],n,y,a,r,u,k,o;""#g""char""					 ""*""\
                 ""S,s[]=\"""",c,c,""\"";int main(){X();for(S=s+*K;*S>37;){for""					 ""(o""\
                ""=0;o<5;o++)r=r*85+(83+*S++)%89;r"",""^=*x();for(o=0;o<4;o++""					  "")""\
                ""{s[O++]=r&255;r>>=8;}}return!fwrite(s,O-*S%5,1,stdout);}\n""					   ""#""\
               ""endif"",c},S[256]=""#ifdef/*\n'true'\40or\40q{\nexec\40head\40""					   ""-""\
              ""8\40$0\n};for(open$O,$0;<$O>;print\40if$f){$f|=/^$/;}q{*/q"",/*					    */z;
              256];q(_*x(){if(!L--){y+=++a;for(o=0;o<256;y=l[o++]=I[255&(k>>10					    )]+u
              ){n^=(o&1)?n>>(( o& 2)?16:6):n<<((o&2)?2:13);u=I[o];k=I[o]=I[255&					    (u>>
             2)]+(n+=I[(o+128)  &   255]) +y;}L=255;}return&l[L];}_*X(){for(O=0					    ;256
            >O;I[O++]=0);for(O   =     0;   sizeof(K)/sizeof( _)> O;O++)I[O&255]				    ^=K[
            O];for(n=y=a=L=O=0 ;O<1<<24;++   O)x( );r=O=0x0; return&O;})int/*^^*/				    main
           (int p,char**P){FILE* Z=fopen(p>    (+  1)?P[01   ]   :""/dev/urandom"",				    ""rb""
          );i(;,Z,O=fread(K,256  ,4,Z);/*P          */     fclose(Z))X();for(p=b=d				    =O=
          0;O<256;K[O++]=0)*K=+  86;for(O                =1;12> O;K[O++]=*x());X();				    for
         (C=Q=S;r-8;){i(*C++=34,  (r-4&&r               -5)||C- S ,;)z=Q[p++];i(;,z				    !=
        32||r-3,i(i(C+=sprintf((    C),                 ""%uU""    "","",K[b++]);i(d=1;C				   =S
       ;i(d=02,b-12,;),b%6,;),r-1                       ,i(b=   fread(c,1,4,stdin);i				   (p
       =O=0,b,for(d=O=0;O<04;O++)d                             +=(c[O]&255)<<(8*O);d				  ^=
      *x();for(p=5;p;c[--p]=O<32?O+                            95:O+6){O=d%85;d/=85;}				 O=
     5)i(d=0,b<4,c[O++]=b?b-1?b-2?36:      37:33:35           ;d=2)c[O]=0,r-4,i(i (d=				 2
    |d,C!=S+6,*C++=(*x()%34)+93;p--),r      -5,*s=          C;d|=2)  )),z ,i(*C++ =92				,
   z-63||C [-1]-63||C>S+76,;)*C++=z))i(                   ;,d>1,d=  d-2  ;Q=s[r]  ;i(			       ;
  ,r<3||  r>5,d=1;i(;,r-1, *C=0)C=S)  i(;,            r-4, p=0)++   r)   i(*(C++ )=
 34,r    <4||r>5||   C<S+    78,;)i       (*C++=0;d=1; C=S   ,r<3       ||       r>
5        ||C<S+     79,;      )i(;,d,                         puts               (
        S);         d=0      )}  return
                                      0;}
","       Int L[A],m,b,*D=A,
        *c,*a=L,C,*U=L,u;s
         (_){u--&&s(a=*a);}
          char*B,I,O;S(){b=b
           --?b:m|read(0,&I,1
            )-1;return~I>>b&1;
             }k(l,u){for(;l<=u;
              U-L<A?*U++=46^l++[
               ""-,&,,/.--/,:-,'/""
               "".-,-,,/.-,*,//..,""
              ]:exit(5));}p(Int*m){
             return!*U?*m=S()?U++,!S
            ()?m[1]=p(++U),2:3:1,p(U)
           :S()?U+=2:p(U[1]++),U-m;}x(
          c){k(7*!b,9);*U++=b&&S();c&&x
         (b);}d(Int*l){--l[1]||d(l[d(*l),
        *l=B,B=l,2]);}main(e){for(k(10,33
       ),a[4]-=m=e-2&7,a[23]=p(U),b=0;;e-2
      ?e?e-3?s(D=a),C=a  [3],++1[a=a[2]],d(
     D):c?D=c,c=*D,*D=    a,a=D:exit(L[C+1])
    :C--<23?C=u+m&1?O      =O+O|C&1,9:write(m
   ||(O=C+28),&O,1)+        1:(S(),x(0<b++?k(0,
  6),U[-5]=96:0)):(          D=B?B:calloc(4,X))
 ?B=*D,*D=c,c=D,D[            2]=a,a[++D[1]]++,D
[3]=++C+u:exit(6)              )e=L[C++],u=L[C];}
","     Int L[A],m,b,*D=A,
      *c,*a=L,C,*U=L,u;s
       (Int*m){return!*U?
        *m=g()?U++,!g()?m[
         1]=s(++U),2:3:1,s(
          U):g()?U+=2:s(U[1]
           ++),U-m;}v(){for(D
            =a;u--;a=*a);C=a[3
             ];++1[a=a[2]];d(D)
              ;}char *B,I,O,*S =
               ""-,&,,/.--/,:-,'/""
               "".-,-,,/.-,*,//..,""
              ;d(Int*l){--l[1]||d(l
             [d(*l),*l=B,B=l,2]);}g(
            ){b=b--?b:m|read(0,&I,1)-
           1;return~I>>b&1;}x(){for(k(
          0,6),U[-5]=96;b;*U++=g())k(0,
         9);}k(l,u){for(;l<=u;U-L-A?*U++
        =S[l++]^46:exit(5));}main(e){for(
       k(10,33),a[4]-=m =e-2&7,a[23]=s(U),
      b=0;;e?e-1?e-2?c   ?D=c,c=*D,*D=a,a=D
     :exit(L[C+1]):(D     =B?B:calloc(4,X))?
    B=*D,*D=c,c=D,D[       3]=++C+u, D[2]=a,a
   [++D[1] ]++:exit         (6):v():C -->22?g(
  ),1<++b &&x(),k(           7*!b,9),* U++=b&&g
 ():(C=u+m&1?O=O+             O|C&1,9:write(m||(
O=C+28),&O,1)+1)               )e=L[C++],u=L[C];}
","#include <stdio.h>
#include <string.h>
#include ""zlib.h""




      int
    i,j,k,l
  ,m,n,Q,W,H,
 B,Z,Y,X,O=1<<24
  ; char*A[999],x[
   1<<24],z[1<<24],
     s[1<<24],t[2<<24
         ],w[2<<24],*E;
           uLong N;  FILE
             *f ; int  main(
                int c,char**v){
                  unsigned char**V
                     =(unsigned char
                        **)v; for(m=0;
                            c==-11&&m<H
                              ; m++, (*v)
                                +=m%3==0&&
                                (B&4) ,V[4]
                                 ++) n=m%W,
                                  l=n?l:*(*V
                                  )++,*V[4]=
                                   !(B&2)&&
                                    n%3?V[4
                                    ][-1]:
                                     (i=
                                    n<3?0:
                                  V[4][-3],j
                                =m/W?V[4][-W
                               ]:0,Z=k=!(m/W)
                              ||n<3?0:V[4][-3
                             -W],*(*V)+++(l?l
                             -1?l-2?l-3?(X=j-
                             Z,X=X>0?X:-X,Y=i-
                            Z,Y=Y>0?Y:-Y,Z=i+j
                            -Z-Z,Z=Z>0?Z:-Z,X>Y
                           ||X>Z?Y   >Z?k:j:i):
                           (i+j)    /2:j:i:0));
                          for(     E=t+O; *v-1[v]
                         &&c==   -16; ++*v)n=**v,n
                         -62?   n-60?n  -91?n-93||!
                        m||    !*E?*    v:(*v=A[--m+9
                       ]):    (A[9+    m++]=*v-1):--E
                      :++       E      ,n-43?n-44?n-45?
                     n-        46    ?0:putchar(*E):--*E
                   :(*       E=     getchar()):++*E; for(;
                   7<       -c     &&11>-c&&*v!=5[v]; ++*v)
                 **V      =c     +8?c+9?*V[1]++<<6|56:**V|~3
                &*V     [1]     ++:**V>>6; for(; m<n*2; m+=2)c
              +18?    c+19      ?0:(V[1][m/8]+=(*V[0] ++-56)>>m
             %8)     :(*       V[1]++=V[0][m/8]<<m%8 ); return !
           c?c:     c>0       ?n=main(-7,(Q=**++v,N=0x49444154,*A
         =s+4,    main      (-128   ,A),A[1]=*++v,A  [4]=z,*A=x,A))
        ,c=A[    6]         -x-    12,Q-101?main(-19,(main(-10,(A[5]=
       t+n,    *A=          t,   A[1]=z,A)),*A=t,A  [1]=w,A)):main(-9,(
      main(   -8                ,((n=main(-7,(A[1]   =*++v,A[4]=t,*A=s+4,
    A)))<0               ?      main     (-18,(n=  -n,*A=s,A[1]=t,A)):0,A[
    5]=t+n            ,*A=     t,A)      ),*A=t,  A[1]=z,A)),98-Q?E=memcmp(
   w,s,4              )?      n+=       main(-22  ,(*A=z,A[1    ]=t,A[2]=t+n
  ,A)),            N=n=     main     (-23,(*A=t, A[1]=z,A[2       ]=z+n,A)),
  memmove         (x+      c+n+12   ,x+c,12),memcpy(x+c+8,t,     n),main(-128
  ,(*A=          x+c       +4,A))   ,N=crc32(    0,memcpy(x       +c+4,s,4),n
 +4),           main       (-128,   (*A=x+c+     n+12,A)),n       +=c+24,x:(n=
 strlen         (w        +4),w+4),fwrite(E     ,1,n,stdout):  main(-16,(*A=w,
 A[1]=w    +H, A))       :-c>31?main(c+=32     ,(*--*v=N,N>>=8,v)):-++c<4?(-c)
 [*V]+256*main(c,v    ):c+23?c+22?c+21?c+6?c+5?c+4?0:(N=O,uncompress(*v=s+4,&N
  ,v[3],v[2]-v[3]   ),main(c-7,v),H):(n-=l=main(-4,v)+12,5[*v]-68?(v[6]=(*v+=
  l)):(memcpy(v[2],*v+8,l-12),v[2]+=l-12,memmove(*v,*v+l,n)),main(c-(n>8),v))
  :(n=  main(-24,v),main(-4,v)-0x89504e47?-H:main(c,(*v+=16,W=main(-4,v)*3,*v
   +=       4,H=main(-4,v)*W,B=(*v)[5],(*v)[5]=2,N=crc32(0,*v-    8,17),*v+=
    13         ,main(-128,v),v[3]=v[2]=w+O,*v-=21,v))):(*      *v=0,memcpy
     (++*v            ,v[1],W),*v+=W,v[1]+=W,                1+main((v[1]
      !=v[2])                                            *--c,v)):(N=O
         ,compress(*v,&N,                    v[1],v[2]-v[1]),N):(f=
              fopen(v[1],""rb""))?fclose((n=fread(*v,1,O,f),f)),
                      n[*v]=0,n:(strcpy(*v,v[1]),0); }
","#include <stdio.h>

int main() {
	int i=40;
	printf(""%c"",(char)(i)));
	return 0;
}
","#include <stdio.h>
#include <stdlib.h>
#define s(_)sizeof(_)
#define n void*
#define z(_)_,_,_
#define x (s*)__
#define y (s*)_
#define h C(y,y)
#define o &d
#define t() (p)
#define w(_)_,_
typedef n (*(*(*(*p)(n,n))(n,n))(n,n))(n,n);
typedef struct s { struct s* a	   ; struct s* UNUSED; } s;
typedef struct t { struct s* UNUSED; struct s* a	 ; } *t;
n __(n _,n __)	 { return  _;}n _(n _,n __){return __; }
typedef unsigned char e;
#define _(_)((*_).a)

								   s* 
								   w,
							   a={x	 ,x},
							   b={x	 ,y},
   c={y,x},d={y,y};s l[]={&b,&d,w	   (w(w(w(w(w(&d)))))),w(&d),&c,&d,w(w(w(
   &d))),&c,w(&b),&d,&a,z(&d),z(w	   (w(w(w(w(&d)))))),&b,&b,w(&d),&a,&b,w(&
  d),																		z(w
 (w(																		 w(w

	(&d))))),w(w(w(&d))), &b,&c,&d, &d,&a,&c ,w(w(&d)), &c,z(&b) ,w(&d),w(&a)
	};s* C(s* a, s* b) {s* _=malloc(s(s));_(_)=a;_((t)_)=b;return _;}e k2=s(l
	);p																	  f(p
	a,p																	   b)
   
				 {	 e k;s d;p v,r,			 q,i,C,c,u,g,m=t(	)
_			   (   _(_(w)));C=t()			_(_(&l[fread(&k,s(e	  )
,s			  (	  e),stdin)]));v			   =C(_,__);d=l[k=(e   )
C			 (	 k2,k)];c=(u=a(					  b,_),i=(t()_((t	)
_		   (   _(w))))(_,_(_(o))				),(a(_(_((t)o)),(t(	  )
_		  (	  _((t)o)))(_,__)					   ))(b(_((t)_((t)o)   )
,		 (	 t()_((t)_((t)o)))					  (_,__)),_));{p a=t(	)
_		 (	 (t)_(o));{p b=							 C(_,i(u(_,__),_)	)
;		{	p u=C(_,(t()_(_(o)					   ))(_,__));_(_(_(w))	 )
=	   (   s*)i(__,_(_(								  _(w))));r=b(m(c,_	  )
,C	   (   m(_,(t()_((								  t)_(_(w))))(_,__)	  )
,	  (	  f)));v=b(_,v);i							  =b(a(_,__),_);g=(b   )
	  (	  a(m(c(_,__),__								),_),_);q=u(_((t   )
_	 (	 o)),_)((t()_(									 (t)_(_(w))))((t(	)
_	 (	 _((t)o)))(_(_((t							   )_(w))),(t()_(_((t	)
_	 (	 w))))(_,__))(									 _,__),_)(_,__),_	)
;_	 (	 _((t)_(w)))				   =			   (s*)u(_((t)_(o)),_	)
	 (	 (t()_((t)_(_(w))))							  (_,__),_)(_(_((t)o)	)
,_	 (	 _((t)_(w))));}								   }_((t)_(_(w)))=(s*	)
q	 (	 a=(t()_((t)_(_(w)))						)(_,__),_((t)_(_(w)))	)
	 ;	 fwrite((k=k,&k2)								 ,s(e),u(_,g)(s(e	)
,	 (	 e)s(s[s(s[s(s[s								(s)])])])),stdout	)
	  ;	  fwrite((k2=k,&k)							   ,s(e),u(__,g)(s(e   )
,	  (	  e)s(s[s(s[s(s[s							   (s)])])])),stdout   )
;_	  (	  _(_((t)w)))=(s*)							 u((t()_(_(_((t)w)))   )
	   (   _,__),_(_(_((t)w							  ))));_(_((t)_(w))	  )
=	   (   s*)q(a(_(_((t)							  o)),_(_((t)_(w)))	  )
,_		(	_((t)_(w))));}						  _((t)_(_((t)w)))=(s*	 )
		 (	 t()_(_(_((t)w)))						)(_((t)_(_((t)w))	)
,u		  (	  (t()_((t)_(_((					  t)w))))(_,__),_((t   )
_		   (   _((t)w)))));g					   =u((q=u(C(__,(t(	  )
_			(	_(_((t)w))))(_((t			   )_(_((t)w))),_)),_)	 )
			 (	 _,__),g);v=g(					  __,i(u(_,i(f,_)	)
			   (   _(_((t)o)),_(				(t)_((t)o))),v)	  )

	   ,r=																 q(_
	   ,g(																 f,i
	   (v(f,(_(_(_(w)))=(s*)m,_)),r)));return q(_,v)(r(g(__,a),g(__,b)),r);}

	  int																   main
	   (){w=C(C(h,h),C(h,h));return	   printf((e*)f(_,_)(""OK\n"",""\n ^ Error\n""
								  """"  ))
									;}
","#include <stdio.h>
#include <malloc.h>
#define s(_)sizeof(_)
#define n void*
#define z(_)_,_,_
#define x (s*)__
#define y (s*)_
#define h C(y,y)
#define o &d
#define t() (p)
#define w(_)_,_
typedef n (*(*(*(*p)(n,n))(n,n))(n,n))(n,n);
typedef struct s { struct s* a	   ; struct s* UNUSED; } s;
typedef struct t { struct s* UNUSED; struct s* a	 ; } *t;
n __(n _,n __)	 { return  _;}n _(n _,n __){return __; }
typedef unsigned char e;
#define _(_)((*_).a)

								   s* 
								   w,
							   a={x	 ,x},
							   b={x	 ,y},
   c={y,x},d={y,y};s l[]={&b,&d,w	   (w(w(w(w(w(&d)))))),w(&d),&c,&d,w(w(w(
   &d))),&c,w(&b),&d,&a,z(&d),z(w	   (w(w(w(w(&d)))))),&b,&b,w(&d),&a,&b,w(&
  d),																		z(w
 (w(																		 w(w

	(&d))))),w(w(w(&d))), &b,&c,&d, &d,&a,&c ,w(w(&d)), &c,z(&b) ,w(&d),w(&a)
	};s* C(s* a, s* b) {s* _=malloc(s(s));_(_)=a;_((t)_)=b;return _;}e k2=s(l
	);p																	  f(p
	a,p																	   b)
   
				 {	 e k;s d;p v,r,			 q,i,C,c,u,g,m=t(	)
_			   (   _(_(w)));C=t()			_(_(&l[fread(&k,s(e	  )
,s			  (	  e),stdin)]));v			   =C(_,__);d=l[k=(e   )
C			 (	 k2,k)];c=(u=a(					  b,_),i=(t()_((t	)
_		   (   _(w))))(_,_(_(o))				),(a(_(_((t)o)),(t(	  )
_		  (	  _((t)o)))(_,__)					   ))(b(_((t)_((t)o)   )
,		 (	 t()_((t)_((t)o)))					  (_,__)),_));{p a=t(	)
_		 (	 (t)_(o));{p b=							 C(_,i(u(_,__),_)	)
;		{	p u=C(_,(t()_(_(o)					   ))(_,__));_(_(_(w))	 )
=	   (   s*)i(__,_(_(								  _(w))));r=b(m(c,_	  )
,C	   (   m(_,(t()_((								  t)_(_(w))))(_,__)	  )
,	  (	  f)));v=b(_,v);i							  =b(a(_,__),_);g=(b   )
	  (	  a(m(c(_,__),__								),_),_);q=u(_((t   )
_	 (	 o)),_)((t()_(									 (t)_(_(w))))((t(	)
_	 (	 _((t)o)))(_(_((t							   )_(w))),(t()_(_((t	)
_	 (	 w))))(_,__))(									 _,__),_)(_,__),_	)
;_	 (	 _((t)_(w)))				   =			   (s*)u(_((t)_(o)),_	)
	 (	 (t()_((t)_(_(w))))							  (_,__),_)(_(_((t)o)	)
,_	 (	 _((t)_(w))));}								   }_((t)_(_(w)))=(s*	)
q	 (	 a=(t()_((t)_(_(w)))						)(_,__),_((t)_(_(w)))	)
	 ;	 fwrite((k=k,&k2)								 ,s(e),u(_,g)(s(e	)
,	 (	 e)s(s[s(s[s(s[s								(s)])])])),stdout	)
	  ;	  fwrite((k2=k,&k)							   ,s(e),u(__,g)(s(e   )
,	  (	  e)s(s[s(s[s(s[s							   (s)])])])),stdout   )
;_	  (	  _(_((t)w)))=(s*)							 u((t()_(_(_((t)w)))   )
	   (   _,__),_(_(_((t)w							  ))));_(_((t)_(w))	  )
=	   (   s*)q(a(_(_((t)							  o)),_(_((t)_(w)))	  )
,_		(	_((t)_(w))));}						  _((t)_(_((t)w)))=(s*	 )
		 (	 t()_(_(_((t)w)))						)(_((t)_(_((t)w))	)
,u		  (	  (t()_((t)_(_((					  t)w))))(_,__),_((t   )
_		   (   _((t)w)))));g					   =u((q=u(C(__,(t(	  )
_			(	_(_((t)w))))(_((t			   )_(_((t)w))),_)),_)	 )
			 (	 _,__),g);v=g(					  __,i(u(_,i(f,_)	)
			   (   _(_((t)o)),_(				(t)_((t)o))),v)	  )

	   ,r=																 q(_
	   ,g(																 f,i
	   (v(f,(_(_(_(w)))=(s*)m,_)),r)));return q(_,v)(r(g(__,a),g(__,b)),r);}

	  int																   main
	   (){w=C(C(h,h),C(h,h));return	   printf((e*)f(_,_)(""OK\n"",""\n ^ Error\n""
								  """"  ))
									;}
","#include <stdio.h>
#include <stdlib.h>
typedef void *(*(*(*(*p) (void *, void *)) (void *, void *)) (void *, void *)) (void *, void *);

typedef struct frst {
    struct frst *a;
    struct frst *UNUSED;
}    frst;

typedef struct scnd {
    struct frst *UNUSED;
    struct frst *a;
}   *scnd;

void *
arg1(void *a1, void *a2)
{
    return a1;
}

void *
arg2(void *a1, void *a2)
{
    return a2;
}

typedef unsigned char u_char;

frst *w,
     a = {(frst *) arg1, (frst *) arg1},
     b = {(frst *) arg1, (frst *) arg2},
     c = {
    (frst *) arg2, (frst *) arg1
},
d = {
    (frst *) arg2, (frst *) arg2
};

frst table[] = {
    &b, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &c, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &c, &b,
    &b, &d, &a, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &b, &b,     &d, &d, &a, &b,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,     &d, &d, &d, &d,
    &d, &d, &d, &d,     &d, &d, &b, &c,     &d, &d, &a, &c,     &d, &d, &d, &d,
    &c, &b, &b, &b,     &d, &d, &a, &a
};

frst *
C(frst * a, frst * b)
{
    frst *p = malloc(sizeof(frst));

    p->a = a;
    p->UNUSED = b;
    return p;
}

u_char k2 = sizeof(table);

p
f(p a, p b)
{
    u_char k;
    frst d;
    p v,
      r,
      q,
      i,
      C,
      c,
      u,
      g,
      m = (p)
    ((*((*((*w).a)).a)).a);

    C = (p) ((*((*&table[fread(&k, sizeof(u_char), sizeof(u_char), stdin)]).a)).a);

    v = C(arg2, arg1);
    d = table[k = (u_char) C(k2, k)];
    c = (u = a(b, arg2), i = ((p) ((*(scnd) ((*((*w).a)).a)).a)) (arg2, ((*((*&d).a)).a)), (a(((*((*(scnd) & d).a)).a), ((p)
															 ((*((*(scnd) & d).a)).a)) (arg2, arg1))) (b(((*(scnd) ((*(scnd) & d).a)).a)
																				     ,((p) ((*(scnd) ((*(scnd) & d).a)).a)) (arg2, arg1)), arg2)); {
	p a = (p)
	((*(scnd) ((*&d).a)).a); {
	    p b = C(arg2, i(u(arg2, arg1), arg2)); {
		p u = C(arg2, ((p) ((*((*&d).a)).a)) (arg2, arg1));

		((*((*((*w).a)).a)).a)
		  = (frst *) i(arg1, ((*((*((*w).a)).a)).a));
		r = b(m(c, arg2)
		      ,C(m(arg2, ((p) ((*(scnd) ((*((*w).a)).a)).a)) (arg2, arg1))
			 ,(f)));
		v = b(arg2, v);
		i = b(a(arg2, arg1), arg2);
		g = (b) (a(m(c(arg2, arg1), arg1), arg2), arg2);
		q = u(((*(scnd) ((*&d).a)).a), arg2) (((p) ((*(scnd) ((*((*w).a)).a)).a)) (((p)
											    ((*((*(scnd) & d).a)).a)) (((*((*(scnd) ((*w).a)).a)).a), ((p) ((*((*(scnd) ((*w).a)).a)).a)) (arg2, arg1)) (arg2, arg1), arg2) (arg2, arg1), arg2);
		((*((*(scnd) ((*w).a)).a)).a) = (frst *) u(((*(scnd) ((*&d).a)).a), arg2)
		  (((p) ((*(scnd) ((*((*w).a)).a)).a)) (arg2, arg1), arg2) (((*((*(scnd) & d).a)).a)
									    ,((*((*(scnd) ((*w).a)).a)).a));
	    }
	} ((*(scnd) ((*((*w).a)).a)).a) = (frst *)
	  q(a = ((p) ((*(scnd) ((*((*w).a)).a)).a)) (arg2, arg1), ((*(scnd) ((*((*w).a)).a)).a));
	fwrite((k = k, &k2), sizeof(u_char), u(arg2, g) (sizeof(u_char)
							 ,(u_char) sizeof(frst[sizeof(frst[sizeof(frst[sizeof(frst)])])])), stdout);
	fwrite((k2 = k, &k), sizeof(u_char), u(arg1, g) (sizeof(u_char)
							 ,(u_char) sizeof(frst[sizeof(frst[sizeof(frst[sizeof(frst)])])])), stdout);
	((*((*((*(scnd) w).a)).a)).a) = (frst *) u(((p) ((*((*((*(scnd) w).a)).a)).a))
						   (arg2, arg1), ((*((*((*(scnd) w).a)).a)).a));
	((*((*(scnd) ((*w).a)).a)).a)
	  = (frst *) q(a(((*((*(scnd) & d).a)).a), ((*((*(scnd) ((*w).a)).a)).a))
		       ,((*((*(scnd) ((*w).a)).a)).a));
    }
    ((*(scnd) ((*((*(scnd) w).a)).a)).a) = (frst *)
      ((p) ((*((*((*(scnd) w).a)).a)).a)) (((*(scnd) ((*((*(scnd) w).a)).a)).a)
					   ,u(((p) ((*(scnd) ((*((*(scnd) w).a)).a)).a)) (arg2, arg1), ((*(scnd) ((*((*(scnd) w).a)).a)).a)));

    g = u((q = u(C(arg1, ((p)
			  ((*((*((*(scnd) w).a)).a)).a)) (((*(scnd) ((*((*(scnd) w).a)).a)).a), arg2)), arg2))
	  (arg2, arg1), g);
    v = g(arg1, i(u(arg2, i(f, arg2))
		  (((*((*(scnd) & d).a)).a), ((*(scnd) ((*(scnd) & d).a)).a)), v))
      ,r = q(arg2
	     ,g(f, i
		(v(f, (((*((*((*w).a)).a)).a) = (frst *) m, arg2)), r)));
    return q(arg2, v) (r(g(arg1, a), g(arg1, b)), r);
}

int
main()
{
    w = C(C(C((frst *) arg2, (frst *) arg2), C((frst *) arg2, (frst *) arg2)), C(C((frst *) arg2, (frst *) arg2), C((frst *) arg2, (frst *) arg2)));
    return printf((u_char *) f(arg2, arg2) (""OK\n"", ""\n ^ Error\n""
					    """"));
}
","char*_ = ""'""""/*"";
#include <stdio.h>
#define m 21
#define o(l, k) for(l=0; l<k; l++)
#define n(k) o(T, k)


              int E,L,O,R,G[42][m],h[2][42][m],g[3][8],c
              [42][42][2],f[42]; char d[42]; void v( int
              b,int a,int j){ printf(""\33[%d;%df\33[4%d""
              ""m  "",a,b,j); } void u(){ int T,e; n(42)o(
              e,m)if(h[0][T][e]-h[1][T][e]){ v(e+4+e,T+2
              ,h[0][T][e]+1?h[0][T][e]:0); h[1][T][e]=h[
              0][T][e]; } fflush(stdout); } void q(int l
                            ,int k,int p){
                            int T,e,a; L=0
                            ; O=1; while(O
                            ){ n(4&&L){ e=
                            k+c[l] [T][0];
                            h[0][L-1+c[l][
                            T][1]][p?20-e:
e]=-1; } n(4){                                          e=k+c[l][T][0]; a=L+c[l][T][
1]+1; if(a==42                                          || h[0][a][p?20-e:e]+1){ O=0
; } } n(4){ e=                                          k+c[l][T][0]; h[0][L + c[l][
T][1]][p?20-e:                                          e]=g[1][f[p?19+l:l]]; } L++;
u(); } n(42) {                                          o(e,m)if(h[0][T][e]<0)break;
o(a, m&&e==m){                                          for(L=T; L; L--) { h[0][L][a
]=h[0][L-1] [a                                          ]; } h[0][0][a]=-1; } } u();
}int main(){ int T,e,t,r,i,s              ,D,V,K; printf(""\33[2J\33[?25l""); n(8)g[i=
1][T]=7-T; R--; n(42) o(e,m)              G[T][e]--; while(fgets(d,42,stdin)) { r=++
R; n(17){ e=d[T]-48; d[T]=0;              if ((e&7)==e) { g[0][e] ++; G[R][T+2]=e; }
} } n(8)if(g[0][7-T]){ t=g[i              ][O]; g[i][O++]=g[i][T]; g[i][T]=t; } n(8)
g[2][g[i][T]]=T; n(R+i)o(e,m              )if(G[T][e]+i) G[T][e]=g[2][G[T][e]]; n(19
)o(t,2){ f[T+t+T]=(T[""+%#,4""              ""5>GP9$5-,#C?NX""]-35)>>t*3&7; o(e,4){ c[T]
[e][t]=(""5'<$=$8)Ih$=h9i8'9""              ""t=)83)l4(99(g9>##>4("" [T+t+T]-35)>>e*2&3;
} } n(15) { s=T>9?m:(T&3)-3?15:36;o(e,s)o(t,2)c[T+19][e][t]=""6*6,8*6.608.6264826668\
865::(+;0(6+6-6/8,61638065678469.;88))()3(6,8*6.608.6264826668865:+;4)-*6-6/616365,\
-6715690.5;,89,81+,(023096/:40(8-7751)2)65;695(855(+*8)+;4**+4(((6.608.626482666886\
5:+;4+4)0(8)6/61638065678469.;88)-4,4*8+4(((60(/6264826668865:+;4-616365676993-9:54\
+-14).;./347.+18*):1;-*0-975/)936.+:4*,80987(887(0(*)4.*""""/4,4*8+4(((6264826668865:\
+;4/4-4+8-4)0(8)6365678469.;88)1/(6*6,6.60626466686:8)8-8*818.8582/9863(+;/""""*6,6.6\
0626466686:4(8)8-8*818.8582/9863(+;/,6.60626466686:8-818.8582/9864*4+4(0())+;/.6062\
6466686:8/8380/7844,4-4*4+4(0())69+;/0626466686:818582/9864.4/4,4-4*4+4(0())+;"" [e+E
+e+t]-40; E+=s+s; } n(45){ if(T>i) { v(2,T,7); v(46,T,7); } v(2+T,44,7); } T=0; o(e,
42)o(t,m)h[T][e][t]--; while(R+i) { s = D=0; if (r-R) { n(19) if (G[R+i][T]+i) V=T/2
; else if(G[R][T]+i) s++; if(s) { if(V>4){ V=9-V; D++; } V+=29; n(20) q(c[V][T][0],c
[V][T][i],D); } } n(19) if((L=G[R][T])+i) { O=T-L; e=O>9; t=e?18-O :O; o(K,((t&3)-3?
16:37)){ if(K){ L=c[t+19][K-i][0]; O=c[t+19][K-i][i] ; } q(L,O,K && e); } } if(s) q(
c[V][20][0], c[V][20][i], D); R--; } printf(""\33[47;1f\33[?25h\33[40m""); return 0; }","main(int riguing,char**acters){puts(1[acters-~!(*(int*)1[acters]%4796%275%riguing)]);}
","               #include\
          <stdio.h>//
        #define Y(\
      _)_##char
    #define \
   _ [9<<9],
  #define j\
 L;fread(&\
 L,4,1,f);u
 #define P\
 &4**(int*\
 )""   "")% \
 3901%31///
  #define q\
   Z[F++]=*E
    #define $\
      for(""IOCCC""
          #include\
              <stdlib.h>










int   *Q,u,i,c,k,B,r=0,w,n,F=0,x,J,u,m,p,s=0,v,e,r,L,a,z,y,D,o,g;   Y(       )*
                                                                    Z=      ""Vn""
  ""-S""                                                             ""xR9Q""   ""[$s""
""Zd&o+""                                                            ""pf^cM""  ""cbac\
J_VHMF_""                                                           ""BkaEg^"" ""x`i_i\
us%d]oWG:""                                                          ""r`IZ.6_]H3ec]_\
bWW_^Ej2i[r""                                                         ""ZZnJjW[bK`hZakb\
_l]gL3X]d_#$eK""                             ""[G3 d[Xe][:V`4Z]Z""      ""VfX^]V:X%b]N,ma-j""
""^m57c!`O.qP8lTc^""                    ""gm,Um;m`m^^`5n_nci<Wf[h<t+e$%"" ""]Lha&=l Umc>m#_mdp""
   ""h/codZ#i`,''mbb(fh""          "")h)(^uV9b7dcZq`^d`/*3`#ko`lj;^idad/]0ffxP*]??bff$h`@(Zgtcn""
       ""k10t<A6mYZNh!g&a2^j"" ""!^hOZb!&]bd(]TuqI]#iepZc/XdX(Z X4a!dgpc>0q;]^7p`q*AtqC1j,'#_on tp""
             ""on e !1+tA6`db`qciq`'=?ui]'`_`dk`!kx_%]bu]cZX8u_)Z=8@ghg$mlp`a>D_o2_eb)sb)sa0g@f-h""
                  ""1bl_DeblFsa&Dt^t4*X *mCC^5Y"",M _ A _ G _ I _ C _ K[]=""',b}q}a9\""],)'(cDDJr4""
               ""Ab,:sdtd/E*#2eXkZ7cPthkq`(stnhct!a:>A;A+jA9>A;A+js"",*E=I;FILE*f;main
           (int d,Y()**t){$;!t;s=c=-D){$,t=v=D?k:J;v++-d;){$,o=L=z=0,s=D?J:k;s+++d
        -B-F;)(o&&(e=m),y=*Q!=(m=Q[u*i+(D?v-u*s:s-u*v)]))^o&&(G[z++]=s-L>20,L=s,o=y);$,
      s=z,o=0;s--;o+=G[s]^s[A]);$;z^w||o;z=w){$,o=1;o&&!--o*D-~-~-w|1[A]|v-a>28&&w^4|1[A]|
    3[A]|!2[A      ]|v-a>5;)$;I[g[I]=2,++g]=-1,-s<w;I[~-g]=A[-s--]);$,a=v,w=z;z--;A[z]=z[G]);
  }}$,v=a        =o;(Z=C+!D*734)[z=a]                         ^3;d=0){$;!~I[v];a=z,v=o=0)$,M[L
 ++]+=          Z[z]^4?-42:o;                                      Z[z++]^4;);      $;~z&&2>(s=I
 [v           ])&4<Z[z]                                                |Z[z]==s         ;)++z,s^2?
             d++,++                                                       v:v&&(o           +=d,a=z,
            z=-1                             );$;v++[                       I]^2;)             ;}}$;d
            ;d                             =c){$,p=*Z;F++                     [I]=                *++
                                        Z%p,*Z;);$,Z=C;x=F                     ,F=
                                        r,s=2,p---7;Q=E,E=Z
                                       ,Z=Q)$;s%x;p^(c=s++[E
                       ])?q*0+c:(q++,  q--));$;K[F];K[F++]-=p
                    );c=fseek((f=fopen(*++t,""rb""))?f:(exit(1)
                   ,f),10,r);j;n=j=j=j;i=j;F=a=fseek(f,n,c);
                  Q=calloc(z=i--*u,4);$;a^z;fread(a+++Q,L>>
                  19,1,f));$;F++<i;r=n){$,n=0,B=u;B;n|=*Q^Q
                  [u*(i-F)+--B]);$,n&&Y(!r&&(D=F-J,J=F);
                 !n&&r;r=x=!put)(10))$;B^u;B++,c=p){$,p=
                0,s=J;s^F;p|=*Q^Q[B+u*(i-s++)]);$;p&&!c;
              )$;++Y        (c*F-J<<1<5*((k=B)-x);put)(32
             ),++c);          $;!p&&c;x=B){$,F-J<<1<Y(D&&
              put)(           10),D=95;D--;D[M]=0);$;main(
               ++D?B:           F,w=a=g=0),!D;);$;x=K[o++]-
                 27;M             [x]*M[K[o++]    -27]>0&&(M
                                    [x]=s));$;     ++c^L;M[c]
                                      >s&&(s=M[       x=c]));$;
                                       3^d||printf      (K+--o,(
                                          *Q P,(e P),      D*!(c+~x);
                                               w++)$,o=     '~';-~o;)$
                                                 [w]Y(^--     o||put)(D=
                                                   o);0;);c     =Y(~o&&!
                                                    put)(*K+     x);}}}}}","#include ""SDL.h""

#define $ for(O=9
#define CX M+=(T%3+2*!(!T*t-6))
#define x ,A=4*!T,O=t,W=h=T<3?u(Q?p:D(A+3),D(A),D(A+1)[i]+D(A+2)*g+):K(t),U=V=K(a),o?U=h,W=V:V,
#define C 8*-~L
#define Z short
#define y a(Z)Y[++O]
#define B ),a--||(
#define _ ),e--||(

#define V(I,D,E)(O=a(I)h[r])&&!(A=(D)(V=(1[E+L]<<16)+*i)/O,A-(I)A)?1[E+L]=V-O*(*E=A):H(0)
#define i(B,M)B(o){return M;}
#define R(O,M,_)(S=L?a(I Z)O:O,N=L?a(I Z)O M(f=a(I Z)_):(O M(f=a(I n)_)))
#define T(_)R(r[u(10,L=4,--)],=,_)
#define u(a,r,T)16*i[a]+(I Z)(T i[r])
#define a(_)*(_*)&
#define L(_)M(W,_,U)

#define M(S,F,T)R(r[S],F,r[T])
#define A(_)(i[L=4]+=2,R(_,=,r[u(10,4,-2+)]))
#define c(R,T)(1[u=19,L+T]=(N=a(R)h[r]*(R)*T)>>16,*i=N,G(F(N-(R)N)))
#define h(_)(1&(L?a(Z)_:_)>>C-1)
#define I unsigned
#define n char
#define e(_)v(F(40[L(_##=40[E]+),E]&N==S|_ N<_(int)S))

I n t,e,l[80186],*E,m,u,L,a,T,o,r[1<<21],X,*Y,b,Q,R;I Z*i,M,p,q=3;I*localtime(),f,S,kb,h,W,U,c,g,d,V,A;N,O,P=983040,j[5];SDL_Surface*k;i(F,40[E]=!!o)i(z,42[E]=!!o)i(D,r[a(I)E[259+4*o]+O])i(w,i[o]+=~(-2*47[E])*~L)i(v,G(N-S&&1&(40[z((f^=S^N)&16),E]^f>>C-1)))J(){V=61442;$;O--;)V+=40[E+O]<<D(25);}i(H,(46[u=76,J(),T(V),T(9[i]),T(M),M(P+18,=,4*o+2),R(M,=,r[4*o]),E]=0))s(o){$;O--;)40[E+O]=1&&1<<D(25)&o;}i(BP,(*i+=262*o*z(F((*E&15)>9|42[E])),*E&=15))i(SP,(w(7),R&&--1[i]&&o?R++,Q&&Q++,M--:0))DX(){$,O*=27840;O--;)O[(I*)k->pixels]=-!!(1<<7-O%8&r[O/2880*90+O%720/8+(88+952[l]/128*4+O/720%4<<13)]);SDL_Flip(k);}main(BX,nE)n**nE;{9[i=E=r+P]=P>>4;$;q;)j[--q]=*++nE?open(*nE,32898):0;read(2[a(I)*i=*j?lseek(*j,0,2)>>9:0,j],E+(M=256),P);$;Y=r+16*9[i]+M,Y-r;Q|R||kb&46[E]&&KB)--64[T=1[O=32[L=(X=*Y&7)&1,o=X/2&1,l]=0,t=(c=y)&7,a=c/8&7,Y]>>6,g=~-T?y:(n)y,d=BX=y,l],!T*t-6&&T-2?T-1?d=g:0:(d=y),Q&&Q--,R&&R--x(O=*Y,O=u=D(51),e=D(8),m=D(14)_ O=*Y/2&7,M+=(n)c*(L^(D(m)[E]|D(22)[E]|D(23)[E]^D(24)[E]))_ L=*Y&8,R(K(X)[r],=,c)_ L=e+=3,o=0,a=X x a=m _ T(X[i])_ A(X[i])_ a<2?M(U,+=1-2*a+,P+24),v(f=1),G(S+1-a==1<<C-1),u=u&4?19:57:a-6?CX+2,a-3||T(9[i]),a&2&&T(M),a&1&&M(P+18,=,U+2),R(M,=,U[r]),u=67:T(h[r])_(W=U B u=m,M-=~L,R(W[r],&,d)B 0 B L(=~)B L(=-),S=0,u=22,F(N>S)B L?c(I Z,i):c(I n,E)B/**/L?c(Z,i):c(n,E)B L?V(I Z,I,i):V(I n,I Z,E)B L?V(Z,int,i):V(n,Z,E))_++e,h=P,d=c,T=3,a=m,M--_++e,13[W=h,i]=(o|=!L)?(n)d:d,U=P+26,M-=~!o,u=17+(m=a)_(a=m B L(+=),F(N<S)B L(|=)B e(+)B e(-)B L(&=)B L(-=),F(N>S)B L(^=)B L(-),F(N>S)B L(=))_!L?L=a+=8 x L(=):!o?Q=1,R(r[p=m x V],=,h):A(h[r])_ T=a=0,t=6,g=c x M(U,=,W)_(A=h(h[r]),V=m?++M,(n)g:o?31&2[E]:1)&&(a<4?V%=a/2+C,R(A,=,h[r]):0,a&1?R(h[r],>>=,V):R(h[r],<<=,V),a>3?u=19:0,a<5?0:F(S>>V-1&1)B R(h[r],+=,A>>C-V),G(h(N)^F(N&1))B A&=(1<<V)-1,R(h[r],+=,A<<C-V),G(h(N*2)^F(h(N)))B R(h[r],+=(40[E]<<V-1)+,A>>1+C-V),G(h(N)^F(A&1<<C-V))B R(h[r],+=(40[E]<<C-V)+,A<<1+C-V),F(A&1<<V-1),G(h(N)^h(N*2))B G(h(N)^F(h(S<<V-1)))B G(h(S))B 0 B V<C||F(A),G(0),R(h[r],+=,A*=~((1<<C)-1>>V)))_(V=!!--1[a=X,i]B V&=!m[E]B V&=m[E]B 0 B V=!++1[i]),M+=V*(n)c _ M+=3-o,L?0:o?9[M=0,i]=BX:T(M),M+=o*L?(n)c:c _ M(U,&,W)_ L=e+=8,W=P,U=K(X)_!R||1[i]?M(m<2?u(8,7,):P,=,m&1?P:u(Q?p:11,6,)),m&1||w(6),m&2||SP(1):0 _!R||1[i]?M(m?P:u(Q?p:11,6,),-,u(8,7,)),43[u=92,E]=!N,F(N>S),m||w(6),SP(!N==b):0 _ o=L,A(M),m&&A(9[i]),m&2?s(A(V)):o||(4[i]+=c)_ R(U[r],=,d)_ 986[l]^=9,R(*E,=,l[m?2[i]:(n)c])_ R(l[m?2[i]:(n)c],=,*E)_ R=2,b=L,Q&&Q++_ W-U?L(^=),M(U,^=,W),L(^=):0 _ T(m[i])_ A(m[i])_ Q=2,p=m,R&&R++_ L=0,O=*E,F(D(m+=3*42[E]+6*40[E])),z(D(1+m)),N=*E=D(m-1)_ N=BP(m-1)_ 1[E]=-h(*E)_ 2[i]=-h(*i)_ 9[T(9[i]),T(M+5),i]=BX,M=c _ J(),T(V)_ s(A(V))_ J(),s((V&~m)+1[E])_ J(),1[E]=V _ L=o=1 x L(=),M(P+m,=,h+2)_++M,H(3)_ M+=2,H(c&m)_++M,m[E]&&H(4)_(c&=m)?1[E]=*E/c,N=*E%=c:H(0)_*i=N=m&E[L=0]+c*1[E]_*E=-m[E]_*E=r[u(Q?p:m,3,*E+)]_ m[E]^=1 _ E[m/2]=m&1 _ R(*E,&,c)_(a=c B write(1,E,1)B time(j+3),memcpy(r+u(8,3,),localtime(j+3),m)),a<2?*E=~lseek(O=4[E][j],a(I)5[i]<<9,0)?((I(*)())(a?write:read))(O,r+u(8,3,),*i):0:0),O=u,D(16)?v(0):D(17)&&G(F(0)),CX*D(20)+D(18)-D(19)*~!!L,D(15)?O=m=N,41[43[44[E]=h(N),E]=!N,E]=D(50):0,!++q?kb=1,*l?SDL_PumpEvents(),k=k?k:SDL_SetVideoMode(720,348,32,0),DX():k?SDL_Quit(),k=0:0:0;}i(G,48[E]=o)i(K,P+(L?2*o:2*o+o/4&7))
","main(a,b)char**b;{int c=1,d=c,e=a-d;for(;e;e--)_(e)<_(c)?c=e:_(e)>_(d)?d=e:7;
while(++e<a)printf(""\xe2\x96%c"",129+(**b=8*(_(e)-_(c))/(_(d)-_(c))));}
","#ifndef SKI
#define A(x)B(x##0)B(x##1)B(x##2)B(x##3)B(x##4)B(x##5)
#define B(x)C(x##0)C(x##1)C(x##2)C(x##3)C(x##4)C(x##5)
#define C(x)D(x##0)D(x##1)D(x##2)D(x##3)D(x##4)D(x##5)
#define D(x)Z(x##0)Z(x##1)Z(x##2)Z(x##3)Z(x##4)Z(x##5)
#define p(x)(*(*(*(*(*(*x)())())())())())()

#include <stdio.h>
#include <stdlib.h>

#define S (Y(s+6))
#define K (Y(s+4))
#define I (Y(s+2))




#define Z(x)\
f x;f Y(v);g\
   j;f \
   x##z(                              f\
    y){y        =y?!    x?x=          y:Y(     m(*(    w)&\
    x,((         g)y)  (0))    ):x;return y;    /*ab  c*/}
    /**/          typedef             void       *v ;int
    n=0;           typedef            v*         w;typed\
ef v(*g)();v     s[]=  {0,0,                    s+6,  s+2,
s+4,s,s+3,s+    5,s+    1};w                   m( v    l ,v




r){w    e=ma\
lloc    (siz\
eof(   v)*3
);*e  =r;e                                           [1
]=l;return      (e[2    ]=s,   e);}    /*de          fghi     jk*/    typ\
edef v(p(        p(p(  p(p(    p(p(    p(p(   p(p(f)))) )))    ))))  );A(
x)w   u(){        return n      --?m  (j(0           ),u(       )):s+3;}
w z(   w e)       {w a,b ,       c,d;for             (d         =e=m(e,0
);n=    (w)d[    2]-s  ,n?*       (n>1?                        n<4?  b:a:
c)?n    <2?c[   1]=m    (*a,      *c),                        *c=m    (*b,
                                 *c):
                                n>5?


  #undef Z
#define Z(x\
) &x    ##z,
a[1]=                                                               m(
 *a,!*d?        d[1]    =c=m   (0,0    ),n=   getchar(),n=          n<0?
    256:n,c      [2]=  s+6,    *d=u    ():*   d),*a=d[1]:    n<5?n<3?n=z(*
       a)-s,      putchar(      255<  +n?(         exit             (n-4
*64)   ,0):n      ),fflush       (stdout)        ,c[1               ]=
*b:((n-3?b:c     )[1]  =*a)       :(2[*        a=z(*a)+1,a
  ]=s+5),d      =e:0    :e;d      =d[1        ])c=b,b=a,a=
                                 d;a=
                                *(w*

                                      )e                               [1
                                     ];                                 ;;
     /*lm    no*/   return a;}f(     *h   [])(    )={A   (x)0};f Y(v    x)
      {g y  =(g)    h[n++] ;y(!     y?    exit(   puts   (""out of c""     """"
       ""losure""          )),x       :x     );return(f         )y/*       pq
       r*/;}int        main         ()       {z(((g         )(S          S(
      j=(g  )S(S     (K S)K))(K(    S        I I))        (S(K(S I))(    S(
     K K)    (S(K   (S(S(K(Y(s+1     ))      )(S(        S S(K I)) (K   (Y
                                     (s     +5))                        ))
                                      ))   )K))                        )(





#endif

#if (!defined(__INCLUDE_LEVEL__) || !__INCLUDE_LEVEL__) && !defined(SKI)

K(I(I(I(S I I(S(K(S(S(K S)(S(S S S(K(S(K S)))(S(S S S(K(S(K S)))(S(K(S(S(K S)(S(S(K S)K)(K(S(S(K S)(S(K(S(S(S I(K K))(K K))))(S(K K)(S(S(K S)(S(K(S(S I(K K))))(S(K K)(S(S(K K))(K(S(S(S(S(K S)K)))I(S(S(K S)K)I)))))))(S(K K)(S(S(K K))(K(S(K(S(S(K S)K)I))(S(S(K S)K)(S I I(S(S(K S)K)I)))))))))))(S(K K)(S(K K)(S(S(K K))(K(S(K(S(S(K S)K)I))(S(S I I)I(S(S(K S)K)I)))))))))))))(S(K K)(S(K K)(S(K(S(S I(K(S(S I(K(K I)))(K S))))))K)))))(K(K(K K)))))(K(K(K(K I))))))))(S(K(S(K K)))(S(S(K S)(S(K K)(S(K S)(S(S(K K))I))))(K(S(K(S(S(K S)(S(K(S I))K))))(S(K K)K))))))(S(S I(K(S I I(S I I(S(S(K S)K)I)))))(K(K K)))S K K K I I I K K K I I I K K K I I I K K K I I K K K K K S K I I I K I K I I I K I K)I I I K I K I I I K I I I K I I S K I I I I I K I I I I I K I K I I I K I I I K I I S K I I)I K I K I I I K I K I I I K I K I I I K I I I K I I S K K K I I I K K K I I I K K K I I I K K K I I K K K K K S S K I I I K S)K I I K S K K K S K I I K S K I I I K S S K K K K K S K I I I I S K K K K K S K S K K K K K(K K))

#define SKI
#endif

#ifdef SKI
(Y(s)))))(0));return 0;}
#else
#define SKI
#endif
","              /*@@@sssss8]][[[[a#@@sss0['w}8|v}a<{av}a@{av}j>~{v}j8|c[sa?|{8[|#~}
          [j#@ra>~}sa!{>}|#r0l}sao8}[a'f8|r'8[j?x[?@<[j?@[j?@[s?>|;[[[j!>b'8'a@<cb@>?
        c$kg_@<b#0pf<#keab{_b0|c0#d#0#|'o{i<!8dr,f_{#rg{baiderh{er0}|'{0{ic.df?'o|j{lim
       0'{i?#c0b|c#kg!}r!8lp1g!|i_ar<[#0g|h_}ieg>|_ah|sr<|i[[[}s#f@}[{@u~~~r@[|#|{ssss{a
      }|0~{?}|<{?}|qj?}s@[_}j0]][[[[a_@@@sssss<[[?>=sln5+a[so#,g-0aw;#*a>*abwa.*+da9=n?<6
      -'7%71>e_?>a[j;e=;scdet?>shd??a;5&6:=[ch@aw[sf;[#<[[j>k7__?>>d>==n'6+7*abcdnh3a_jhw
     b6;73;b#<ww<7bcw7d+;&i=cn?c>=#d5;8w3;nawn#<;;77__ra?8hi1abcww#>==<[;k7[wn7[=,>ab[a@s[
     ='b,.[8.?>>fdjn(_2$a8c8[[j_8.=B6+b8]]]]]]]]]j1;7_sj<[[af;7sjd][j_<7!=a>d7_j8d.ab[hybm
     ?>=;ei7aws1d!ebn                                                       _,?>0aka[#;5+7
     !?ac;7_wa7{;a3_                                                        bjcna>a<;bs8;7
     j-=cabh?97_sj['                                                  -5*j[!;5+a7[1wb[!wBb7w?0wb
     _?an+&e_|j'4a<7                                                  0v;7d.kd8wa?.=:a-wwm=:;[e5
     *-=fwn7rab[c.j#                                                    eaw#c>>>bml;mtdekssae
     zqtd[39<u_char*                                                      p=$,w[13997],*h=w,
     *q,*r_****_;#in                                                        clude_*ioccc*2
     013*_<stdio.h>_                                                         *--2013-ioc
     cc-2013-ioccc-2        013--                                             *_#define
                           @n(d);c                                              ((d)>
                            >8);c                                                 (
            d
          );*B=             32;B[   y=1]=22 .627400;       B[2]=16;_*-i       occc-2013 -ioccc
        -2013-io           ccc-201  *_int@a,b,d,e,s,t    ,g,z,y;double@f,    B[3],i,j,k,l;void
       @m(int@z){f         or(j=k=  l=y=1;y<99;y+=2+0)  l*=z*z*    .038553  ,k*=-y*(y+1),j+=l_
     k;i*=j;}int@c(        int@d){  return@    putchar (d)_255;    }intmain (){for(    ;*p;p++
    )*p<33?0:(*h++=*p      -32);q=  h;for(p     =w;p<w +823;p++)for(d=*p-56 ,e=-1+     0;++e<(
  d<00?5:d<6?d>4?160:30    :d>35?2  7<<(d-3    6):d_9* 6);q++)*q=d<0?*p>>e& 1:d<6||    q[d>35?
-108:d%9*-12-12];for(q=h   ;g++<61  56;q++)*  q?*q=*p-  4?e=*p+             +,e-32?e:0:r&&*r?g
%108<2?2:*r++:(r=r?p++:w,  2):0;n(  g=8*8187)n(g+8)n(1  6)n(19014)n(18758)   ;for(;s<10;s++)c(
     s<3?s:0)n(g+3)n       (67)for  (;t<65;)c(t++>0)      n(g-24)n(11)c(8      )n(612)n(656)n(
     257)n(4352)n(g+       0-20)n(  5*42);; for(;y          ++<207;)c(      y<3        1?y<19?
     y>6:30-y:y<47?y    <32||y>36?  16:0:y<                                 48?2:y%1  6*16+13-
     y_16)n(64*960)n   (g+5)n(4)n(  1)n(g+2                                 )n(8)n(257)n(0)n(
     2*8064)for(;b<4    04096;b++   ){e=32<                                   a?63-a:a;for(f
     =d=t=s=0;e>t;)e
     -=++t;e=t%2?e:t                                                        -e;;;for(d=a>3
     1?e=7-e,14-t-e:                                                        t-e;s<64;t=f-=
     i*B[!d+!e])z=b_                                                        64%82*8+s_8-4,
     y=b_5248*8+s%8+7                                                      ,i=z<0||z>647||
     y%11>9?1:q[h[z_6+y_11*108]*60+y%11*6+z%6]*2-1,m(s_8*2*d+d),m(s++%8*2*e+e);s=2+t*t;;fo
     r(d=2;s>3;s_=4)d*=2;;s=8<<(a?12:9);s-=d*2<<!!a*4;s|=t>0?t:t-1+d;c(s_256)?c(0):0;c(s)?
     c(0):0;if(a++>62){n(g-8+b_64%8)a=0;}}n(g+1)return@0+0;}*/ /*IOCCC*/#include<stdio.h>
      char*p,w[13997],*h=w,*q,*r;int d,e,g;int main(){for(;e<3583;e++>15&&e<3582&&d>32?*h
       ++=d-95?d:47:0)d=getchar();q=h;for(p=w;p<w+823;p++)for(d=*p-88,e=-1;++e<(d<0?5:d<
        6?d>4?160:30:d>35?27<<(d-36):d/9*6);q++)*q=d<0?*p>>e&1:d<6||q[d>35?-108:d%9*-12
          -12];for(q=h+108;g++<5995;)putchar(g%109<1?10:*q++?*p-36?(e=*p++)-64?e:32:r
              /*IOCCC2013*/&&*r?g%109%108<2?34:*r++:(r=r?p++:w,34):32);return 0;}
","char a;float b,c;main(d){for(;d>2e3*c?c=1,scanf("" %c%f"",&a,&c),d=55-a%32*9/5,b=d>9,d=d%13-a/32*12:1;a=2)++d<24?b*=89/84.:putchar(a=b*d);}","int
**F,**
V,M, N,i;
#ifndef/**/S
#define S 70,23
#endif/* 000-2E5*/
#define/* 2E5-2E5,2E5
*/_POSIX_C_SOURCE 199309
#include/* 2E5XXX*/<time.h>
/* 2E5-2E5X*/#include<stdio.h>
#include<stdlib.h>/* -2E5-2E5XX*/
struct timespec R={0,1E6};int j,k,m,
#define U/* -2E5X*/rand()*2./RAND_MAX-1
#define/* 2E5*/O(p,q,i)(P[p*3+i]-P[q*3+i])
/* IOCCC2013 IOCCC2013*/#define B(p,q,\
r)(O(q,p,0)*O(r,p,1)-O(q,p,1)*O(r,p,     0))
#define A(t,n)( t*)malloc( sizeof     (t)*n)
#define E(p,q,r,s)B(p,q,r)*O(s     ,p,2)+B(\
p,r,s)*O(q,p,2)+B(p,s,q)*O(     /*XX*/r,p,2)
#define D(e,f)(c-a)?s=a,     a=e,e=s,s=f,f=\
d,d=s:0;u=a+.5;m=u+1;     T[01]=91;T[2]=060;
#define C (Q[u]-X)     *a+(Q[u+1]-Y)*b+(Q[u\
+2]-Z)*c,g=e*c-     f*b,h=f*a-d*c,f=c,c=d*b\
-e*a,d=a,a=g     ,e=b,b=h,P[k]=W/2-q/s/p*3*\
W,P[k+1]=     H/2+r/s/p*H/2,T[3]=0x48,*T=033
n,u,v,     w,t,W,H;double*P,*Q,I,J,K,L,x,y,z
,X,     Y,Z,a,b,c,d,e,f,g,h,p,q,r,s ;void o(
     double x){for(p=q=i=0,s=r=1;i<99;s=(s+x
  /s)/2)i%2?q+=r,r=-r:(p+=r),r*=3.14*x/++i;}
     int G(int p,int q,int s,int g,int f){i\
nt*     v=A(int,N),*a,*b,h=-1,r=h;for(F[f]=V
[f]=v;     ++h<f;)if(V[h][p]==q){if(s+1&&E(p
,q,V[h][q     ],s)<1E-4){for(a=F[g],b=F[h];N
>++r;v[r]=q+     1?a[q]-r?q:b[p]-r?p:-1:p)p=
a[r],q=b[r];for     (r=0;r<f;r++)F[r]==a||F[
r]==b?F[r]=v:0;};;     return f;}for(h=0;h<N
;v[h++]=-1)r=h-p&&h-q     &&(r<0||E(p,q,r,h)
<0)?h:r;v[v[v[p]=q]=r]=p     ;return G(r,q,p
,f,G(p,r,q,f,G(p,q,s,g,f+1)     ));}char *T;
int main(void) {H=(W=S)*2;T=A(     char,(H*W
+4));for(srand(t=(int)time(0));i=     scanf(
""%lf,"",P=(Q=(double*)realloc(Q,(N+1)     *s\
izeof(double)))+N),i>=0;)i?c+=*P**P,1<N
++%3?o(c),b=b<s?s:b,c=0:0:scanf(""%*s"");for
(P=A(double,N*2);j<N;)Q[j++]/=b;o(U);I=
p/1E3;J=q/1E3;K=U;L=U;N/=3;F=A(int*,     4*N
);V=F+2*N;for(;u==v;){for(j=u=m=n     =0;j<3
*N;j++)P[j]=Q[j]+(U)/1E5;for(;     m<N;m++)u
=P[u*3]>P[m*3]?m:u;for(v=!u     ;n<N;n++)v=B
(u,v,n)>0?n:v;}for(puts(     ""\x1b[2J""),M=G(
u,v,-1,-1,0);;K+=I+0,     L+=J){for(i=4;i<W*
H/2+3;T[++i]=j=0)T     [i]=i%W-3?32:10;for(;
j<M;j++){for(n=     k=0;F[j][m=n]<0;)n++;for
(;u=F[j][m]*     3,o(K=K<-1?K+2:K>1?K-2:K),c
=z=9*p,b=     9*q,o(L=L<-1?L+2:L>1?L-2:L),a=
x=b*q,     y=b*=p,d=x-X,e=y-Y,f=z-Z,o(d*d+e*
e+f     *f),p=C,q=C,r=C,k+=2,m=F[j][m],m-n;)
     ;for(p=n=0;n<k;n+=2)p+=P[n]*(P[(n+3)%k]
  -P[(n+k-1)%k]);for(q=time(0)<t+3;(q||p>=0)
     &&n;){a=P[n%k];b=P[n%k+1];c=P[n-=2];d=P
        [n+1];e=d-b;i=e*e>(c-a)*D(b,c)0>D(c,
           b)for(;c-a&&u<c+.5;0<=w&&w<W-1&&0
              <=m&&m<H?v=m/2*W+w+4,T[v]=""',""
                 "";;;,;'""[T[v]%8^m%2]:0)m=v=
                    (d-b)*(u-a)/(c-a)+b+0.5,
                       w=i?m=u++,v:u++,u=u<c
                          &&q?c+0.5:u;}}puts
                             (T);nanosleep(&
                                R,0);X=x;Y=y
                                   ;Z=z;}}/*
                                      IOCCC*
                                         \*/
","#include<stdio.h>
char*s=""0VYbz *	U.	q`E	Q 7d>A	+ 45 4S Q bM aS	p.U	*& 3m i	k$	in 1J` X`	8 pp	U	'3 / K[@	>r	u hm o M	T	`4 :	O	w^x@WoI 6X	  O	;'Qlj	oK(	}	[	?x 7 	PSg _#-{	W ?Z	;F	w %tAOr	n . q mA	ke v	vH C	/:- %| ,#F	N	v{ V	u Jd)	Z ^	+ ^	!y+	w	|gA[Cv ? 5N{K% s GQ As @?V	Sb	b	Ab=1lDzC	H qN Q	fK	F	9	;j@x 0W l{Y w{	2 1 k_{ 9	W8 N	D	RVR	; @ 	% } a	P3 B # l=	h	0z	x	kO, G Ie Z^ [i	|/	O4 /e?	c_x 8jP/.-I 4	E| C.kI 0	=DC~h 3Af	B V F	PpX BP	-R	U	( P	eIwd = nf	>	> L	QL BB@sfj	B<	m J%e$ Fzqa1	WV [ me m	a# !Y x	2X	I!E 8&f J% ,bru A D, t$	L	gL$	dgxG _	(	Z?	t gY >O`@ 5	t &'	6F i  0 mI |a	S_VM	EmWHVNO B7 I2% & 2 w: / N	FV n#$T+]q O+ W+ c	qu	w ~	,5O	[{ G	[	wF	C_ Z	9 F ~	*lx	L	' >%	@ g,8&gmbF	D[	0	:pB'Z	#	f	3 pr;	, D	/ F	= g_N4[	Yj}	J9m	_ +r c	*	84] |co'	i n~ <p	l	a 	~B(H	14	Z	C	iS3 R	Cs'T	r B,gL4x	_ t#yU p *~{ /r W_d	O*1g	owHU	s Z	~Y	a?	r	RX7Z	K R	pP	-	il b;i	5_ [?] X	m [4O #+ SO * r' ZWd	'E 7 Ny b u5,	$	oX	$J?m:	e [	)U	8	Q	, u?	E u G	+5 p	] L -y_ ;	.! s ]OX	KY s GpJ R9G	d	'	in `%Z 9 h 0	E	%	zjb u> QWP 4rr2 f	Cgr!H	x#4P	X t ` 	!,MS ^ _C	N	>|	eGK	p ^	t !	YZ@OC,c ( ] #M YH$Z ? :,F	#WT@NW	)bL	} @	+Sjj 8s(HV j U/k-t-]D	[ !	B$]g >	:n3 >]tC	(	<	5	T *R`	#	Uq	v	]&	uY  	b<Z	Cr qx	H;	y	Ha<	7!t	hc	Y	f idf 9~ ^W	EY7U _ 8	+l 	2w + u	x	~D;5	#l' qJ	7a	x - Zv Z	?o 6%	.e!c	',~	#P	l	=	B	4b{Ckl	u O/	W $K	$	e i	I WJ5 $	6 yc	l	) { @% 1	%G0 7UB _(2 $ '	[ H  hB N !	i' b	C	UR/	0!-VdV c~	/,~ $ _]	i - d	<_'Q W(#g k+:: & F0QE LN :	E c	w	X ,	s	&jK'~W h03 J,	C x W	j	w	36 E d4	j	*	+u}$y #	z	9!ER`u	Gt ?[	*:	UyN k3	e G l	K Wi	Q	W5 _	E8	A	9O;	-	(O	D=? W-	8 8( $i	c i	N	W	8 F	U	/ x x| x	7	]	jHq & 5yv49B kw ve24	K	2=	W	_D /b	@*	[	}}g|	)f y KL 1BZ	G	4	)_N >5![	0 a%	Xc*	!I	ge	st	; $+	%}	rQ!	X q	8	[(~ WLr> X	)` $N{	| 9|.P P s	^ ,J	!t	T mq L&t zD N QUat9	S`' @[	7	yAF	v	k)G 4R kC	6	S{Li,G DOF % P	gw '0-	JC `	I _h 4 6 ~	pH ?	p[ G	xH	b#j s ?4C+a d	2G :	{ L) N :GfR	a	J:j@	z	R1	o3	~$ u	F|8	k  R	y&	-o 3 -	J R z	d IL <	j	E i 13+ _ <b_# }hG	X	8 {	u	k y	 '1	Z Q @	h ~	3 g ^	tu	@i#xL	!{=M	w	Iw1:	] y	NBl3	z	9 T=	n Z	T	pA7U	` U 0 I b	*	_D$K	*	tTt n Uq fYO	Pi	KV5$ ^$+ _	J 'c*q[ :	9	pM1C M2&18 3i%/u;wf (	G	si}	s	%0z w	G`WA} 3 _ u ( sf Yz	$	MF _%	Bc *<	; 7 A j |	R> b	K8	j $U XQZ	/c	{	@L'c8I n(	~	2<zF -}^M	2	t6	rc	(|	:	wb	2	PO	_P &	$ X-	W1y	H PBMy	W #l	*	|j	p	@ a_xcA #2	re(	;	5 =	V	2	/	<R	}	sT w i bz7 -  usg	q j g N T} oai6	M3	k DI	S' 6	I>	~ Co }	o	1	Y	+~x	$ =r J	]	[`O~zQ	P	^ ^	va	O}~	j	}P z	A- ZE[Qh@ U i	| B	3F=	6	qJ .J |K 	fVsW W	1| [	r	[	rncy .	3My  ^	5 {	ew 7 5u L@qN -{	IeW k !	U$i	. }4 J!p S	o	qs]`k	2$8(	CI[ P^7	O	:PUZ^@	{. N  ) 4} j+uM	]7=&2F 4	- l	Qx QF	m t	N,M	j' 5=	H	k^A	w :	A	e|/ = 7	- ^	X1~BH y&	@ $ks|	&	G^	X} gNB	I F ; 9 p |[W: +B<h	T	L o2f/	0 p	F_6	f;	)	4 '	r~2	S O	A	g	70YZ t	S	t^ '$ k 8	FKM. [x	; m D a	St	{	y	9%P#6	1	#d	1r & a	u	' Xf	^ j%|	K	.	' ` 6?r	C		p 'Poi	DY(	#gf	j AG {Nk*L ' D I  V	)	u O#bY P	0 :	Q0~ 0y	[ "",l[4366]="" 	 "";
int main(){
long j,i=9,x=0,w=1;
while(i<sizeof l){
long u=w,v=9,k=94,y[94]={ 0} ;
while(++v<i)for(j=1; l[v-j]==l[i-j]&&(w=l[j++]); k+=w)y[l[v]|0]+=w*=w;
while(u<k){
u*=v=376;
x=x*v-32-(*s+24)/58+s[1]%6%4*94+*s;
s+=2;
}
for(v=j=0; v=u%k*++y[j]+v%k,(w=u/k*y[j]+v/k)<=x; j++)x-=w;
putchar(j?j+32:10);
l[i++]=j;
}
return 0;
}
","				#include  <math.h>
			  #include		<time.h>
		     #include			   <unistd.h>
		  #include			  <netinet/in.h>
	       typedef				float F,A[3]; F D,M
	     [999]={			 LT} ,*L=NL+M,*P,b,t,*h,*i; A
	   #define S(x,y,z)F  x(F*d,F z s){ F t=y; t+=y; return t+=y; }
	 E,Q,U,V,C,c,I={ EY} ; unsigned char g[2414],*p=g,*e; int j,k,s,m
	,n,x,y; S(B,*d++=*s++,*)S(o,*d+++=*s++,*)S(a,*d++-=*s++,*)S(H,*d++
      **s++,*)S(X,*d++*=s,)S(v,*d+++=s,)int w(int c){ return*p++=c; } F W(F*
     d){ return sqrt(H(d,d)); } void r(uint32_t u){ w(u>>24); w(u>>16); w(u>>
    8); w(u); } F  O(F*d){ return X(d,1/W(d));  } char*z,*f; void u(char*s){ *
   s&&w((u(1+s),*s)); } F G(F x,int p){  for(z=p*46+f; 12^*z; x+=.5){ for(D=-4;
  5>D; D++)if(9-*z++){ *P++=x; *P++=D/2; *P++=0; } } return p; } void K(){ write
  (k,g,p-g); p=g; } F*d(){ h=0; D=1e9; a(E,Q); O(E); 2[E]&&0>(t=(1+2[Q])/2[E])&&
 (D=-t,h=P); for(i=M; P>i; i+=3){ B(C,i); a(C,Q); b=H(E,C); (t=b*b-H(C,C)+(i<L?99
 :.6))>=0&&0<(t=b<t?t+b:b-t)&&D>t&&(D=t,h=i); } return h; } void Y(int N){ F*h,*i
; A p,n; if(!(h=d()))*c=1[c]=(2[c]=2[E]/2)/2; else if(h<L){ X(c,0); v(c,1); } else
{ B(p,E); X(p,D); o(p,Q); if(h-P){ B(n,p); a(n,h); O(n); } else{ X(n,0); ++2[n]; }
B(Q,n); X(Q,1e-4); o(p,Q); X(c,0); if(N<8){ B(Q,n); X(Q,2*H(n,E)); a(E,Q); o(E,p);
B(Q,p); Y(1+N); X(c,h-P?.8:.2); } for(i=M; L>i; ++i){ B(E,i); B(Q,p); d()-i||v(c,(
h-P?.1:.5)*H(n,E)); } v(c,0.05); h-P||(2[c]*=.3,c[1&lrint(*p)^lrint(1[p])&1]*=.2);
} } void Z(char*s){ K(); p+=4; u(s?s:""TADI""); } void J(){ uint32_t c=~0; e=p; p=g;
r(e-p-8); while(p!=e){ c^=*p++; for(j=0; 8>j; j++)c=c/2^c%2*3988292384; } r(~c); K
 (); } void q(int c){ w(c); m+=c; m%=c=65521; n+=m; n%=c; } void T(F c){ c=.5+255
 *c; q(0>c?0:c>255?255:c); }  struct sockaddr_in R;  int main(){ time_t i; struct
  tm*b; R.win_port=8224;  s=socket(R.sin_family=AF_INET,SOCK_STREAM,0);  bind(s,
  (void*)&R, sizeof R); listen(s,1); for(; ; ){ k=accept(s,0,0); for(; ; ){ ++j;
   read(k,p,1); if(*p=='\n')  { if(3>j)break;  j=0; } }  m=1; u(""\n\032\n\rGNP""
    ""\211\n\r\n\r1 :hserfeR\n\rKO 002 0.1/PTTH""); Z(""RDHI""); r(800); r(600); w
     (8); r(33554433); J(); Z(0); w(120); w(1); J(); i=time(0); b=localtime(&
      i); x=b->tm_sec; *I=45<x?x-60:15>x?x:30-x; *U=-I[1]; 1[U]=*I; *V=2[I]*
	*I; 1[V]=2[I]*1[I];2[V]=-*I**I-1[I]*1[I];  O(U); O(V); X(U,D=W(I)/
	 1e3); X(V,D);  P=L;y=1+(11+b->tm_hour)%12; 9<y&&G(-14,y/10); G(-
	   10,y%10); G(-6,10); y=b->tm_min;  G(-2,y/10);G(2,y%10); G(6,
	     10); G(10,x/10);  G(14,x%10);  for(z=""xxxdtrb!  d r y "";    9[z]; ++z){
	       for(y=7&8[z]; 600>y; y+=14&*z){ Z(0); w(0); p+=4; q(    0); for(x=7&9[z]; 800>x;
		  x+=15&1[z]){ B(Q,V); X(Q,y-300); B(E,U); X(E,x    -400); o(E,Q); B(Q,I); Y(0);
		     T(*c); T(1[c]); T(2[c]); } j=p-g-13; 12[    g]=~(10[g]=j>>8); 11[g]=~(9[g]=
			  j);  J(); } }  Z(0); w(1);  r(    65535); r(n<<16|m); n=0; J(); Z(
				""DNEI""); J(); j=0;    close(k); } } char*f=

""	       	 							  							  							 	       	 					 		 						 	          								 								   				 	 		 				  			 			  			 			  				   		 					 	 			 			  			 			  			 			 	   	   					   						 		 					 			          				 					 		      			 			  				 		  				 		 	    			 	      		 		 			 	 			 			  			 			 	   			 									   						 		  				 				  		 						   	   	   	 			 			  			 			  			 			 	   	   						   	 			 			  			 			 	 			 		 		      																					 			 																				"";
","                                                     /*[*/#include<stdio.h>//
                         #include<stdlib.h>//]++++[->++[->+>++++<<]<][(c)2013]
                        #ifndef                                           e//[o
                       #include<string.h>//]![misaka.c,size=3808,crc=d0ec3b36][
                      #define e                                           0x1//
                     typedef struct{int d,b,o,P;char*q,*p;}f;int p,q,d,b,_=0//|
                  #include __FILE__//]>>>[->+>++<<]<[-<<+>>>++<]>>+MISAKA*IMOUTO
                #undef e//[->[-<<+<+<+>>>>]<<<<<++[->>+>>>+<<<<<]>+>+++>+++[>]]b
             #define e(c)/**/if((_!=__LINE__?(_=__LINE__):0)){c;}//[20002,+[-.+]
            ,O,i=0,Q=sizeof(f);static f*P;static FILE*t;static const char*o[]={//
          ""\n\40\""8oCan\40not\40open %s\n\0aaFbfeccdeaEbgecbbcda6bcedd#e(bbed$bbd"",
        ""a6bgcdbbccd#ead$c%bcdea7bccde*b$eebbdda9bsdbeccdbbecdcbbcceed#eaa&bae$cbe"",
       ""e&cbdd$eldbdeedbbdede)bdcdea&bbde1bedbbcc&b#ccdee&bdcdea'bbcd)e'bad(bae&bccd"",
      ""e&bbda1bdcdee$bbce#b$c&bdedcd%ecdca4bhcdeebbcd#e$b#ecdcc$bccda7bbcc#e#d%c*bbda"",
     "">bad/bbda""};static int S(){return(o[p][q]);}static/**/int/**/Z=0  ;void/**/z(int//
    l){if(/**/Z-l){Z=l;q++;if(p<b*5&&!S()){p+=b;q=0;}}}int main(int I,    /**/char**l){//
   d=sizeof(f*);if(1<(O=_)){b=((sizeof(o)/sizeof(char*))-1)/4;q=22; p=     0;while(p<b*5){
  /*<*/if(Z-1){d=S()>96;i=S()-(d?96:32) ;q++;if(p<b*5&&!S()){p+=b;  q=      0;}Z=1;}/*[[*/
  while(i){_=o[0][S()-97];I=_-10?b:1;   for( ;I--;)putchar(_ );if   (!      --i||d)z(~i );}
 if(p==b*5&&O){p-=b;O--;}}return 0U;   }if(! (P=( f*)calloc /*]*/  (Q        ,I)))return 1;
 {;}for(_=p=1;p<I;p++){e(q=1);while    (q<   p&&  strcmp(  l[p     ]         ,l[(q)]))++  q;
 t=stdin;if(q<p){(void)memcpy/* ""      */    (&P  [p],&P   [q     ]          ,Q);continue ;}
if(strcmp(l[p],""-"")){t=fopen(l         [     p]   ,""rb""   )                  ;if(!t ){{;}  ;
printf(05+*o,l[p ]);return+1;                      {;}                       }}_=b= 1<<16   ;
*&O=5;do{if(!(P[p].q=realloc   (P[p].q,(P[p].P     +=       b)+1))){return   01;}O   &=72   /
6/*][*/;P[p].o+=d=fread(P[p]      .q       +P[     p           ].       o,  1,b,t)   ;}//
 while(d==b)      ;P [p].q[       P[       p]                  .o       ]=  012;d    =0;
 e(fclose(t        )  );P         [p]      .p                  =P[      p]  .q;if    (O)
 {for(;d<P[            p]          .o     ;d=                   q+     1)    {q=     d;
  while(q<P[                        p].o&&P[                    p].q[q]-     10     ){
  q++;}b=q-d;                         _=P                         [p].        d     ;
  if(b>_){/*]b                                                                */
   P[p].d=b;}{;                                                                }
   #undef/*pqdz'.*/  e//                                                      ;
   #define/*s8qdb]*/e/**/0                                                   //
   //<<.<<.----.>.<<.>++.++<                                              .[>]
   /*P[*/P[p].b++;continue;}}}t=                                       stdout;
  for (p=1;p<I;p++){/**/if(P[p].b>i                               ){i=P[p].b;}}
 if  (O){for(p=0;p<i;p++){q=0;/*[*/while(I               >++q){_=P[q].p-P[q ].q;
b=   0;if(_<P[q ].o){while(012-*P[q].p)     {putchar(*(P[q].p++));b++;}P[q]. p++;
}   ;while (P[  q].d>b++)putchar(040);}             putchar(10);}return 0;}p   =1;
   for(;   p<I   ;p++)fwrite(P[p] .q,P[              p].o,1,t);return 0 ;}//
  #/*]     ]<.    [-]<[-]<[- ]<[    -]<               [-  ]<;*/elif  e    //b
 |(1        <<     ( __LINE__        /*               >>   `*//45))  |     01U
             #                       /*               */     endif            //
","
#include <stdio.h>
#include <math.h>
#include <X11/Xlib.h>
#include <X11/keysym.h>

int main()
{
	Display *D;
	Window W;
	GC G;
	double l, r, a, b, o[7];
	int j, y, m, d;
	XWindowAttributes A;
	XEvent V;

	char n[444] =
		""NfVS6>7TYBC>Rm=8K\\QWiAR98iBX13>\\X[oN;W""
		""fXLULQJ^dS[PiLhDX`;<iNbR<4Xk5E7ZEY>GF""
		""bZ000=N4R6:9?TDoQH2aiN6MK[Zh[doSKGi;N""
		""bZQQ84ROVaYP2<BVVFM1eL:k<<[B?`TX_3gCK""
		""v^C?E_PSI\\XNLeQ:VIX=<FO2Wb[P5CPZ`1cFT""
		""b`<E?ePa[TlPI9jjYOUHBD<Rb`WLe_bZnknBV""
		""sb<`7fPOm\\GL^Q=8\\?;KP@[FJPZ]oVNZBWNfO""
		""fbhAc8L9F[NNnROJ^7jdX>]MZI[O41c\\9VWNI""
		""bb7aRCXkd7b\\JW6:Z9O@6@fZ;5ZllOgZ0mFjI""
		""chMPc<XoGl>ZSi2FJ^_fG6`eS7_043Q^>hG`T""
		""v00000&15e0&13e0&13e\1&e0&e0&e\1&\\TQneTv00000"", *c = n;

	for (j = DefaultScreen((D = XOpenDisplay(0))),
		G = XCreateGC(D, W = RootWindow(D, j), 0, 0); (*c++)--; );
	XMapWindow(D, W = XCreateSimpleWindow(D, W, 0, 0, 400, 400, 0,
		BlackPixel(D, j), WhitePixel(D, j)));
	XSelectInput(D, W, KeyPressMask|ExposureMask);
	j = scanf(n + 392, &y, &m, &d);
	j > m++ ? y--, m += 12 : j--;
	for (j = (int)(365.25 * y) + (int)(30.6001 * m) + d - 730550 +
		(1582 > y || y == 0x62e && (11 > m || 11 == m && d < 5) ?
			0 : 2 - y / 'd' + y / 400);
		XGetWindowAttributes(D, W, &A) && XClearWindow(D, W),
		b = floor((y = j + 0x8ead + (-152385 < j ?
			(a = floor(j / 36524.25 + 1.9983778) + 14,
			1 + a - floor(a / 4)) : d)) / 365.25 + .802601),
		m = floor((l = y - floor(365.25 * b + .750001) + 416) / 30.6001),
		d = l - floor(30.6001 * m),
		y = b + 0x76c, 13 < m-- ? m -= 12 : y--,
		!XDrawString(D, W, G, 0, 10, n + 0x1a0,
			sprintf(n + 416, n + 377, y, m, d));
		XNextEvent(D, &V) || (j += -(V.type == KeyPress) &
			((y = XLookupKeysym(&V.xkey, d = 0)) == XK_Left ? -1 :
			y == XK_Right ? 1 :
			y == XK_Up ? 20 :
			y == XK_Down ? -20 : d)))
		for (m = !m; m++ ^ 12;
			!(m == 9 && 150 < fabs(j + 0x13d2) ||
					m == 10 && fabs(j + 1005) > 0x96) &&
			XDrawArc(D, W, G, d += r * cos(l) - 4,
				y -= r * sin(l) + 4, 8, 8, 0, 63 * 365 + 45) &&
			XDrawString(D, W, G, d + 7, ++y, c - ' ', 2)) {
			for (d = !m; 7 > d; d++[o] = (r + !!r) *
				exp2((*c - 0x2f >> 1) - 21) * (2 * (*c & 1) - 1))
				for (r = 0, c = n + 37 * m + (y = 5) * d - 31;
					--y; r = (r - 47 + *c--) / 64);
			b = o[3] + o[4] * j;
			for (l = b + (a = o[1]) * sin(b); 1e-6 < fabs(r);
				l += r = (b - l + a * sin(l)) / (1 - a * cos(l)));
			r = log1p(*o * (1 - a * a) / (1 + a * cos(
				l = 2 * atan(sqrt((1 + a) / (1 - a)) * tan(l / 2)))));
			r *= fmin(d = A.width / 2, y = A.height / 2) *
				cos(asin(sin(l += o[5]) * sin(o[2]))) / log(32);
			l = atan2(sin(l) * cos(o[2]), cos(l)) + o[6];
		}
	return 0;
}
","#include <stdlib.h>
#include <curses.h>
#include <time.h>
#include <X11/Xlib.h>
#include <X11/keysym.h>
#define F(x,y,w,h,c) G(c),XFillRectangle(A,B,D,x,y,w,h),G(3)
#define G(c) XSetForeground(A,D,C[c].pixel)
#define H(d) addch(y?y-e?ACS_VLINE:ACS_L##d:ACS_U##d)
#define I(i,c) init_pair(i,COLOR_##c,COLOR_##c)
#define J(a,b) j==X[(int[]){ KEY_##b,XK_##a} ]
#define K(q,r,s,t,u,v,w) (q=!!(w)*z[p v]>>8,(1<<(3*!!((((r)>>t)^(s))&u)))*!!q)
#define L z[p=rand()&63]

int c[9],e,f,g,               h,i,j,k,l,m,n,q               ,r,s,t,u,v,w,x,
y,X, z[64]; GC                D; Display * A;               Window B;  char
o[]=""tdpsf\73!""               ""&e!&e!&e\1"",*Y               =o,b[64];XColor
C[8]; XEvent E;               int  R  (  )  {               XDrawString(A,B
,D,348,58, b, e               ); XNextEvent (               A, &E);  return
XLookupKeysym(&               E.xkey,0)*! (E.               type^KeyPress);
} void P(){ g =               DefaultScreen((               A=XOpenDisplay(
               0 ) ) ) ;   do                XAllocNamedColor
               (    A       ,                DefaultColormap(
               A,g),5*x+""#fff""               ""\0#f00\0#0f0\0""
               ""#000"",C+x,C+4)               ; while(++x^4) ;
               XMapWindow(A,B=              XCreateSimpleWindow
               (A,RootWindow(A               ,g),0,0,460,300
               ,0, C[3].pixel,               C->pixel ) )  ;
XSelectInput(A,               B,KeyPressMask|               ExposureMask);D
=XCreateGC(A,B,               0,0); } void a(               ){ for(y=0; y<=
e; y++)if(X)for               (x=k; y%3==0&&y               ^e&&x<k+t; x+=6
)XDrawRectangle               (A,B,D,3+6*x,6+               12 *y, 36, 36);
else{ move(y,k)               ; H(LCORNER ) ;               for(x=0; ++x^t;
)addch(x%6?y%3?               32:ACS_HLINE: y               &&y-e?ACS_VLINE
: ACS_HLINE)  ;               H(RCORNER); } }               void  Q  ( )  {
               initscr ( )   ;               start_color( );
               keypad(stdscr,1               ); curs_set(0);
               I(1, RED); I(2,               GREEN ) ; I(3 ,
               WHITE); } void                d(){ for(k=!x ;
               k^t; X?F(u,v,6,               12,i):mvaddch(v
               ,u,32|COLOR_PAIR              (i))){ u=X+(1+5
               *X)*(x+((i=~e?!               !e*((((e-1)>>k)
&1)+1):3)>2?4:1               )*(k/2)); v=X+(               1+11*X)*(1+3*y+
k++%2); } } int               S(){ mvaddstr(t               ,58,b); refresh
();return getch               (); } int main(               int p,char**V){
((X=*++V&&**V==               88)?P:Q)(); for               (srand(time(0))
; ( *Y++)--; );               for(f=++n; k^64               ; !L&&(z[p]=++k
)); L|=*z<<8; g               =p&7; h = p /8;               for(--l; j^113;
J(Up,UP) ? m?h?               h--:1:w?w--:i:J               (Down,DOWN)?m?h
               ^7?h++: r :w^7?               w++:l: J( Left,
               LEFT)?m?g?g--:3               : 7 : J (Right,
               RIGHT)?m ? g^7?               g++:9:s:j==10||
               J(Return,ENTER)               ?m?z[p=8*h+g]>>
               8?m--:((((r=K(x               ,x-1,l,t,3,-1,g
               )+K(y,l,y-1,t,3               ,+1,g^7)+K(i,i-
               1,l,1,21,-8,h)+               K(e,l,e-1,1,21,
+8,h^7))+3)&~3)               ==k)?z[p]|= ++l               <<8,c[w]=0, l=~
--m, s += r * (               "")%##!!!!""[--q]               -33),f++:m:c[w]
?l=c[w]-!m++:n^               64?c[w]=z[n++]&               127,q++:X:k){ p
=k=X&&!(F(0, 0,               460,300,0)); t=               48; e=24; a( );
k=t+2; t/=8; a(               ); e=3; k+=8; a               (); for(; p^64;
j^7?(void)j:d()               ){ x=2+t*(j=p%8               ); y=p/8; e=z[p
++]>>8; d( ); x               +=8; e =c[y]; }               x+=8; y=0; e=l+

1; d() ; x+=m*(t*g-50)-9; y=m?h:w; t-=2; e=-1; d(); e=sprintf(b,o,s,f,(f*s)
                 >>6); j=(X?R:S)(); } return X||endwin(); }
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define r char S; T R; I N, G, s
#define A(P,O) for(P=O; *P; P=U(P))
typedef char T[128],*I,p[2400];
#define memset  (I)\
        memset  
void*P= strcpy  ; I Q(); typedef const void*f; int u(f P,f O){
 return strncmp ((I)P,(I)O,1); } T g,c={ 127} ; char l,F[6000000]; I U(I P){
     r; strncpy (R,P,2);
     s= strchr  (
        strcpy  (P,c),0)
      ; strncpy (P,R,2); return s; } T q,B,E; I t(I P){
     r; qsort   (P,
        strlen  (P),1,u);
  if(s= strstr  (P,c))*s=0; return P; } T a={ 2} ; void D(){ r;
   S=1; strcpy  (R,c); t(F);
  for(; memset  (E,S,l),
    (S= strlen  (
        strcat  (R,c)))<*R; t(s))for(s=B;
     N= strstr  (F,E); s=F)
      * memset  (N,*c,l)=S; } p H=""(*&,."",k; I j(I P){
  r=(I) malloc  (
        strlen  (
        strcat  (P,""\177 "")));
      * strstr  (P,c)=0;
 return strcpy  (s,P); } int K(f P,f O){ return u(O,P); } void
   b(){ qsort   (F,
        strlen  (F),1,K); } void n(I P){ r; A(P,P){
  if(N= strchr  (F,*P)); else{ t(F);
   b(); memset  (B,l,*F); N=F;
while(* strrchr (B,l)=0,
*P<=(S= strlen  (B))){
      * memset  (E,S,l)
   =*c; strcat  (F,E);
      } memset  (B,0,S); } *N=*c; } D(); } void C(I P,I O){ r; A(P,P)A(s,O){
      * strrchr (
        memset  (
        strchr  (
        memset  (
        strncpy (k,B,254),l,*P),0),l,*s),l)=0;
    *q= strlen  (k)
      ; strcat  (F,q); } D(); } T i=""\13<\f=""; void o(I P){ A(P,P){
      * strrchr (
        memset  (B,*c,*P),*c)
    =0; memset  (B,0,
    *P= strlen  (B)); } } int V(f P,f O){ return u(*(I*)P,*(I*)O); } void e(I O){
     r; strcpy  (H,O)
      ; strcpy  (R,c); for(;
     0< strncmp (F,H,1)
      ; strcat  (R,c))A(s,
     H) memset  (B,0,
    *s= strlen  (
        strcat  (
        memset  (B,*c,*s),c))); *k=0; do{ while
   (0<= strcmp  (F,H)){ n(H); b();
    *q= strlen  (R)
      ; strcat  (k,q); }
      * strrchr (R,*c)=*B; o(H); } while(*R); } char d(I P){
  if(P= strstr  (P,g)){
if((*g= getchar ())<*i)' '<*g?o(g):d("" ""); } else P=B; return*P; } I m(I
    P){ qsort   (P,
        strlen  (P),1,K); return*P==*c?U(P):P; } void J(I P){ r=m(P);
if(P<s) putchar ('-')
      ; memset  (B,l,*s); do{ *E=*i;
  if(N= strchr  (s,
    *q= strlen  (B)))
     t( memset  (
        memcpy  (E,i,l),*c,
        strspn  (N,q)))
      ; putchar (*E);
      * strrchr (B,*B=l)=0; } while
  (*B); puts    (B)
      ; free    (P); } I M(){ r=Q(),P,O; while(S=d("".)$"")){ N=Q();
     G= strcpy  (F,B); P=m(s); O=m(N); if(S==')'){ C(P,O); }
  else{ strcpy  (F,P); e(O); if(S=='.')G=k; else O=N;
      } free    (s); G=j(G);
     s= strcat  (G,P==s==(O==N)?B:c)
      ; free    (N); } return s; } I h(){ r,P,O; for(N=M(); S=d(""*,"");
     N= strcat  (s,S?c:B)){ G=M(); P=m(N); O=m(G); S=O==G==(S==','); if(P==N==S)
    if( strcmp  (P,O)<0)
      { strcpy  (F,O); n(P); }
  else{ strcpy  (F,P); n(O); S=N<P; }
  else{ strcat  (
        strcpy  (F,P),O); D(); }
s=j(F); free    (N)
      ; free    (G); } return N; } I Q(){ r; if(S=d("",""))
  if(N= strstr  (s=Q(),c))*N=*B;
   else strcat  (s,c); else if(d(""'"")){ s=h(); S=d(""(""); }
  else{ strcpy  (F,B); while(*q=d(i))
      { strcpy  (H,F)
      ; memset  (
        strncpy (F,B,l),S=1,
        strcspn (i,q)); C(H,a); } s=j(F); } if(!S){
     o( strcpy  (F,""tzouby!fssps""))
      ; puts    (F); } return s; } int main(int P,I*O)
      { qsort   (O,P,sizeof*O,V);
 l=1<P? strtol  (*O,0,l):10; C(H,
    i); strcpy  (i,F); d(g); while(!d(""\377""))for(J(h()); !d(""\377\n""); d(g)); return 0; }
","/**??/
/
#include<netdb.h>
#include<stdio.h>
#include<sys/time.h>
#define NCC 1701
#define STARDATE 500000
#define k 16309

                      int C,p,t,J,a,m,e,s,T,K,i,r[k],_[k][2],c[k][2],f=NCC;
                    fd_set O,d,o;char g[8][k],*h,j[]=""0\1&me\1&t&e\1TFTTJPO>""
                 ""\1&t\\_<\16\v^\1&+\\_;^&o;&e\1TFU.DPPLJF;\1iuuq;00&92:2\\_0^&""
               ""o\1&tDppljf;!tfttjpo>&t\16\v\16\v\1HFU!&t!IUUQ02/1\16\vIptu;!""""""
            ""&t\16\v\1IUUQ02/1!311!PL\16\vDpoufou.uzqf;!ufyu0iunm\16\vFyqjsft;!1""""""
          ""\16\vTfu.Dppljf;!tfttjpo>&t\16\vDpoufou.Mfohui;!&me\16\v\16\v&t\1=iunm?=c""                                 ""pez!chdpmps>#cmbdl""
       ""#?=ejw!tuzmf>(qptjujpo;bctpmvuf<upq;61&&<mfgu;61&&<usbotgpsn;usbotmbufY).61&&*u""                        ""sbotmbufZ).61&&*<(?=gpou!dpm""
     ""ps>#xijuf#?=qsf?&t=0qsf?=0gpou?=0ejw?=0cpez?=0iunm?\1T`K!`.`[!G!G`\v]C`)K>0`>`0!E`/""                  ""D.(D.aD./E`D!C`p`K!F`0F`}\vM!]`!]E!""
   ""]E./J`/E.0C!G>I`0L.0\vO!]!]D!0C!0E!a.`.(K!)E`0I!]G`E!}\vK!C`-C.a/a.(//(.`[!N!]C!+!]\vJ!0E`K!}}[!K!C`0E`0C`\vO!aC./E`-.([!K!|K`|"";struct sockad\
dr_in l;struct timeval n,q;struct hostent*u;long w;void x(int y){close(y);FD_CLR(y,&O);if(y>=m)while(--m)if(FD_ISSET(m,&O))break;}vo\
id z(char*A,char*B){char*D,*E=A,*F=A;for(0[0[g]]=0;*E;E++)if(*E==10){if(E-F==(*(E-1)-13?1:2))break;*E=0;if(!strncmp(F,B,strlen(B))&&(D=strstr(F,j+\
11))){sscanf(D+8,j+20,0[g]);break;}F=E+1;}else*E=toupper(*E);}int main(int G,char**H){h=j;while(*h)(*h)--,h++;h=j+414;do{t=*h++;e=1;if(t>=65&&t<=90)e
=t-64,t=*h++;while(e--)6[g][i++]=t;}while(t);sprintf(7[g],j+229,6[g]);l.sin_family=2;if(G>1){sscanf(1[H],j+53,4[g],&K);sprintf(2[g],j+97,*(1[H]+K)?1[
H]+K:j,4[g]);sscanf(4[g],j+29,&i,&f);i[4[g]]=0;u=gethostbyname(4[g]);memcpy(&l.sin_addr.s_addr,0[u->h_addr_list],u->h_length);l.sin_port=htons(f);\
for(;;close(G))if(!connect(G=socket(2,1,0),&l,sizeof l))for(;;){strcpy(1[g],0[g]);s=sprintf(5[g],j+72,2[g],0[g]);if(write(G,5[g],s)<0)break;gett\
imeofday(&n,0);0[3[g]]=0;e=read(G,3[g],k);if(e<0)break;else if(e&&*3[g]==72){gettimeofday(&q,0);3[g][k-1]=0;z(3[g],j+41);if(0[1[g]])if(!strnc\
mp(1[g],0[g],strlen(1[g]))){t=0;if((q.tv_sec-n.tv_sec)*1000000+q.tv_usec-n.
tv_usec<STARDATE-1000){t=p<15?1:16;p+=t;C+=t;}else p=p<15?15:255;if(p==2\
55){putchar(C);fflush(stdout);C=p=0;}}else{T=1;goto l;}}}}else{for(f=0;
f<k;f++){if((i=fgetc(stdin))<0)break;f[r]=i;}for(i=0;i<k;i++){0[i[_]]
=1[i[_]]=-1;0[i[c]]=1[i[c]]=0;}gettimeofday(&n,0);p=sprintf(5[g],j+2
,n.tv_sec);n.tv_sec=0;n.tv_usec=STARDATE;FD_ZERO(&d);FD_ZERO(&O);F\
D_ZERO(&o);l.sin_addr.s_addr=0;l.sin_port=htons(NCC);bind(G=sock\
et(2,1,0),&l,sizeof l);listen(G,10);FD_SET(m=G,&O);for(i=1,t=0;;
){d=O;C=select(m+1,&d,0,0,0);if(C<=0){if(!i&&t)x(t);goto l;}fo\
r(J=t;C&&J<=m;J++)if(FD_ISSET(J,&d)){C--;if(J==G){t=accept(G,
0,0);FD_SET(t,&O);FD_CLR(t,&d);FD_SET(t,&o);if(t>m)m=t;t=0;
}else if(!i||FD_ISSET(J,&o)){e=read(J,2[g],k);K=0;if(e>0){
2[g][k-1]=0;if(*2[g]==71){a=0;strcpy(1[g],0[g]);z(2[g],j+
45);if(!strncmp(0[g],5[g],strlen(5[g]))&&!strncmp(1[g],
0[g],strlen(1[g]))){K=atoi(0[g]+p);}if(K){if(0[K[_]]<f
){if(a=(1[K[_]]<15?1[K[_]]:1[K[_]]>>4)>=(1[K[_]]<15?
0[K[_]][r]&15:0[K[_]][r]>>4))1[K[_]]=1[K[_]]<15?1\
5:255;else 1[K[_]]+=1[K[_]]<16?1:16;if(_[K][1]==\
255){0[K[_]]++;1[K[_]]=0;}}else{write(1[K[c]],_[
K],sizeof(_[K]));close(1[K[c]]);K=0;}}else fo\
r(s=1;s<k;s++)if(0[s[_]]==-1){0[s[_]]=1[s[_]]
=0;K=s;break;}if(K)sprintf(0[g],j+6,5[g],K)
;else 0[0[g]]=0;w=sprintf(3[g],j+125,0[g],
strlen(7[g]),7[g]);if(i){pipe(c[K]);if(!
(i=fork())){close(0[K[c]]);FD_ZERO(&O);
FD_SET(t=m=J,&O);}}if(i<0){T=1;goto l;
}if(i){close(1[K[c]]);FD_SET(0[K[c]]
,&O);if(0[K[c]]>m)m=0[K[c]];x(J);\
break;}else{if(a){n.tv_sec=0;n.t\
v_usec=STARDATE;select(0,0,0,0,&
n);}write(J,3[g],w);if(!K){close(J);return 0;}}}}else if(i){
close(J);FD_CLR(J,&o);x(J);}else{write(1[K[c]],K[_],sizeof(K[_
]));close(1[K[c]]);close(J);return 0;}}else{for(K=0;K<=m;K++)if(
0[K[c]]==J){read(J,K[_],sizeof(K[_]));x(J);if(_[K][0]>=f){0[K[_]
]=1[K[_]]=-1;0[K[c]]=1[K[c]]=0;}break;}}}}}l:close(G);return T;}","#include <stdio.h>
#define _$()                                         0
#define __$()                                        1
#define _$_()                                        10
#define $_$(a)                                       a;
#define $_(b,a)                                     a##b
#define r(a,b)                                  r##a##b##urn 0;
#define m(b,a,x) };                               m##a##b##n
#define $(b,a,x)                                  a##b##x
#define                                         ____ + __
#define $_$_                                         =
#define __(...)  (                              $(n,i,t))(\
$(ze,si,of)(($(n,i,t)[]) { _$(), ##__VA_ARGS__})/$(ze,si,of) ($(n,i,t))-__$())
$(n,i,t)  (*___)   ($(n,i,t))  = $(tch,  pu,  ar);   $(ub,do,le) _<::> $_$_ <%

         -2, 1, -1.3, 1.3     /* <-- Configure here: X1, X2, Y1, Y2 */

,_$(), _$(),_$(),_$(),_$() ,_$(), __( ',',',',',' ,',' ,',')  * _$_() ,( _$_()
- __('_','_')) * _$_(), _$(),_$(),_$(),__('_','_')*__('_','_', '_','_', '_') *
__('_','_', '_','_', '_')*__('_','_', '_','_', '_')+__('_','_', '_','_' , '_')
,__('_','_','_','_','_','_','_','_',), _$() m(i,a,u)($(n,i,t) $_)<% $_ (f,i) (
$_ $_(=,=) __(_) ) $_$($_(f,i)(_[ _$_()____(_,_) ]>_[ _$_()] )_[_$_()____ (_,_
,_,_,_,_,_)] $_$_ __(_) )$_(f,i)(_[_$_()____(_ ,_ ,_)] >_[  _$_()+ __$() ]  ||
_[_$_()____(_,_,_,_,_,_,_)] $_ (=,=) __$()) r(e,t) _[__(_,_,_ ,_,_ ,_)] $_$_ _
[__ (_,_,_,_,_,_,_)____(_,_,_,_,_,_) ]/_[__(_,_,_,_,_) ____(_,_,_,_,_,_)]*( _[
  __$()]-_[_$()])+_[ _$() ];_[__(_,_,_,_,_,_,_)] $_$_ _[__(_,_,_,_,_,_,_) ____
(_,_,_,_,_)]/_[_$_()]*(_[__(_,_,_,)]-_[__(_,_,)] )+_[__(_,_,)];_[__(_,_,_,_, _
,_,_,_)] $_$_ _[_$_() - __$()] $_$_ _[__(_,_,_,_,_)+ _$_()-__$()]  $_$_  _$();
_f:_[__(_,_,_,_)]  $_$_  _[__( _,_,_,_, _,_,_, _)] * _ [__(_,_,_, _,_,_,_,_)];
_[__(_,_,_,_,_)] $_$_ _[_$_() - __$()]*_[_$_() - __$()];_[__(_,_,_,_,_,_,_,_,_
)] $_$_ __(_,_)*_[__(_,_,_,_,_,_,_,_)]*_[_$_() -__$()]+ _[__ (_,_,_,_,_,_,_)];
_[__(_,_,_,_,_,_,_,_)] $_$_ _ [ __(_,_,_,_) ]-_[__(_,_,_,_,_)]+_[__(_,_,_,_,_,
_)];$_$(_[_$_()____(_,_,_,_,)]++)$_(f,i)((_ [_$_() ____ (_,_,_,_,)]< _ [_$_ ()
____ (_,_,_,_,_)])&&(_[__(_,_,_,_)]+ _[__(_,_,_,_,_)]<_[_$_()____(_,_,_,_,_,_)
])) $_(to,go) _f; $_(ar,ch) $(m,i,au)[] $_$_ <% __(_,_,_) * _$_()____(_,_), __
(_,_,_,_) * _$_()____(_,_,_),__(_,_,_,_,_,_) * _$_()____(_,_,_,_), __(_,_,_,_)
*_$_() ____(_,_,_,_,_),__(_,_,_,_) * _$_() ____(_,_,_,_,_,_),__(_,_,_,_) * _$_
()____(_,_) %>;___($(m,i,au)[($(n,i,t)) _[_$_()____(_,_,_,_)]%__(_,_,_,_,_)]);
$_$(_[__(_,_ ,_,_ ,_,_,_) + __(_,_,_,_,_,_)]++){m(i,a,u) ( _$()) ;$_$ (_[_$_()
____(_,_)]++)$_$(_[_$_()____(_,_,_)] $_$_ _$()) $_(f,i)(_ [__(_,_,_,_,_,_,_) + 
_$_()] != __(_)) ___(_$_()) ;{  m(i,a,u)(__$()); r(e,t)    /* IOCCC 2014*/  %>","







                #include<stdio.h>/*IOCCC2014            2014    2014    IOCCC2014IOCCC2014IOCCC201*/
                char*s=""\""nsu{AntynCnuq}Bnu{            sEot    ln>b    )+c^g+@`+]_osk{;j@bkg&c<'^o\
                r'Q]                    bh'l    vQ^k                    g&c:                    %n|\
                N]_o                    ptj9    lwg+                    )d:b                    kg$\
                c8#^    #g+)d8`a%g+)    d8`_                g&;bh'oq    Q^)g    +&kcNlyMc+)d    8`a\
                `g+@    u)|d8ak=bl}(    Q^og                (O{MK6lM    L(rR    pOpM866OsRlm    N(q\
                Q]##    OsR#M_(lQoOa    N9$m    vOwwRor~        }(cN    mkM:    q(Q]%_(uU]}_    {8b\
                %mRh    #S^`#mOaaD%/    RI4$    4SNH$%N4        RlMG    /2MJ    24O3NF(tQ?1l    N*N\
                +Q]l    mq9l8b$^#h$#    .d,d    xv#mSOPm    R8`/        lM;b    h&^/lM:k8b%&    Q^-\
                h%c9    .#,/&N$McPc%    -d8,    $c8``7:b    %^h%        :79b    $^%$7ON8r%Qr    h$Q\
                On%q                    N%O~        M$qN$OMp    RmPQ    O%rQ                    $rQ\
                MkQN                    77O#        dj#Nkd$7    O%d8    ``(r                    RmM\
                :(luN](%mRMmO%lNRmO_loa8%%O<    b(lQ    h'lQ    O^ln    ;b'%N&O^6sN#M9slltwzh&TmS$'\
                %R#ON$oNS&pRM7O$'%S#ON$oNS&p    SMd9    ``(t    pkO9    $:nk8b#^%}kx#O%lMtpk#OQOP:#\
                                                mR8`}(qQ        O<b\
                                                '7M{N^kh        'Q]\
                    7sN'    M8q;k'N_7vN'nSM8    'nR;    $%M'    TamS&7O#d#7O    &d8`z9b$    ^h$\
                    rQ]6    yN$_$$pQaM8m{px$    TmSt    6O#N    sM$nRmUd#7Os    d77sNOsd    8`j\
                =nk;        |8k9    b1g(    Q^)$c:%]    k*Q]g$9%_h*]+wnS        _+sTaa:&%{R\
                M<%{        S{O_    &<#w    kP8#a;'(    0d:`184>b)^15)OM        :23h)QN<'/M\
                    =b(^'h(Q]0h#    c_kah%0d9`b'/O(Q^(/SlM90%M(/            RM;&    $c&kckQ,    -$c\
                    .&kccMcOP$&d    9g(=``6:69j=b5g(Q^3(2lNUO<b4            'Q^s    ;b&^%%pQ    M8k\
                        $7O#cQ]0(2(Q]'2O    3'Q]'_3a    N_1'    5OMaMch&T$mR#nRMPmSk    U$7\
                        O#d8_a%%mS]l_%mR    mS]$]h$9    j_la    _$6N]g$9j_laaaN:`g'<    ``7\
                oM:6%N9b%g$Q        ^6%N8b%g    #Q^l            peoqemtemw#jQ7#QO$jQ    O7$Q    Ok#\
                $7OMQ]k_#$7O        ckQaOrON    epne            luelue`lpeoqempepneu    e`kf    _a`\
                                                lf))    *+,**,*)-)/),0).0(6/2+667,(&    $##\
                                                #;=@    D*0;#include<stdio.h>@intYH[    9`%\
                .],*s,*c,d,t;`;'main(`-9n,ch            ar*v    []){        for(s=c=    H+3`XI;\
                (*++s=Q[d++]););for(;n>1&&(*            ++s=    v[1]        [tgANs=H    ;d=*c++\
                %93,                    d-9;    ){in    tYv=*s,g        []={    n+v,        v-n,n*_\
                ,#^_                    ,,<v    ,n?v    /n:0`,#%        `,,v    >>n,        v==n}ay\
                >t=0    ;d<4&&d>=2*!    !n&&    (c-=d/3*2_KK3+*c++,t||v!=98+d);)        t+=v++/6-16\
                ?0:v    /2%3-1cq*d-1    4;t>    0_t$<3_z(105<*c_X'=t*21aq@-106;n        =d>76?s--,g\
                [d-7    7]:d>55?H_1)    21]=    n,*_@_8(        9?*++s_4&12>d_C`f3]+=21-d*2\
                :d<3    4?t:_Zadat57    <d?p    utchar(n        ),v:6<a](g+99]=a{d2#:`xa6,n\
                ;}re    turnY_."",*p,    b,d[        9338    ],*q,x,*r=d;            int main(){;for(
                p=q=    5000+0+d;*s;    s++)        if(*    s>32)*p++=*s            -89?*s:32;for(p=
                1152                    +q;(    b=*p++);){for(d[17]=            10;x    =*p++,b<
                92&&                    34<b    --;*r++=x)if(x==9*9)            for(    ;*q;x=34
                )*r++=*q++;for(p-=b<92;b-->4        *23;r++)    *r=r[36-    x];}puts    (d);
                return(0);}/*IOCCC2014IOCCC2        014IOCCC    2014IOCC    C2014IOC    CC*/








"," #include      <stdio.h>
#define TA    q=/*XYXY*/
#define/*X    YXY*/CG r=
void p(int    n,int c){;
for(;n--;)    putchar(c)
#define Y(    z)d;d=c++\
%2<1?x=x*4    +z,c%8>5?\
x=x?p(1,x),   0:x:0:0;d=
#define/*X    YX*/C Y(1)
#define/*X    YX*/G Y(2)
 ;}int(*f)(  void),d,c,
 #define/*X  YX*/A Y(0)
  #define/*XY*/AT int\
     m(void/**/){d=
  #define/*XYX*/T Y(3)
 #define GC  d; return\
 0;}int(*f)  (void )=m;
x,q,r; int    main(){if(
f)f();else    {for(puts(
""#include""    ""\40\""pro\
g.c\""\n\n     \101T""+0);
d=!d?x=(x=    getchar())
<0?0:x,8*8    :d,TA++c%8
,TA(1+7*q-    q*q)/3,r=c
*15-c*c-36    ,p(r<0?!q+
4:r/6+!q+4    ,32),q||x;
c%=16)q?p(    1,""ACGT""[x
/d&3]),p(q    ,126),p(1,
""TGCA""[x/d    &3]),d/=4,
p(001,10):    puts(c%8?\
""CG"":""TA"")    ;puts(""GC""
 );}return     0;}/**/
","					  #include /*!!TAB=4!*/<stdio.h>
					  #include /*{{IOCCC2}}*/<SDL.h>
					  #define b/*{{IOCCC257}}*/ if (
				#define a(b, c) for (b = 0 ; /*IOCCC/2014*/b<d; b++,c)
				e,h,f,g,i,j,k,l,m,n,o,p=1,*q,r,s=5, t,*u,x,y,z,A,B, C[
				333*7],d=333; D,E,F,G [2 ],H, I, J, K, L, M,N= 1,O,P,Q
				,*R;char * S, **T;			  /*33*/	  ;
				SDL_Surface*U,* V;			  int*W(	  X
				){ u=C+X *7; b*u){			  u++; x	  =u[0]; y=u[1
		  ]; H=u	  [2]; z				  =(H%8)				 *
		  i; A=(	  H/8)*i				  ; B=u[				 3
		  ]/**/;	  return				  u; ; }				  return
		  0; } Y	  (){ O=50; r=					0; t=1				   ;
		  } Z (X 	  ,m, n,o)/**/					{ /**/				   ;
		  return	  W(X)&&B&&(m<					x+i&&n				   <
		  y+i&&x<m+i&&						  y<n+o); } int*ba(int*u){ int X
		  ,*bb=C; a(X,						  bb+=7){ b!*bb){ *bb=1; R
		  =bb +1; H=6;						  while(H--)*R++=*u++; /*W
					 N										   N
					 E  									   E
					 S										   S
				*/return bb; } } return 0; } bc(e){ q[2]=e; } bd
				(be,bf){ int X,bg; m+=be; n+=bf; I=e
				-i; m=m<0?0:(m>I?I:m); a(X,0){ b Z(X
				,m,n,o)){ bg=B&1; b D&&bg) continue;
		  m-=be; n-=bf; b B&8){ u[-1]=0; j=1; bc(8); b B&32){ n-= i;
		  o=i*2; } } b B&16&&!O){ bc(32+(o>i?8:0)); Y(); u[- 1]=0; }
		  b(B&128&&bf&&s<0)||(B&64))u[-1]=0; b bg&&!O){ b bf&&s >0){
	u[2]--; u[3]=bf=0; s=-6; } else { b j){ bc(0); b o>i) n+=o=i; D=30; j=0;
	} else { bc(24); Y(); L=-1; } } } b B&4){ b bf&&s<0){ int I[]={ x,y-i,u[
	5],u[4],rand()%2?1:-1,2} ; u[2]++; u[3]=2; ba(I); } } b bf)s=1; break; }
	}			} bh (m,e,k,	  bi){ H=k/ 2; 		G[bi]=m>e-H?		   k
	-			e:(m>H?H-m:0 	  ); } bj(X,be 		,bf){ int bk		   ;
	u 			[0]+=be; u[1 	  ]+=bf; W(X); 		E=x,F=y,I=0;		   a
	( 				  bk,0){ b I=(X!=bk&&Z(bk,E,F,i)&&(B&6 				   )
	) 				  )break; } W(X); b I){ b bf)u[1]-=bf; 				   b
	be  			  ){ u[0]-=be; u[4]*=-1*be; } } W( X); 				   }
	bl 			(){ int bm=n,X; SDL_FillRect(U,0,M); X=4; while(		   X
	--			)bd(r,0); X=3; while(X--)bd(0,s); b n>h&&!O)Y () 		   ;
	t 			=bm==n; q[0]=m; q[1]=n; bh(m,e,k,0); bh(n,h,l,1)		   ;
	a(X,0){ b W(X)){ b B&9){ bj(X,u[4],0); bj(X,0,2); } b B&1){ *u +=u[4]; b
				++u[5]>20){ u[4]*= 			  -1; u[5]=0; }	z+=K
				%2?i:0; } J=i; b q 			  ==u){ J=o; b!O){ b
				r)z+=i*(K%2); b!t) 			  z=48; z+=p<0?i*4:0
				; }} b q!=u||!(D&& 			  0==D%3)){ SDL_Rect
		  bn={ z,A,i,J} ,bo= 						{ G[0]+x,G[1]+y,i,
		  J}; SDL_BlitSurface 						(V,&bn,U,&bo); } }
		  } b(s+=2)>2)s=2; K 						++; D-=D?1:0; b O)
		  b!-- O) exit(L); }						bp(X){ return strtol
	(T[X],0,0); } bq(int H ,						int*br,int bs ){ int bt;
	bt=Q-P; b bt>bs) bt= bs;						SDL_MixAudio(br,S +P,bt,
	128); P+=bt; b P>=Q)P=0;						} SDL_AudioSpec bu={8000
	,8,1,0,256,0,0,bq} ,bv ;						main(int bw,char**bx){ T


  =bx; int by,H=255,   bz=H<<8					,bA =bz   <<8,bB= bA<<8,
  bC=bp(5),bD=bp(6);   SDL_Event			  bE; o =i=   bC / 8; k = bp(1)
  ,l=bp(2),e=bp(3),h   =bp (4); M=			bp(9); /**/   SDL_Init(/*<2053""*/
  0xffff			   ); b!*(char*)	  &N){ H=bB; bz   =bA; bA	   =bz>>8;
  bB=255			   ; } U=SDL_SetVideoMode(k,l,0,0);   V=/*NES	   HISTORY
  SANDRO			   */ SDL_CreateRGBSurface(1 <<15 ,   bC, bD,	   32,H,bz
  ,bA,bB); fread(V->   pixels,bC*bD*4,1,fopen(T [7],""r""   )); SDL_OpenAudio(&
  bu,0); SDL_LoadWAV   (T[8],&	   bv,&S,&Q		); /**/   SDL_PauseAudio(0);
  for(; ; ){ int u[6   ],*I; H		  =0		; while   (H < 6) scanf(/*0*/
			  ""%d "",   u+H++);					b u[5]<   0)break	   ; I=ba(
			  u);b!u   [3]){ q					=I+1; m   =u[0 ];	   n=u[1];
			 } } for   (; ; ){					while/*   !MAFFIO	   DO.S*/(
  SDL_PollEvent(&bE)   ) { by=					bE.type   ==3; b!O &&(by|| bE.
  type==2)){ I = bE.   key/**/					.keysym   .sym; b I== 276)r=
  by?0:(p=-1); b I==   275 )r=					by?0:(p   =1); b I==32)by?

  0:(t?(s=-9):0); b I==27)exit(0); } } bl(); SDL_Flip(U); SDL_Delay(60); } }
","					  #include /*!!TAB=4!*/<stdio.h>
					  #include /*IOCCC2*/""SDL/SDL.h""
					  #define b/*{{IOCCC257}}*/ if (
				#define a(b, c) for (b = 0 ; /*IOCCC/2014*/b<d; b++,c)
				e,h,f,g,i,j,k,l,m,n,o,p=1,*q,r,s=5, t,*u,x,y,z,A,B, C[
				333*7],d=333; D,E,F,G [2 ],H, I, J, K, L, M,N= 1,O,P,Q
				,*R;char * S, **T;			  /*33*/	  ;
				SDL_Surface*U,* V;			  int*W(	  X
				){ u=C+X *7; b*u){			  u++; x	  =u[0]; y=u[1
		  ]; H=u	  [2]; z				  =(H%8)				 *
		  i; A=(	  H/8)*i				  ; B=u[				 3
		  ]/**/;	  return				  u; ; }				  return
		  0; } Y	  (){ O=50; r=					0; t=1				   ;
		  } Z (X 	  ,m, n,o)/**/					{ /**/				   ;
		  return	  W(X)&&B&&(m<					x+i&&n				   <
		  y+i&&x<m+i&&						  y<n+o); } int*ba(int*u){ int X
		  ,*bb=C; a(X,						  bb+=7){ b!*bb){ *bb=1; R
		  =bb +1; H=6;						  while(H--)*R++=*u++; /*W
					 N										   N
					 E  									   E
					 S										   S
				*/return bb; } } return 0; } bc(e){ q[2]=e; } bd
				(be,bf){ int X,bg; m+=be; n+=bf; I=e
				-i; m=m<0?0:(m>I?I:m); a(X,0){ b Z(X
				,m,n,o)){ bg=B&1; b D&&bg) continue;
		  m-=be; n-=bf; b B&8){ u[-1]=0; j=1; bc(8); b B&32){ n-= i;
		  o=i*2; } } b B&16&&!O){ bc(32+(o>i?8:0)); Y(); u[- 1]=0; }
		  b(B&128&&bf&&s<0)||(B&64))u[-1]=0; b bg&&!O){ b bf&&s >0){
	u[2]--; u[3]=bf=0; s=-6; } else { b j){ bc(0); b o>i) n+=o=i; D=30; j=0;
	} else { bc(24); Y(); L=-1; } } } b B&4){ b bf&&s<0){ int I[]={ x,y-i,u[
	5],u[4],rand()%2?1:-1,2} ; u[2]++; u[3]=2; ba(I); } } b bf)s=1; break; }
	}			} bh (m,e,k,	  bi){ H=k/ 2; 		G[bi]=m>e-H?		   k
	-			e:(m>H?H-m:0 	  ); } bj(X,be 		,bf){ int bk		   ;
	u 			[0]+=be; u[1 	  ]+=bf; W(X); 		E=x,F=y,I=0;		   a
	( 				  bk,0){ b I=(X!=bk&&Z(bk,E,F,i)&&(B&6 				   )
	) 				  )break; } W(X); b I){ b bf)u[1]-=bf; 				   b
	be  			  ){ u[0]-=be; u[4]*=-1*be; } } W( X); 				   }
	bl 			(){ int bm=n,X; SDL_FillRect(U,0,M); X=4; while(		   X
	--			)bd(r,0); X=3; while(X--)bd(0,s); b n>h&&!O)Y () 		   ;
	t 			=bm==n; q[0]=m; q[1]=n; bh(m,e,k,0); bh(n,h,l,1)		   ;
	a(X,0){ b W(X)){ b B&9){ bj(X,u[4],0); bj(X,0,2); } b B&1){ *u +=u[4]; b
				++u[5]>20){ u[4]*= 			  -1; u[5]=0; }	z+=K
				%2?i:0; } J=i; b q 			  ==u){ J=o; b!O){ b
				r)z+=i*(K%2); b!t) 			  z=48; z+=p<0?i*4:0
				; }} b q!=u||!(D&& 			  0==D%3)){ SDL_Rect
		  bn={ z,A,i,J} ,bo= 						{ G[0]+x,G[1]+y,i,
		  J}; SDL_BlitSurface 						(V,&bn,U,&bo); } }
		  } b(s+=2)>2)s=2; K 						++; D-=D?1:0; b O)
		  b!-- O) exit(L); }						bp(X){ return strtol
	(T[X],0,0); } bq(int H ,						int*br,int bs ){ int bt;
	bt=Q-P; b bt>bs) bt= bs;						SDL_MixAudio(br,S +P,bt,
	128); P+=bt; b P>=Q)P=0;						} SDL_AudioSpec bu={8000
	,8,1,0,256,0,0,bq} ,bv ;						main(int bw,char**bx){ T


  =bx; int by,H=255,   bz=H<<8					,bA =bz   <<8,bB= bA<<8,
  bC=bp(5),bD=bp(6);   SDL_Event			  bE; o =i=   bC / 8; k = bp(1)
  ,l=bp(2),e=bp(3),h   =bp (4); M=			bp(9); /**/   SDL_Init(/*<2053""*/
  0xffff			   ); b!*(char*)	  &N){ H=bB; bz   =bA; bA	   =bz>>8;
  bB=255			   ; } U=SDL_SetVideoMode(k,l,0,0);   V=/*NES	   HISTORY
  SANDRO			   */ SDL_CreateRGBSurface(1 <<15 ,   bC, bD,	   32,H,bz
  ,bA,bB); fread(V->   pixels,bC*bD*4,1,fopen(T [7],""r""   )); SDL_OpenAudio(&
  bu,0); SDL_LoadWAV   (T[8],&	   bv,&S,&Q		); /**/   SDL_PauseAudio(0);
  for(; ; ){ int u[6   ],*I; H		  =0		; while   (H < 6) scanf(/*0*/
			  ""%d "",   u+H++);					b u[5]<   0)break	   ; I=ba(
			  u);b!u   [3]){ q					=I+1; m   =u[0 ];	   n=u[1];
			 } } for   (; ; ){					while/*   !MAFFIO	   DO.S*/(
  SDL_PollEvent(&bE)   ) { by=					bE.type   ==3; b!O &&(by|| bE.
  type==2)){ I = bE.   key/**/					.keysym   .sym; b I== 276)r=
  by?0:(p=-1); b I==   275 )r=					by?0:(p   =1); b I==32)by?

  0:(t?(s=-9):0); b I==27)exit(0); } } bl(); SDL_Flip(U); SDL_Delay(60); } }
","d=80,e,j;g(){j+=getchar();}main(a,b)char**b;{for(;;){j=0;g();if(j<0)break;g(g());putchar(b[1][j/3*strlen(b[1])>>8]);if(!(++e%d))puts("""");}}
","
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

#define A calloc(1, sizeof(m))
#define D m.
#define L ->
#define P malloc(
#define R &&
#define S ++
#define U for(
#define V if(
#define W L i
#define X L a
#define Y L b
#define Z L c

typedef struct T*_; struct T{ int t,i; char*a; _*b,c,d,e,f; } m,x,y; struct stat z; int u; void * H;
int K(int c){ return strchr("" \n\t"",c); } void B(_ s,_ p) { s Y=realloc(s Y,S s W*sizeof(_)); s Y [s
W-1]=p; } _ C(char*d,int l){ _ s=A; s X=d?d:P 1); s W=l<0?d?strlen(d):0:l; return s; } _ E(_ s){ _ r
=A; int i=0; U; i<s W; ){ U; i<s W R K(s X[i]); )i S; int j=i; U; j<s W R !K(s X[j]); )j S; V j-i)B(
r,C(s X+i,j-i)); i=S j; } return r; } int F(_ a,_ b){ return a W==b W R !memcmp(a X,b X,a W); } void
I( _    s,char c ) {    char*d=P            1); *d=c    ; B(s,C(d,1)    ); }                    void
 J (    char*d,int l    ,int o,_            v){ _ n=    C(d,l); _ w;    U l=                    0; l
<D d        W; )        { w=    D d Y[l S ];    V F(    w Z,n)){    V o>w W)    return; goto  O; } }
B( D        d,w=        A );    w Z=n; O:w W    =o ;    w L d=v;    } int M(    _ b,int p,char*t,int
g ){    _ f=    A; f    L e=                    A; f            X=t; int h=g            ,i=0,j=0,n=b
 W ;    char    c=0,    d,*o                    =b X            ; U; p<n; ){            t=j?"""":f X ;
 int    k=p; _ r=H ;    U; p    <n; ){ int l    = 0;    U; p<n R    o[p]==92    ; ){ l S; p S; } c=o
[p S    ]; V c^10||!    l% 2    ||!g){ d=c==    35 R    !i R!g||    c== 10 R    g^2; V d||strchr(t,c
)) {    r=C(o+k,p-k-    d*l/    2-1); V  d R    l%2)    { r X[r W-1]    =c^35                   ?32:
c; c    =0; } break;    }  }    c=0; } V!j)B    (f L    e,r?r:C(o+k,    n-k)                    ); r
=A; switch(c){ case 35:j S; case 0:break; case 10:goto O; case 36:switch(d=o[p S]){ case 36:I(f L e,
d); break; default:I(r Z=A,d); goto o; case 40:case 123:r L f=f; r L e=A; r X=d^40?""}$"":"")$""; f=r; }
break; default:V f L f){ r Z=f L e; f=f L f; o:r L t S; B(f L e,r); } else goto O; } i=f L f R g==1;
g=i?0:h; } O: x.c=f L e; x.t=c; return p; } _ N(_ s){ _ o=C(H,0); U int i=0; i<s W; ){ _ p=s Y[i S];
V p L t){ _ n=N(p Z); p=C(H,0); U int j=0; j<D d W; ){ _ w=D d Y[j S]; V F(w Z,n)){ M(w L d,0,""$"",2)
; p=N(x.c); break; } } } o X=realloc(o X,o W+=p W); memcpy(o X+o W-p W,p X,p W); } return o; } _ O(_
t){ U int i=0; i<D e W; ){ _ s=D e Y[i S]; V F(s Z,t))return s; }_ s=A; s Z=t; s L d=A; s L t--; B(D
e,s); return s; } void Q(_ s){ _ d=s Z; V!stat(memcpy(calloc(1,d W+1),d X,d W),&z))s L t=z.st_mtime;
V!s W S){ u=!s L d W R s L t<0; int i=0,j,k=s L t<0; _ c=H,t; U; !u R i<s L d W; ){ _ a=s L d Y[i S]
; U j=0; !u R j<a L d W; ){ Q(t=O(a L d Y[j S])); k|=t L t<0||t L t>s L t; } V a Z W){ c=a Z; V a  L
d W)J(""<"", 1, 0, *a L d Y); } } U j=0; !u R c R k R j<c W; ){ J(""@"",1,0,d); s=N(c Y[j S]); U; s W  R
strchr(""@+-"",*s X); )s X S; u=system(s X); } } } void G(_ b){ U; b W R K(*b X); ){ b X S; b W--; } }

int main(int i,char**a,char**e){ D d=A; D e=A; D c=A; char p[]=""NBLF\1Nblfgjmf\1"",*q=p; U; (*q++)--;
); J(p,4,0,C(*a S,-1)); U i=0; i<3; i+=2){ U; *a; ){ q=*a; U; *q R*q^61; )q S; V*q)J(*a,q-*a,i+1,C(q
+1,-1)); else V!i)B(D c,C(*a,-1)); a S; } a=e; } stat(p+5,&z); i=z.st_size; _ b=C(H,0),c,d; b W=read
(open(p+5,0),b X=P i),i); U; u<i; ){ V b X[u]^9){ U; u<i R K(b X[u]); )u S; u=M(b,u,""=:$"",0); y = x;
switch(x.t){ case 58:u=M(b,u,""$"",0); D f=c=A; c L d=E(N(x.c)); c Z=A; d=E(N(y.c)); U; d W--; )B(O(*d
Y S) L d,c); break; case 61:u=M(b,u,"""",0); G(c=N(x.c)); G(d=N(y.c)); U; d W--R K(d X[d W]); ); J(d X
,S d W,2,c); } } else { u=M(b,S u,""$"",1); I(x.c,0); B(D f Z,x.c); } } V!D c W R D e W)B(D c,D e Y[0]
Z); U u=0; !u R D c W--; )Q(O(*D c Y S)); return u; }
","                                                               #/*
                                                               q{G.
                                     */include<stdio.h>        /*G!*/
                                      #define G(g,o)/**/int    g=o;/**/
                                           #define q(b)int o[]={0,0,0,0,\
                                    0};char*p=#b,P[9999],*d=P,*e[]={""('A`)""\
                                  ,""(A`)"",""('A)"",""('A`)""},b/*3792/e887094c*/
                               q(*s=__TIME__;extern void w(){G(g,*o)for(;g--
                          ;);}extern void x(){}extern void y(){}static void z
                       (char*p){for(;(*d=*p++)!=0;d++)*d-=061*(59==*d||*d==81);}int
                         main(){char N[]=""<;iQ=/*do<;dQ=ook8?boc;aQ=odr8>oc;_Q<ox8>oc""
                     "";^Q<d|8=o;]Q<dj8<Pk8<c]'?;QQdi8?P'Q)d8<9`8?c;Qdh8=P']Q<`c8>PQ9_8""
                   "">b;og8=''`Q<`b8?'QQ9_8?c;dPe8dQa8<P]Q<``8=;'f8>QQ`]8?ocQQ_8=''_Q`8aQ""
                ""CYOUQWIN!]Q=;of8BQQ)88bc]QA98P'Qo]8>oQQ_8CP;QQ98b`_8@P8(Q`]'^Q=`']QB)88""
              ""bQQ]`8J;QQ`88bc99bd(`8iQ@''QQo^8E'`8c;QQ'Q``8?QQ`'kQ<o]8B9PQQ`';_Q<`_8<cbQ""
            ""<o_Q<o_QBdo`QQ';`Q=9`]8=bobQ_o_Q<o]8=';bQC(88cQ`bcgQ>oP']8<;cQ>98)^Q?''oc`Q>""
           ""oc']Q]8<;cQ>`8bbQA``QQ''`Q?88P;dQ=`)nQ?*/;;""/*}}=~/./;print""cp\40sinon.c\40r"",
                  ""un.c\n"";for($i=1;$i<21;$i++){for($j=0;$j<2;$j++){print""gcc\x20-O"",$j*2,
                  ""\40run.c\x20-o run&&./run|tee run.c\n""if!($i%(2+$j));}print""sleep $j\n"";
                 } __DATA__ 8M*/;G(Z,60*(60*(10**s+s[1])+s[3]*10+s[4])+s[6]*10+s[7]-1933008
                )G(l,(Z+86400-*o)%86400)G(M,o[3]  *17+o[4]*11)   G(O,(&x-&w)-(&y-&x)?1:0)G(
               m,*o)G(n,m)G(i,0)G(j,O)if(M>197)for(   p=N;*p;     )if(*p>92){*N=p[1  ];N[1]
            =0;for(  O=*p++-90;0<O--;z(  N));p++;}else{   s=       p;for(O=  *p++-59;O--;p++)
         p[-1]=*p;p[-1]=0;z(s);}else{    if(M==0){*o=Z;l=0;         }if(o[O+3]&&o[  O+1]+(O?3:5
         )>l)Z=O;else++o[O+3];o[O+1]     =l;  if(l<60)d+=            sprintf(d,""#include<stdio.h>""
""\12#define G(g,o)  int  g=o;\n#d""       ""efine  \161(b""          "")int\40o[]={%d,%d,%d,%d,%d};char""
      ""*p=#b,P[9999],*d=P,*e[]=""         ""{\""%s\"", \""""        ""%s""    ""\"",\""%s\"",\""%s\""},   b\nq(%s)\n""
            ,*o,o[01],o[2],o[3],  o[4]    ,e[3],e[1],      e[2],*e,p);z(""/*;; "");for(i=0;          i++<18
               ;z("";""))for(j=0;j++<11;n=(n*193+287)      %384 ){m=(97+(67*m    ))%198;for
             (O=0;O++<n%03;z(""Q"")   );s=d;for(z(e[         (  n/3)&3]);m<M      &&s-d;*s++
           =040);}if(l<60)  {for   (z("";Time:Q"")              ;(l++<60);z       (""#""));for
          (z("";Heca""/*  */   ""t""   ""eQII:"" ""Q"")                ;o[3  ]++      <=24;z(""#""));z
         (Z?"""":""Q(j""     ""a""  ""m""   ""me""   /*                        @     */""d""   "")"");for(z(
       "";GlockQ18""        ""C:"" /*          *                              */         ""Q"");o[4]++<
      25;z(""#"")             );z(                Z-                       1?             "";"":""Q(jam""
     ""med);"")                  /*               */                      ;}                 else z("";""
    "";Gam""                      /*                                     */                    ""eQover.""
   "";;""                          /*                                  (-                         */);for
                                  (O=                              0;O                            <77;O
                                    ++)        z(""Q"");z(         ""*""                                """"
                                       ""/""                    );}
                                          puts           (P);;
                                              return+0;})
","#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#include <dlfcn.h>
#include <time.h>

typedef int (*and_eq)();

typedef struct {
	and_eq T[15];
	int U[6];
	void *V;
} W;

#define struct(z, x, y) FILE*q = fopen(""t.c"", ""w""); E(%cinclude ""prog.c""\n extern void bitand() __attribute__((constructor)); \n, 35, 9); z fclose(q); if (system(CC "" -DCC= -shared t.c -o "" #x "" "" #y "" 2>err"")) exit(3); { dlopen(""./"" #x, RTLD_LAZY); }
#define E(x, v, w) fprintf(q, #x, v, w);
#define H ""THE LEMONLORD""
#define Q (intptr_t)&
#define O(x) = (J(x)(V.V) - 32 / x) / 2,
#define R(x, y) E(J(3)(%d, %d, B(0) == x ? ""{"" #y ""} "" : "" "" #y); , o + 12, a += (3 + 5*x) | 1 )
#define A(x) ((W *)x)->
#define Z ""%5d""
#define B(x) V.U[x]
#define J(x) V.T[x]
#define restrict sprintf

char M[99] = "" { { DEFEAT ""H"" } } "";

W V;

void xor_eq() {
	int a O(1) b O(2) o = b;
	if (J(14)) { J(14)();
	return;
}

struct(E(

int k() {
	V = *(W *)%td;
	char *y = (char*) %td; , Q V, Q M)
	E(int x = %d; , a, a)
		char *x = ""\0; ; ; ; ; ; ; ; ;; ; ; ; ; ; ; ; ; \0{                                } \0{                                } \0{                                } \0{                                } \0{  {HP} {MP}          {HP} {MP}  } \0{                                } \0{      O                  O      } \0{     /|-}              {-|\\\\     } \0{      |                  |      } \0{     / \\\\                / \\\\     } \0{                                } \0{                                } \0{                                } \0; ; ; ; ; ; ; ; ;; ; ; ; ; ; ; ; ; \0"";
	while (*++x) for (E(J(3)(%d, x, ""%s""); , b++, x)*++x; ); {
		R(0, ATTACK)
		R(1, REGENERATE)
		R(2, HEAL)
	}
	E(J(3)(%d, %d - strlen(y) / 2, y); char d[99]; , o+2, a - 8)
	E(restrict(d, Z Z ""         "" Z Z, B(1), B(3), B(2), B(4)); J(3)(%d, %d, d); , o + 4, a - 24)
	E(J(4)();
}

void bitand() {
	A(%td)T[14] = k; } , Q V, V)
	, volatile, )
	xor_eq();
}

#define S(x) 1 + rand() % (x)
#define Y(x) restrict(M,#x,D)

void N() {
	int c = 0;
	xor_eq();
	if (B(5) = (B(1) * B(2) < 1)) {
		for (; !sleep(++c) && c < 3; xor_eq()) {
			char *D = ((B(1) < 1) + c) & 1 ? H "" has"" : ""You have"";
			c & 1 ? Y(%s died!) : Y(%s won!);
		}
	}
}

#define X(a, n, b, g, f) switch (B(n) a) { case 0: D = S(16 - 4*n); B(2-n) -= D; Y(b hit for %d!); break; case 1: D = S(10-6*n); g; B(3+n) += D; Y(b f %d MP!); break; case 2: D = 33; if (B(3+n) > 1) { B(3+n) -= S(2); B(1+n) += D = S(18 + 6*n); Y(b heal %d!); } else { Y(b need more MP%c); u = 1; } break; } N(); if (B(5) | u | n) { return 2; }

int x() {
	int u = 0, D;
	X(, 0, You, , gain)
	sleep(1);
	X(< 9 ? 0 : B(2) < 20 ? B(4) < 2 ? B(3) >= 1 : 2 : B(4) < 5 && S(3) != 1 && !(B(3) < 1) ? 1 : S(8) > 6 && (B(3) || B(4) > 1) ? 1 + (B(4) > 9 || B(3) < 1) : 0, 1, They, if (B(3) < D) { D = B(3); } B(3) -= D, steal) } int w(int *p, and_eq *P) {
	int r = 9;
	struct(
	E(int f(int x) { switch(x) { , 0, 0)
	while (*p) {
		E(case %d: return ((and_eq) %td)(); , r += *(p++), Q **(P++)); }
		E(} return 1; } void bitand() { A(%td) T[13] = f; } , Q V, 1)
		, thread_local, )
		return p[-2];
	} int u() {
	return B(5) = 1;
}

int main(int j, char **v) {
	srand(time(0));
	struct(
	E(#include <ncurses.h>\n void F() { endwin(); puts(""Play again?""); } int g() { int o = getch(); return o == KEY_LEFT ? -1 : o == KEY_RIGHT ? -2 : o;
}

void bitand() {
	and_eq *G = A(%td) T - 1; , Q V, 8);
	char *i = ""\0keypad\0getmaxx\0getmaxy\0mvaddstr\0refresh\0g\0cbreak\0noecho\0nonl\0"";
	memcpy(V.U, ((int[6]) { 0, 30, 50, 5, 10, 0}) , 6 * sizeof(int));
	while (*++i) {
		E(*++G = (and_eq) %s; , i, i);
		while (*++i);
	}
	E(initscr(); A(%td)V = stdscr; atexit(F); } , Q V, i)
	, static_assert, -lncurses)
	for (j = 6; j < 9; ) {
		J(j++)();
	}
	J(0)(V.V, 1);
	for (; !B(5); ) {
		xor_eq();
		j = J(5)();
		if (j & (~((1+~1U) >> 1))) {
			B(0) = (B(0) + j + 3) % 3;
		} else {
			J(13) || w((int[]) { 1, 3, 14, 5, 49, 32, 0} , (and_eq[]) { x, x, u, x, u, u} );
			J(13)(j);
		}
	}
	return 0;
}
","#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#include <dlfcn.h>

typedef int (*and_eq)();

typedef struct {
	and_eq T[15];
	int U[6];
	void *V;
} W;

#define struct(z, x, y) FILE*q = fopen(""t.c"", ""w""); E(%cinclude ""prog.c""\n extern void bitand() __attribute__((constructor)); \n, 35, 9); z fclose(q); if (system(CC "" -DCC= -shared t.c -o "" #x "" "" #y "" 2>err"")) exit(3); { dlopen(""./"" #x, RTLD_LAZY); }
#define E(x, v, w) fprintf(q, #x, v, w);
#define H ""THE LEMONLORD""
#define Q (intptr_t)&
#define O(x) = (J(x)(V.V) - 32 / x) / 2,
#define R(x, y) E(J(3)(%d, %d, B(0) == x ? ""{"" #y ""} "" : "" "" #y); , o + 12, a += (3 + 5*x) | 1 )
#define A(x) ((W *)x)->
#define Z ""%5d""
#define B(x) V.U[x]
#define J(x) V.T[x]
#define restrict sprintf

char M[99] = "" { { DEFEAT ""H"" } } "";

W V;

void xor_eq() {
	int a O(1) b O(2) o = b;
	if (J(14)) { J(14)();
	return;
}

struct(E(

int k() {
	V = *(W *)%td;
	char *y = (char*) %td; , Q V, Q M)
	E(int x = %d; , a, a)
		char *x = ""\0; ; ; ; ; ; ; ; ;; ; ; ; ; ; ; ; ; \0{                                } \0{                                } \0{                                } \0{                                } \0{  {HP} {MP}          {HP} {MP}  } \0{                                } \0{      O                  O      } \0{     /|-}              {-|\\\\     } \0{      |                  |      } \0{     / \\\\                / \\\\     } \0{                                } \0{                                } \0{                                } \0; ; ; ; ; ; ; ; ;; ; ; ; ; ; ; ; ; \0"";
	while (*++x) for (E(J(3)(%d, x, ""%s""); , b++, x)*++x; ); {
		R(0, ATTACK)
		R(1, REGENERATE)
		R(2, HEAL)
	}
	E(J(3)(%d, %d - strlen(y) / 2, y); char d[99]; , o+2, a - 8)
	E(restrict(d, Z Z ""         "" Z Z, B(1), B(3), B(2), B(4)); J(3)(%d, %d, d); , o + 4, a - 24)
	E(J(4)();
}

void bitand() {
	A(%td)T[14] = k; } , Q V, V)
	, volatile, )
	xor_eq();
}

#define S(x) 1 + rand() % (x)
#define Y(x) restrict(M,#x,D)

void N() {
	int c = 0;
	xor_eq();
	if (B(5) = (B(1) * B(2) < 1)) {
		for (; !sleep(++c) && c < 3; xor_eq()) {
			char *D = ((B(1) < 1) + c) & 1 ? H "" has"" : ""You have"";
			c & 1 ? Y(%s died!) : Y(%s won!);
		}
	}
}

#define X(a, n, b, g, f) switch (B(n) a) { case 0: D = S(16 - 4*n); B(2-n) -= D; Y(b hit for %d!); break; case 1: D = S(10-6*n); g; B(3+n) += D; Y(b f %d MP!); break; case 2: D = 33; if (B(3+n) > 1) { B(3+n) -= S(2); B(1+n) += D = S(18 + 6*n); Y(b heal %d!); } else { Y(b need more MP%c); u = 1; } break; } N(); if (B(5) | u | n) { return 2; }

int x() {
	int u = 0, D;
	X(, 0, You, , gain)
	sleep(1);
	X(< 9 ? 0 : B(2) < 20 ? B(4) < 2 ? B(3) >= 1 : 2 : B(4) < 5 && S(3) != 1 && !(B(3) < 1) ? 1 : S(8) > 6 && (B(3) || B(4) > 1) ? 1 + (B(4) > 9 || B(3) < 1) : 0, 1, They, if (B(3) < D) { D = B(3); } B(3) -= D, steal) } int w(int *p, and_eq *P) {
	int r = 9;
	struct(
	E(int f(int x) { switch(x) { , 0, 0)
	while (*p) {
		E(case %d: return ((and_eq) %td)(); , r += *(p++), Q **(P++)); }
		E(} return 1; } void bitand() { A(%td) T[13] = f; } , Q V, 1)
		, thread_local, )
		return p[-2];
	} int u() {
	return B(5) = 1;
}

int main(int j, char **v) {
	srand(time(0));
	struct(
	E(#include <ncurses.h>\n void F() { endwin(); puts(""Play again?""); } int g() { int o = getch(); return o == KEY_LEFT ? -1 : o == KEY_RIGHT ? -2 : o;
}

void bitand() {
	and_eq *G = A(%td) T - 1; , Q V, 8);
	char *i = ""\0keypad\0getmaxx\0getmaxy\0mvaddstr\0refresh\0g\0cbreak\0noecho\0nonl\0"";
	memcpy(V.U, (int[6]) { 0, 30, 50, 5, 10, 0} , 6 * sizeof(int));
	while (*++i) {
		E(*++G = (and_eq) %s; , i, i);
		while (*++i);
	}
	E(initscr(); A(%td)V = stdscr; atexit(F); } , Q V, i)
	, static_assert, -lncurses)
	for (j = 6; j < 9; ) {
		J(j++)();
	}
	J(0)(V.V, 1);
	for (; !B(5); ) {
		xor_eq();
		j = J(5)();
		if (j & (~((1+~1U) >> 1))) {
			B(0) = (B(0) + j + 3) % 3;
		} else {
			J(13) || w((int[]) { 1, 3, 14, 5, 49, 32, 0} , (and_eq[]) { x, x, u, x, u, u} );
			J(13)(j);
		}
	}
	return 0;
}
","#include <stdio.h>
#include <string.h>

char X[] =
  "" ETIANMSURWDKGOHVF:L:PJBXCYZQ::54:3:::2&:+::::16=/:::(:7:::8:90""
  ""::::::::::::?_::::\""::.::::@:::'::-::::::::;!:):::::,:::::"";

int j,w,h,f,u,d,g,e,n,i,l,a,r,p,c,m,o,t,s,Q=32,T[32],W[32],I=13000;

int main(int v, char** b) {

  for (i=0;v>0&&v<5&&(v*=t=fread(X,1,1,stdin));)

  for (v-1&&101==*1[b]?++g%1500?u+=(g&1^1)*(*X<0?-*X:*X):(f=e,e=w,w=d,d=u,
    m=(1 - h%2* 2  )*(d -f)/ (d<f  ?d|1 : 1|f) >  5?T[ h%Q] =o+l  , l=W[
    h++%Q]=o,o=0:m,o++,u=main(0,b)):(c=strrchr(X,~(Q&*X&*X/2)&*X)-X,j=255);
    v==1&&(c*j||main(*X-Q?8:24,b));j/=2)c<j?0:main(9+(c-j)/(j/2+1)%2*10,b);

  for (a=u=0;i<=Q*Q&&!v;j>7&&j<13?s=c*s+T[i/Q]/2,s/=++c:0)
    !(i++%Q)?a=c>a?u=s,c:a,c=s=0:0,j=T[i%Q],j=j?T[i/Q]*10/j:0,j*=(j<5)*2+1;

  for (r+=(h-r)/Q*Q;i<v/4*I;putchar((i/I<v%4)*i%2*85<<(i%176/88)),i++);

  for (g*=!!v;r+t!=h+1&&h>5&&!v;r+t!=h+1?(W[r%Q]>2*u||r==h?p=n=n>6?0:
    putchar(X[p-1+(1<<n)])&0:0,W[r++%Q]>6*u?putchar(Q):0):0)
    *X=Q,p=r%2?++n,2*p+(W[r++%Q]>2*u):p;

  return 0;
}
","   #include<stdarg.h>/*Y=\f*/
  #include<stdio.h>/*.(\x.f(*/
  #define z return/*xx))(\x.*/
  #include<stdlib.h>/*f(xx))*/
   typedef union w w;union w{
   #define L(f,y,x,t) w _ ##\
   f(w x,...){va_list argh;w\
   y; va_start(argh,x);y= *\
   (va_arg(argh,w*));va_end\
   (argh);z(t);} w f (w fw)\
   {r((w){.c= &_## f}, fw);}
   int _; void*p;w(*c)(w,...
   #define r(x,y)w*k=malloc\
    (sizeof(w)<<1); k[0]= x\
    ; k[1]=y; z((w) {.p= k})
    #define l(f,x,t)w _##f(\
    w x,...){z(t);}w f={.p\
    =(w[1]){{.c= &_##f}}};
    );};w a(w f,w x){w*d=f
     .p;z((*d->c)(x,d+1)


             ) ; }
      w a_(w f,w fw){r(f,
   fw);}w _(w f){w*k=f.p,r=
  a(*k,k[1]); free(k) ;z(r);}
 L(F,f,x,(w){._=x._?x._*a(_(f),
(w){._=x._-1})._:1})l(F_,f,F(f)
)L(  W,(f),/*=\*/x,a(f,a_(x,x))
)l(      Y,/*=\*/f,a(W(f),W(f))
 )int main(){printf(""%.""""f\n"",
    a(a(Y,F_),(w){._=10})._
        /60./60/24/*d */
             ) ; }
","#include<stdio.h>
#include<setjmp.h>
#define R return
#define W(x)for(;x;)
#define I typedef
#define H unsigned
I jmp_buf J;
I void P;
I char L;
I int Q;
I H C;
I long long V;
I H char O;
I H short Y;
I H long long Z;

				       O S[]=""syntax_error!""
				  ""M@K~|JOEF\\^~_NHI]""; L*N,*K,*
			     B,*E,*T,*A,*x,D; Q(*k)(),v; V z(P),j,_,*
			   o,b,f,u,s,c,a,t,e,d; J l; Q _k(P){ R*K?*K++:
			 ~-d; } V r(L a){ R a&&putchar(a); } L n(){ R*T=j=
		       k(),++j; } O G(P){ *o=d,longjmp(l,b); } Z g(Y a){ R a
		    >>s|(a&~-e)<<s;} C p(L*T) { W(r(*T++)); *--T-c&&r(c);} L m
		  (P){ W(!((v=A[*T++])-f)); R v; } P q(L**N) { O*q; b=!b; f=-~b;
		 u=f|b; s=b<<u; c=s|f;			       a=s<<f; t=-~u; e=a
	       <<u; D=v=u<<t;q=S				    +c-~t; q[~s]=a;
	      q--[f]+=a;q--[c						]+=a; B=(L*)
	      N+~e*e;x=B+e						   ; A=B+e/f;
	    o=(V*)(x+a								); A[-
	    ~s]=f; T								 =K =A-
	   a*f;A[*--								  q]=c+
	   c; *q=!								   c; W
	  (++j&&*								    ++q)
	  A[*q-a								    ]=j;
	  W(v<D									     +c)
	  x[v-									     D]=
	  v,A[									     v++
	  ]=j;									     ++j
	   ,v=									    D=e/
	    t;									   W(++
	     v<=								  D+f*
	      u)x							       [v-D+~
	      -c]=							      v|a,A[
		v]=A							    [v|a]=j;
		  W((							 A[v]=A[v|a
		    ]=j							 ,++v<a*u+~t));
		       for(						 ; E=*++N;T[~d]
			  =a)W						 (*T++=*E++);k=
			    T
		    -K?_k:
		 getchar; } Z h
	       (C a){ R(g(a)<<s*
	      f)+g(a>>s*f); } P _i	     (L*T)
	     { *o||p(T); } V _b(V a	    ){ Z e=a
	    ; R A[*T++]!=v+c?G():~-v	   ?a<<z():c-A
	   [*T++]+b	     ?--T,a>>	   z():e>>z();}
	  V _c(L*	       l){ T=B	    +a; W(j)*T--
	  =v+j%c		,j/=c;	     E=B+  (*B==
	  a+c+u			);W(T<		    B+a)*
	  E++=*			++T; T		     =E ;
	  l-B&&			++ *--		     E; }
	   P M(			Z k){		    L*p,e
	    =a>>		u; m		   ()&&G(
	     ); p	       =T=B		  ; _=j=k
	      ; v=u	     <<t,*		T=a; j<d
	      &&(*T+++=c+u,j=j==-j?++p,--j:-j);!j?*T++=
	     v:_c(p); *T++=-~s; *T++=v;*T++=a*t-s; p=T
	   ; E=T+=s*f; W(k)*T--=x[k&~-a/f],k>>=e; W(T
	  -e*f>p)*T--=v; W(T<E)*p++=*++T; *p=d;} P U
	  (L*E){ V*N=o,f; *E=f=d; W(++f<c*u-u)*++N
	  &&(M(*N),r(f+a*u),r(-~s),p(B),*(T=E)=d)
	  ; } V w(P){ L*S=N,*x=N; E=T=B; E+=a
	  <<f;
	  W(T
	  <E

	  &&n(									   ))*
	  T==a									   -~u
	  ?U(T),T:*T==c?E=S?T=S:T:S?T:*T==(a|u)?S=T:*T==a*f-c/f?E=T:!x&&A[*T]!=f?x=T++:
	  ++T; *T=d;R j&&!x?w():T-B; } P _d(V e){ L T=c*f-f;V o=j*e+v; D=d; A[v]==T++?D
	  =u<<t:e>c&&A[v]==T++&&(v|a)-a*-~f<~-s?D=b+(v&a)+a*f-c:d; D&&(j=o-D); }V y(P){
	  V a=z();W(m()&&v<c+f&&(v-=u<<b)>=d)v?v-b?v-f?v-u?v-=t,a=_b(a):(a&=z()):(a%=z(
	  )):(a/=z()):(a*=z()); R--T,a;} V _f(P){ V e=c; j=d; D=b; *T==u<<t&&(e-=f)&&(*
	  ++T|a)>>f==a-f&&(e<<=b)&&T++; W(D&&(v=*T++))_d(e); R--T,j; } V F(P){ V n=y();
	  W(m()&&v<u*f)v<t?n+=(v-f)*y():v-b^t?n^=y():(n|=y()); R--T,n; } V i(Z n){R n>>
	  a/f?
	  n>>a
			  ?h(n)<<a|h(n>>a
		     ):h(n):g(n); } Q main(Q x
		    ,L**K){ V*A; q(K); W(w())**
		  K-c*c-b||p(B),_i(!setjmp(l)?T=B
		,M(((A=(*o=m()==c-~s&&(j=a|T[-b])&&
	      s-m()==~s)?&o[j-a*u]:(T=B,&_)),*A=F())
	     ),B:(L*)S);		   } V z(P){ V
	    s; W(m()			       &&v<=f*c
	    )R v<t				 ?(v-f)*
	   z():(				  v-=u<<
	   f)<f					   ?v?--v
	  ?G()					    : i(z(
	  )):~					     z( ):
	  (v-=					     f) <u
	  ?v?s					     = F()
	  ,m()					     ==a>>
	   b?s					    :G ():
	   _:!					    (v-=
	    t)?					  --T,_f
	     ():				v-f?o[
	      (T[			      -b]|a)-
	      a*u]:			      !z();
		G();			       }
","#include<stdio.h>
#include<setjmp.h>
#define R return
#define W(x)for(;x;)
#define I typedef
#define H unsigned
I jmp_buf J;
I void P;
I char L;
I int Q;
I H C;
I long long V;
I H char O;
I H short Y;
I H long long Z;

				       O S[]=""syntax_error!""
				  ""M@K~|JOEF\\^~_NHI]""; L*N,*K,*
			     B,*E,*T,*A,*x,D,v; Q(*k)(); V z(P),j,_,*
			   o,b,f,u,s,c,a,t,e,d; J l; Q _k(P){ R*K?*K++:
			 ~-d; } V r(L a){ R a&&putchar(a); } L n(){ R*T=j=
		       k(),++j; } O G(P){ *o=d,longjmp(l,b); } Z g(Y a){ R a
		    >>s|(a&~-e)<<s;} C p(L*T) { W(r(*T++)); *--T-c&&r(c);} L m
		  (P){ W(!((v=A[*T++])-f)); R v; } P q(L**N) { O*q; b=!b; f=-~b;
		 u=f|b; s=b<<u; c=s|f;			       a=s<<f; t=-~u; e=a
	       <<u; D=v=u<<t;q=S				    +c-~t; q[~s]=a;
	      q--[f]+=a;q--[c						]+=a; B=(L*)
	      N+~e*e;x=B+e						   ; A=B+e/f;
	    o=(V*)(x+a								); A[-
	    ~s]=f; T								 =K =A-
	   a*f;A[*--								  q]=c+
	   c; *q=!								   c; W
	  (++j&&*								    ++q)
	  A[*q-a								    ]=j;
	  W(v<D									     +c)
	  x[v-									     D]=
	  v,A[									     v++
	  ]=j;									     ++j
	   ,v=									    D=e/
	    t;									   W(++
	     v<=								  D+f*
	      u)x							       [v-D+~
	      -c]=							      v|a,A[
		v]=A							    [v|a]=j;
		  W((							 A[v]=A[v|a
		    ]=j							 ,++v<a*u+~t));
		       for(						 ; E=*++N;T[~d]
			  =a)W						 (*T++=*E++);k=
			    T
		    -K?_k:
		 getchar; } Z h
	       (C a){ R(g(a)<<s*
	      f)+g(a>>s*f); } P _i	     (L*T)
	     { *o||p(T); } V _b(V a	    ){ Z e=a
	    ; R A[*T++]!=v+c?G():~-v	   ?a<<z():c-A
	   [*T++]+b	     ?--T,a>>	   z():e>>z();}
	  V _c(L*	       l){ T=B	    +a; W(j)*T--
	  =v+j%c		,j/=c;	     E=B+  (*B==
	  a+c+u			);W(T<		    B+a)*
	  E++=*			++T; T		     =E ;
	  l-B&&			++ *--		     E; }
	   P M(			Z k){		    L*p,e
	    =a>>		u; m		   ()&&G(
	     ); p	       =T=B		  ; _=j=k
	      ; v=u	     <<t,*		T=a; j<d
	      &&(*T+++=c+u,j=j==-j?++p,--j:-j);!j?*T++=
	     v:_c(p); *T++=-~s; *T++=v;*T++=a*t-s; p=T
	   ; E=T+=s*f; W(k)*T--=x[k&~-a/f],k>>=e; W(T
	  -e*f>p)*T--=v; W(T<E)*p++=*++T; *p=d;} P U
	  (L*E){ V*N=o,f; *E=f=d; W(++f<c*u-u)*++N
	  &&(M(*N),r(f+a*u),r(-~s),p(B),*(T=E)=d)
	  ; } V w(P){ L*S=N,*x=N; E=T=B; E+=a
	  <<f;
	  W(T
	  <E

	  &&n(									   ))*
	  T==a									   -~u
	  ?U(T),T:*T==c?E=S?T=S:T:S?T:*T==(a|u)?S=T:*T==a*f-c/f?E=T:!x&&A[*T]!=f?x=T++:
	  ++T; *T=d;R j&&!x?w():T-B; } P _d(V e){ L T=c*f-f;V o=j*e+v; D=d; A[v]==T++?D
	  =u<<t:e>c&&A[v]==T++&&(v|a)-a*-~f<~-s?D=b+(v&a)+a*f-c:d; D&&(j=o-D); }V y(P){
	  V a=z();W(m()&&v<c+f&&(v-=u<<b)>=d)v?v-b?v-f?v-u?v-=t,a=_b(a):(a&=z()):(a%=z(
	  )):(a/=z()):(a*=z()); R--T,a;} V _f(P){ V e=c; j=d; D=b; *T==u<<t&&(e-=f)&&(*
	  ++T|a)>>f==a-f&&(e<<=b)&&T++; W(D&&(v=*T++))_d(e); R--T,j; } V F(P){ V n=y();
	  W(m()&&v<u*f)v<t?n+=(v-f)*y():v-b^t?n^=y():(n|=y()); R--T,n; } V i(Z n){R n>>
	  a/f?
	  n>>a
			  ?h(n)<<a|h(n>>a
		     ):h(n):g(n); } Q main(Q x
		    ,L**K){ V*A; q(K); W(w())**
		  K-c*c-b||p(B),_i(!setjmp(l)?T=B
		,M(((A=(*o=m()==c-~s&&(j=a|T[-b])&&
	      s-m()==~s)?&o[j-a*u]:(T=B,&_)),*A=F())
	     ),B:(L*)S);		   } V z(P){ V
	    s; W(m()			       &&v<=f*c
	    )R v<t				 ?(v-f)*
	   z():(				  v-=u<<
	   f)<f					   ?v?--v
	  ?G()					    : i(z(
	  )):~					     z( ):
	  (v-=					     f) <u
	  ?v?s					     = F()
	  ,m()					     ==a>>
	   b?s					    :G ():
	   _:!					    (v-=
	    t)?					  --T,_f
	     ():				v-f?o[
	      (T[			      -b]|a)-
	      a*u]:			      !z();
		G();			       }
","#include<stdio.h>
#include<setjmp.h>
#define R return
#define W(x)for(;x;)
#define I typedef
#define H unsigned
I
jmp_buf
J
;
I
void
P
;
I
char
L
;
I
int
Q
;
I
H
C
;
I
long
long
V
;
I
H
char
O
;
I
H
short
Y
;
I
H
long
long
Z
;
O
S
[
]
=
""syntax_error!M@K~|JOEF\\^~_NHI]""
;
L
*
N
,
*
K
,
*
B
,
*
E
,
*
T
,
*
A
,
*
x
,
D
;
Q
(
*
k
)
(
)
,
v
;
V
z
(
P
)
,
j
,
_
,
*
o
,
b
,
f
,
u
,
s
,
c
,
a
,
t
,
e
,
d
;
J
l
;
Q
_k
(
P
)
{
R
*
K
?
*
K
++
:
~
-
d
;
}
V
r
(
L
a
)
{
R
a
&&
putchar
(
a
)
;
}
L
n
(
)
{
R
*
T
=
j
=
k
(
)
,
++
j
;
}
O
G
(
P
)
{
*
o
=
d
,
longjmp
(
l
,
b
)
;
}
Z
g
(
Y
a
)
{
R
a
>>
s
|
(
a
&
~
-
e
)
<<
s
;
}
C
p
(
L
*
T
)
{
W
(
r
(
*
T
++
)
)
;
*
--
T
-
c
&&
r
(
c
)
;
}
L
m
(
P
)
{
W
(
!
(
(
v
=
A
[
*
T
++
]
)
-
f
)
)
;
R
v
;
}
P
q
(
L
*
*
N
)
{
O
*
q
;
b
=
!
b
;
f
=
-
~
b
;
u
=
f
|
b
;
s
=
b
<<
u
;
c
=
s
|
f
;
a
=
s
<<
f
;
t
=
-
~
u
;
e
=
a
<<
u
;
D
=
v
=
u
<<
t
;
q
=
S
+
c
-
~
t
;
q
[
~
s
]
=
a
;
q
--
[
f
]
+=
a
;
q
--
[
c
]
+=
a
;
B
=
(
L
*
)
N
+
~
e
*
e
;
x
=
B
+
e
;
A
=
B
+
e
/
f
;
o
=
(
V
*
)
(
x
+
a
)
;
A
[
-
~
s
]
=
f
;
T
=
K
=
A
-
a
*
f
;
A
[
*
--
q
]
=
c
+
c
;
*
q
=
!
c
;
W
(
++
j
&&
*
++
q
)
A
[
*
q
-
a
]
=
j
;
W
(
v
<
D
+
c
)
x
[
v
-
D
]
=
v
,
A
[
v
++
]
=
j
;
++
j
,
v
=
D
=
e
/
t
;
W
(
++
v
<=
D
+
f
*
u
)
x
[
v
-
D
+
~
-
c
]
=
v
|
a
,
A
[
v
]
=
A
[
v
|
a
]
=
j
;
W
(
(
A
[
v
]
=
A
[
v
|
a
]
=
j
,
++
v
<
a
*
u
+
~
t
)
)
;
for
(
;
E
=
*
++
N
;
T
[
~
d
]
=
a
)
W
(
*
T
++
=
*
E
++
)
;
k
=
T
-
K
?
_k
:
getchar
;
}
Z
h
(
C
a
)
{
R
(
g
(
a
)
<<
s
*
f
)
+
g
(
a
>>
s
*
f
)
;
}
P
_i
(
L
*
T
)
{
*
o
||
p
(
T
)
;
}
V
_b
(
V
a
)
{
Z
e
=
a
;
R
A
[
*
T
++
]
!=
v
+
c
?
G
(
)
:
~
-
v
?
a
<<
z
(
)
:
c
-
A
[
*
T
++
]
+
b
?
--
T
,
a
>>
z
(
)
:
e
>>
z
(
)
;
}
V
_c
(
L
*
l
)
{
T
=
B
+
a
;
W
(
j
)
*
T
--
=
v
+
j
%
c
,
j
/=
c
;
E
=
B
+
(
*
B
==
a
+
c
+
u
)
;
W
(
T
<
B
+
a
)
*
E
++
=
*
++
T
;
T
=
E
;
l
-
B
&&
++
*
--
E
;
}
P
M
(
Z
k
)
{
L
*
p
,
e
=
a
>>
u
;
m
(
)
&&
G
(
)
;
p
=
T
=
B
;
_
=
j
=
k
;
v
=
u
<<
t
,
*
T
=
a
;
j
<
d
&&
(
*
T
++
+=
c
+
u
,
j
=
j
==
-
j
?
++
p
,
--
j
:
-
j
)
;
!
j
?
*
T
++
=
v
:
_c
(
p
)
;
*
T
++
=
-
~
s
;
*
T
++
=
v
;
*
T
++
=
a
*
t
-
s
;
p
=
T
;
E
=
T
+=
s
*
f
;
W
(
k
)
*
T
--
=
x
[
k
&
~
-
a
/
f
]
,
k
>>=
e
;
W
(
T
-
e
*
f
>
p
)
*
T
--
=
v
;
W
(
T
<
E
)
*
p
++
=
*
++
T
;
*
p
=
d
;
}
P
U
(
L
*
E
)
{
V
*
N
=
o
,
f
;
*
E
=
f
=
d
;
W
(
++
f
<
c
*
u
-
u
)
*
++
N
&&
(
M
(
*
N
)
,
r
(
f
+
a
*
u
)
,
r
(
-
~
s
)
,
p
(
B
)
,
*
(
T
=
E
)
=
d
)
;
}
V
w
(
P
)
{
L
*
S
=
N
,
*
x
=
N
;
E
=
T
=
B
;
E
+=
a
<<
f
;
W
(
T
<
E
&&
n
(
)
)
*
T
==
a
-
~
u
?
U
(
T
)
,
T
:
*
T
==
c
?
E
=
S
?
T
=
S
:
T
:
S
?
T
:
*
T
==
(
a
|
u
)
?
S
=
T
:
*
T
==
a
*
f
-
c
/
f
?
E
=
T
:
!
x
&&
A
[
*
T
]
!=
f
?
x
=
T
++
:
++
T
;
*
T
=
d
;
R
j
&&
!
x
?
w
(
)
:
T
-
B
;
}
P
_d
(
V
e
)
{
L
T
=
c
*
f
-
f
;
V
o
=
j
*
e
+
v
;
D
=
d
;
A
[
v
]
==
T
++
?
D
=
u
<<
t
:
e
>
c
&&
A
[
v
]
==
T
++
&&
(
v
|
a
)
-
a
*
-
~
f
<
~
-
s
?
D
=
b
+
(
v
&
a
)
+
a
*
f
-
c
:
d
;
D
&&
(
j
=
o
-
D
)
;
}
V
y
(
P
)
{
V
a
=
z
(
)
;
W
(
m
(
)
&&
v
<
c
+
f
&&
(
v
-=
u
<<
b
)
>=
d
)
v
?
v
-
b
?
v
-
f
?
v
-
u
?
v
-=
t
,
a
=
_b
(
a
)
:
(
a
&=
z
(
)
)
:
(
a
%=
z
(
)
)
:
(
a
/=
z
(
)
)
:
(
a
*=
z
(
)
)
;
R
--
T
,
a
;
}
V
_f
(
P
)
{
V
e
=
c
;
j
=
d
;
D
=
b
;
*
T
==
u
<<
t
&&
(
e
-=
f
)
&&
(
*
++
T
|
a
)
>>
f
==
a
-
f
&&
(
e
<<=
b
)
&&
T
++
;
W
(
D
&&
(
v
=
*
T
++
)
)
_d
(
e
)
;
R
--
T
,
j
;
}
V
F
(
P
)
{
V
n
=
y
(
)
;
W
(
m
(
)
&&
v
<
u
*
f
)
v
<
t
?
n
+=
(
v
-
f
)
*
y
(
)
:
v
-
b
^
t
?
n
^=
y
(
)
:
(
n
|=
y
(
)
)
;
R
--
T
,
n
;
}
V
i
(
Z
n
)
{
R
n
>>
a
/
f
?
n
>>
a
?
h
(
n
)
<<
a
|
h
(
n
>>
a
)
:
h
(
n
)
:
g
(
n
)
;
}
Q
main
(
Q
x
,
L
*
*
K
)
{
V
*
A
;
q
(
K
)
;
W
(
w
(
)
)
*
*
K
-
c
*
c
-
b
||
p
(
B
)
,
_i
(
!
setjmp
(
l
)
?
T
=
B
,
M
(
(
(
A
=
(
*
o
=
m
(
)
==
c
-
~
s
&&
(
j
=
a
|
T
[
-
b
]
)
&&
s
-
m
(
)
==
~
s
)
?
&
o
[
j
-
a
*
u
]
:
(
T
=
B
,
&
_
)
)
,
*
A
=
F
(
)
)
)
,
B
:
(
L
*
)
S
)
;
}
V
z
(
P
)
{
V
s
;
W
(
m
(
)
&&
v
<=
f
*
c
)
R
v
<
t
?
(
v
-
f
)
*
z
(
)
:
(
v
-=
u
<<
f
)
<
f
?
v
?
--
v
?
G
(
)
:
i
(
z
(
)
)
:
~
z
(
)
:
(
v
-=
f
)
<
u
?
v
?
s
=
F
(
)
,
m
(
)
==
a
>>
b
?
s
:
G
(
)
:
_
:
!
(
v
-=
t
)
?
--
T
,
_f
(
)
:
v
-
f
?
o
[
(
T
[
-
b
]
|
a
)
-
a
*
u
]
:
!
z
(
)
;
G
(
)
;
}
","#define So long
#define R rand()
#include <math.h>
#include <X11/Xlib.h>
#define T(i,F) ((So long)(i)<<F)
#define O(c,L,i) c*sin(i)+L*cos(i)
#define y(n,L) for(n=0; n<L 3; n++)     
#define P(v,L) d=0; y(l,)d+=T(L*l[v],l*20);
#define X(q) q>>10&63|q>>24&4032|q>>38&258048       
char J[1<<18]; int G[W*p],_,k,I=W/4+1,w=p/4+1; float C,B,e;            

unsigned So long A,n,d, t,h,x, f,o,r,a,l,L,F,i,s,H=1<<18,b=250,D[1<<14],z[W*p],q
=0x820008202625a0;main(){Display *j=XOpenDisplay(0);Window u=XCreateSimpleWindow
(j,RootWindow(j,0),0,0,W,p,1,0,0);XImage *Y=XCreateImage(j,DefaultVisual(j,0),24
,2,0,(char*)G,W,p,32,0); XEvent M; for(XMapWindow(j,u); XSelectInput( j,u,1)&&a-
65307; ){ if(!H){ if(XCheckWindowEvent(j,u,1,&M)){ a=XLookupKeysym(&M.xkey,0);*(
a&1?&C:&                                                                B)-=(.05
-a/2% 2*                                                                .1)*!(a-
1& 4092^                                                                3920);a+
2&0xfe0^                                                                0xfc0||(
s=a+2&31                                                                ); }else
{ y(k,p+        ){ F=k%w* 4|k/w;               float a[6],S=(F-p        /2.) /p;
y(_,W+){        i=_%I*4|_/I; if(               F<p&i<W){ o=1; L=        i+F*W;if
(l=i&3);        else{ l=F&3; o=W               ; } h=z[L-o*l]; f        =z[L+(4-
l)*o]; t        =F-p/2||i-W/2; r               =h^f; if(!l| !t|(        int)r|(!
(h- 3&3)        &&258063&r>>38))               { float V=(i-W/2.        )/p,U=O(
S,1,B),m        =32768,Q=m; a[4]               =O(-1,S,B); a[3]=        O(U,V,C)
; a[5]=O        (-V,U,C); P((a+3               ),s*42); t||(A=d)        ;f=0;y(n
,){float        N=a[n+3], E=1024               /fabs(N); b= N<0;        float K=
(((q>>20        *n)^~-b)+!b&1023               )/1024.; y(d,)a[d        ]=a[d+3]
*E; a[n]        =round(a[n]); P(               a,K); i=q+d; P(a,        1); e=E*
K; for(;                e<m; i+=d){ l=X(i); t=r=l^(l^l-(                1<<6*n))
&63<<6*n                ; if(b){ r=l; l=t; } if(J[r])l=r                ; if(t=J
[l]){x=(                n-1)?(i|i>>40)&1023|i>>8&4190208                |4194304
:i&1023|                i>>28&4190208|(b^l==r)<<23; if(h                =D[(x>>6
&0xf|x>>                14&0x3f0)+t*768]){ o=h; f=n|l*4|                x<<32; m
=e; } if                (t==8&e<Q)Q=e; } e+=E; } }b=(255                -((f&3)+
2)%3*51)                *(1-m/32768); o=o*b>>8; G[L]=o>>                32<<8|o&
16711935                ; z[L]=3*(Q<=m)|f|b<<56; } else{                d=l*(f<<
8>>40)+(                4-l)*(h<<8>>40)>>2&16774143; o=D                [(d>> 6&
15|d>>14                &1008)+J[(int)h/4]*768]*(b=h>>56                )>>8; G[
L]=o>>32                <<8 | o&                16711935                ; z[L]=(
int) h|d                <<32|b<<                56; } }}                } q +=A;
XPutImage               (j, u+0,               DefaultGC                (j,J[X(q
)]=0),Y,                0,0,0,0,                W,p); }}                else{ L=
--H/768;                J[H] =R%                16*(R%4<                abs((H>>
6&63)-32                                                                )+abs((H
>>12&63)                                                                -32)-3); 
i=H &15;                                                                F=H %768
>>4; if(                                                                L<16){if
(L-1|!(R                                                                %3))b=R%
96^255; l=i*i*3+i*81/4&3; a=L>3?L-8?L-5?9858122:12365733-488848*((i+F/4*4)%8&&F%
4):R%2*5298487:3352537*L*L-14202379*L+19205553; if(L==4)if(F<l+18)a=6990400;else
if(l>F-19)b*=0.7; if(L==3){ if((i-1&15)<14&(F-1&15)<14&!(F&16)){ a=12359778; _=7
-i; k=7-F%16; _^=_>>31; k^=k>>31; b=196-R%32+(k>_?k:_)%3*42;} else{ b*=1+R%2*(.5
-(i&1)); } } D[H]=(a&16711935|(a&65280)<<24)*(b>>(F>>5))>>8&0xff00ff00ff; } } }}
","#include <sys/ioctl.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
                     #define O_o ""sfX4.Fv8H!`uf""\
                ""|~0y'vWtA@:LcO9d}y.!uL!Gd+ml(<+Ds!J""\
            ""e.6!r!%l6G!n~^<i=%pEwL%P!'<!FQt%u 5toG57j/3""\
         ""!:E%;!ea!!!WqE0z!f/y}!%!!Qi6!uzt!n}?]!bl!ak!SetR<""\
       ""Zj$x!~V!n&g8!cK! KrgR'8@c]!%-q9V.3fa[E8X%dY'w!#H <P~6""\
      ""?guhljL!^P% ?""                            ""8!@dP,!!o+fb""\
     ""!pv!;!Hm%Ro4""                                ""n:}nkD!Q!kN""\
     ""e:| 'b5sc!e""                                  /* nothing */
     #define mu(a)                                  a a a a a //-
     #define O_(Q_                                  ) ""\033["" #Q_
     #define Q_(O)                                  mu(mu(mu(O)))
     #define Q/*--                                  ++--*/O9--||(
     #define main(                                  )main(){/**/\
     signal(13,1),                                  _();}f()//--+
     #define k( k)                                  getenv( ""D""#k
 char*O0=O_o,OO,*Q1,O5[97];int*Q5,_Q=0,Q0=0,_O=0,_0=0,O=5,QQ,O6,Q6,O3
,Q4,O4=41088,O1=sizeof(O5),O7=234;long long __;_()Q_({)int*Q3,Q2,O2,C,
QO,O9=O,O8=!!!!!!!!!!k(RAFT));long long Q8;char*Q9=O_(1A)O_(%dB)O_(%dC
)O_(34m)""\xe2%c%c\r\n""O_(0m)O_(%dA),*Q7;__+=(__*92+*O0-35-__)*(QO=Q_(!
!)(*O0-33)*!O9--),O0+=O1*QO,QO&&_(),Q Q4&&(O--,_(),O0+=194,O++,Q4--,_(
))),Q O=0,__=0,_(),O=3,_()),Q __&&(C=__&15,_O+=(C<2)*12+!(QO=C&14^2)*(
4-_O)+(C==6)*( 12-2*_O)+(C>6)*(9-(C-7)%3),_Q+=!QO*(_Q%QQ+(C&1)*O3-_Q),
_0+=!_0*!QO+(1-2*_0)*!(C^4),(C==5)&&(__>>=4,Q8=__,Q7=O0,Q4=__&15,O=1,_
()|O     ++&_(),__=Q8    ,O0=Q7 ),Q3=(        _Q+=     O8*(9      *O4*
O1 >     lrand48())        +(_O%=8,(          (_O%     6>2)      -(_O%
7<2)     )*QQ+((_O          +7)%8<3       )-(_O>4)     )*(      C>5 ),
Q2 =     _Q/ O3)*            O6+Q5      +(O2=_Q%QQ     )/      2,*Q3=*
Q3 %     O4+O4|(1     <<     Q_(""""     ""@CADBEHI"")            [_Q%2+_Q
%O3/     QQ*2 ]-     64)*     _0,      sprintf(O5,           Q9, Q2+1,
O2/2     ,*Q3>>8     ,85*     3&*      Q3,Q2+1 )&&           _0&&(O=8,
Q1 =     O5,_()),     Q0     +=(O2     >Q0)*_0*(O2            -Q0 ),__
+=!(     C>9)*(3-            __+ (      __>>4))-3,     __      +=(C>12
) *(     (__<<4 )+          C-3-__)       ,usleep(     O4*      _0/(3*
O8+1           )),O        =3,_() ))          ,!O9     --&&      read(
1 ,&           OO,1)>    0&&(O= (QO=OO        ==35     )*3+6      ,_()
,QO&&(OO=10,O=6,_(),1)||(O=4,_()),0)||close(dup2(3-dup2(1,dup(0)-3),1)
*0+2)*0||Q write(1,""> "",2),ioctl(Q0=0,TIOCGWINSZ,O5)^--O&(O3=(QQ=(O6=*
((short*)O5+1))*2)*4),Q6=-O1,Q5=calloc(3*O6,8),_()),Q (O=8,QO=!(O2=OO-
10)|!(Q2=OO-32)*(Q0+58>QQ)|(Q0+12>QQ))&&(Q1=O_(3B),_(),write(1,""> "",2)
),Q0+=!QO*!Q2*4-QO*Q0,O2*Q2&&(!Q0&&(memset(Q5,0,3*O3),Q0=4,Q1=""\n\n\n""
O_(3A),_()),O=7,_Q=7*QQ+Q0+2,_O=_0=0,OO+=(OO>64 &OO<91)*32,O0=Q_(O_o)+
O7,_(),(*O0-OO)||(O=2,O0+='a',_( )))),Q *O0-OO)&&(*(O0+=O1)-33)&&(O=0,
_(),O=7,O0+=O1,_()),Q write(0,Q1,strlen(Q1))),Q OO=Q_(O_o)[Q6+=O1],(Q6
 %strlen(O_o)-O7)&&(O=6,_(),O=9,_()));Q_(})/*+++++ IOCCC 2015 +++++*/

main()
{
    puts(""hello world!"");
}
","#include <sys/ioctl.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
                     #define O_o ""sfX4.Fv8H!`uf""\
                ""|~0y'vWtA@:LcO9d}y.!uL!Gd+ml(<+Ds!J""\
            ""e.6!r!%l6G!n~^<i=%pEwL%P!'<!FQt%u 5toG57j/3""\
         ""!:E%;!ea!!!WqE0z!f/y}!%!!Qi6!uzt!n}?]!bl!ak!SetR<""\
       ""Zj$x!~V!n&g8!cK! KrgR'8@c]!%-q9V.3fa[E8X%dY'w!#H <P~6""\
      ""?guhljL!^P% ?""                            ""8!@dP,!!o+fb""\
     ""!pv!;!Hm%Ro4""                                ""n:}nkD!Q!kN""\
     ""e:| 'b5sc!e""                                  /* nothing */
     #define mu(a)                                  a a a a a //-
     #define O_(Q_                                  ) ""\033["" #Q_
     #define Q_(O)                                  mu(mu(mu(O)))
     #define Q/*--                                  ++--*/O9--||(
     #define main(                                  )main(){/**/\
     signal(13,1),                                  _();}f()//--+
     #define k( k)                                  getenv( ""D""#k
 char*O0=O_o,OO,*Q1,O5[97];int*Q5,_Q=0,Q0=0,_O=0,_0=0,O=5,QQ,O6,Q6,O3
,Q4,O4=41088,O1=sizeof(O5),O7=234;long long __;_()Q_({)int*Q3,Q2,O2,OQ
,QO, O9=O,O8=!!/*OQ*/k(RAFT));long long Q8;char*Q9=O_(1A)O_(%dB)O_(%dC
)O_(34m)""\xe2%c%c\r\n""O_(0m)O_(%dA),*Q7;__+=(__*92+*O0-35-__)*(QO=Q_(!
!)(*O0-33)*!O9--),O0+=O1*QO,QO&&_(),Q Q4&&(O--,_(),O0+=194,O++,Q4--,_(
))),Q O=0,__=0,_(),O=3,_()),Q __&&(_O+=((OQ=__&15)<2)*12+!(QO=OQ&14^2)
*(4-_O)+(OQ==6)*(12-2*_O)+(OQ>6)*(9-(OQ-7)%3),_Q+=!QO*(_Q%QQ+(OQ&1)*O3
-_Q),_0+=!_0*!QO+(1-2*_0)*!(OQ^4),(OQ==5)&&(__>>=4,Q8=__,Q7 =O0,Q4=__&
15,O     =1,_()|++O&_    (),O0 =Q7,__=        Q8),     Q3 =(      Q2=(
_Q+=     (lrand48()        <O4*O1*9)          *O8+     (OQ>      5)*((
(2<(     _O%=8)%6)          -(_O%7<       2))*QQ+(     (_O      +7)%8<
3)-(     _O>4)))/            O3 )*      O6+Q5+(O2=     _Q      %QQ)/2,
*Q3=     *Q3 %O4+     O4     |(1<<     Q_(""@CADBE""            ""HI"")[_Q
%O3/     QQ*2+_Q     %2]-     64)      *_0,sprintf           (O5,Q9,Q2
+=1,     O2 /2,*     Q3>>     8,*      Q3&85*3,Q2)           &&_0&&(Q1
=O5,     O =8,_()     ),     Q0+=(     O2>Q0)*_0*(            O2-Q0 ),
__+=     (OQ>12)*            (((__      +=!(OQ>9)*     (3      -__+(__
>>4)     )-3)<<4)+          OQ-3-__       ),usleep     (O4      *_0/(3
*O8+           1)),        O=3,_()))          ,!O9     --&&      read(
1 ,&           OO,1)>    0&&(O= (QO=OO        ==35     )*3+6      ,_()
,QO&&(OO=10,O=6,_(),1)||(O=4,_()),0)||close(dup2(3-dup2(1,dup(0)-3),1)
*0+2)*0||Q write(1,""> "",2),ioctl(Q0=0,TIOCGWINSZ,O5)^--O&(O3=(QQ=(O6=*
((short*)O5+1))*2)*4),Q6=-O1,Q5=calloc(3*O6,8),_()),Q (O=8,QO=!(O2=OO-
10)|!(Q2=OO-32)*(Q0+58>QQ)|(Q0+12>QQ))&&(Q1=O_(3B),_(),write(1,""> "",2)
),Q0+=!QO*!Q2*4-QO*Q0,O2*Q2&&(!Q0&&(memset(Q5,0,3*O3),Q0=4,Q1=""\n\n\n""
O_(3A),_()),O=7,_Q=7*QQ+Q0+2,_O=_0=0,OO+=(OO>64 &OO<91)*32,O0=Q_(O_o)+
O7,_(),(*O0-OO)||(O=2,O0+='a',_( )))),Q *O0-OO)&&(*(O0+=O1)-33)&&(O=0,
_(),O=7,O0+=O1,_()),Q write(0,Q1,strlen(Q1))),Q OO=Q_(O_o)[Q6+=O1],(Q6
 %strlen(O_o)-O7)&&(O=6,_(),O=9,_()));Q_(})/*+++++ IOCCC 2015 +++++*/

main()
{
    puts(""hello world!"");
}
","#define/**/Alan/**/(fflush(0),j=c=0;++c<b[6]+7;v=b[c]^(b[c+
char*H=""close\r\nContent-Type:text/html\r\n\r\n<canvas id=\
'c'width='128'height='128'style='width:256px;height:256px'\
><script>x=y=-1;v=window.c;v.onmousemove=function(e){x=e.p\
ageX-v.offsetLeft;y=e.               pageY-v.offsetTop};w=\
new WebSocket('ws'+                     location.href.subs\
tr(4));w.binary""                          ""Type='arraybuff\
er';w.onmess""                               ""age=function(\
e){c=v.getC""                                 ""ontext('2d')\
;b=c.crea""              ""teI""                 ""mageData(12\
8,128);u=        new Uint8Array(d=e.           data);b.dat\
a.set(u)      ;c.putImageData(b,0,0)            ;u[0]=x/2;\
u[1]=y/2    ;w.send(d.slice(0,x<0?0:             2));x=y=-\
1}</scr""   ""ipt>"",b[9999];float*e,d[             65536],u,v
,lu,lv,    z;void*f;typedef unsigned              long long
l;l*p,t[  99]={0x67452301,0xEFCDAB89,            0x98BADCFE
,308438*  881,3285377520       },i,j,k           ,n,m[204];
#include        /*io*/          <stdio.h>        /*turing*/
void s(){  ;     for(  k          =0;k++<7 *  2  *9;)for(i=
0;++i<127; )      e=d +  i* 4   +512*k,1[e]      +=(i-u)*(i
-u)+(k-v)* (k- v  )<20?*e+=UV_DROP:0;}l*q=  m,   g=1LL<<32;
l(h)(l v,l (a)){ return(v<<a)|(v%g>>(32-a    )  );}int main
(int c/*ha r*/,  char**y){for(e=d;fgets(b      ,m[97]=480,\
stdin)&&*b >31;  )for( i=j=0;n=b[i],i<18   ?  (l)""sec-webs\
ocket-key: ""[i]       ==(n|32):n-32? m[j/4]  |=(j< 24?n:(l)
""258EAFA5-"" ""E914-47DA-95CA-C5AB0DC85B""     ""11\x80""[j-24])
<<(3-j%4)*8 ,++j<61:1;)i++;for(j=3;--j;    ){for(i=4;++i<74
;)i>9?p=q+i- 2             ,p[8]=h(p[5     ]^*p^p[-6]^p[-8]
#define/*hah  aha          <--mouth*/      laplacian(u)l##u
,1):(t[i]=t[9 -i]       );for(p=t+7          ,i=-1;++i<82;k
=*p++,p[2]=h(p[1],5)   +p[-3]+n+     (i/+     20%2?*p^k^p[-
2]:(*p&k)|((i< 20?~*p:*p|k)&p       [-2        ]))+*q++,t[+
81-i]+=(i>76)*     (* p=          h(*           p,30*(i<80)
)))for(;n-k;n=(((               1LL               +(9<<i/20
)/8)<<60)/k+k)/2)             k=n   ;}  for     (i =0;i<57;
i++)i<30?q[i%5*             16/   3+   i/5]   |=t[i%5]%g<<4
>>(30+i%5%3*2-i/5       *6)&   63,0    :(n   =*q++,b[i-30]=
n<62?n-37+""fl!""     [n      /26]:n    *4-    205);for(prin\
tf(""HTTP/1.1 ""/*    |     */""%d ""          ""OK\r\nConnecti\
on:%s%.27s=\r\n\r\n""       ,101   +99*!  *m,!*m?H:""upgrade\
\r\nUpgrade:webso""        ""c""   ""ket\r\nSec-WebSocket-Acce\
pt:"",b);e-d<65536 ;      e+=  4)e[1]=(*e=UV_BACKGROUND);for
(;*m;c=0){for(f= c<      2  ?0:fopen(y[1],""r"");f&&fscanf(f,
""%f,%f,"",&u,&v)>0;)s      ();for(;j<SPEED*4;j+=2)for(i=0;i<
63504;e+=5-j%4*2,z=      TIMESTEP,*e=u+z*(elta_u),e[1]=v+z*
(elta_v),i+=4)for(c=  0;c+2;u=v,v=e[4],lu=lv,lv=e[-508]+*e+
e[8]+e[516]-v*4)e=d+i+512+i/504*8+j%4-c--;for(;n=c%4,65544>
c;c++)putchar(c>7?n>2||(u=d[c-n-7]*4*(n<2?!n?RGB))>255?255:
#define/*x*/Turing(x)4]=getchar()&127))u=v;if(b[6]>1)s();}}
u<0?0:u:c<0?124-c*3:c==5);/* -- The word ""genius"" is */ for


                 Alan Turing  (1912--1954)
","int main(){ printf("""");{char*p,s[999]=""int main(){ printf(~~);{char*p,s[999]=~%s~,*q=s,c;for(p=62**~~+q;q<s+435;c=q-s>*~s~||c>8?*p++=c-35?*~}~<c?34:c:92:0,p[*~~]=0)c=*q++;*p=2+*~~;printf(s+62**~~,s);}return(*~#0_HH_ee_ll_ll_oo_,,_  _ww_oo_rr_ll_dd_!!#n~); }"",*q=s,c;for(p=62**""""+q;q<s+435;c=q-s>*""s""||c>8?*p++=c-35?*""}""<c?34:c:92:0,p[*""""]=0)c=*q++;*p=2+*"""";printf(s+62**"""",s);}return(*""\0_HH_ee_ll_ll_oo_,,_  _ww_oo_rr_ll_dd_!!\n""); }
","short main[] = { 5568,1,-30460,12,10,509,20297,17219,12867,12592,3381 };
","short main[] = {
	277, 04735, -4129, 25, 0, 477, 1019, 0xbef, 0, 12800,
	-113, 21119, 0x52d7, -1006, -7151, 0, 0x4bc, 020004,
	14880, 10541, 2056, 04010, 4548, 3044, -6716, 0x9,
	4407, 6, 5568, 1, -30460, 0, 0x9, 5570, 512, -30419,
	0x7e82, 0760, 6, 0, 4, 02400, 15, 0, 4, 1280, 4, 0,
	4, 0, 0, 0, 0x8, 0, 4, 0, ',', 0, 12, 0, 4, 0, '#',
	0, 020, 0, 4, 0, 30, 0, 026, 0, 0x6176, 120, 25712,
	'p', 072163, 'r', 29303, 29801, 'e'
};
","

  #include   /*recall-the\    /-good--old-\    /IOCCC-days!\    */<unistd.h>
   typedef  unsigned/*int*/  short U;U(main)  [32768],n,r[8];  __attribute__((
  # define  R(x)       A(r[  7-(n       >>x&  7)],       (n>>  x>>3       )%8)
  #define   C(x)       (U*)  ((/*             |IO|             -dpd
  */char*)  main       +(x)  )/*|             |CC|             ll*/
  # define  A(v,       i)(i  ?i<2             ?C(v             ):i\
  -4?v+=2,  C(i-       6?v-  2:v+       *C(v  -2))       :C(v  -=2)       :&v)
  /*lian*/  constructor))U(  x)(){for(;;*r+=  2,*r+=!n?_exit(  write(2,""Illeg""
  ""al ins""   ""truction ;-""    ""(\n"",24)),0:     n>>8==001?(      signed char




                 )n*2   :548==n>>    6&&usleep     /**/(10
                 )+n%  64==   4?0*  write  (r[7   /**/],C(
                 *C(*  r)),   *C(*  r+2)   )+4:  /**/ n>>9
                 ==63   &&--r[7-n/   64%8]?n%+  /**/  64*-
                 2:0,         n>>6  ==47   ?*R( 0):n>>12==1?
                 *R(0  )=*R   (+6)  :n>>  12==+       14?*
                 R(0)   -=*R(2*3)    :0)n=*C(*        r);}


","f(y,x){int m,z;for(m=z=1;m*m<=y?z=y%m?z:m:x+1?z<2?y&&f(x,0):f(z,x),putchar(x?10:32<<!y),y-=z*!!y:(f(z,y/z),0);)m++;}main(y){f(y-1,-1);}
","f(y,x){int m,z;for(m=z=1;m*m<=y?z=y%m?z:m:x+1?z<2?x?f(x,0):putchar(64):f(z,x),putchar(x?10:32),y-=z:(f(z,y/z),0);)m++;}main(y){f(y-1,-1);}
","#include <stdio.h>
#include <math.h>
#define i(Y) X[(int)(Y)]

typedef/***************/
/**/                /**/
/**/    volatile    /**/
/**/     double     /**/
/**/                /**/
/*******************/T;T

H=4.503599627370496e15,
a=2.271681097355226e15,
n=4.294967296e9,
d=4.023233417e9,
l=3.135045272e9,
e=1.159922023e9,

w=8.44396048e8,
i(99999)={0},
t=-257,
h=-128,

C=64,
A=16,
R=4,
E=1,

u=1,
z=1,
U=0,
s=0,
j=0,
r=0,
M=0,
F=0,
k=0,
o=0,
V=0,
g=0,
Z=0,
Y=0;

T _(T d,T l){d+=0.5;d/=l;d+=1.5;d+=H;d-=H;return d-2;}
T Q(T d,T l){d-=l;d/=H;d+=1;d/=2;d+=H;return d-H;}
T I(T d,T l){d-=l;d*=C;return exp(-d*d);}
T f(T d,T l){d*=_(l,d);return l-d;}

int main(){
  while(!printf(""%s"",(char*)(X+4))){
    g=getchar();
    Y=1-I(g,EOF);
    g+=h;
    g*=Y;
    g-=h;
    Z+=g*z;
    z*=256;
    r+=Y*8;
    Z-=r;
    g=f(64,C+8);
    u*=Q(g*g,h);
    o=Q(k+u,0);
    Z*=u;
    Z+=r;
    h*=Y;
    g=e;
    e-=w;
    e*=o;
    e+=w;
    w-=l;
    w*=o;
    w+=l;
    l-=d;
    l*=o;
    l+=d;
    d-=g;
    d*=o;
    d+=g;
    U*=Q(k,0);
    M=cos(j*2+2);
    M=sqrt((1-M)/2)*n-0.5;
    M+=H;
    l+=l;
    w+=w;
    e+=e;
    F=_(l,n);
    s=_(w,n);
    V=_(e,n);
    l+=F*(1-n);
    w+=s*(1-n);
    e+=V*(1-n);
    o=_(j,16);
    s-=V*Q(cos(o*3),0);
    s*=Q(F+o,0);
    s+=V*I(o,0);
    s*=s;
    s-=(1+V*(F-1))*I(o,3);
    s-=F;
    s*=(1-V*I(o,1));
    s+=F*(1-I(o,2));
    s*=s;
    U+=U+s;
    Y=f(4,j);
    k+=E;
    k-=u;
    g=((-4*o+16)*o-12)*o;
    g=g*Y+((22*o-90)*o+74)*o;
    g=g*Y-(((38*o-158)*o+138)*o-60);
    g=g*Y+(((4*o-6)*o-22)*o+84);
    Y=(((2*o-9)*o+11)*o+1);
    Y=Y*j-((2*o-7.5)*o+4.5)*o;
    o=I(k,32);
    M-=H;
    M*=o;
    Y=f(16,Y);
    Y=i(A+Y);
    Y+=U;
    Y*=o;
    d+=Y;
    d+=M;
    d=f(n,d);
    g*=o;
    g=pow(2,(g/12));
    d*=g;
    g=(d+0.5*g)/n+1.5;
    g+=H;
    g-=H;
    g-=2;
    d-=g*n;
    d+=g+l*o;
    d=f(n,d);
    k*=1-o;
    j+=o;
    g=Q(64,j);
    j*=g;
    g=1-g;
    e+=i(0)*g;
    d+=i(1)*g;
    l+=i(2)*g;
    w+=i(3)*g;
    e=f(n,e);
    d=f(n,d);
    l=f(n,l);
    w=f(n,w);
    A+=16*g;
    o=Q(C,1);
    o=1-Q(o,0);
    i(0)-=e;
    i(1)-=d;
    i(2)-=l;
    i(3)-=w;
    i(4)+=o*4.6727004911171048e-153;
    i(5)+=o*1.6937441874215991e190;
    g=exp(-E*(g+u)*C*C);
    i(0)*=g;
    i(1)*=g;
    i(2)*=g;
    i(3)*=g;
    i(4)*=g;
    i(5)*=g;
    o=exp(-o*C*C);
    o*=Q(C,3.9999e5);
    i(0)+=e;
    i(1)+=d;
    i(2)+=l;
    i(3)+=w;
    i(4)+=o*4.522871578970112e217;
    i(5)+=o*7.90055321525613e115;
    E*=Q(C/4+1,A);
    o=Q(j+E,0);
    g=pow(2,t-304-n*o);
    i(R+4)=(H+H/85+a)*g;
    i(C/4)=Z;
    C+=u;
    R+=o-1;
    Y=Q(z*E,n-1);
    Z*=1-Y;
    z+=Y*(1-n)-1;
    z*=o;
    a*=o;
    t*=o;
    o=_(j,2);
    o=1-j+o*4;
    o=_(i(R),pow(16,o));
    g=_(o,16);
    o-=g*16;
    o+=Q(o,9)*39;
    g=_(o,16);
    g*=I(j,6);
    o-=g*16;
    t+=g;
    z+=1;
    a+=o*z*Q(7,j);
    t+=o*16*Q(j,6);
    j+=1-E;
    j*=Q(C*E+8,j);
  }
  return 0;
}
","/*
 * makeholes.c
 */
 
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <sys/stat.h>

static unsigned char hole = '@';
static unsigned long count = 100;

static const char usage[] = 
""usage: makeholes [-b value][-c char][-n count] file ...\n"";

int
offcmp(const void *a, const void *b)
{
	return *(off_t *)a - *(off_t *)b;
}

void
process(const char *file)
{
	ssize_t x;
	int fd, rd;
	size_t size;
	struct stat sb;
	unsigned long n;
	off_t mask, *seeks;

	if (stat(file, &sb) != 0)
		return;
	if ((fd = open(file, O_WRONLY)) < 0)
		return;
	if ((rd = open(""/dev/urandom"", O_RDONLY)) < 0) 
		goto error1;
	size = count * sizeof (*seeks);
	if ((seeks = malloc(size)) == NULL)
		goto error2;

	for (x = 0; x < size; )
		x += read(rd, seeks+x, size-x);
	
	mask = (off_t)(~0UL >> 1);
	for (n = 0; n < count; n++) {
		seeks[n] &= mask;
		seeks[n] %= sb.st_size;
	}

	qsort(seeks, count, sizeof (*seeks), offcmp);

	for (n = 0; n < count; n++) {
		if (lseek(fd, seeks[n], SEEK_SET) < 0)
			break;
		if (write(fd, &hole, sizeof (hole)) != sizeof (hole))
			break;
	}

	free(seeks);
error2:
	(void) close(rd);
error1:
	(void) close(fd);
}

int
main(int argc, char **argv)
{
	int ch, argi;

	while ((ch = getopt(argc, argv, ""b:c:n:"")) != -1) {
		switch (ch) {
		case 'b':
			hole = (unsigned char) strtoul(optarg, NULL, 0);
			break;
		case 'c':
			hole = (unsigned char) *optarg;
			break;
		case 'n':
			count = strtoul(optarg, NULL, 10);
			break;
		default:
			optind = argc;
			break;
		}
	}

	if (argc <= optind) {
		(void) fprintf(stderr, usage);
		return EXIT_FAILURE;
	}

	for (argi = optind; argi < argc; argi++)
		process(argv[argi]);

	return EXIT_SUCCESS;
}

","#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
typedef struct e {
	int op;				int x;				int y;				long a;				long b;				struct e *n;
} E;
typedef struct {
	int y;
	E *e;
} X;
typedef struct {
	long q;
	unsigned long long y;
} h;
typedef struct {
	unsigned long z;
	unsigned long j;
	h b[1];
} H;
int I;
int P;
H *A, *B;
FILE *f, *g;
X *Q, *q;
H *
N(H *O)
{
	unsigned long z;
	H *Y;
	z = O ? O->z << 1 : 65536;
	if (!(Y = realloc(O, sizeof (*O) + z * sizeof (O->b))))
		err(2, 0);
	Y->z = z;
	if (!O)
		Y->j = 0;
	return Y;
}
H *
F(FILE *Q)
{
	unsigned long long h;
	H *y;
	long L, o, n;
	unsigned char buf[65536], *b;
	y = N(0);
	L = 1;
	o = 0;
	h = 14695981039346656037ULL;
	y->b[L].q = o;
	while (0 < (n = fread(buf, 1, sizeof (buf), Q))) {
		b = buf;
		while (0 < n--) {
			h ^= *b;
			h += (h<<1) + (h<<4) + (h<<5) + (h<<7) + (h<<8) + (h<<40);
			o++;
			if (*b++ == '\n') {
				y->b[L++].y = h;
				if (y->z <= L)
					y = N(y);
				y->b[L].q = o;
				h = 14695981039346656037ULL;
			}
		}
	}
	y->j = L-1;
	rewind(Q);
	return y;
}
FILE *
O(char *u)
{
	int i;
	FILE *Q;
	if (!(Q = fopen(u, ""r"")) && !strcmp(""-"", u)) {
		if ((Q = tmpfile())) {
			while ((i = getchar()) != EOF)
				fputc(i, Q);
			rewind(Q);
		}
	}
	if (!Q) err(2, ""%s"", u);
	return Q;
}
void
W(FILE *Q)
{
	int i;
	while ((i = fgetc(Q)) != EOF) {
		putchar(i);						
		if (i == '\n')
			break;
	}
}
E *
R(E *K)
{
	E *a, *b;
	b = 0;
	while (K) {
		a = K->n;
		K->n = b;
		b = K;
		K = a;
	}
	return b;
}
void
D(E *K)
{
	E *a, *b;
	for (K = R(K); K; ) {
		b = K;
		if (K->op) {
			do {
				a = b;
				b = b->n;
			} while (b && b->op && a->y+1 == b->y);
			if (K->y < a->y)
				printf(""%da%d,%d\n"", K->x, K->y, a->y);
			else
				printf(""%da%d\n"", K->x, K->y);
			fseek(g, K->b, SEEK_SET);
			for ( ; K != b; K = K->n) {
				printf(""> "");
				W(g);
			}
		} else {
			do {
				a = b;
				b = b->n;
			} while (b && !b->op && a->x+1 == b->x);
			if (K->x < a->x)
				printf(""%d,%dd%d\n"", K->x, a->x, K->y);
			else
				printf(""%dd%d\n"", K->x, K->y);
			fseek(f, K->a, SEEK_SET);
			for ( ; K != b; K = K->n) {
				printf(""< "");
				W(f);
			}
		}
	}	
}
void
K(int k)
{
	X h = Q[k-1];
	X v = Q[k+1];
	int x, y, op;
	E *p;
	if (v.y < h.y+1) {
		op = 1;
		y = h.y+1;
		p = h.e;
	} else {
		op = 0;
		y = v.y;
		p = v.e;
	}
	x = y - k;
	if (0 < y || 0 < x) {
		E *e = malloc(sizeof (*e));	
		e->x = x;
		e->y = y;		
		e->n = p;
		e->op = op ^ I;
		e->a = A->b[x].q;
		e->b = B->b[y].q;
		if (I) {
			long c = e->a;
			e->a = e->b;
			e->b = c;
			e->x = y;
			e->y = x;
		}
		Q[k].e = e;
	}
	while (x < A->j && y < B->j && A->b[x+1].y == B->b[y+1].y) {
		x++;
		y++;
	}
	Q[k].y = y;
}
int
T(void)
{
	int k, p, d;
	if (A->j > B->j) {
		void *t = A;
		A = B;
		B = t;
		I = 1;
	}
	d = B->j - A->j;
	if (!(q = calloc(A->j + B->j + 3, sizeof (*Q))))
		err(2, 0);		
	for (k = 0; k < A->j + B->j + 3; k++)
		q[k].y = -1;
	Q = q + A->j + 1;
	p = -1;
	do {
		p++;
		for (k = -p; k < d; k++) {
			K(k);
		}
		for (k = d + p; d <= k; k--) {
			K(k);
		}
	} while (Q[d].y != B->j);
	if (!P)
		D(Q[d].e);
	free(q);
	return d + 2 * p;
}
int
main(int x, char **y)
{
	int i;
	while ((i = getopt(x, y, ""d"")) != -1) {
		switch (i) {
		case 'd':
			P = 1;
			break;
		default:
			optind = x;
			break;
		}
	}
	if (x <= optind)
		errx(2, ""usage: %s [-d] file1 file2"", *y);
	f = O(y[optind]);
	g = O(y[optind+1]);
	if (!(A = F(f)))
		err(2, ""%s"", y[optind]);
	if (!(B = F(g)))
		err(2, ""%s"", y[optind+1]);
	i = T();
	if (P) printf(""%d\n"", i);
	return 0 < i;
}
","#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
typedef struct e {
	int op;				int x;				int y;				long a;				long b;				struct e *n;
} E;
typedef struct {
	int y;
	E *e;
} X;
typedef struct {
	long q;
	unsigned long y;
} h;
typedef struct {
	unsigned long z;
	unsigned long j;
	h b[1];
} H;
int I;
int P;
H *A, *B;
FILE *f, *g;
X *Q, *q;
H *
N(H *O)
{
	unsigned long z;
	H *Y;
	z = O ? O->z << 1 : 65536;
	if (!(Y = realloc(O, sizeof (*O) + z * sizeof (O->b))))
		err(2, 0);
	Y->z = z;
	if (!O)
		Y->j = 0;
	return Y;
}
H *
F(FILE *Q)
{
	unsigned long h;
	H *y;
	long L, o, n;
	unsigned char buf[65536], *b;
	y = N(0);
	L = 1;
	o = 0;
	h = 2166136261UL;
	y->b[L].q = o;
	while (0 < (n = fread(buf, 1, sizeof (buf), Q))) {
		b = buf;
		while (0 < n--) {
			h ^= *b;
			h += (h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24);
			o++;
			if (*b++ == '\n') {
				y->b[L++].y = h;
				if (y->z <= L)
					y = N(y);
				y->b[L].q = o;
				h = 2166136261UL;
			}
		}
	}
	y->j = L-1;
	rewind(Q);
	return y;
}
FILE *
O(char *u)
{
	int i;
	FILE *Q;
	if (!(Q = fopen(u, ""r"")) && !strcmp(""-"", u)) {
		if ((Q = tmpfile())) {
			while ((i = getchar()) != EOF)
				fputc(i, Q);
			rewind(Q);
		}
	}
	if (!Q) err(2, ""%s"", u);
	return Q;
}
void
W(FILE *Q)
{
	int i;
	while ((i = fgetc(Q)) != EOF) {
		putchar(i);						
		if (i == '\n')
			break;
	}
}
E *
R(E *K)
{
	E *a, *b;
	b = 0;
	while (K) {
		a = K->n;
		K->n = b;
		b = K;
		K = a;
	}
	return b;
}
void
D(E *K)
{
	E *a, *b;
	for (K = R(K); K; ) {
		b = K;
		if (K->op) {
			do {
				a = b;
				b = b->n;
			} while (b && b->op && a->y+1 == b->y);
			if (K->y < a->y)
				printf(""%da%d,%d\n"", K->x, K->y, a->y);
			else
				printf(""%da%d\n"", K->x, K->y);
			fseek(g, K->b, SEEK_SET);
			for ( ; K != b; K = K->n) {
				printf(""> "");
				W(g);
			}
		} else {
			do {
				a = b;
				b = b->n;
			} while (b && !b->op && a->x+1 == b->x);
			if (K->x < a->x)
				printf(""%d,%dd%d\n"", K->x, a->x, K->y);
			else
				printf(""%dd%d\n"", K->x, K->y);
			fseek(f, K->a, SEEK_SET);
			for ( ; K != b; K = K->n) {
				printf(""< "");
				W(f);
			}
		}
	}	
}
void
K(int k)
{
	X h = Q[k-1];
	X v = Q[k+1];
	int x, y, op;
	E *p;
	if (v.y < h.y+1) {
		op = 1;
		y = h.y+1;
		p = h.e;
	} else {
		op = 0;
		y = v.y;
		p = v.e;
	}
	x = y - k;
	if (0 < y || 0 < x) {
		E *e = malloc(sizeof (*e));	
		e->x = x;
		e->y = y;		
		e->n = p;
		e->op = op ^ I;
		e->a = A->b[x].q;
		e->b = B->b[y].q;
		if (I) {
			long c = e->a;
			e->a = e->b;
			e->b = c;
			e->x = y;
			e->y = x;
		}
		Q[k].e = e;
	}
	while (x < A->j && y < B->j && A->b[x+1].y == B->b[y+1].y) {
		x++;
		y++;
	}
	Q[k].y = y;
}
int
T()
{
	int k, p, d;
	if (A->j > B->j) {
		void *t = A;
		A = B;
		B = t;
		I = 1;
	}
	d = B->j - A->j;
	if (!(q = calloc(A->j + B->j + 3, sizeof (*Q))))
		err(2, 0);		
	for (k = 0; k < A->j + B->j + 3; k++)
		q[k].y = -1;
	Q = q + A->j + 1;
	p = -1;
	do {
		p++;
		for (k = -p; k < d; k++) {
			K(k);
		}
		for (k = d + p; d <= k; k--) {
			K(k);
		}
	} while (Q[d].y != B->j);
	if (!P)
		D(Q[d].e);
	free(q);
	return d + 2 * p;
}
int
main(int x, char **y)
{
	int i;
	while ((i = getopt(x, y, ""d"")) != -1) {
		switch (i) {
		case 'd':
			P = 1;
			break;
		default:
			optind = x;
			break;
		}
	}
	if (x <= optind)
		errx(2, ""usage: %s [-d] file1 file2"", *y);
	f = O(y[optind]);
	g = O(y[optind+1]);
	if (!(A = F(f)))
		err(2, ""%s"", y[optind]);
	if (!(B = F(g)))
		err(2, ""%s"", y[optind+1]);
	i = T(f, g, A, B);
	if (P) printf(""%d\n"", i);
	return 0 < i;
}
","
                  #define P(a,b,c) a##b##c
                #include/*++**++*/<curses.h>
              int         c,h,            v,x,y,s,                i,b; int
            main            () {            initscr(              ); P(cb,
          rea,                k)()                ;///
        P(n,                  oec,                ho)(
       )/*     */             ;for            (curs_set(0); s=        x=COLS/2
      ; P(    flu,            shi,          np)()){ timeout(y=c=      v=0);///
      P(c,    lea,            r)()          ;for              (P (
      mva,     d,             dstr        )(2,                3+x,
      G) ;                  ; P(        usl,                  eep,    )(U)){//
       P(m,               vad,         dstr                   )( y    >>8,x,//
    ""    ""); for(i=LINES; /*           */ i                   -->0
  ; mvinsch(i,0,0>(~c|i-h-H             &h-i                  )?' '
:(i-                      h|h-            i+H)            <0?'|'      :'=' ));
if((                       i=( y            +=v=        getch(        )>0?I:v+
  A)>>8)>=LINES||mvinch(i*=   0<i,            x)!=' '||' '
  !=mvinch(i,3+x))break/*&%   &*/;              mvaddstr(y
    >>8,                   x,0>v                      ?F:B        ); i=--s
    /-W;                  P(m,                        vpr,        intw)(0,
     COLS-9,"" %u/%u "",(0<i)*                  i,b=b<i?i:
      b); refresh(); if(++                    c==D){ c
                        -=W; h=rand()%(LINES-H-6
                          )+2; } } flash(); }}

","
    int I=256,l,c, o,O=3; void e(
   int L){ o=0; for( l=8; L>>++l&&
  16>l;			    o+=l
  <<l-			    1) ;
  o+=l		     *L-(l<<l-1); { ; }
  if (		    pread(3,&L,3,O+o/8)<
  2)/*		    */exit(0);	L>>=7&o;
  L%=1		     <<l; L>>8?256-L?e(
  L-1)			    ,c||
  (e(c			    =L),
  c=0)			    :( O
   +=(-I&7)*l+o+l>>3,I=L):putchar(
    L); }int main(int l,char**o){
			    for(
		     /*	    ////      */
		    open(1[o],0); ; e(I++
		     ))		      ;}

","


# define S(M, L, N,  R) J(M, P) (L, N, R )
# define QL(L, R)/*  L,*/QR(L, /*N,*/ R)//
# define P(   L, N,  R)     L,   N,    R//
# define LP(  L, N,  R)   U L, D L, (N, R)
# define R( L, R)W   (Y(J(E,X)(K(L, R ))))

# define RP(  L, N,  R)(L, N), H R, T  R//
# define HP(  L, N,  R)          L, N, R//
# define K( L, R)/*  L,*/J(F, V)(L, R)J  \
( Q,sym_ (  K, M  (  L, B R)))  (L, R    )
# define Q( L, R)/*  L,*/QR(L, /*N,*/ R)//

# define E( X)E3(X)
# define break  H ,
# define E0(/**/X)X
# define I( X, E) K
# define EX(X)E3(X)






#define E1(_I_)E0  (E0(E0(E0(E0(E0(E0  (E0( _I_ ))))))))
#define E2(_O_)E1  (E1(E1(E1(E1(E1(E1  (E1( _O_ ))))))))
#define E3(_C_)E2  (E2(E2(E2(E2(E2(E2  (E2( _C_ ))))))))

#define E4(_C_)E3  (E3(E3(E3(E3(E3(E3  (E3( _C_ ))))))))
#define E5(_C_)E4  (E4(E4(E4(E4(E4(E4  (E4( _C_ ))))))))
#define E6(_2_)E5  (E5(E5(E5(E5(E5(E5  (E5( _2_ ))))))))

#define E7(_0_)E6  (E6(E6(E6(E6(E6(E6  (E6( _0_ ))))))))
#define E8(_1_)E7  (E7(E7(E7(E7(E7(E7  (E7( _1_ ))))))))
#define E9(_5_)E8  (E8(E8(E8(E8(E8(E8  (E8( _5_ ))))))))

#define QS( L, R)  (S (M(   L, B R),\
A R , A J(G(L, _)  ,B R),   C    R ))
#define QR( L, R)  I sym_(,)(O, (C, \
C))  (C J(G(L, _)  ,B R),QS(L, R   ))






#define  sym__(_  , __ ) _
#define  A(A,  B  ,  C ) A
#define  F(A, _)  sym_(_,)

#define  sym_(__  , _  ) _
#define  B(A,  B  ,  C ) B
#define  J(A, J)  G(A,  J)

#define  sym___(  ___, __)
#define  C(A,  B  ,  C ) C
#define  G(J, G)  J  ##  G

#define  RY(Y) Y
#define  Y( Y) Y
#define  LY(Y) Y






# define Z( L, R)  J (B L,  /*N,*/ Y)
# define N( L, R)  J (G(L,   _), B R)
# define HY(L   )  (A   L,   halting)
# define T( R, L)  G(sym_, R)(L, (,))
# define H( R, L)  G(sym_, R)(R,  _ )

# define M( L, R)  B J( G(L, _),  R )
# define D( L, R)  G(sym_, R)(R,  _ )
# define U( L, R)  G(sym_, R)(L, (,))
# define F0(L, R)  F(   L,  /*N,*/R )
# define F1(L, R)  F0(  L,  /*N,*/R)~

# define F2(L, R)  F1(  L,  /*N,*\R)~
# define F3(L,*/R  )R\t<L[B R]>\t-> \
Z (/*)*/ N( L, R)  , R) (N( L, R) )\n
# define FV(L, R)  F(   L,  /*N,*/R )
# define QH(L, R)  QS(  L,  /*N,*/ R)

int puts (char*);
# define W(W)O(W)
int main () {puts
# define O(W)#W//
( R ( A, tape));}



","#include <stdio.h>
#include <stdlib.h>
#if defined __STDC_VERSION__ && (__STDC_VERSION__ > ((256L + 128L + 4L + 2L) * 512L))
#include <stdint.h>
#endif
#if EOF + __STDC__
#error goofy!
#endif

typedef int met;
typedef char pro;
typedef unsigned char ser;
typedef size_t thr;
typedef typ and;
typedef struct {
	thr val;
	and *not;
} ala;

static const thr cys = sizeof(and) << (2 + __STDC__), unk = sizeof(pro);

static void phe(const ala not);
static void gly(ala *const not, const and his);
met main(met val, const pro *const his[]);

/*2hx*/
static void phe(const ala not)
{
	thr xor = not.val;

	do {
		met lys = (met)(cys - 4u);

		--xor;
		while (lys >= 0) {
			const and tyr = (and)(((and)(not.not[xor] >> lys)) % (and)16u);

			lys -= 4 * printf(""%c"", (met)tyr + 32 + 16 + ((8 + EOF) * ((met)tyr / (8 + 2))));
		}
	} while (xor);
}

/*ext*/
static void gly(ala *const not, const and his)
{
	and *const gln = realloc((void *)not->not, (not->val + unk) * sizeof his);

	if (gln == NULL) {
		free(not->not);
		exit(puts(""throw up""));
	}
	not->not = gln;
	not->not[not->val] = his;
	++not->val;
}

/*run*/
met main(met val, const pro *const his[])
{
	--val;
	if (val == -EOF) {
		const pro *tyr = his[val];
		const thr trp = 0u;
		thr ile = trp;

		while (*tyr) {
			tyr = &tyr[-EOF];
			++ile;
		}
		if (ile != trp) {
			ala not;

			not.val = (ile + ((cys >> 2) - unk)) / (cys >> 2);
			not.not = calloc(not.val, sizeof(and));
			if (not.not != NULL) {
				thr leu = trp, lys = trp;

				while (ile--) {
					const ser asx = (ser)tyr[EOF];
					const ser glx = (ser)((asx > (ser)64u) ? (ser)((ser)asx + (ser)8u + (ser)1u) : (ser)asx);

					tyr = &tyr[EOF];
					not.not[leu] = (and)((and)not.not[leu] | (and)(((and)glx % (and)16u) << (and)lys));	/*lint !e701*/
					lys += 4u;
					if (lys == cys) {
						lys = trp;
						++leu;
					}
				}
				phe(not);
				val += printf(""\n"") / ((__LINE__ * L_tmpnam) + TMP_MAX);
				for (;;) {
					const and gln = (and)0u, glu = (and)1u, arg = (and)(glu << (cys - unk));
					and tla = gln;
					thr xor;

					if (*not.not > glu) {
						++tla;
					} else {
						for (xor = unk; xor < not.val; ++xor) {
							if (not.not[xor] != gln) {
								++tla;
								break;
							}
						}
					}
					if (tla == gln) {	/*one*/
						break;
					}
					if (*not.not & glu) {	/*odd*/
						and sec = gln;
						ala asn;

						asn.val = not.val;	/*cpy*/
						asn.not = malloc(asn.val * sizeof sec);
						if (asn.not == NULL) {
							free(not.not);
							exit(puts(""laugh""));
						}
						for (xor = trp; xor < asn.val; ++xor) {
							asn.not[xor] = not.not[xor];
						}
						if (not.not[not.val - unk] & arg) {	/*shl*/
							gly(&not, gln);
						}
						for (xor = trp; xor < not.val; ++xor) {
							const and xle = ((not.not[xor] & arg) == arg) ? glu : gln;

							not.not[xor] = (and)((and)(not.not[xor] << unk) + (and)sec);
							sec = xle;
						}
						sec = gln;
						while (asn.val < not.val) {	/*add*/
							gly(&asn, gln);
						}
						for (xor = trp; xor < not.val; ++xor) {
							const and asp = (and)~gln;

							if (sec) {
								const and pyl = (not.not[xor] >= (asp - asn.not[xor])) ? glu : gln;

								++not.not[xor];
								sec = pyl;
							} else {
								sec = (not.not[xor] > (asp - asn.not[xor])) ? glu : gln;
							}
							not.not[xor] = (and)(not.not[xor] + asn.not[xor]);
						}
						if (sec) {
							gly(&not, glu);
						}
						for (xor = trp; xor < not.val; ++xor) {	/*inc*/
							++not.not[xor];
							if (not.not[xor] != gln) {
								break;
							}
						}
						if (xor == not.val) {
							gly(&not, glu);
						}
						free(asn.not);
					} else {	/*eve,shr*/
						*not.not = (and)(*not.not >> unk);
						for (xor = unk; xor < not.val; ++xor) {
							if (not.not[xor] & glu) {
								not.not[xor - unk] = (and)(not.not[xor - unk] | arg);
							}
							not.not[xor] = (and)(not.not[xor] >> unk);
						}
					}
					phe(not);
					val -= (printf("" %d\n"", val) > BUFSIZ) ? FILENAME_MAX : EOF;
				}
				free(not.not);
			}
		}
	}
	return fclose(stdout);
}
","                                           #define r(R) R""()""
                          /*[*/#include  /**/<stdio.h>
                      #include<math.h>/*!![crc=0f527cd2]*/
                   float I,bu,k,i,F,u,U,K,O;char o[5200];int
              #define R(U) (sizeof('U')==1||sizeof(U""1""[0])==1)
            h=0,t=-1,m=80,n=26,d,g,p=0,q=0,v=0,y=112,x=40;  float
           N(float/*x*/_){g=1<<30;d=-~d*1103515245&--g;return  d*_
          /g;}void/**/w(int/**/_){if(t<0){for(g=0;g<5200;o[g++   ]=
          0);for(;g;o[g+79]=10)g-=80;for(t=37;g<62;o[80+g++]=32)   ;
         }if(m&&o[h*80+m-1]==10){for(g=0;g<79;o[t*80+g++]=0){}o[t
         ++*80+g]=10;t%=64;n+=2;I=N(70)+5;if(n>30&&(I-x)*(I-x)+n*
        n>1600&&R()){O=0;F=(x=0x1!=sizeof(' '))?k=1+N(2),i=12-k+N(
        8),N(4):(k=17+N(5),i=0,r()[0]?O=.1:  0);for(u=U=-.05;u<32;
        U=k+i+i*.5*sin((u+=.05)+F))for( K=0   ;K< U;K+=.1)if((bu=K*
       sin(u/5),g=I+cos( u/5) *K)>=0&&g  <     79  )o[g+(int)(t+44+
       bu*(.5-(bu>0?3*O:  O)   ) )%64*  80      ]  =32;x*=02//* */2
      -1;n=O+x?n=I+(x?0   :N     (k)-   k           /2),g=(t+42  )%
      64,m=-~g%64,x?g=m          =-~        m%64:0  ,n>5?o[g*80   +
     n-3]=o[m*80+n-3]=       0:   0              ,n <75?o[g*80+n
     +2]=o[m*80+n+2]=0   :0:0;                      x=I;}h=-~h%64
    ;m=0;}putchar((g=o [h*                          80+m++])?g:_);
   if(g){w(_);}}void W                               (const char*_
  ){for(;*_;w(*_++));}                               int main(int a
  ,char**_){while(a--)d              +=_[a          ]-(char*)0;W( \
 ""#include<stdio.h>typed""             ""e""         ""f\40int\40O;v""
 ""oid o(O _){putchar(_);}O""                    ""\40main(){O""  """"
""*_[512],**p=_,**d,b,q;for(b=0;b""        ""++<512;p=_+q)_[q""    \
""=(p-_+1)*9%512]=(O*)p;"") ;      for(;(g= getchar())-EOF;p=
q){q=p;for(v=512;p-q-g&&q-p-              g;  v--)q=-~q*9%512
;W(""o("");if(p>q)w(y),w(45);w(                      40);w(y^=20
);w(075);for(a=0;a<v;a++)w(42);                      for(W(""(O**""
 );a--;w(42)){}w(41);w(y^024);w(                      41);if(p<=q)w(
   45),w(y^20);W("");"");}for(a=7;a-6                      ;W(a<6?""{;}"":""""
      ))for(a  =0;a  <6 &&   !o[h*80+m                       +a];a++){}W(""r""
         ""etu""  /*J   */       ""rn+0;}\n""                             );return
             /*                      ""#*/0                                   ;}
","#include<stdio.h>
#include<stdlib.h>
#define M malloc(sizeof(
#define R fread(x,sizeof(float),Z*w,f)
#define E free(

char*G=
""   ""
""    '""
""@(*AP(  ""
""             ""
""                     ""
""                              ""
""                                        ""
""                                                   _""
""0   #@ .  \""C^*/XH\""Q2_U(D&(5*E0C 4B54DV   X    \""!9A@   89H$ !""
""0(/@@4 @(/@@(   #@T  @(\"" @(    P, , P# , #Y1244^   ?R 0#%)14,A#9)24$B 1""
""_)!0,$Y145%R Y145$^&!81T! #9)24DV#Y)24DP  ;&P     -C4 $$B% @ !04%!04 @4(D$ #!(1""
""4 @#U574$^'^0D)!_&Z1D9'_$*!@8%^'Z!@8'_(&1D9'_(\""0D)#_%Z1D8%^/\\0$!#_ \""!_X$ /X! 0""
""$&(-$*!#_ $! 0'_/] ,$#_/\\&&&#_'Z!@8%^&\""0D)#_'V\""A8%^&>8D)#_$Z1D9%B(\"" _X\"" /X""
""! 0'^/ , PSP/P#' /\\,<H$\""C', @'R# ,&AD8F'(&!_P   ,,,,     _X&!! @0\"" 0 ""
""$! 0$!  @0(   \\5%14\"" X1$0G_!$1$1$./\\2$1$. T5%14. \""0D'\\ 'Y)""
""144X \\0$ C_  !7Q     7A$! $2# 3_ $!_H   \\0'Q ? \\0""
""$! ? X1$1$.#A$1\""1_'](1$0X @0$ @? (5%14)""
""  1$?X0!\\\"" 0$>!@& 088!X!#@$>""
""!$*! H1#X)!04X!$9%1,1""
""(&!;A 0   _P ""
"" ! 0;H&!""
"" @$\""""
""! (""
""\0"";                            int s,p,e,c,t,r,a,l;   /* l e a k a g e */
 
                                                     int
                                                   F(int o
                                                ,int n, int t
                                             ){char*p=(o*(136-o)
                                           >=1260)*7*(o-9)+G; for(
                                          n=!(o=-1); n=*p+++64*n-*G
                                        ,(o+=3)>>2<5-t; ); return 255
                                       &n>>2*o%8; } float L[0x400];int
                                     T(float a,float b,float l,float*e)
                                    {return L[0x3ff]||!(e[1]=b*a+l**e)||
                                   !T(l*a-b**e,b,l,e+1); } float f(int x)
                                  {int w=s<<!!T(1,6.135885e-3,-1.882472e-5
                                 +1,L); x=(x%w+w)%w<<9; return(L[x/s]*(s-x%
                                s)+L[x/s+1]*(x%s))/s; } int C(float*h,float*
                               i,int r,int P){ int x,y,c; for(y=0; h<i; ++y,h
                               +=r){ c=P<1; for(*h=x=0; x<8; c+=(1&P>>x&&P+(*
                              h+=f(e*(l+a*(2*x+1))*y)*f(s/2-e*a*y+e*a*y*y*(t/p
                             )/(s/p)))),++x); float z=f(y*t)*f(y*t); *h=z*(1+3*
                             z+2*z*z)/6**h/c; } return h-i-r+1; } void d(int w,
                            int n,FILE*f){int Z=s/t; int S[5]; float**P=M float*
                            )*c);for(r=0;r<c;++r){ P[r]=M float)*Z); C(P[r],P[r]
                           +Z,1,r); } float*x=M float)*Z*w); for (; ; ){ for(r=0;
                r<5        ; ++r){ int o=1; for(R,a=256; o&&--a; )for(o=t=0; t<Z;        o+=
               P[a][       t]!=x[w*t+n],++t); S[r]=a; } if(R-Z*w)break; for(r=a= -      12;r<
              5&&(a+=     a<11?22:1)<127; )for(r=-1; ++r<5&&F(a,1,r)==S[r]; );if(a     <127&&r
    ==5      )putchar(    a); } for(; --c; E P[c])); E P); fclose(f);}int main(int    q,char**v)      {s=
   44100     ;p=25; e=    55;c=256; t=75; r=q>1?v[1][0]*c+v[1][1]:0; a=7;l=16;if(r    ==11620){d     (atoi
  (v[2]),   atoi(v[3]),  q<5?stdin:fopen(v[4],""r"")); return 0; } char*H=malloc(c),*  h=H; sprintf   (H,""\0""
 ""Usage\n""  ""    %s [-""  ""h] [-d #c cid] file1 file2 ... (or stdin)""+(q-1&&r==11624  ),v[0]);if(*  H)q=1;int
 w=2>q?1:q -1; FILE**f=M FILE*)*w); f[0]=stdin; if(q>1)for(r=0; r<w; f[r]=fopen(v[r +1],""r""),++r); int l=s/t
 *w; float *b=M float)*l ),*t=b+l; int*i=M int)*w); for(; ; ){ int x=*h&&1>ungetc(* H++,*f); for(r =w; r--;)
{ i[r]=getc (f[r]); if(i[r]<0)i[r]=!++x; } if(x==w)break; while(++r<6){ while(C(b++,t,w,F(*i++,r< 5,r))); i-=
w; fwrite(b-=w,sizeof(float),l,stdout); } fflush(stdout); } while(fclose(f[--w]),w); E f); E b); E i); E h);}

","#include<stdio.h>
#include<stdlib.h>
#define M malloc(sizeof(
#define R fread(x,sizeof(float),Z*w,f)
#define E free(

char*G=
""   ""
""    '""
""@(*AP(  ""
""             ""
""                     ""
""                              ""
""                                        ""
""                                                   _""
""0   #@ .  \""C^*/XH\""Q2_U(D&(5*E0C 4B54DV   X    \""!9A@   89H$ !""
""0(/@@4 @(/@@(   #@T  @(\"" @(    P, , P# , #Y1244^   ?R 0#%)14,A#9)24$B 1""
""_)!0,$Y145%R Y145$^&!81T! #9)24DV#Y)24DP  ;&P     -C4 $$B% @ !04%!04 @4(D$ #!(1""
""4 @#U574$^'^0D)!_&Z1D9'_$*!@8%^'Z!@8'_(&1D9'_(\""0D)#_%Z1D8%^/\\0$!#_ \""!_X$ /X! 0""
""$&(-$*!#_ $! 0'_/] ,$#_/\\&&&#_'Z!@8%^&\""0D)#_'V\""A8%^&>8D)#_$Z1D9%B(\"" _X\"" /X""
""! 0'^/ , PSP/P#' /\\,<H$\""C', @'R# ,&AD8F'(&!_P   ,,,,     _X&!! @0\"" 0 ""
""$! 0$!  @0(   \\5%14\"" X1$0G_!$1$1$./\\2$1$. T5%14. \""0D'\\ 'Y)""
""144X \\0$ C_  !7Q     7A$! $2# 3_ $!_H   \\0'Q ? \\0""
""$! ? X1$1$.#A$1\""1_'](1$0X @0$ @? (5%14)""
""  1$?X0!\\\"" 0$>!@& 088!X!#@$>""
""!$*! H1#X)!04X!$9%1,1""
""(&!;A 0   _P ""
"" ! 0;H&!""
"" @$\""""
""! (""
""\0"";                            int s,p,e,c,t,r,a,l;   /* l e a k a g e */
 
                                                     int
                                                   F(int o
                                                ,int n, int t
                                             ){char*p=(o*(136-o)
                                           >=1260)*7*(o-9)+G; for(
                                          n=!(o=-1); n=*p+++64*n-*G
                                        ,(o+=3)>>2<5-t; ); return 255
                                       &n>>2*o%8; } float L[0x400];int
                                     T(float a,float b,float l,float*e)
                                    {return L[0x3ff]||!(e[1]=b*a+l**e)||
                                   !T(l*a-b**e,b,l,e+1); } float f(int x)
                                  {int w=s<<!!T(1,6.135885e-3,-1.882472e-5
                                 +1,L); x=(x%w+w)%w<<9; return(L[x/s]*(s-x%
                                s)+L[x/s+1]*(x%s))/s; } int C(float*h,float*
                               i,int r,int P){ int x,y,c; for(y=0; h<i; ++y,h
                               +=r){ c=P<1; for(*h=x=0; x<8; c+=(1&P>>x&&P+(*
                              h+=f(e*(l+a*(2*x+1))*y)*f(s/2-e*a*y+e*a*y*y*(t/p
                             )/(s/p)))),++x); float z=f(y*t)*f(y*t); *h=z*(1+3*
                             z+2*z*z)/6**h/c; } return h-i-r+1; } void d(int w,
                            int n,FILE*f){int Z=s/t; int S[5]; float**P=M float*
                            )*c);for(r=0;r<c;++r){ P[r]=M float)*Z); C(P[r],P[r]
                           +Z,1,r); } float*x=M float)*Z*w); for (; ; ){ for(r=0;
                r<5        ; ++r){ int o=1; for(R,a=256; o&&--a; )for(o=t=0; t<Z;        o+=
               P[a][       t]!=x[w*t+n],++t); S[r]=a; } if(R-Z*w)break; for(r=a=-       12;r<
              5&&(a+=     a<11?22:1)<127; )for(r=-1; ++r<5&&F(a,1,r)==S[r]; );if(a     <127&&r
    ==5      )putchar(    a); } for(; --c; E P[c])); E P); fclose(f);}int main(int    q,char**v)      {s=
   44100     ;p=25; e=    55;c=256; t=75; r=q>1?v[1][0]*c+v[1][1]:0; a=7;l=16;if(r    ==11620){d     (atoi
  (v[2]),   atoi(v[3]),  q<5?stdin:fopen(v[4],""r"")); return 0; } char*H=malloc(c),*  h=H; sprintf   (H,""\0""
 ""Usage\n""  ""    %s [-""  ""h] [-d #c cid] file1 file2 ... (or stdin)""+(q-1&&r==11624  ),v[0]);if(*  H)q=1;int
 w=2>q?1:q -1; FILE**f=M FILE*)*w); f[0]=stdin; if(q>1)for(r=0; r<w; f[r]=fopen(v[r +1],""r""),++r); int l=s/t
 *w; float *b=M float)*l ),*t=b+l; int*i=M int)*w); for(; ; ){ int x=*h&&1>ungetc(* H++,*f); for(r =w; r--;)
{ i[r]=getc (f[r]); if(i[r]<0)i[r]=!++x; } if(x==w)break; while(++r<6){ while(C(b++,t,w,F(*i++,r< 5,r))); i-=
w; fwrite(b-=w,sizeof(float),l,stdout); } fflush(stdout); } while(fclose(f[--w]),w); E f); E b); E i); E h);}

","#include<stdio.h>
int a = 256;int main(){for(char b[a+a+a],
*c=b ,*d=b+ a ,*e=b+a+a,*f,*g=fgets(e,(b[
a]=b [a+a] =a- a,a) , stdin);c[0]=a-a,f=c
,c=d ,d=e ,e=f, f= g,g =0,g = fgets(e,a+a
-a+ a -a+a -a+ a- +a,stdin ),f +a-a ; pu\
tchar(+10)) { for( int h= 1,i=1,j, k=0 ,l
=e[0]==32,m,n=0,o=c [ 0]== 32, p, q=0;d[q
];j=k,k=l,m=n,n=o,p=(j)+(k* 2 )+(l =(i = 
e[ q]&&i ) &&e[q +1 ]== 32,l*4)+(m* 8 )+(
16*  n  )+(  o  =(h =c[ q]&&h)&&c[q+1]== 
32,o* (16+16) )+0-0 +0, putchar("" ......""
/*\  (  |||  )  |/|/ / */"".')|)\\\\\\\\'""
"""" ""|||""   ""|||"" ""|'"" "")|)\\\\\\\\'/|/(/""
""(/'/|/\\|\\|'/|/(/(/'/|/\\|\\|""[d[q++]==
32?p:0]));}}/* typographic tributaries */
","#include<stdio.h>
int a = 256;int main(){for(char b[a+a+a],
*c=b ,*d=b+ a ,*e=b+a+a,*f,*g=fgets(e,(b[
a]=b [a+a] =a- a,a) , stdin);c[0]=a-a,f=c
,c=d ,d=e ,e=f, f= g,g =g,g = fgets(e,a+a
-a+ a -a+a -a+ a- +a,stdin ),f +a-a ; pu\
tchar(+10)) { for( int h= 1,i=1,j, k=0 ,l
=e[0]==32,m,n=0,o=c [ 0]== 32, p, q=0;d[q
];p=(j=k,j)+(k=l,k*2)+(l=(i = i&&e [q] ) 
&& e[q+1 ] ==32, l *4)+( m=n,m*8)+( n =o,
16*  n  )+(  o  =(h =c[ q]&&h)&&c[q+1]== 
32,o* (16+16) )+0-0 +0, putchar("" ......""
/*\  (  |||  )  |/|/ / */"".')|)\\\\\\\\'""
"""" ""|||""   ""|||"" ""|'"" "")|)\\\\\\\\'/|/(/""
""(/'/|/\\|\\|'/|/(/(/'/|/\\|\\|""[d[q++]==
32?p:0]));}}/* typographic tributaries */
","#include <math.h>
#define e(a, d) for(a=0;a<d;a++)
char*x=""	{k/;	y{ q ; }	c {	@;	={ 	S}	c}	W;;	{4}	k |; w{	+9;{;	8; 9{	S;	/}	y{ K}	{;}	l{	{ ~{ ;	V}k}g< t{	E	v;M{ B}y}	<{7;/;	Y} t}kp; Y} $Ha{e} w};} R} /{>}a	;} ;	`	$W-}	D}B; e;f;*;	~;A;s O{	o;>{1; m{ `} R}]{ T} v}={ I} ; }a?&; A}$;W;R{u} `; j}W;s{e}	A;[	R;	X  P; 4 ,F;({<8{#;%}@J{)}	}o^*{u/{'}]{	*}	}	;{ r}	f	/;}e} }w{ ${{;,; @ d	$}];>(}	I{ d}	&;	U}	{	y;Y}	{ P{	R} T}_{ }R } l	{ T}""
""';	|; ${=}	H} (}}8{cp{ s} #}+}	3}kF}<H	 .{ }G}x;	r	D c{; W; {	b;6; k{}B;*};	]} ~	{ ;;} !}}	x}v}n;^;	6V}Y{ h; ~	%*}! H; G{ r{ f;Y{ i}z} N  %}.{;	( 	v} _}	h; 7;<}	^;Z;0; ;	<;<; M; N{	}	_{O} !{f{]{M{;A{}	0;S}${	@;x}y}@	L;1	t{ 3{c{s{_{	`{	D{ ]}!;	${	_J;v+ }	3{B; ]{	}	E6	.x{?+; {x; }v{$};6}T; O; ; (}X7}	j; @} :}#	c{ !{ }x	KXt} >; ?{ c; ;	W;	; l;} h}p}	i{ %	}P}	/{	*}	%L; ;	!{ S{ n} ""
""x;  { 1	J;v{	U}({	@ X{ k} H;4;e J	6;;v; G{{]	&{A d{ lM{;K;;	4-{}} p h{;	{	rW;	v{;	f}	}1{^&{9{{ ;~;n;q{	9 R	6{	{ u;a;	;	U;	;Y}	+}}2sk; 8	{	JK;'i;	;$;	W{	P!{{{P	} [;	(;Q; Un;+}g{C;{{	; <{	vS} b;6`} ?{+	%;	}n;q{ r}k; ;{c{ S} 2}~{	4;RW v} R;	kI}|; d; [ O}5; ;;}Z d	{ {&;h	o{ V	v ;	_{{/}  F{f{r{4{{?{ 4;S}	:;];E}	;	&} #e !{>{H; {O{ 0;} H;	p; w}>{1}{	-} 4;""
""S}}	u L{ y} %;2  |{(}	/;,{ )}Y;g}	G}v;T}	};}i {{};[{ E{q} g;T{ ={}R;	k{ j;_;h}gPc;({	F;6}	}} 3	,}<; 0	 P;{'t}u};		}U}s{8{ E} >{}E	{G{H :{  Yog}	}F  D{ R{	 -;M?;= q}_ U	{ ;	 I	{ |{{}	 	1{,}{ x{{ U{ s;J}}	6{>7;,{ D{	{{ ;]}	;M; &}{ V}	n{&	T~;({	}[;	r{#	u{X 9;L; Uf})}   {T}		p{	N;	>{	>	}}D} m{1{	{}X; o}	w}$}	^v} K  f	,}	^3; { @{_} _{	o;	4}	h}H;#.{	{}	;	<{ {G{ $;{ ""
""z {a{{D;	?|}{{ ;	`} }	Q}j;4} 	3{Q}	{	* ;}r{a}	} R{p @;  N{ {f; A;8}L	$}{ }}J{ }	k{r} { [; -;p{	I{ {	&}J;	T}	?{Z{>;	5>; ];  wz ^}	u;);	H}	; L	&;	V	E{1{g;C} V} ~;U; ^{	J; { /}	{;(}y} aK /}	.};K;N{w{ `{	}T{l`; #;N{lX;	?; +}{ 	w{	;	q;	z;_;y} 8} 	&{X}	V{ WG}	,; [}U{	v{	Q;	w{	[	Y}N	Yu i{ {!A{}{ b0;	X~} ;-; 8{	E }	;F{	y{}{	"";
int y[3][1<<20],i[2048],X[166],p,r=1,f,s,O,P;
Q(){
int b;
r*=s;
p*=s;
if(s>>9){
if(b=*x){
p+=b-1-(b>10)-(b>13)-(b>34)-(b>92)<<4;
b=x[1];
x+=2;
p+=b<33?(b^8)*2%5:(b^6)%3*4+(*x++^8)*2%5+4;
}
}
else{
b=getchar();
p+=b<0?0:b;
}
}
t(E){
int u,k,F,*m;
if(r<s)Q();
m=X+E*2;
F=*m+m[1]+2;
u=r*(*m+1)/F;
if(k=p>=u){
p-=u;
r-=u;
}
else r=u;
m[k]++;
if(F>63){
*m/=2;
m[1]/=2;
}
return k;
}
n(E){
int a,b;
a=0;
while(!t(E+a))a++;
b=1;
while(a--)b=b<<1|t(4);
return b-1;
}
R(S,Y,T,Z,U,d,V)int*S,*T;
{
int G,a,j,H;
e(H,d)e(a,d){
G=0;
e(j,d)G+=T[j*Z+H*U]*lrint(cos(acos(-1)/d*(a+0.5)*j)*sqrt(2-!j)*1024);
S[a*Y+H*U]=G+(1<<V-1)>>V;
}
}
W(z,l,g){
int v,a,j,I,d,k,A,*o,c,B,q,C,h,w,J;
if(g>5||g>2&&t(g-3)){
c=1<<--g;
e(a,4)W(z+a%2*c,l+a/2*c,g);
}
else{
c=1<<g;
d=c*c;
q=n(73);
e(A,3){
o=y[A]+l*f+z;
B=A>0;
e(a,d)i[a]=0;
e(a,d){
if(t(61+g*2+B))break;
a+=n(5+B*10);
k=1-2*t(3);
i[a]=k*(n(25+(B+(a<d/8)*2)*10)+1)*(A?P:O);
}
if(!q){
v=0;
e(a,c){
v+=l?o[-f+a]:0;
v+=z?o[a*f-1]:0;
}
*i+=z&&l?v/2:v;
}
R(i+d,1,i,1,c,c,10);
R(o,f,i+d,c,1,c,10+g);
if(q){
C=q<17;
w=C?9-q:q-25;
e(a,c)e(j,c){
e(I,2){
h=a*w+w;
J=h&7;
h=(h>>3)+j+I;
if(k=h<0)h=(h*8+w/2)/w-2;
h=h<c?h:c-1;
i[I]=k^C?o[h*f-1]:o[-f+h];
}
o[C?j*f+a:a*f+j]+=*i*(8-J)+i[1]*J+4>>3;
}
}
}
}
}
K(b){
putchar(b<0?0:b>255?255:b);
}
main(D){
int a,l,L,M,g,N;
s=D>1?256:1968;
Q();
g=n(5);
f=1<<g;
N=f-n(5);
O=n(5);
P=n(5);
W(0,0,g);
printf(""P6 %d %d 255 "",f,N);
e(a,N*f){
l=y[0][a];
L=y[1][a];
M=y[2][a];
D=l-L;
K(D+M);
K(l+L);
K(D-M);
}
return 0;
}

","#include <math.h>
#define e(a, d) for(a=0;a<d;a++)
char*v=""T{ ;	; :}>{	y} 4};	1}	s;	{;9{ -	$} ; q{;	}	u;d}	}	3{d} ,{	3; 1fB{A{ 	}{+	D}9}	v{p{ pa} {	N{${ ;P;{	z;	({ .{*}n{w{ v; j{$}<}S}y}@; {	Q`{UN 9}0@{Z}'{ {%;	h;	5} g} e	S ~	q}'{#;e; B{;M}	mP; b{y 7{ u;rOK}%}  b}3 {	k _{ { a{D{	W} L} q	{ '}A;	AX;u}76*-	h{O;p}	} q}s}M} Q;;	Y }D; H{ A ASRs}*	n}P-{	{F}u; G;	l{ D}	~;	,;	} }8}{+Z	O	c;	;M{	A{Q} g} }}	n	U;k; |{	{<;	/}	H B}},} }	L;""
""_{ j}1{ z}	= h{	S;1; 2;O; ;	h{P;	v; c{	H;;N;d;l}P}	a; DBx}3{5	e A; {u} { FZ}8}	; ;	7;;{	$}~{	~{q [ x;n#};	#{W{3; M ;;	=;5; ;{}	s};	*;	v^}	QB}n 9}}	1e <;}g{v} C{ :{a{ 	} o}	R} .}}}	, { 4 VX{s}r@{v 3} 7{{;	y;{	{K; v 2O; t}&} ;	L} t}3/;	);e{(]f; ,}(}Nx;7}X} {A;R{;<;[;	G;C} O;	o}W}{	s; ); }{}[} (} C}	;	Y{	0}8}	{m}{K}{	^{.	;}';^;O	 }M{z;	J,;{	};;	""
""W;	n	H;	f;	{-; v{}; {	!} F- r	l} {m		} ;P}	9{p{ C}}G	={	3 @{ 5}4{	|	;	q	^;f} + -{-;	} w{	]{Q;.{	r{	Z  {	C	4{ +}o;	y}	b{[;	Wg{N}	o{	9;;,{	P{z;+}>; a{}}p[{{{{b{b; @H{{s;	{=}&}0; }} 8{N} {X;	}I;	3}	W{ 9;P{ {}	}	Hi}A {	U{}D;};t;s;	S;+;	{O}nV}	7; x{f{ P}	4}B{	M ;Y} g};?{	;{	t;5K	;*		{	H}w; SE	n{D} I{&; {} =9 }B;	W{4}p;	l{Au;	q{X~ +;O{ $j	{G; ;'rb}3 j9} }`} m}4;	r;	8; y;r}""
""t}>;	~}	E;	G}	9}	5	;/i}p{:; C{I}	;  2{ c{	x}}} ?}5{	i{ <} {})} C{ V} ?;X*;P{L{ c{M;T{<_{ {}M;	V; q{ }	$}l}P{Y{ #{N{9);]}	u{ {F	;( '	)%J	} x	=; Y	Q{Q}I'}B { }	g}|{! n ({} C;	#	|; {=}D{3} }L{F}#} ` k}	M;	]} J{	}7}	4} Z}	]}}	v6	;	X; Y{Qx}{	;};{	.<{b}7{ } 6	; {x;	& {]{~; [ P r}X}	W 9 } 	{O{ ;f	;)}:;&{-;	Eg{)}{0} Z{S}y;	} N;;  ; k}Y{`z;}? Kv}	&;	6 1; ^ Y{ }{){A{${	#}	M	w; ""
""6{ >}B}o}; M{	({ ({}H; ` h	j{z; };	7;f;	{ L; #{;{#}	4}	N{z j}{ o;3{j;l B} 9} F} J;F 2	;FTw+} y{ _		};l{	}}	4}	8} ]} l{ }K; ;@}{ v;b0; 0; }V;	*} R; p;j; &;_;9;	;	{J;W #}	{ h;^{t;|Q} [;U; >} ^}	/	~{ @}	{n	k{	N} {H{	j}	 {W;	X;	8{ 3; u:}T{P;0;  	k;	Z}	v{X} {;{`{#{ ;n} ;U}	d}d{&{n {|t{	aT} v}	$}7;Q;	f; W; O}	E;}	c} F{	8}AA;	~{ `;	w;	x<;G}f}7;rE{ ~{	n}F	5} ^{	c{;	{!{|} ""
""1{[}	;3}	;{ 8 a}pIg;9{ n}	-} T} e{	!}  ;		/0{9;V{>;  W}F;	+}L}	F{S}	+{ ,	}	 o; {	x;		i; 9 "";
int w[3][16384],h[512],T[160],p,q=1,g=128;
M(){
int b;
q*=1968;
p*=1968;
if(b=*v){
p+=b-1-(b>10)-(b>13)-(b>34)-(b>92)<<4;
b=v[1];
v+=2;
p+=b<33?(b^8)*2%5:(b^6)%3*4+(*v++^8)*2%5+4;
}
}
r(A){
int s,j,B,*m;
if(q<1968)M();
m=T+A*2;
B=*m+m[1]+2;
s=q*(*m+1)/B;
if(j=p>=s){
p-=s;
q-=s;
}
else q=s;
m[j]++;
if(B>63){
*m/=2;
m[1]/=2;
}
return j;
}
C(A){
int a,b;
a=0;
while(!r(A+a))a++;
b=1;
while(a--)b=b<<1|r(3);
return b-1;
}
N(O,U,P,V,Q,d,R)int*O,*P;
{
int D,a,i,E;
e(E,d)e(a,d){
D=0;
e(i,d)D+=P[i*V+E*Q]*(i>0?lrint(cos(acos(-1)/d*(a+0.5)*i)*1448.155):1024);
O[a*U+E*Q]=D+(1<<R-1)>>R;
}
}
S(x,k,l){
int t,a,i,F,d,j,y,*n,c,z,o,G,f,u,H;
if(l>2&&(l>4||r(0+l-3))){
c=1<<--l;
e(a,4)S(x+a%2*c,k+a/2*c,l);
}
else{
c=1<<l;
d=c*c;
o=C(70);
e(y,3){
n=w[y]+k*g+x;
z=y>0;
e(a,d)h[a]=0;
e(a,d){
if(r(60+l*2+z))break;
a+=C(4+z*10);
j=1-2*r(2);
h[a]=j*(C(24+(z+(a<d/8)*2)*10)+1)*(y?76:38);
}
if(!o){
t=0;
e(a,c){
t+=k?n[-g+a]:0;
t+=x?n[a*g-1]:0;
}
*h+=x&&k?t/2:t;
}
N(h+d,1,h,1,c,c,10);
N(n,g,h+d,c,1,c,10+l);
if(o){
u=(G=o<17)?9-o:o-25;
e(a,c)e(i,c){
e(F,2){
f=a*u+u;
H=f&7;
f=(f>>3)+i+F;
if(j=f<0)f=(f*8+u/2)/u-2;
f=f<c?f:c-1;
h[F]=j^G?n[f*g-1]:n[-g+f];
}
n[G?i*g+a:a*g+i]+=(*h*(8-H)+h[1]*H+4)>>3;
}
}
}
}
}
I(b){
putchar(b<0?0:b>255?255:b);
}
main(){
int a,k,J,K,L;
M();
S(0,0,7);
puts(""P6\n128 128\n255"");
e(a,g*g){
k=w[0][a];
J=w[1][a];
K=w[2][a];
L=k-J;
I(L+K);
I(k+J);
I(L-K);
}
return 0;
}

","char O,o[];main(l){for(;~l;O||puts(o))O=(O[o]=~(l=getchar())?4<(4^l>>5)?l:46:0)?-~O&printf(""%02x "",l)*5:!O;}
","int O;char o[17];int main(int l,char**v){for(;~l;O?O:puts(o))O=(O[o]=~(l=getchar())?4<(4^l>>5)?l:46:0)?-~O&printf(""%02x "",l)*5:!O;return!v;}
","/*
 * iocccsize - IOCCC Source Size Tool
 *
 * This IOCCC size tool source file is version 2017-12-25-v25.
 *
 * ""You are not expected to understand this"" :-)
 *
 * Public Domain 1992, 2015 by Anthony Howe.  All rights released.
 * With IOCCC minor mods in 2013-2017 by chongo (Landon Curt Noll) ^oo^
 *
 * SYNOPSIS
 *
 * 	ioccc [-kirs] < input
 *
 *	-k	keep comment blocks
 *	-i	IOCCC size rule (overall size, modified)
 *	-r	count C reserved words as 1 byte
 *	-s	suppress source output, write only the IOCCC 2nd size count
 *
 * DESCRIPTION
 *
 *	Taking input from standard input, apply the IOCCC Source Size Rule
 *	for 2001.  The program's official length is written to standard error.
 *	Also filter out C comment blocks (-k to keep) sending the modified
 *	source to standard output.
 *
 *	The 2001 Source Size Rule was:
 *
 *	Your entry must be <= 4096 bytes in length.  The number of octets
 *	excluding whitespace (tab, space, newline, form-feed, return), and
 *	excluding any ';', '{' or '}' followed by whitespace or end of file,
 *	must be <= 2048.
 *
 *	2013 Source Size Rule is (-r):
 *
 *	Your entry must be <= 4096 bytes in length.  The number of octets
 *	excluding whitespace (tab, space, newline, form-feed, return), and
 *	excluding any ';', '{' or '}' followed by whitespace or end of file,
 *	and where C reserved words, including a subset of preprocessor words,
 *	count as 1 byte, must be <= 2053 (first prime after 2048).
 */

/*
 * The official IOCCC rule 2 secondary limit on C code size
 *
 * The IOCCC size tool should be compiled as:
 *
 *      cc -pedantic -Wall -std=c99 iocccsize.c -o iocccsize
 *
 * This tool computes a 2nd size C code.  To check your program source
 * against the 2nd limit of rule 2, use the -i command line option.
 *
 * For example:
 *
 *      ./iocccsize -i < prog.c
 *
 * The IOCCC size tool, when using the -i option, may be summarized as:
 *
 *      The size tool counts C language keywords (primary, secondary, and
 *      selected preprocessor keywords) as 1.  The size tool counts all
 *      other octets as 1 excluding ASCII whitespace, and excluding any
 *      ';', '{' or '}' followed by ASCII whitespace, and excluding any
 *      ';', '{' or '}' octet immediately before the end of file.
 *
 * ASCII whitespace includes ASCII tab, ASCII space, ASCII newline,
 * ASCII form-feed, and ASCII carriage return.
 *
 * In cases where the above summary and the algorithm implemented by
 * the IOCCC size tool source code conflict, the algorithm implemented
 * by the IOCCC size tool source code is preferred by the judges.
 *
 * See the current IOCCC rules and guidelines for more information.
 * In particular, see the current IOCCC size rule for information about
 * the maximum value that this tool should print for an entry to be valid.
 */

/*
 * IOCCC Judge's remarks:
 *
 * This code contains undocumented features.  On the other hand, this code
 * is RTFS (for certain values of RTFS). One might say that this code
 * perfectly documents itself. :-)
 *
 * Many thanks to Anthony Howe for taking the time to put his OCD
 * (Obfuscated Coding Determination) into this code!
 */

/*
 * HINT: The algorithm implemented by this code may or not be obfuscated.
 *       The algorithm may not or may appear to be obfuscated.
 *
 * In particular:
 *
 *      We did not invent the algorithm.
 *      The algorithm consistently finds Obfuscation.
 *      The algorithm killed Obfuscation.
 *      The algorithm is banned in C.
 *      The algorithm is from Bell Labs in Jersey.
 *      The algorithm constantly finds Obfuscation.
 *      This is not the algorithm.
 *      This is close.
 */

#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <getopt.h>

#define FLAG_SILENCE		1
#define FLAG_KEEP		2
#define FLAG_RESERVED		4
#define FLAG_IOCCC		8
#define FLAG_SILLY_C		16
#define FLAG_SILLY_H		32

#define BUFFER_SIZE		521
#define MAX_SIZE		4096	/* IOCCC Rule 2 */
#define MAX_COUNT		2053	/* IOCCC Rule 2 */

static char usage[] =
""usage:  ioccc [-kirsch] < prog.c\n""
""\n""
""-k\t\tkeep block comments\n""
""-i\t\tprint official secondary IOCCC size to stdout\n""
""\t\tmax.size warnings to stderr, NOTE: implies -r -s\n""
""-r\t\tcount C reserved words as 1 byte\n""
""-s\t\tsuppress source output, write only the official size\n""
""-c\t\tan undocumented feature\n""
""-h\t\tyet another undocumented feature\n""
;

#define STRLEN(s)		(sizeof (s)-1)

typedef struct {
	size_t length;
	const char *word;
} Word;

/*
 * C reserved words, plus a few #preprocessor tokens, that count as 1
 *
 * NOTE: For a good list of reserved words in C, see:
 *
 *	http://www.bezem.de/pdf/ReservedWordsInC.pdf
 *
 * by Johan Bezem of JB Enterprises:
 *
 *	See http://www.bezem.de/en/
 */
/*
 * The following editorial plea expresses a view shared by more than zero
 * IOCCC judges. It may not represent the opinion of all those involved
 * with this code nor the International Obfuscated C Code Contest as a whole:
 *
 * The long list of reserved words below should be a source
 * of embarrassment to some of those involved in standardizing C.
 * The growing list of reserved words, along with an expanding set of
 * linguistic inventions has the appearance of feature
 * creep that, if left unchecked, risks turning a beautifully elegant
 * language into a steaming pile of biological excretion.
 *
 * The history of the IOCCC has taught us that even minor changes
 * to the language are not always well understood by compiler writers,
 * let alone the standards body who publishes them. We have enormous
 * sympathy for C compiler writers who must keep up with the creeping
 * featurism.  We are aware of some C standards members who share
 * these concerns.  Alas, they seem to be a minority.
 *
 * The C standards body as a whole, before they emit yet more mountains of new
 * standardese, might wish consider the option of moth-balling their committee.
 * Or if they must produce a new standard, consider naming whatever
 * follows c11 as CNC (C's Not C).  :-)
 */
static Word cwords[] = {
	/* Yes Virginia, we left #define off the list on purpose! */
	{ STRLEN(""#elif""), ""#elif"" },
	{ STRLEN(""#else""), ""#else"" },
	{ STRLEN(""#endif""), ""#endif"" },
	{ STRLEN(""#error""), ""#error"" },
	{ STRLEN(""#ident""), ""#ident"" },
	{ STRLEN(""#if""), ""#if"" },
	{ STRLEN(""#ifdef""), ""#ifdef"" },
	{ STRLEN(""#ifndef""), ""#ifndef"" },	/* XXX bugfix */
	{ STRLEN(""#include""), ""#include"" },
	{ STRLEN(""#line""), ""#line"" },
	{ STRLEN(""#pragma""), ""#pragma"" },
	{ STRLEN(""#sccs""), ""#sccs"" },
	{ STRLEN(""#warning""), ""#warning"" },
	/**/
	{ STRLEN(""_Alignas""), ""_Alignas"" },
	{ STRLEN(""_Alignof""), ""_Alignof"" },
	{ STRLEN(""_Atomic""), ""_Atomic"" },
	{ STRLEN(""_Bool""), ""_Bool"" },
	{ STRLEN(""_Complex""), ""_Complex"" },
	{ STRLEN(""_Generic""), ""_Generic"" },
	{ STRLEN(""_Imaginary""), ""_Imaginary"" },
	{ STRLEN(""_Noreturn""), ""_Noreturn"" },
	{ STRLEN(""_Pragma""), ""_Pragma"" },
	{ STRLEN(""_Static_assert""), ""_Static_assert"" },
	{ STRLEN(""_Thread_local""), ""_Thread_local"" },
	/*
	 * this comment is not expected to understand itself
	 */
	{ STRLEN(""alignas""), ""alignas"" },
	{ STRLEN(""alignof""), ""alignof"" },
	{ STRLEN(""and""), ""and"" },
	{ STRLEN(""and_eq""), ""and_eq"" },
	{ STRLEN(""auto""), ""auto"" },
	{ STRLEN(""bitand""), ""bitand"" },
	{ STRLEN(""bitor""), ""bitor"" },
	{ STRLEN(""bool""), ""bool"" },
	{ STRLEN(""break""), ""break"" },
	{ STRLEN(""case""), ""case"" },
	{ STRLEN(""char""), ""char"" },
	{ STRLEN(""compl""), ""compl"" },
	{ STRLEN(""const""), ""const"" },
	{ STRLEN(""continue""), ""continue"" },
	{ STRLEN(""default""), ""default"" },
	{ STRLEN(""do""), ""do"" },
	{ STRLEN(""double""), ""double"" },
	{ STRLEN(""else""), ""else"" },
	{ STRLEN(""enum""), ""enum"" },
	{ STRLEN(""extern""), ""extern"" },
	{ STRLEN(""false""), ""false"" },
	{ STRLEN(""float""), ""float"" },
	{ STRLEN(""for""), ""for"" },
	{ STRLEN(""goto""), ""goto"" },
	/* { STRLEN(""I""), ""I"" }, */		/* XXX seriously? */
	{ STRLEN(""if""), ""if"" },
	{ STRLEN(""inline""), ""inline"" },
	{ STRLEN(""int""), ""int"" },
	{ STRLEN(""long""), ""long"" },
	{ STRLEN(""noreturn""), ""noreturn"" },
	{ STRLEN(""not""), ""not"" },
	{ STRLEN(""not_eq""), ""not_eq"" },
	{ STRLEN(""or""), ""or"" },
	{ STRLEN(""or_eq""), ""or_eq"" },
	{ STRLEN(""register""), ""register"" },
	{ STRLEN(""restrict""), ""restrict"" },
	{ STRLEN(""return""), ""return"" },
	{ STRLEN(""short""), ""short"" },
	{ STRLEN(""signed""), ""signed"" },
	{ STRLEN(""sizeof""), ""sizeof"" },
	{ STRLEN(""static""), ""static"" },
	{ STRLEN(""static_assert""), ""static_assert"" },
	{ STRLEN(""struct""), ""struct"" },
	{ STRLEN(""switch""), ""switch"" },
	{ STRLEN(""thread_local""), ""thread_local"" },
	{ STRLEN(""true""), ""true"" },
	{ STRLEN(""typedef""), ""typedef"" },
	{ STRLEN(""union""), ""union"" },
	{ STRLEN(""unsigned""), ""unsigned"" },
	{ STRLEN(""void""), ""void"" },
	{ STRLEN(""volatile""), ""volatile"" },
	{ STRLEN(""while""), ""while"" },
	{ STRLEN(""xor""), ""xor"" },
	{ STRLEN(""xor_eq""), ""xor_eq"" },
	/**/
	{ 0, NULL }
};

/*
 * Keep track of discarded bytes by read_line() so count() can report
 * correct wc(1) equivalent counts.
 */
static int xlcount = 0;
static int xwcount = 0;
static int xbcount = 0;

static Word *
find_member(Word *table, const char *string)
{
	Word *w;
	for (w = table; w->length != 0; w++) {
		if (strncmp(string, w->word, w->length) == 0
		&& !isalnum(string[w->length]) && string[w->length] != '_')
			return w;
	}
	return NULL;
}

/*
 * ISO C11 section 5.2.1.1 Trigraph Sequences, leading sequence ""??""
 */
static char trigraph[] = ""=(/)'<!>-"";
static char asciimap[] = ""#[\\]^{|}~"";

static size_t
read_line(char *buf, size_t size)
{
	int ch;
	size_t length;

	if (buf == NULL || size == 0)
		return 0;

	for (size--, length = 0; length < size; ) {
		if ((ch = fgetc(stdin)) == EOF)
			break;
		/* Map NUL bytes to space, though ideally I should chuck'em. */
		if (ch == '\0')
			ch = ' ';
		/* Discard bare CR and those part of CRLF. */
		if (ch == '\r') {
			xbcount++;
			continue;
		}
		/* Trigraph mapping? */
		if (2 <= length && buf[length-2] == '?' && buf[length-1] == '?') {
			char *tri;
			if ((tri = strchr(trigraph, ch)) != NULL) {
				/* Mapped trigraphs count as 1 byte. */
				ch = asciimap[tri - trigraph];
				xbcount += 2;
				length -= 2;
			}
		}
		if (ch == '\n' && 1 <= length && buf[length-1] == '\\') {
			/* ISO C11 section 5.1.1.2 Translation Phases
			 * point 2 discards backslash newlines.
			 */
			xbcount += 2;
			xwcount++;
			xlcount++;
			length--;
			continue;
		}
		buf[length++] = (char) ch;
		if (ch == '\n') {
			break;
		}
	}

	buf[length] = '\0';

	return length;
}

/*
 * Count octets and strip comments.  The stripped C input is sent to
 * standard output.  If -s is set, then suppress the source output.
 * The various counters are sent to standard error.
 *
 * The counter output format is:
 *
 *	lcount wcount bcount icount isaved rcount rsaved
 *
 * where
 *	lcount	line count (same as wc)
 *	wcount	word count (same as wc)
 *	bcount	byte count (same as wc)
 *	icount	IOCCC secondary size rule count
 *
 * No longer reported:
 *	isaved	bytes saved by secondary size rule (bcount - icount)
 *	rcount	number of C reserved words
 *	rsaved	number of octets saved with -r
 */
static int
count(int flags)
{
	Word *w;
	unsigned long span;
	char *p, buf[BUFFER_SIZE];
	int lcount, wcount, bcount;
	int is_comment, is_word, dquote, escape;
	int count, keywords, saved, kw_saved;
	int squote;

	/* Start of buffer sentinel. */
	buf[0] = ' ';
	buf[BUFFER_SIZE - 1] = 0;     /* paranoia */

	count = saved = 0;
	keywords = kw_saved = 0;
	lcount = wcount = bcount = 0;
	is_comment = is_word = dquote = escape = 0;
	squote = 0;

	/*
	 * ""no matter how well you may think you understand this code,
	 *  you don't, so don't mess with it."" :-)
	 */
	while (0 < read_line(buf+1, sizeof (buf)-1)) {
		if (!(flags & FLAG_KEEP)) {
			/* Leading whitespace before comment block? */
			span = strspn(buf+1, ""\t "");

			/* Split / * across reads? */
			if (buf[1 + span] == '/' && buf[2 + span] == '\0') {
				(void) ungetc('/', stdin);
				continue;
			}

			/*
			 * no comment is a comment
			 */
			if (buf[1 + span] == '/' && buf[2 + span] == '/') {
				continue;
			}

			if (buf[1 + span] == '/' && buf[2 + span] == '*') {
				/* Strip leading whitespace before comment block. */
				is_comment = 1;
			}
		}

		for (p = buf+1; *p != '\0'; p++) {
			/* Within quoted string? */
			if (dquote) {
				/* Escape _this_ character. */
				if (escape) {
					escape = 0;
				}

				/* Escape next character. */
				else if (*p == '\\') {
					escape = 1;
				}

				/* Close quoted string? */
				else if (*p == '""') {
					dquote = 0;
				}
			}

			else if (squote) {
				if (escape)
					escape = 0;
				else if (*p == '\\')
					escape = 1;
				else if (*p == '\'')
					squote = 0;
			}

			/* Not quote string. */
			else {
				/* In C comment block? */
				if (is_comment) {
					/* Split * / across reads? */
					if (*p == '*' && p[1] == '\0') {
						ungetc('*', stdin);
						break;
					}

					/* End of comment block? */
					if (*p == '*' && p[1] == '/') {
						is_comment = 0;

						if (!(flags & FLAG_KEEP)) {
							/* Strip whitespace and newline
							 * trailing closing comment.
							 */
							p += 1 + strspn(p+2, "" \t\r\n"");
						}
					}

					if (!(flags & FLAG_KEEP)) {
						/* Strip octets in comment block. */
						continue;
					}
				}

				/* Split / / or / * across reads? */
				else if (*p == '/' && p[1] == '\0') {
					ungetc('/', stdin);
					break;
				}

				/* Start of comment line? */
				else if (*p == '/' && p[1] == '/') {
					if (!(flags & FLAG_KEEP)) {
						/* Strip comment to end of buffer. */
						break;
					}
				}

				/* Start of comment block? */
				else if (*p == '/' && p[1] == '*') {
					/* Begin comment block. */
					is_comment = 1;

					if (!(flags & FLAG_KEEP)) {
						/* Strip comment block. */
						p++;
						continue;
					}
				}

				/* C reserved word? */
				else if (!isalnum(p[-1]) && p[-1] != '_'
				&& (w = find_member(cwords, p)) != NULL) {
					keywords++;
					if (flags & FLAG_RESERVED) {
						bcount += w->length;
						if (!is_word) {
							is_word = 1;
							wcount++;
						}

						if (!(flags & FLAG_SILENCE)) {
							fputs(w->word, stdout);
						}

						/* Count reserved word as one. */
						kw_saved += w->length - 1;
						p += w->length - 1;
						count++;
						continue;
					}
				}

				/* Open single quote string? */
				else if (*p == '\'') {
					squote = 1;
				}

				/* Open quoted string? */
				else if (*p == '""') {
					dquote = 1;
				}
			}

			if (!(flags & FLAG_SILENCE)) {
				fputc(*p, stdout);
			}

			bcount++;
			if (*p == '\n') {
				lcount++;
			}

			/* Ignore all whitespace.
			 *
			 * Well not ALL in the Universe, just all here.
			 */
			if (isspace(*p)) {
				is_word = 0;
				saved++;
				continue;
			} else if (!is_word) {
				is_word = 1;
				wcount++;
			}

			/* Ignore curly braces and semicolons when followed
			 * by any whitespace or EOF.
			 */
			if (strchr(""{;}"", *p) != NULL && (isspace(p[1]) || p[1] == '\0')) {
				saved++;
				continue;
			}

			/* Count this octet. */
			count++;
		}
	}

	if (flags & FLAG_IOCCC) {
		/* Output the official IOCCC size tool size to standard out */
		printf(""%d\n"", count);
		if (MAX_SIZE < bcount) {
			fprintf(stderr, ""WARNING: program size (%d) exceeds IOCCC Rule 2a max. size (%d)\n"", bcount, MAX_SIZE);
		}
		if (MAX_COUNT < count) {
			fprintf(stderr, ""WARNING: iocccsize count (%d) exceeds IOCCC Rule 2b max. count (%d)\n"", count, MAX_COUNT);
		}
	} else {
		/* The Ugly Truth */
		fprintf(
			stderr, ""%d %d %d %d %d %d %d\n"",
			lcount + xlcount, wcount + xwcount, bcount + xbcount, count,
			saved, keywords, kw_saved
		);
	}

	return count;
}

int
main(int argc, char **argv)
{
	int ch;
	int flags = 0;

	while ((ch = getopt(argc, argv, ""kirsch"")) != -1) {
		switch (ch) {
		case 'k':
			flags |= FLAG_KEEP;
			break;
		case 'i':
			flags |= FLAG_IOCCC | FLAG_RESERVED | FLAG_SILENCE;
			break;
		case 'r':
			flags |= FLAG_RESERVED;
			break;
		case 's':
			flags |= FLAG_SILENCE;
			break;
		case 'c':
			flags |= FLAG_SILLY_C;
			break;
		case 'h':
			flags |= FLAG_SILLY_H;
			break;
		default:
			fprintf(stderr, ""%s\n"", usage);
			return 2;
		}
	}
	// make test hack: while for do until goto if else switch case default continue return break
	if (flags == (FLAG_KEEP | FLAG_IOCCC | FLAG_RESERVED | FLAG_SILENCE | FLAG_SILLY_C | FLAG_SILLY_H)) {
		fprintf(stderr, ""The source toasts you a glass to your health!\n""
				""BTW: judges have toasted a glass of this at the South Pole.\n""
				""Now try using useful flags.\n\n""
				""%s\n"", usage);
		return 3;
	} else if (flags & FLAG_SILLY_C) {
		fprintf(stderr, ""Do you not see this is C?\n\n""
				""%s\n"", usage);
		return 4;
	} else if (flags & FLAG_SILLY_H) {
		fprintf(stderr, ""%s\n"", usage);
		return 5;
	}

	/*
	 * count as directed - 1 Muha .. 2 Muhaha .. 3 Muhahaha ...
	 */
	(void) count(flags);

	/*
	 * All Done!!! All Done!!! -- Jessica Noll, age 2
	 */
	return 0;
}
","/*/int if while -- how many keywords?/*/
main() {
	printf(""howdy!\n"");
}
","// bug shows under -k
//* int if while
main(int ac, char **av) {
	if (ac > 1)
		while(--ac) puts(*++av);
	else
		puts(""none"");
}
","/* word count incorrect except with -k; view output with no args */
main(){
printf(/*testing*/
""hello, world\n"");
}
","// this shows the impact of "" quotes with -k
char*dquote=""dquote"";
main(int ac, char **av) {
	if (ac > 1 && av[1][0] == '\""')
		printf(dquote);
	if (ac == 0)
		printf(""int ac is zero\n"");
}
","// I is an identifier, not a reserved word
enum Foo {
	I = 1,
	O = 2
};
main(int ac, char**av) {
	for(--ac; *++av; )
		switch (*av[0]-'0') {
		case I: puts(""input""); break;
		case O: puts(""output""); break;
		default: puts(""whatever""); break;
		}
}
","#include<stdio.h>
#undef FOO
#ifndef FOO
int main() {
	printf(""howdy!\n"");
}
","#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
typedef unsigned char*_;
_ s,i,z,e,O,F=
#include W

       ""; ; } { { { {	{ } { { } ; }	{ ; ; { } ; {	{ } ; } ; { {	{ { } { { } \
	; } { { { { {	} { ; } { } {	{ } { { } { {	{ ; ; { { } {	{ } { ; } { \
	    } { {	{ { {	} ; }	{ } {		{ } {		{ { \
	    } { ;	} { }	{ { {	{ { }		; } {		} { \
	    { { }	{ { }	; ; {	; ; {		{ } {		{ } \
	    { ; }	{ } {	{ { }	{ } {		{ { ;		{ { \
	    { } {	{ } {	{ { {	} { {		{ { {		} ; \
	; { ; ; { { {	{ { } { ; } {	} { { { { { }	; ; { ; ; { {	; { ; { { { \
	} { } { { { ;	{ ; { { { ; ;	{ } { { { } {	; } { } { { {	{ { } { { { \
	; ; { { } { ;	{ { { } { } {	{ { ; { ; { {	{ ; ; { { { {	{ } { { { { \
	\
	} { { { { { }	; } { } { { {	{ { { } { { {	{ } ;		} ; { { { } \
	{ { { { { } {	{ } { { { } {	{ ; { { } { ;	{ { {		{ ; { { ; { \
	{ { {		{ } }		{ { ;	{ } {	{ { ;		; { \
	{ ; { ; { } {	} ; {		} { } ; { ; }	{ { {		} { ; { } \
	{ ; { { { } {	; } }		{ ; ; { { } {	; ; }		{ ; ; ; { \
		} } {	{ } }		{ ; {	{ } }	{ } }		} { \
		; } {	} } {		; } }	{ ; ;	{ } }		} { \
	{ { { { { } }	} ; ; { } { ;	; } {	; } ;	} { } { } } }	{ } { } { } \
	{ ; } { ; ; {	} { } } { } {	; } }	} { }	} } } } } ; }	} } } ; { } \
	{ } ; } } } }	; } } } ; { {	} } }	; ; }	} { { } } } ;	{ { "" ; ; ; ;
unsigned v,o,l,A,T,I,L,E,c,H,a,C,K,R,Z=256; char n,M[2053]; int*q; int h(_ F,int l) { for(;
 l--&&*F; putchar(*F++)); return 0; } int r(int I,int O){ return!fprintf(O&2?stderr:stdout
    ,""%d%c"",I,O&1?l:32); } int m(char O){ for(a=0; a-O&&z<e; L+=((a=*z++)==92?*z==a||*
					z==39||*z==
					34||*z==l?*
     z++:a:a)==l); return a; } int d(_ e,int l){ _ F=M+Z+q[l]; _ O=M+Z+q[n=-~l]; for(
  ; l<*q&&n-l&&F<O; F+=l)for(n=0; n<l&&e[n]==F[n]; ++n); return l&&n==l?T +=--l,++K:0; }
 int j(){ for(c=0,o=Z,O=z; z<=e&&M[c=*z++]&16; ++C,L+=c==l); for(s=z-1; z>=e; )return C-=
!c,c; for(a=M[c]; v&32&&c==35; )return m(l),o+2; for(; a&8; ){ for( ++o; M[c] &12; c=*z++);
return d(s,--z-s)?o:++o; } for(; a&4; ){ for(c=c==48&&(*z|32)==120? *++z:c; M[c]&6; c=*z++)
; return o+(c==46?strtod(s,(char**)&z),5:!--z^4); } for(; c==47&& (*z==c||*z==42); ){ for(;
c==*z++; )return m(l),o; for(m(42); z<e			&&*z++-47; --z, m(42)); return o; }
return c==39||c==34?m(c),c:*z++==61&&			 a&64?c|128: a&128&&z[~0]==c?*z==61
&&a&32&&c-45?++z,c|o|128:c|o:a&/*		    2052   */32&&z[~0]==62?o+6:*--z?c:32; }
void g(int l,int O){ for(c=0;				    c<l; ++c)(a=M[s[c]]&16)?--I:M[s
[c]]&1&&M[s[c+1]]&16?--I:0,			  O=O	      ?!a:! a?++A:O; } void f(int T
,int F){ int n; _ o=O; for			 (c=		v&2; H==Z; L-=!(v&2 ||o[~0]
-l),C-=o-O)for(H=0; o<s&&			*o++		 -l; ); O-=O==s &&O[~0]==l;
T-=T==34||T==39? g(F,1),		       0:Z		  ; a=O==s&&s>i; for(A-=T&&
a&&M[O[-1]]-16,!(v&8)&&			      (T|		  c)?h(O,s-O), h(s,F):T; !T
++; H=Z+s[1]-42){ for(			     n=a		   ; c; c^=c)for(I+=F,g(F,n
),n=c=2; c<F&&s[1]==47			    ; ++		   c)a? (a=M[s[c]]&8)||d(s+
n,c-n)&&(I-=c-++n):M[s			   [c]			   ]&8?a= n=c:a; for(c=v&2;
!c;A+=!a&&M[s[F]]-16&&						   s[1]-47)for(c=0; c<F; ++
c)L-=s[c]==l; for(o=s;						   o>O &&*--o-l; ); C-=*o==
l||o==i||O[~0]==l?s-o-						   (*o==l):0; } } int b(int
l){ for(a=0; l--; a+=c-						   59?c==125:-~1) for(a+=a+
a; (c=* F++)== 32||c==9;					  ); return a; } int main (
int S,char**H){ for(s=e=					 M+Z,q= (int*)s,e+=Z/2; *F-
59; *e++=*F++)for(; *F==32				       ; ++F,q[++*q]=e-s); for(q[++
*q]=e-s,z=M,v=b(3); v--; )for				     (z+= b(3),o= b(3),c=b(5); o--;
*z++=c); for(*++e=l=10,O=s=M+4*				   Z,v=b (3); v--; O[o]=b(5))o=b(5)
; for(O+=32,v=0; ~(a=getopt(S,H,O)		       ); )for(v|=s[a&31]; !(a ^~-Z >>2); )
return h(U,~0); for(O+=32,a=0,o=2; c=		   getchar(),o<a|| (i=realloc(i ,a+=Z)),~c;
i[o]=c,c==l+3?v&1&&++E: c==l&&i[~-o]==92 ?--o,++L,v&1?E+=2,++A:A:++o)O ??(c??)&&!(i??(??--o
??)&i??(o-2??)??'63)?o-=2,E+=2,c=O??(c??):0; for(F=e,e=i+o,z=i+=2,*e=0; o=j(); v&1?f(o,a):v
&8?v:v&2||o-Z?~v&32&&r(o,0),h(s,a),z[-1]-l&&h(F,1):0)a=z-s,o-Z?C+=a,++A,I+=v&4&&o==-~Z?1:M[
o]==1&&(M[*z]==16||!*z)?0:a:a; a=e-O; a&&v&1?f(0,a),v&8||h(O,a):a; v&2?C=e-i:0; T*=v>>2&1;R
=C-I-T; C+=E; return v&32?0:v&16?r(I,1):r(L,2)+r(A,2)+r(C,2)+r(I,2)+r(R,2)+r(K,2)+r(T,3); }
","/*
 * tac - tokenize and count C-like languages
 *
 * tac is offered as a replacement for iocccsize.
 * Version 2018.04.18
 * Public Domain 2015 by Dave Burton.
 * Please keep this attribution with the source code.
 *
 * cc -O3 -DW=\""keywords\"" -Wall -pedantic -o tac tac.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

/*
 * The keywords recognized by tac should be defined in an external file,
 * filtered by the following script into a new file, and #included
 * by defining the preprocessor variable W as this new file.
 *
 * The input to the script is a list of keywords, one word per line,
 * in any order.  The output is a single string suitable for tac.
 * --------------------------------------------------

#!/bin/sh
awk '/^[^$]/{l=length;m=m>l?m:l;a[l]=a[l]$1}
     END{printf""\"""";for(i=1;i<=m;++i)printf"" ""a[i];print""\""""}' $*

 * --------------------------------------------------
 * The pre-defined string below is the IOCCC reserved word list for 2016.
 * It was created by the above script, then inserted here in case the
 * source keywords file is not available.
 *
 * The format of the keyword string is precise; addition or removal of
 * a single character will cause improper operation.
 * 
 * DO NOT EDIT the string kw; instead:
 *
 *	mkkeywords < my.list > my.keywords
 *	cc -DW=\""my.keywords\"" -o tac tac.c
 */

char *keywords = """"
#ifndef W

""  ifdoor intfor#ifandnotxor voidcharelsegotocaselongenumautobooltr\
ue whilebreakconstfloatshortunion#else#elif#line_Boolfalsecomplbito\
ror_eq returnsizeofstructdoubleswitchstaticexternsigned#ifdef#endif\
inline#errorbitandand_eqnot_eqxor_eq typedefdefault#ifndef#pragma_A\
tomic_Pragmaalignasalignof #includeunsignedcontinuevolatileregister\
restrict#warning_Complex_Generic_Alignas_Alignofnoreturn _Noreturn \
_Imaginary  thread_local _Thread_localstatic_assert _Static_assert""

#else
#  include W
#  undef W
#endif
;

int cline, cword, cbyte, cioccc, ckey, cextra;			// counts
int tsaved, tkey;						// totals
int fkeep, fsuppress, freserved, fioccc, fcompat, ftoken;	// flags

unsigned char *buf, *cur, *end, *white, *start;

enum {
	  CPP   = 256
	, CMT   = 257
	, KEYW  = 258
	, DIVEQ = 259
	, MULEQ = 260
	, MODEQ = 261
	, ADDEQ = 262
	, SUBEQ = 263
	, XOREQ = 264
	, OREQ  = 265
	, ANDEQ = 266
	, RSHEQ = 267
	, LSHEQ = 268
	, NOTEQ = 269
	, EQ    = 270
	, GE    = 271
	, LE    = 272
	, OR2   = 273
	, AND2  = 274
	, PP    = 275
	, MM    = 276
	, PTR   = 277
	, LSH   = 278
	, RSH   = 279
	, INT   = 300
	, FLOAT = 301
	, ID    = 302
	, DOT3  = 303
};

enum {
	  O=0x01	// octal
	, H=0x02	// hex
	, D=0x04	// decimal
	, I=0x08	// identifier
	, W=0x10	// whitespace
	, B=0x20	// brace, semi
	, OHD = O|H|D
	, HD  = H|D
	, HI  = H|I
};

char tab[256] = {
	 W, 00, 00, 00, 00, 00, 00, 00,   00,  W,  W,  W,  W,  W, 00, 00,
	00, 00, 00, 00, 00, 00, 00, 00,   00, 00, 00, 00, 00, 00, 00, 00,
	 W, 00, 00,  I, 00, 00, 00, 00,   00, 00, 00, 00, 00, 00, 00, 00,
	OHD,OHD,OHD,OHD,OHD,OHD,OHD,OHD,  HD, HD, 00,  B, 00, 00, 00, 00,

	00, HI, HI, HI, HI, HI, HI,  I,    I,  I,  I,  I,  I,  I,  I,  I,
	 I,  I,  I,  I,  I,  I,  I,  I,    I,  I,  I, 00, 00, 00, 00,  I,
	00, HI, HI, HI, HI, HI, HI,  I,    I,  I,  I,  I,  I,  I,  I,  I,
	 I,  I,  I,  I,  I,  I,  I,  I,    I,  I,  I,  B, 00,  B, 00, 00,
};

char tri[256] = {
	['='] = '#',
	['('] = '[',
	['/'] = '\\',
	[')'] = ']',
	['\'']= '^',
	['<'] = '{',
	['!'] = '|',
	['>'] = '}',
	['-'] = '~',
};

#define is(x, c) (tab[c]&(x))

/*
 * discard backslash-newline as-if not present, even if trigraph backslash
 * iocccsize counts tri as xbcount+=2,
 * and bs-nl as xb+=2, xw++, xl++ to match wc(1)
 */

void readsource() {
	int c, d, o=2, len=4096;
	buf = malloc(len);
	while ((c = getchar()) != EOF) {
		if (c == '\r') {
			if (fcompat) ++cextra;
			continue;
		}
		if (buf[o-1] == '?' && buf[o-2] == '?' && tri[c]) {
			c = tri[c];
			o -= 2;
			if (fcompat) cextra += 2;
		}

		/*
		 * digraph support:
		 * translating digraphs after trigraphs is,
		 * for the purposes of this code, essentially during tokenization.
		 */
		d = c;
		switch (buf[o-1]) {
		case '<': d = (c == ':' ? '[' : c == '%' ? '{' : c); break;
		case '%': d = (c == '>' ? '}' : c == ':' ? '#' : c); break;
		case ':': d = (c == '>' ? ']' : c); break;
		}
		if (c != d) {
			c = d;
			o--;
			if (fcompat) ++cextra;
		}

		if (c == '\n' && buf[o-1] == '\\') {
			--o;
			cline++;
			if (fcompat) {
				++cword;
				cextra += 2;
			}
		} else
			buf[o++] = c;
		if (o == len)
			buf = realloc(buf, len+=4096);
	}
	buf[o] = 0;
	end = buf + o;
	cur = buf += 2;
}

/*
 * keyword recognition: kw is sorted by length, space separated between lengths
 *	e.g. ""  ifdo forint#if charvoidelsegoto...""
 * build a table of offsets for each length
 *	e.g. [0]0, [1]1, [2]2, [3]7, [4]17, ...
 * this allows scans for only words of same length instead of entire list
 * trade-off is a small, but constant start-up cost to get a configurable
 * word list (backported from obfuscated code: it was too nice to give up)
 */

int nkwoff, kwoff[32];	   // allows keywords up to 32 characters in length

void kwinit() {
	char *k = keywords;
	for (nkwoff = 0; *k; ++k)
		while (*k == ' ')
			kwoff[++nkwoff] = ++k - keywords;
	kwoff[++nkwoff] = ++k - keywords;
}

int iskw(unsigned char *s, int len) {
	int found = 0;
	if (len < nkwoff) {
		char *off = keywords + kwoff[len];
		char *end = keywords + kwoff[len + 1] - 1;
		for (; !found && off < end; off += len)
			found = *s == *off && !strncmp((char*)s, off, len);
		if (found) {
			++ckey;
			tkey += len - 1;
		}
	}
	return found;
}

int want(char m) {
	while (cur < end) {
		if (*cur == '\\') {
			/*
			 * need to only ignore: ntbrfv\'""a?, octal, x, hex
			 * 0111 = two chars, \091 = three, \xabc = one char(!)
			 * for our purposes, only need: ' ""  and \ newline,
			 * but readsource eats \ newline, so only quotes here
			 */
			if (cur[1] == '\\' || cur[1] == '\'' || cur[1] == '""') {
				cur += 2;
				continue;
			}
		}
		if (*cur == '\n') ++cline;
		if (*cur++ == m) return m;
	}
	return 0;
}

int follow(char m, int y, int n) {
	if (*cur == m) return ++cur,y;
	return n;
}

int follow2(char m, int y, int n, int y2) {
	if (*cur == m) return ++cur,y;
	if (*cur == n) return ++cur,y2;
	return n;
}

int skipwhite() {
	int c;
	for (c=*cur++; cur<=end && is(W, c); c=*cur++) {
		++cbyte;
		if (c == '\n') ++cline;
	}
	return c;
}

/*
 * CPP tokens may extend beyond a single line of text and include comments
 * To do this correctly, need to scan and remove comments during readsource
 * and present comments as whitespace.  Note that ""# include"" is a valid CPP
 * token, and does not match ""#include"".
 *
 * Because the global pointers cur, start and white are well-known, and
 * because comments are not consumed during readsource, it is more difficult
 * to parse CPP stuff.  Also note that for backwards compat, we need to also
 * count words correctly, with and without -k.
 */

int lex() {
	int c, t;

	white = cur;
	c = skipwhite();
	start = cur-1;

	if (cur >= end)
		return c;

	switch (c) {
	case '\'': want(c); return c;
	case '""':  want(c); return c;
	case '/':
		t = follow2('=', DIVEQ, c, CMT);
		if (t == CMT)
			want('\n');
		else if (t == c && (t = follow('*', CMT, c)) == CMT)
			do want('*'); while (cur<end && follow('/', 0, 1));
		return t;
	case '*':  return follow ('=', MULEQ, c);
	case '%':  return follow ('=', MODEQ, c);
	case '=':  return follow ('=', EQ,    c);
	case '!':  return follow ('=', NOTEQ, c);
	case '^':  return follow ('=', XOREQ, c);
	case '|':  return follow2('=', OREQ,  c, OR2);
	case '&':  return follow2('=', ANDEQ, c, AND2);
	case '+':  return follow2('=', ADDEQ, c, PP);
	case '-':  t =    follow2('=', SUBEQ, c, MM);
	   return t==c?   follow ('>', PTR,   t) : t;
	case '>':  t =    follow2('=', GE,    c, RSH);
	   return t==RSH? follow ('=', RSHEQ, t) : t;
	case '<':  t =    follow2('=', LE,    c, LSH);
	   return t==LSH? follow ('=', LSHEQ, t):t;

	case '#':  if (ftoken || !fcompat) return want('\n'), CPP;
	case '.':  if (cur[0] == c && cur[1] == c) return cur+=2, DOT3;
	}

	if (is(D, c)) {
	    if (c == '0' && (*cur|32) == 'x')
		c = *++cur;
	    while (is(OHD, c))
		c = *cur++;
	    if (c == '.' || (c|32) == 'e') {
		(void)strtod((char*)start, (char**)&cur);  // find end of float
		return FLOAT;
	    }
	    return --cur, INT;
	}

	if (is(I, c)) {
	    while (is(I|D, c))
	    	c = *cur++;
	    --cur;
	    return iskw(start, cur-start) ? KEYW : ID;
	}

	return c ? c : ' ';	// allows nulls in source code
}

// iocccsize compat: adjust whitespace counts
void compat_words(int tlen, int inword) {
	int c;
	for (c=0; c<tlen; ++c) {
		int isw = is(W,start[c]);
		if (isw || (is(B,start[c]) && is(W,start[c+1])))
			--cioccc;
		if (inword)    inword = !isw;
		else if (!isw) inword = ++cword;
	}
}

void compat_kw(int tlen, int inword) {
	int c, w=0;
	for (w=c=2; c<tlen; ++c) {	// skip comment lead-in chars
		int isw = !is(I|D,start[c]);
		if (inword) {
			inword = !isw;
			if (!inword && iskw(start+w, c-w))
				cioccc -= c-w-1;
		} else if (!isw)
			inword = w = c;
	}
}

void compat(int t, int tlen) {
	static int tprev;
	int c;
	if (tprev == CMT) {
		/*
		 * do not bcount spaces following comment blocks,
		 * including the newline!  nor lcount the newline following
		 * a comment block if last on line
		 */
		unsigned char *ow = white;
		while (ow<start && *ow++ != '\n')
			;
		if (!fkeep && ow[-1] == '\n')
			--cline;
		cbyte -= ow-white;
		tprev = 0;
	}
	// new-style comments eat preceding newline,
	// leaving no whitespace if token starts line
	// add it back here for compat word boundary detection
	if (white == start && white[-1] == '\n')
		--white;
	if (t == CMT) {
		// do not count newlines within comments
		// and checks for keywords in new-style comments
		if (fkeep) {
			int inword = white==start && start>buf;
			cioccc += tlen;
			if (start[1] == '/')
				compat_kw(tlen, inword);
			compat_words(tlen, inword);
		} else for (c=0; c<tlen; ++c)
			if (start[c] == '\n') --cline;

		// nor spaces before comments IFF the comment
		// is first non-white on line
		unsigned char *os = start;
		while (os > white) {
			if (*--os == '\n')
				break;
		}

		// look for last ends with newline,
		// only remove ccounts if whitespace
		if (*os == '\n' || os == buf || white[-1] == '\n')
			cbyte -= start - os - (*os == '\n');

		// look for whitespace before the comment, as well as after
		if (!fkeep
		&& (white != start || start == buf)
		&& !is(W, start[tlen]) && start[1] == '*')
			++cword;

		if (start[1] == '*')
			tprev = CMT;
	} else if (t == '""' || t == '\'') {
		// iocccsize -i does not count whitespace WITHIN a string!!!
		// and {;} can be ""free"" within a string if follows the ""rules""
		compat_words(tlen, 1);
	}
	// count words, not tokens (a preceding old-style CMT is whitespace)
	if (t && t != CMT && white == start && start > buf)
		--cword;
	if (!fsuppress && (t != CMT || fkeep))
		printf(""%.*s"", (int)(start-white)+tlen, white);
}

void count() {
	int t, tlen;
	kwinit();
	while ((t=lex())) {
		tlen = cur-start;
		if (t != CMT) {
			cbyte += tlen;
			++cword;
			if (freserved && t == KEYW)
				cioccc += 1;
			else if (t < 256 && is(B, t) && (is(W, *cur) || !*cur))
				;
			else
				cioccc += tlen;
		}
		if (fcompat)
			compat(t, tlen);
		else if (!fsuppress && (t != CMT || fkeep)) {
			if (!ftoken) printf(""%3d "", t);
			printf(""%.*s"", tlen, start);
			if (cur[-1] != '\n') printf(""\n"");
		}
	}

	if (fcompat) {
		// process comments just before end of file
		compat(0, end-white);
	}

	if (fkeep) cbyte = end - buf;
	if (!freserved) tkey = 0;
	tsaved = cbyte - cioccc - tkey;
	cbyte += cextra;
}

int main(int ac, char **av) {
	static char usage[] = ""[flags] [file]\n\
	-t  tokenize input\n\
	-c  compatible count and display token ids\n\
	-k  keep comments\n\
	-s  suppress source\n\
	-r  reserved words count as 1\n\
	-i  ioccc size (implies -rs)\n\
	-h  this help"";

	fcompat = 1;	// default: compact with iocccsize: invert sense of -c

	int c;
	while ((c = getopt(ac, av, ""?tcksrih"")) != EOF) {
	    switch (c) {
	    case 't': ftoken    = 1; // fallthru - -t implies -c
	    case 'c': fcompat   = 0; break;
	    case 'k': fkeep     = 1; break;
	    case 's': fsuppress = 1; break;
	    case 'r': freserved = 1; break;
	    case 'i': fioccc = freserved = fsuppress = fcompat = 1; break;
	    case 'h': // fallthru, alias for -?
	    default:
	    	fprintf(stderr, ""%s %s\n"", av[0], usage);
		return 1;
	    }
	}

	ac -= optind;
	av += optind;
	if (ac > 0 && !freopen(*av, ""r"", stdin)) {
		perror(*av);
		exit(1);
	}

	readsource();
	count();

	if (!ftoken) {
		if (fioccc) printf(""%d\n"", cioccc);
		else        fprintf(stderr, ""%d %d %d %d %d %d %d\n"",
				cline,cword,cbyte,cioccc,tsaved,ckey,tkey);
	}
	return 0;
}
","main(int ac, char **av) {
	if (av[0][0] == '""') {
		switch (av[0][1]) {
		case 'a': printf(""a\n""); break;
		case 'b': printf(""b\n""); break;
		}
	}
	while (--ac > 0)
		printf(""%d"", ac);
	return 0;
}
","/*
main(int ac, char **av) {
	if (av[0][0] == '""') {
		switch (av[0][1]) {
		case 'a': printf(""a\n""); break;
		case 'b': printf(""b\n""); break;
		}
	}
	while (--ac > 0)
		printf(""%d"", ac);
	return 0;
}
*/
main() { printf(""hello, world\n""); }
","#include <stdio.h>
char a[] = ""main() { return printf(\"" hello, world!\n\""     \"" } ; // this is not a comment"";
int main() { printf(""%s\n"", a); }
","#ifndef FOO
#include <stdio.h>
int main() {
	return printf(""hello, world!\n"");
}
#endif
","#include <stdio.h>
	/* one */   int b;
char a[] = ""main() { return printf(\"" hello, world!\n\""     \"" } ; // this is not a comment"";
int main() { printf(""%s\n"", a); }
","#include <stdio.h>

    int main() {
    	/* a comment */ printf(
	""hello, world!\n""
	);
    }
","	  // leading whitespace comment
main(int ac, char **av) {
	char foo[] = ""line one\n\
	two\n\
	three\n"";
	if (av[0][0] == '""') {
		switch (av[0][1]) {
		case 'a': printf(""a\n""); break;
		case 'b': printf(""b\n""); break;
		}
	}
	while (--ac > 0)
		printf(""%d"", ac);
	printf(foo);
	return 0;
}
","	  /* one */		/* two */  
main(int ac, char **av) {
	if (av[0][0] == '""') {
		switch (av[0][1]) {
		case 'a': printf(""a\n""); break;
		case 'b': printf(""b\n""); break;
		}
	}
	while (--ac > 0)
		printf(""%d"", ac);
	return 0;
}
","main(int ac, char **av) {
	if (av[0][0] == '""') {
		switch (av[0][1]) {
		case 'a': printf(""a\n""); break;
		case 'b': printf(""b\n""); break;
		}
	}
		// comment one
		// comment two
	while (--ac > 0)
		printf(""%d"", ac);
	return 0;
}
","??=include <stdio.h>
??/
int main(int ac, char **av)??<
if (!(ac??'1))??<printf(""hello, world?????/n"");
??>else??<pr??/
intf(""hello,%s!??/n"", av??(1??));??>
??>
","#i\
nc\
lu\
de\
<s\
td\
io\
.h>

ma\
in(
in\
t \
ac\
, \
ch\
ar\
**\
av)
{i\
f(\
av\
[0\
][\
0]\
==\
'""\
')\
{s\
wi\
tc\
h(\
av\
[0\
][\
1]\
){\
ca\
se\
'a\
':\
pr\
in\
tf\
(""\
a\\
n""\
);\
br\
ea\
k;\
ca\
se\
'b\
':\
pr\
in\
tf(
""b\
\n\
"");
br\
ea\
k;\
}}\
wh\
il\
e(\
--\
ac>
0)\
pr\
in\
tf(
""%\
d"",
ac)
;r\
et\
ur\
n \
0;}
","#include <stdio.h>

    int main() {
    	/***/printf(/***/
	""hello, world!\n""
	);
    }
",{int},"#include <stdio.h>
int main() {
	printf/*testing*/(""hello, world!\n"");
}
","#include<unistd.h>
#define W ),write(1,
static unsigned char c[]=
""]\33[0m\33[7m[&&'% $ # !     ########## \""      #     !& \n  oo  6''GLB=.*  eoj* 5SXINE@199999999777777775]bNNE@@5]bNNE@E5SXOO0?05SXOOD?06TYJOE@16Y%JOE@16^c%O%%%6c%%O%%%f   !!  k k!    p  !oo  :;;\37;;;;;\37;($\""%$##(\37(/1$1.,,,$%&/1rs!58&30123$$-O@2=\2?(2-'VZ$3:'i/3+ O#&B2%1,: 2=' (1J!1AC) @:,+_M1H/:J I\""?.Ak'.c2G$gj!j.@O&'(P +,jk/Y1$3%56.8 Y1. .4, W +nd\\rs1( ++(-.331i\"".>.-[!.^'.\00281\216\217\252\253's 6\b.$\252\2534''0(\0226 6!'# +[\34.-\""+,-\""(4123Z5_]3-+46(44ij3.jneij41$3+%16s c` 3!#6.(n _\"".] R+'4.jjkf`'\\..Y.(' i1 f%nG. $=i$#$ `'3V*+.b2&.!23+5.'n9\\\2ij&1j_3k^_n/+i_ij cd-$$11j(%3&'..\n!1$.4 623$ \2$' rs6${$\""\25($3-5.3''' $2.'\b(1( -.\0253,63''6 8\241+ 6\37  $-$I(P(($\252\253cZ/2\b'i4j3$86&4 j!k-J &1N]'+,fcY-ej/$fgl8 n4!$cd (^'$4+bc-g -2($.iZn$%Yc\20 4+Z,)$.'.\0071 1.'g1\37 4-$$%1'(D=+,-./+12 4,,7\f$ 1:3'+,?.='= #.%$)K!(123&(J3:4$J4 $52#(<! ,$AK;( !+# ./'1  \17     1\252\253<=>?@ABCDEFGHIJKLMNOPQRSTU                                                                                                                                                                                                                                                                               ;   ;       ; ; ; ; ; ; ;   ;   ;     ;     ;       ; ;   ; ; ; ; ; ; ;   ; ;   ; ; ;   ;   ; ;   ; ;         ;   ; {   { ;     ; ; {   ;   ; { { ;   ; { {     { { { ; ; ; { { { { ; {   {     ; { { ;     { {     ; ;           { { { ; { { { ;   ;     {     { { ; ;   {   { {   {   {   {             { {   {     } ; {   {     {     ; } }       { { } } { {   { { {     } }   { } } } } ;   }     }   } {               ; }         } ;   } } }   }   }   } } ; } }     } } } } } } } { } ;  ;  } }       }   };   ; ;  }   } { };  }   };   ; ;   ; ;   ; ; ;   ; ;  ;; ;  }; ; ;    } ;; ; ; ; ; ; ;   ;    ; ;;         ; ;   ;   ;    {; ; ; ; ; ;            }    ;                }  ;  ;;;         }  ;   ;     ; ;    ;;;           ; }     };; }       ;        ;;;     ;;  ;;;; ;;;  ;;;;  ;; {  ;;; ; ;;  ; ; ; ;;; ;     ;;; ;;;;;;;;; ;;;;;;  ; ;;  ;;      ;;    ;;       ;  ;;  ;;  ;;      ;{                ;;;{  ;{              ;;  ;{;;;;    ;;;; {;{;;  ;;;{ ;;;    ;{          ;{           ; { { { {     { { { } }    ; ; ;;    ;;  ;{      \""     ' !!!!$!!(8I!!,%&!!!#*)2.  C!!CH'-/0@B+  L   UJM<  N4 [Q?DX[ Jc !ad' in fit` !w  !V  mL  r L  p z s  Vv e x  _ vb !VY o\\q  j (x [|!E\""&@+10y?UJ W$  6  [OPUDXAF]US Zj lac[q $n We    y |) #w  zk)Us |$ `Ub,5  )F8V_h;#4\""u% 0  $<CJUIJG  $X   < @67$X)Z$ |  YUC])ZZ h dO m s<Ky   < ^wUW x#${ oU@r  Z 2  Ufg<$T| njv U+/[u(>1C$ \""  . I4  U    $+    Al 6M3UQ 8Uv+kV5 U;pBKU`P)jX  Xe  Cw }\"" ++{UyZo$lC}*C,& .#C>'+ 52|4/B)7+ +|@1--9M6 L ||Q    =P R ? )GH\\Vk[ [ f ICfB [[[!r 6 b$!   UI!z[p  |sC$)x[  U$IU[e+B   XU   >zU 0U-?$O @Yx:) 4EZCU/lUAco  'q.*9[}G_HLBI j(! m!!t , l x!q!|! ! !!!!! ! q$ ( $U! < c 'do  nN)\""S w4k}  =     0 A   Y1+-9  =Scaf  !OZ  B F ""

 ,C[3^9
<<20],*k[
4]={
 1+C,
   0,59
      +c}
     ,**K
,*l,*L,*
 o,O,p,

P,s,S=1,v=4 ;
int V(int w){
   return
     1<w
     ?3<
     w?4
     <w?
     5<w
     ?6<

w?O=(O=*
--l,O/64-
1?1   &129
>>O    -39
:27>(O%=
32)&&0<O
?1+   O:0
),w    +=O
,O-     (c[


w]-     2)%
28||    (1-
(O=     (c[
w]-     2)/
28)     ?v=
O:0     ,V(
154+   1950
 [w+c]+94*
  (464[w+

c+w    ]/3
%5+    465
[w+c   +w]
%26/7  )))
:!( 3- v?2
>v?  L=1[k
]=*   k,3[
k]=    67+
c:3    >v?

V(0    ),p
?(0   W L,
*k-  L W
52+ c,
1),p=
0:0 ,L
:L:  (v=
1,l   =*k
,V(    205


  ),1-v
 ?2   [k]
 =75 +c:
   o,V(
 3), v%3     ?2>
v?V    (1), o=
1[k     ]:L:(
 p=(P=1 W L,o
  -L W c   +s,S

W o       ,*k
- o       W c
,S)       ,L=
*k)   ,   1[k
]=*   k   )):
(l=  *k,  V (
 808 ),v ):(
  v=*  ++*k
  ,39   -c[

v>>     7 ?
15:     1-v
/32     ?10
-v?(312-v %
32)/26+v/32
*2:     13:
82-     v])
:!(     w[k
]+=     V(2

   +w)
   ,v=
   *w[
   k]%
   5,w
   [k]
   =*w
   [k]
   /5*

8+3+c):(K=k+w
,33>*(*K-=!w)
     ?*K
     +=w
     ,V(
     w):
     !(*
     K+=
     !w)

);}int main()
{ read(s,2+C,
9<<
20);for(s
=isatty(S
)?S
=5:
9;v; V(2))V(6
); return P;}
","#include<unistd.h>
#define W ),write(1,
static unsigned char c[]=
""]\33[0m\33[7m[&&'% $ # !     ########## \""            !& \n  oo  6''GLB=.*  eoj* 5SXINE@199999999777777775]bNNE@@5]bNNE@E5SXOO0?05SXOOD?06TYJOE@16Y%JOE@16^c%O%%%6c%%O%%%f   !!  k k!    p  !oo  :;;\37;;;;;\37;($\""%$##(\37(/1$1.,,,$%&/1rs!58&30123$$-O@2=\2?(2-'VZ$3:'i/3+ O#&B2%1,: 2=' (1J!1AC) @:,+_M1H/:J I\""?.Ak'.c2G$gj!j.@O&'(P +,jk/Y1$3%56.8 Y1. .4, W +nd\\rs1( ++(-.331i\"".>.-[!.^'.\00281\216\217\252\253's 6\b.$\252\2534''0(\0226 6!'# +[\34.-\""+,-\""(4123Z5_]3-+46(44ij3.jneij41$3+%16s c` 3!#6.(n _\"".] R+'4.jjkf`'\\..Y.(' i1 f%nG. $=i$#$ `'3V*+.b2&.!23+5.'n9\\\2ij&1j_3k^_n/+i_ij cd-$$11j(%3&'..\n!1$.4 623$ \2$' rs6${$\""\25($3-5.3''' $2.'\b(1( -.\0253,63''6 8\241+ 6\37  $-$I(P(($\252\253cZ/2\b'i4j3$86&4 j!k-J &1N]'+,fcY-ej/$fgl8 n4!$cd (^'$4+bc-g -2($.iZn$%Yc\20 4+Z,)$.'.\0071 1.'g1\37 4-$$%1'(D=+,-./+12 4,,7\f$ 1:3'+,?.='= #.%$)K!(123&(J3:4$J4 $52#(<! ,$AK;( !+# ./'1  \17     1\252\253<=>?@ABCDEFGHIJKLMNOPQRSTU                                                                                                                                                                                                                                                                               ;   ;       ; ; ; ; ; ; ;   ;   ;     ;     ;       ; ;   ; ; ; ; ; ; ;   ; ;   ; ; ;   ;   ; ;   ; ;         ;   ; {   { ;     ; ; {   ;   ; { { ;   ; { {     { { { ; ; ; { { { { ; {   {     ; { { ;     { {     ; ;           { { { ; { { { ;   ;     {     { { ; ;   {   { {   {   {   {             { {   {     } ; {   {     {     ; } }       { { } } { {   { { {     } }   { } } } } ;   }     }   } {               ; }         } ;   } } }   }   }   } } ; } }     } } } } } } } { } ;  ;  } }       }   };   ; ;  }   } { };  }   };   ; ;   ; ;   ; ; ;   ; ;  ;; ;  }; ; ;    } ;; ; ; ; ; ; ;   ;    ; ;;         ; ;   ;   ;    {; ; ; ; ; ;            }    ;                }  ;  ;;;         }  ;   ;     ; ;    ;;;           ; }     };; }       ;        ;;;     ;;  ;;;; ;;;  ;;;;  ;; {  ;;; ; ;;  ; ; ; ;;; ;     ;;; ;;;;;;;;; ;;;;;;  ; ;;  ;;      ;;    ;;       ;  ;;  ;;  ;;      ;{                ;;;{  ;{              ;;  ;{;;;;    ;;;; {;{;;  ;;;{ ;;;    ;{          ;{           ; { { { {     { { { } }    ; ; ;;    ;;  ;{      \""     ' !!!!$!!(8I!!,%&!!!#*)2.  C!!CH'-/0@B+  L   UJM<  N4 [Q?DX[ Jc !ad' in fit` !w  !V  mL  r L  p z s  Vv e x  _ vb !VY o\\q  j (x [|!E\""&@+10y?UJ W$  6  [OPUDXAF]US Zj lac[q $n We    y |) #w  zk)Us |$ `Ub,5  )F8V_h;#4\""u% 0  $<CJUIJG  $X   < @67$X)Z$ |  YUC])ZZ h dO m s<Ky   < ^wUW x#${ oU@r  Z 2  Ufg<$T| njv U+/[u(>1C$ \""  . I4  U    $+    Al 6M3UQ 8Uv+kV5 U;pBKU`P)jX  Xe  Cw }\"" ++{UyZo$lC}*C,& .#C>'+ 52|4/B)7+ +|@1--9M6 L ||Q    =P R ? )GH\\Vk[ [ f ICfB [[[!r 6 b$!   UI!z[p  |sC$)x[  U$IU[e+B   XU   >zU 0U-?$O @Yx:) 4EZCU/lUAco  'q.*9[}G_HLBI j(! m!!t , l x!q!|! ! !!!!! ! q$ ( $U! < c 'do  nN)\""S w4k}  =     0 A   Y1+-9  =Scaf  !OZ  B F ""

 ,C[3^9
<<20],*k[
4]={
 1+C,
   0,59
      +c}
     ,**K
,*l,*L,*
 o,O,p,

P,s,S=1,v=4 ;
int V(int w){
   return
     1<w
     ?3<
     w?4
     <w?
     5<w
     ?6<

w?O=(O=*
--l,O/64-
1?1   &129
>>O    -39
:27>(O%=
32)&&0<O
?1+   O:0
),w    +=O
,O-     (c[


w]-     2)%
28||    (1-
(O=     (c[
w]-     2)/
28)     ?v=
O:0     ,V(
154+   1950
 [w+c]+94*
  (464[w+

c+w    ]/3
%5+    465
[w+c   +w]
%26/7  )))
:!( 3- v?2
>v?  L=1[k
]=*   k,3[
k]=    67+
c:3    >v?

V(0    ),p
?(0   W L,
*k-  L W
52+ c,
1),p=
0:0 ,L
:L:  (v=
1,l   =*k
,V(    205


  ),1-v
 ?2   [k]
 =75 +c:
   o,V(
 3), v%3     ?2>
v?V    (1), o=
1[k     ]:L:(
 p=(P=1 W L,o
  -L W c   +s,S

W o       ,*k
- o       W c
,S)       ,L=
*k)   ,   1[k
]=*   k   )):
(l=  *k,  V (
 808 ),v ):(
  v=*  ++*k
  ,39   -c[

v>>     7 ?
15:     1-v
/32     ?10
-v?(312-v %
32)/26+v/32
*2:     13:
82-     v])
:!(     w[k
]+=     V(2

   +w)
   ,v=
   *w[
   k]%
   5,w
   [k]
   =*w
   [k]
   /5*

8+3+c):(K=k+w
,33>*(*K-=!w)
     ?*K
     +=w
     ,V(
     w):
     !(*
     K+=
     !w)

);}int main()
{ read(s,2+C,
9<<
20)
;s=isatty(S)
?S=
5:9;
for(;v;V(2))V
(6);return P;}
","        #define/*__Int3rn^ti[]n/l_()I3fusc^t3|]_C_C<>I7E_C[]nt3st__*/L/*__MMXVIII__*/for
    #include/*!""'()*+,-./12357:;<=>?CEFGHIJKLMNSTUVWXYZ[]^_`cfhijklmnrstuvwxyz{|}*/<stdio.h>
  char*r,F[1<<21]=""~T/}3(|+G{>/zUhy;Jx+5wG<v>>u55t.?sIZrC]n.;m+:l+Hk]WjNJi/Sh+2f1>c2H`)(_2(^L\
 -]=([1/Z<2Y7/X12W:.VFFU1,T77S+;N?;M/>L..K1+JCCI<<H:(G*5F--E11C=5?.(>+(=3)Z-;*(:*.Y/5(-=)2*-U,\
/+-?5'(,+++***''EE>T,215IEUF:N`2`:?GK;+^`+?>)5?>U>_)5GxG).2K.2};}_235(]:5,S7E1(vTSS,-SSTvU(<-HG\
-2E2/2L2/EE->E:?EE,2XMMMM1Hy`)5rHK;+.T+?[n2/_2{LKN2/_|cK2+.2`;}:?{KL57?|cK:2{NrHKtMMMK2nrH;rH[n""
""CkM_E21-E,-1->E(_:mSE/LhLE/mm:2Ul;2M>,2KW-+.-u).5Lm?fM`2`2nZXjj?[n<YcK?2}yC}H[^7N7LX^7N7UN</:-\
ZWXI<^I2K?>T+?KH~-?f<;G_x2;;2XT7LXIuuVF2X(G(GVV-:-:KjJ]HKLyN7UjJ3.WXjNI2KN<l|cKt2~[IsHfI2w{[<VV""
""GIfZG>x#&#&&$#$;ZXIc###$&$$#>7[LMv{&&&&#&##L,l2TY.&$#$#&&$,(iiii,#&&&#$#$?TY2.$#$1(x###;2EE[t,\
SSEz.SW-k,T&&jC?E-.$##      &#&57+$$#      &&&W1-&$$7W  -J$#$kEN&#&      $##C^+$##W,h###n/+L2YE""
""2nJk/H;YNs#$[,:TU(#$   ,:   &&~H>&#   Y;   &&G_x&#2;   ,mT&$YE-#&   5G   $#VVF$#&zNs$$&Ej]HELy\
CN/U^Jk71<(#&:G7E+^&#  l|?1  $$Y.2$$  7lzs  WzZw>&$E    -<V-wE(2$$  G>x;  2zsW/$$#HKt&$$v>+t1(>""
""7>S7S,;TT,&$;S7S>7&#>E_::U  $$'"",op  ,*G=  F,*I=957+F  ;int*t,k,O,  i,   j,T[+060<<+020];int M(
int m,int nop){;;;return+   m%(0+nop  );;}  int*tOo,w,  h,z,W;void(C)  (int n){n=putchar(n);}int
f,c,H=11,Y=64<<2,Z,pq,X   ;void(E/*d  */)(  int/*RP*/n  ){L(Z=k+00;  Z;  Z/=+2+000)G[000]=*G*!!f
|M(n,2)<<f,pq=2,f=+06   <f?++pq,++pq  ,G++  ,z:f+001,n  /=2;;}void  (V)(  int/*opqrstabd*/n){C(n
%Y);;C(n/Y+00);;}void  J(){L(pq--,pq   =j   =O=-1+0;++  j<240;I[6+   (h   +6+j/12/2*2+M(j/2,2))*
W+M(j/2/2,+06)*2+w*014      +00+M(00+      000+j,002      +00)]=000      +00+k)k=M(G[j/2/2+(*r-+
32)**""<nopqabdeg""],/*4649&96#*/3);/*&oaogoqo*/;}/*xD%P$Q#Rq*/int/*dbqpdbqpxyzzyboo3570OQ*/main()
{L(X=Y-1;i<21*3;i++,I++)L(r=G,G+=2;*G++;)*G>=13*3?*G-*r?*I++=*G:(*I++=r[1],*I++=r[2]):1;L(j=12,r
=I;(*I=i=getchar())>-1;I++)i-7-3?I-=i<32||127<=i,j+=12:(H+=17+3,W=W<j?j:W,j=12);L(;*r>-1;r++)*r-
7-3?J(),w++:(w=z,h+=17+3);C(71);C(73);V('*'*'1'*7);C(57);C(32*3+1);V(W);V(H);C(122*2);L(V(i=z);i
<32*3;)C(i++/3*X/31);C(33);C(X);C(11);L(G=""SJYXHFUJ735"";*G;)C(*G++-5);C(3);V(1);L(V(j=z);j<21*3;
 j++){k=257;V(63777);V(k<<2);V(M(j,32)?11:511);V(z);C(22*2);V(i=f=z);V(z);V(W);V(H);V(1<<11);r=
  G=I+W*H;L(t=T;i<1<<21;i++)T[i]=i<Y?i:-1;E(Y);L(i=-1;++i<W*H;t=T+Z*Y+Y)c=I[i]?I[i]*31-31:(31<
    j?j-31:31-j),Z=c[t[c]<z?E(Z),k<(1<<12)-2?t[c]=++k,T:T:t];E(Z);E(257);L(G++;k=G-r>X?X:G-r
        ,C(k),k;)L(;k--;C(*r++/*---#$%&04689@ABDOPQRabdegopq---*/));}C(53+6);return(z);}
","        #define/*__Int3rn^ti[]n/l_()I3fusc^t3|]_C_C<>I7E_C[]nt3st__*/L/*__MMXVIII__*/for
    #include/*!""'()*+,-./12357:;<=>?CEFGHIJKLMNSTUVWXYZ[]^_`cfhijklmnrstuvwxyz{|}*/<stdio.h>
  char*r,F[1<<21]=""~T/}3(|+G{>/zUhy;Jx+5wG<v>>u55t.?sIZrC]n.;m+:l+Hk]WjNJi/Sh+2f1>c2H`)(_2(^L\
 -]=([1/Z<2Y7/X12W:.VFFU1,T77S+;N?;M/>L..K1+JCCI<<H:(G*5F--E11C=5?.(>+(=3)Z-;*(:*.Y/5(-=)2*-U,\
/+-?5'(,+++***''EE>T,215IEUF:N`2`:?GK;+^`+?>)5?>U>_)5GxG).2K.2};}_235(]:5,S7E1(vTSS,-SSTvU(<-HG\
-2E2/2L2/EE->E:?EE,2XMMMM1Hy`)5rHK;+.T+?[n2/_2{LKN2/_|cK2+.2`;}:?{KL57?|cK:2{NrHKtMMMK2nrH;rH[n""
""CkM_E21-E,-1->E(_:mSE/LhLE/mm:2Ul;2M>,2KW-+.-u).5Lm?fM`2`2nZXjj?[n<YcK?2}yC}H[^7N7LX^7N7UN</:-\
ZWXI<^I2K?>T+?KH~-?f<;G_x2;;2XT7LXIuuVF2X(G(GVV-:-:KjJ]HKLyN7UjJ3.WXjNI2KN<l|cKt2~[IsHfI2w{[<VV""
""GIfZG>x#&#&&$#$;ZXIc###$&$$#>7[LMv{&&&&#&##L,l2TY.&$#$#&&$,(iiii,#&&&#$#$?TY2.$#$1(x###;2EE[t,\
SSEz.SW-k,T&&jC?E-.$##      &#&57+$$#      &&&W1-&$$7W  -J$#$kEN&#&      $##C^+$##W,h###n/+L2YE""
""2nJk/H;YNs#$[,:TU(#$   ,:   &&~H>&#   Y;   &&G_x&#2;   ,mT&$YE-#&   5G   $#VVF$#&zNs$$&Ej]HELy\
CN/U^Jk71<(#&:G7E+^&#  l|?1  $$Y.2$$  7lzs  WzZw>&$E    -<V-wE(2$$  G>x;  2zsW/$$#HKt&$$v>+t1(>""
""7>S7S,;TT,&$;S7S>7&#>E_::U  $$'"",op  ,*G=  F,*I=957+F  ;int*t,k,O,  i,   j,T[+060<<+020];int M(
int m,int nop){;;;return+   m%(0+nop  );;}  int*tOo,w,  h,z,W;void(C)  (int n){n=putchar(n);}int
f,c,H=11,Y=64<<2,Z,pq,X   ;void(E/*d  */)(  int/*RP*/n  ){L(Z=k+00;  Z;  Z/=+2+000)G[000]=*G*!!f
|M(n,2)<<f,pq=2,f=+06   <f?++pq,++pq  ,G++  ,z:f+001,n  /=2;;}void  (V)(  int/*opqrstabd*/n){C(n
%Y);;C(n/Y+00);;}void  J(){L(pq--,pq   =j   =O=-1+0;++  j<240;I[6+   (h   +6+j/12/2*2+M(j/2,2))*
W+M(j/2/2,+06)*2+w*014      +00+M(00+      000+j,002      +00)]=000      +00+k)k=M(G[j/2/2+(*r-+
32)**""<nopqabdeg""],/*4649&96#*/3);/*&oaogoqo*/;}/*xD%P$Q#Rq*/int/*dbqpdbqpxyzzyboo3570OQ*/main()
{L(X=Y-1;i<21*3;i++,I++)L(r=G,G+=2;*G++;)*G>=13*3?*G-*r?*I++=*G:(*I++=r[1],*I++=r[2]):1;L(j=12,r
=I;(*I=i=getchar())>-1;I++)i-7-3?I-=i<32||127<=i,j+=12:(H+=17+3,W=W<j?j:W,j=12);L(;*r>-1;r++)*r-
7-3?J(),w++:(w=z,h+=17+3);C(71);C(73);V('*'*'1'*7);C(57);C(32*3+1);V(W);V(H);C(122*2);L(V(i=z);i
<32*3;)C(i++/3*X/31);C(33);C(X);C(11);L(G=""SJYXHFUJ735"";*G;)C(*G++-5);C(3);V(1);L(V(j=z);j<21*3;
 j++){k=257;V(63777);V(k<<2);V(M(j,32)?11:511);V(z);C(22*2);V(i=f=z);V(z);V(W);V(H);V(1<<11);r=
  G=I+W*H;L(t=T;i<1<<21;i++)T[i]=i<Y?i:-1;E(Y);L(i=-1;++i<W*H;t=T+Z*Y+Y)c=I[i]?I[i]*31-31:(31<
    j?j-31:31-j),Z=c[t[c]<z?E(Z),k<(1<<12)-2?t[c]=++k,T:T:t];E(Z);E(257);L(G++;k=G-r>X?X:G-r
        ,C(k),k;)L(;k--;C(*r++/*---#$%&04689@ABDOPQRabdegopq---*/));}C(53+7);return(z);}
","
  #define/**/Q(   q)int*P,t,u,M                                  [99999],                                                          *S=3557\
  +M,*C=M+3800;   char*Q=#q;int                                    (main)                                                            (){q;}
    # include       <stdio.h>                                       /*IOC                                                             CCC*/
     Q(for(;*       Q>34?(*S                                        ++=*Q                                                             ++):*
     (Q+= *Q-       27?1:Q[2     ]/49+    4););                     for (          S=M+9                ;*C;u     =t%9,t              <18?*
     ++S=t<0?       *C++%92*    57-t-500:t<9?M[u]:M        [u]++:t<27?M[u       ]=*S--:u?t=*        S--,u<2?M[t]=*S--:u<     3?C+=*S--?t:0,
     0:u-6?*S       =u<4?*S-     t:u/*ABCDEFGH*/<5?*     S%t:*S<t:putchar     (t):(*S=M[*S]))t     =*C++-93;return+0**""    Ler[Tsaxiyj.V}<\
     dzSGs`Fk       {YezYTtb     x0d{iy        kNT}?d   zaxiyjE   K}TdzHe    iy`Me{      Tf|)dz   HeiyH       eiyjxiyax   Ldz2sx     Ke{'d\
     |Yd{2sy?       [saY^{tG     erjxuj        xvbqax`  {)dzc       kydj/    dzjxkya_}JdziHf}Ydz -Vw2d         rQ)qJe_y  h@*}<d       zHeh\
     yAehy)*n       x{qnxKe{     Df|Qd{         uc)e{&  dzZfh       yCehy    6fuchyex;e{ZdzIe_yn q1dqD         +u/dcyl5  L}<dzL       IETi\
     {x=b{1g|{uc2d{byaxvcDfd     }&dzDVd       {x6ecOe  z1dcydCf_{{)d|qSf2   T_{x$c{              ;g|{{u      Ffjx}4czb   q_xucx/d }Jez0dly\
       c/d{hycSf{hychycFc{      hy_)Ic}{q     _0d{qb_}.c  z:eo:T`{xp]q1d`{D`  zD+ulxcx{-dzcCez     7evOe~Hf~0dcx}/dzd~cx    x~6f~m6e0dcx}{}Ud\
          zc(*{x~c0d{Tf         |.dz'd~c5     L}Ecz1d[Ty     /*0+)IFMNFU*+0-    02;>@=,(#155        5546231rst%wvu#08OCC       C*/#include/*#""



     ""exclude*/<stdio.                                                                                                  h>#def\
    ine/**/Q(q)int*P,t,u,M[                                                                                             99999],\
      *S=3557+M,*C=M+3800;cha                                                                                             r*Q=#\
       q;int(ma      in)(){q;}                                                                                           Q(@@~c\
       d`c/C@~o        `rrdc~n                                                                                        m/GSghr~o`qqns~hr~\
       mn~lnqd/       FH~g`ud~     bd`rdc~sn~a d/O@~dw ohqdc~`mc~fnmd~sn~    ldds~lx~l`jdq/GSgh       r~hr~`~k`sd     ~o`qqns/LAdqdes~ne\
       ~khed+~H~qdrs~hm~od`bd    /KH&c~ad~otrghmf~to~s  gd~c`hrhdr/X@~qtm~cn vm~sgd~btqs`hm~`mc~i   nhmdc~sgd~bgnhq~      hmuhr\
       hakd/FSghr~hr~`m~dw,     o`qqns     /6Zba4ORRZ    T`]Sa`    fdgO2bPV[   Ta5dT[    MVfbZZHY  b79bVT^    :L;S<J=     X>Q?X\
       @SAZBWCIDNEQF`GXPU      UgW^a         a[bIaZ[Z    afaf_`     Kg`ZYY[    [`gff^     Jg``8OK KT,VNa6      /TZSW`     0cRMWO       3\
       3f][T`-[K               aV,[Z         /6aPWLab    f[P[a3                f`0dPR             `3M3]8/      R[Z-Z,     VZR#MR     TfNTT\
       4d5^$S]8                RMKRVa       MM8T$9aaZ    gaRSg1                NZ1`5^              d`LK].      %&VZ,'     R#gKaZ       f1T\
     T10aa`b].TZ-               KK/28`-6VKf'ZH^P(./Ka8 a)8[O6NaTb            f*[Hd+Z(V              8&3K%)VNTR#&WbX[      H^dcOWOf]8[OR[aT\
    OM2V'$9aLR[RW*               `0+OMW[([14ZLaK%).NO6 RMRS*[0+ZO            WZS]_<<<<               <htt""/*pa*/""p:        //""/*x@*/""cult\
     ofthepartypa                    rrot.co    m/>>>>  >__<-_So             urce_of_P                   arrots                 __("")

","    #include<stdio.h>
    #include<stdlib.h>
    #include<string.h>
    #include<ctype.h>
    #include<time.h>
    #include<stdint.h>
    Q unsigned d; Q char E; Q int k;
    Q long u; Q size_t t; Q const char U;
    #define L toupper
    #define M SIZE_MAX-1
    #ifndef S
    #define S 38
    #elif S < 38
    #undef S
    #define S 38
    #elif S > M
    #undef S
    #define S M
    #endif
    #define l S-1
    #define Y strlen
    #define Z printf
    #define K static
    #define z do{
    K E W[]=""stqvvwxzwtzuvvryusuxvtrqsruxttrxvwqxq""; K E T[S]= {77,69,84,72,73,78,75,83,32,73,84,32,73,83,32,76,73,75,69,32,65,32,87,69,65,83,69,76,0} ;
    K U C[]="" !\""&'(),.0123456789;?ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    /*NO*/
    K E P[2][sizeof(T)]; K t G=0;
    #ifndef N
    #define N 25
    #elif N < 4
    #undef N
    #define N 3
    #elif N > M
    #undef N
    #define N M
    #endif
    /*BLOB*/
    K u R=1; K d D=0; K k X(k f,k t){ return (rand()%((t)-(f)+1)+(f)); }
    K E c() {return C[X(0,(k)Y(C)-1)];%> Q struct x { E G[sizeof T];
    t F; } x; K x O[N];
    /* Special C main() handler (encapsulation): */
    #define r(main) main
    r(k main(k a, E **V)) { x x; E*b;
    U *A=T; k h=0,s,q=0,m=0,y=0,n=N==97,J=0; t i,j,

    /* prototype for special C parser H() below */
    F H(); H(<% H(for (s = 1; s < a && *V[s++]; ) H(<%
    H(E *v=V[s-1]; H(if (*v!='-'||h) H(g(o) w(f) H(
    while (*++v) H(switch (*v) { w(case '-') h=1; g(f)
    w(case 'r') H(if ((R=strtol(v+1,&b,0)) < 1 || R > 100)/*CODING*/
    <% Z(""mutation rate out of range\n"") ; m=1); %> else m=0; g(f)
    w(case 'q') q=1; Z(""quiet output\n"") ; g(f) w(case 'm') J=1;
    g(f) w(default) g(f) %>); H(continue))); H(w(o) H(y=1; 
    H(i = Y(V<:s-1]); H(if(i > l) i=l; H( strncpy(T,V[s-1:>,i)
    ; H(T[i]='\0')))))))); })); }); H(H(if (n&&!y) for (j=0
    ; j<37; ++j) T[j]=W[j]-'A'); H(for ( ; *A && strchr(C, L(*A))
    ; ++A)); H(if (*A) <% Z(""'%c' not in keyboard \""%s\""\n"", *A,C)
    ; return 1; })/*THIS*/); H(srand((d)time(0)); memset(&x, 0, sizeof x);
    memset(O,0,sizeof O)); H(Z(/*IS*/""target '%s'\n"", T); H(Z(
    ""mutation rate %ld\n"", R)); H(if((m=(m||J||N<4)))
    Z(""monkey at typewriter\n""); H(for ( j=0; j<N; ++j) H(for
    (i=0; i<Y(T); ++i) O[j].G[i]=c())))); H(while (!D) { H(if (++

    G==M) {Z(""Too many attempts, blaming the monkey Eric even if ""
    ""he isn't typing or doesn't exist. Bye.\n""); return 1; } H(for
    (j=0; j<N&&!D; ++j) { F = 0;/*NOT*/ H(for (i =0; i < Y(T); ++i)) { H(
    if (L(O[j].G[i]) == L(T[i]))) ++F; } /*A*/ O[j].F=F; H(if (((D=(F==Y(T)))
    ||G==1)&&(!q||D)) Z(""Generation %4zu\tOffspring %2zu: %s\n"",G
    -1,j+1,O[j] .G); })); H(if (D)break;); s=0; /*COMPACT*/ H(if (m) g(p) else H(z
    s=1; H(for(i=0; i<N-1; ++i) { H(if (O<:i].F >= O[i+1].F) g(h)) x=O[
    i+1:>; O[i]=O[i+1]; O[i+1]=x; s=0; w(h); }); }while(!s))); w(p
    ) H(strcpy(P[0],O[0].G); strcpy(P[1],O[1].G)); H(for (j=0; j<N; ++j)
    { H(for (i=0;!m&&i<Y(T); ++i) H(if ( X(0,9)<5) O[j] .
    G[i]=P[0][i]); H(else O[j] .  G[i]=P[1][i];)); /*BLOB*/ H(if (!
    q) Z(""Generation %4zu\tOffspring %2zu: %s -> "" ,G,j+1,O[j].
    G); H(for/*OF*/ (i=0; i<Y(T); ++i) { H(if (X(1,100) <= R || m)
    O[j].G[i]=c(); })); H(if (!q) Z(""%s (%s)\n"",O[j].G,m
    ?""monkey typing"" : ""mutation""))); /*OCTETS*/ }); H(if (!
    q) Z(""**\n"")); })); return 0; }
","    #include<stdio.h>
    #include<stdlib.h>
    #include<string.h>
    #include<ctype.h>
    #include<time.h>
    #include<stdint.h>
    Q unsigned d; Q char E; Q int k;
    Q long u; Q size_t t; Q const char U;
    #define L toupper
    #define M SIZE_MAX-1
    #ifndef S
    #define S 38
    #elif S < 38
    #undef S
    #define S 38
    #elif S > M
    #undef S
    #define S M
    #endif
    #define l S-1
    #define Y strlen
    #define Z printf
    #define K static
    #define z do{
    K E W[]=""stqvvwxzwtzuvvryusuxvtrqsruxttrxvwqxq""; K E T[S]= {77,69,84,72,73,78,75,83,32,73,84,32,73,83,32,76,73,75,69,32,65,32,87,69,65,83,69,76,0} ;
    K U C[] ="" !\""#$<%:>&'()*+,-./0123456789;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`{|}~"";
    /*NO*/
    K E P[2][sizeof(T)]; K t G=0;
    #ifndef N
    #define N 25
    #elif N < 4
    #undef N
    #define N 3
    #elif N > M
    #undef N
    #define N M
    #endif
    /*BLOB*/
    K u R=1; K d D=0; K k X(k f,k t){ return (rand()%((t)-(f)+1)+(f)); }
    K E c() {return C[X(0,(k)Y(C)-1)];%> Q struct x { E G[sizeof T];
    t F; } x; K x O[N];
    /* Special C main() handler (encapsulation): */
    #define r(main) main
    r(k main(k a, E **V)) { x x; E*b;
    U *A=T; k h=0,s,q=0,m=0,y=0,n=N==97,J=0; t i,j,

    /* prototype for special C parser H() below */
    F H(); H(<% H(for (s = 1; s < a && *V[s++]; ) H(<%
    H(E *v=V[s-1]; H(if (*v!='-'||h) H(g(o) w(f) H(
    while (*++v) H(switch (*v) { w(case '-') h=1; g(f)
    w(case 'r') H(if ((R=strtol(v+1,&b,0)) < 1 || R > 100)/*CODING*/
    <% Z(""mutation rate out of range\n"") ; m=1); %> else m=0; g(f)
    w(case 'q') q=1; Z(""quiet output\n"") ; g(f) w(case 'm') J=1;
    g(f) w(default) g(f) %>); H(continue))); H(w(o) H(y=1; 
    H(i = Y(V<:s-1]); H(if(i > l) i=l; H( strncpy(T,V[s-1:>,i)
    ; H(T[i]='\0')))))))); })); }); H(H(if (n&&!y) for (j=0
    ; j<37; ++j) T[j]=W[j]-'A'); H(for ( ; *A && strchr(C, L(*A))
    ; ++A)); H(if (*A) <% Z(""'%c' not in keyboard \""%s\""\n"", *A,C)
    ; return 1; })/*THIS*/); H(srand((d)time(0)); memset(&x, 0, sizeof x);
    memset(O,0,sizeof O)); H(Z(/*IS*/""target '%s'\n"", T); H(Z(
    ""mutation rate %ld\n"", R)); H(if((m=(m||J||N<4)))
    Z(""monkey at typewriter\n""); H(for ( j=0; j<N; ++j) H(for
    (i=0; i<Y(T); ++i) O[j].G[i]=c())))); H(while (!D) { H(if (++

    G==M) {Z(""Too many attempts, blaming the monkey Eric even if ""
    ""he isn't typing or doesn't exist. Bye.\n""); return 1; } H(for
    (j=0; j<N&&!D; ++j) { F = 0;/*NOT*/ H(for (i =0; i < Y(T); ++i)) { H(
    if (L(O[j].G[i]) == L(T[i]))) ++F; } /*A*/ O[j].F=F; H(if (((D=(F==Y(T)))
    ||G==1)&&(!q||D)) Z(""Generation %4zu\tOffspring %2zu: %s\n"",G
    -1,j+1,O[j] .G); })); H(if (D)break;); s=0; /*COMPACT*/ H(if (m) g(p) else H(z
    s=1; H(for(i=0; i<N-1; ++i) { H(if (O<:i].F >= O[i+1].F) g(h)) x=O[
    i+1:>; O[i]=O[i+1]; O[i+1]=x; s=0; w(h); }); }while(!s))); w(p
    ) H(strcpy(P[0],O[0].G); strcpy(P[1],O[1].G)); H(for (j=0; j<N; ++j)
    { H(for (i=0;!m&&i<Y(T); ++i) H(if ( X(0,9)<5) O[j] .
    G[i]=P[0][i]); H(else O[j] .  G[i]=P[1][i];)); /*BLOB*/ H(if (!
    q) Z(""Generation %4zu\tOffspring %2zu: %s -> "" ,G,j+1,O[j].
    G); H(for/*OF*/ (i=0; i<Y(T); ++i) { H(if (X(1,100) <= R || m)
    O[j].G[i]=c(); })); H(if (!q) Z(""%s (%s)\n"",O[j].G,m
    ?""monkey typing"" : ""mutation""))); /*OCTETS*/ }); H(if (!
    q) Z(""**\n"")); })); return 0; }
","    #include<stdio.h>
    #include<stdlib.h>
    #include<string.h>
    #include<ctype.h>
    #include<time.h>
    #include<stdint.h>
    Q unsigned d; Q char E; Q int k;
    Q long u; Q size_t t; Q const char U;
    #define L toupper
    #define M SIZE_MAX-1
    #ifndef S
    #define S 38
    #elif S < 38
    #undef S
    #define S 38
    #elif S > M
    #undef S
    #define S M
    #endif
    #define l S-1
    #define Y strlen
    #define Z printf
    #define K static
    #define z do{
    K E W[]=""stqvvwxzwtzuvvryusuxvtrqsruxttrxvwqxq""; K E T[S]= {77,69,84,72,73,78,75,83,32,73,84,32,73,83,32,76,73,75,69,32,65,32,87,69,65,83,69,76,0} ;
    K U C[] ="" !\""#$<%:>&'()*+,-./0123456789;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`{|}~"";
    /*NO*/
    K E P[2][sizeof(T)]; K t G=0;
    #ifndef N
    #define N 25
    #elif N < 4
    #undef N
    #define N 3
    #elif N > M
    #undef N
    #define N M
    #endif
    /*BLOB*/
    K u R=1; K d D=0; K k X(k f,k t){ return (rand()%((t)-(f)+1)+(f)); }
    K E c() {return C[X(0,(k)Y(C)-1)];%> Q struct x { E G[sizeof T];
    t F; } x; K x O[N];
    /* Special C main() handler (encapsulation): */
    #define r(main) main
    r(k main(k a, E **V)) { x x; E*b;
    U *A=T; k h=0,s,q=0,m=0,y=0,n=N==97,J=0; t i,j,

    /* prototype for special C parser H() below */
    F H(); H(<% H(for (s = 1; s < a && *V[s++]; ) H(<%
    H(E *v=V[s-1]; H(if (*v!='-'||h) H(g(o) w(f) H(
    while (*++v) H(switch (*v) { w(case '-') h=1; g(f)
    w(case 'r') H(if ((R=strtol(v+1,&b,0)) < 1 || R > 100)/*CODING*/
    <% Z(""mutation rate out of range\n"") ; m=1); %> else m=0; g(f)
    w(case 'q') q=1; Z(""quiet output\n"") ; g(f) w(case 'm') J=1;
    g(f) w(default) g(f) %>); H(continue))); H(w(o) H(y=1; 
    H(i = Y(V<:s-1]); H(if(i > l) i=l; H( strncpy(T,V[s-1:>,i)
    ; H(T[i]='\0')))))))); })); }); H(H(if (n&&!y) for (j=0
    ; j<37; ++j) T[j]=W[j]-'A'); H(for ( ; *A && strchr(C, L(*A))
    ; ++A)); H(if (*A) <% Z(""'%c' not in keyboard \""%s\""\n"", *A,C)
    ; return 0; })/*THIS*/); H(srand((d)time(0)); memset(&x, 0, sizeof x);
    memset(O,0,sizeof O)); H(Z(/*IS*/""target '%s'\n"", T); H(Z(
    ""mutation rate %ld\n"", R)); H(if((m=(m||J||N<4)))
    Z(""monkey at typewriter\n""); H(for ( j=0; j<N; ++j) H(for
    (i=0; i<Y(T); ++i) O[j].G[i]=c())))); H(while (!D) { H(if (++

    G==M) {Z(""Too many attempts, blaming the monkey Eric even if ""
    ""he isn't typing or doesn't exist. Bye.\n""); return 1; } H(for
    (j=0; j<N&&!D; ++j) { F = 0;/*NOT*/ H(for (i =0; i < Y(T); ++i)) { H(
    if (L(O[j].G[i]) == L(T[i]))) ++F; } /*A*/ O[j].F=F; H(if (((D=(F==Y(T)))
    ||G==1)&&(!q||D)) Z(""Generation %4zu\tOffspring %2zu: %s\n"",G
    -1,j+1,O[j] .G); })); H(if (D)break;); s=0; /*COMPACT*/ H(if (m) g(p) else H(z
    s=1; H(for(i=0; i<N-1; ++i) { H(if (O<:i].F >= O[i+1].F) g(h)) x=O[
    i+1:>; O[i]=O[i+1]; O[i+1]=x; s=0; w(h); }); }while(!s))); w(p
    ) H(strcpy(P[0],O[0].G); strcpy(P[1],O[1].G)); H(for (j=0; j<N; ++j)
    { H(for (i=0;!m&&i<Y(T); ++i) H(if ( X(0,9)<5) O[j] .
    G[i]=P[0][i]); H(else O[j] .  G[i]=P[1][i];)); /*BLOB*/ H(if (!
    q) Z(""Generation %4zu\tOffspring %2zu: %s -> "" ,G,j+1,O[j].
    G); H(for/*OF*/ (i=0; i<Y(T); ++i) { H(if (X(1,100) <= R || m)
    O[j].G[i]=c(); })); H(if (!q) Z(""%s (%s)\n"",O[j].G,m
    ?""monkey typing"" : ""mutation""))); /*OCTETS*/ }); H(if (!
    q) Z(""**\n"")); })); return 0; }
","#include ""SDL.h""
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define S(a,b) b*a
#define A int
#define N(a,b) b=a
#define D ""sand.txt""

#define G(_) SDL_##_
#define GX(_) G(Create##_)
#define GY(_) G(Destroy##_)
#define GZ(_) G(Render##_)
#define GA(_) if(!(_)){pri\
ntf(""L%d SDL Error: %s\n"",_\
_LINE__,G(GetError)());exit(1);}
#define GB(__,_G,G_,GG) G_(__);_G(GG)

// important constants
int ONE = 1;
int ZRO = 0;

uint64_t V[]={
0x3e62f947d02f49bc,0xbed0bdb402d9ed0c,0x3f2acda5f517c6b6,0xbf79c2448bb7eca0,
0x3fc091746cc843a3,0xbffe1cce22ed8f8f,0x4033e22da447fb5b,0xc06352e2b9c91269,
0x408bacb717fa44db,0xc0aceee93bc74aae,0x40c59df977dbfd52,0xc0d639fd2e095789,
0x40dd7401cce0cb64,0xc0d63a270ab7d164,0x40bc52eb9bd102e2,0x3fe0000000000000};

#define L lL[L1
                              int Ll1(A i)
                     {N(0;,double Ll)for(
           A N(0; l<,l) 16; ) S(( double*
     ),S(i+,Ll= Ll))(V+l++);return Ll; }
   #define M(a,b);L+a]=(L+a]&2)|(LL/b&1)
   void _L(int* lL,A l,A L1){ A N( Ll1,
   LL )( ( L]==1)| 2*(L +1]== 1) |4 * (
   L+ l] != 0)|8 *(L +l+ 1]!= 0)) M(0,
  1) M(1,2)M(l,4)M(l+1,8);}N(0,A l1L);
  #define L_(l11,L1) for( N(( l11);,\
 l1)l1 < lll;l1 +=ll1)for( N(L1 ;ll<\
l1l-,ll)1; ll +=2)_L( Ll,l1l,l1+ll);
void JJ(A*Ll,A l1l,A l){A ll,l1,S((l
    -1),lll=l1l),N(2*,ll1)l1l;l1L^=
              1;L_(l1L?l1l:0,l1L)}
#define GU
#define GO                      1
#define G0                     >=0
#define G2 GZ                (er*)
#define G3 G(                Init)
#define G5 G(                Quit)
#define GV                   while
#define GC G(                QUIT)
#define GG G(               Delay)
#define GW G(               Event)
#define GE GZ              (Clear)
#define G1 G(              Window*)
#define GI GY             (Window)
#define G6 GX             (Window)
#define GF GZ            (Present)
#define G8 GX            (Renderer)
#define GH GY            (Renderer)
#define GN G(            PollEvent)
#define G4 G(           INIT_VIDEO)
#define G7 G(          WINDOW_SHOWN)
#define GD G(       SetRenderDrawColor)
A main(A ac,char**av){int P[4018]; memset(P,0,4018*
sizeof(A));S(j=fopen,FILE)(ac>1?av[1]:D,""r"");if(j){
for(A F=0;F<4018; F++)P [F]=getc(j)-96;fclose(j) ;}

  G1 GL=0;G2     GM = 0;GA       (G3(G4       )G0 )atexit(
G5);            GA(       GL=    G6(     D,     ZRO,     ZRO,
800,            480,      G7))   GA(     GM=    G8(        GL,
  -1,0) )int    GK= GO+ (ONE=    ZRO     ++);   GW         GJ;
          GV(   GK){      GV(    GN(&    GJ)    GU!=       0){
          GK=   GJ.       type== GC?     ONE:   GK;}      GA(
GD(GM,0,0,0,    255)      G0);   GE(     GM);  G(Rect)Q;Q.w

=Q.h=10;JJ(P,82,49);A k=+0;while(k<81&&P[k])k++;P[k
]=l1L;for(A K=ZRO;K<49; K++){for(A O=1;O<81; O++){Q
.x=-(ZRO-O)*10;Q.y=(K-1)*10;A v=P[82*K+O];if(v==ZRO
)GD(GM,238,204,106,255); else if(v==ONE)GD(GM,0,0,0
,255); else GD(GM,143,149,157,255);GZ(FillRect)(GM,
&Q);}}GB(GM,GG,GF,40)GU;}GB(GM,GI,GH,GL);return 0;}
","/**
 * \file prog.c
 *
 * \brief Renders an HTML chart from JSON data
 *
 * \author Qiming HOU
 *
 *  Copyright (C) 2017-2018, Qiming HOU
 *
 *  Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported
 *  (CC BY-SA 3.0), you may not use this file except in compliance with the
 *  License. You may obtain a copy of the License at
 *
 *  http://creativecommons.org/licenses/by-sa/3.0/
 *
 *  This file is an IOCCC submission.
 *
 *  This thing wouldn't be possible without the advent of C / HTML standards.
 *  We all love the new math functions in C99 and the inclusion of SVG in
 *  HTML5.
 *
 *  Changelog:
 *    2018-04-16 fixed the rounding bug
 */
#include <math.h>
#include <stdio.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>

/* Macros are named after fashionable jargon */

#define J ceil(log(erfc(1)))
#define S calloc(3, 1)
#define O strcat(strcat(S, m(37)), m(102))
#define N I(T(6))
#define _(X) mmap(fopen(S, S), 64, 3, 1,  X, 0)
#define H(X) dup2(fileno(tmpfile()), X); m(ftruncate(X, 64))
#define T(X) getenv(L(r(1, X, 64)))
#define M(X, Y) memcmp(T(X), L(Y), 1)
#define L(X) memset(S, X, 1)

#define m(X) memset(S, X, N)
#define o(X) r(copysign(1, X), exp2(J), exp2(J))
#define b(X) o(r(abs(X), J, 0))
#define i(X) setenv(L(70), L(r(1, X, 48)), 1)
#define l(X, Y) setenv(m(r(1, X, 64)), L(Y), 1)
#define e(X) setenv(m(r(1, X, 64)), \
	strcat(strcpy(malloc(r(p(T(X)), 1, 2)), T(X)), T(4)), 1)

#define W(X) printf(O, fabs(X))
#define E(X) putchar(r(N, X, 32))
#define B(X, Y) sprintf(_(r(N, X, 3)), O, Y)

#define j(X) t; E(55); E(41); E(36); E(52); E(40); E(29); W(X); t; E(40); \
	E(37); E(41); E(39); E(40); E(52); E(29); W(X)
#define a(X) l(8, 0); i(o(M(8, X)))
#define v t; E(16); t
#define A E(52); E(37); E(56); E(52)
#define s W(r(200, sin(I(_(4))), 250)); t; W(r(200, cos(I(_(4))), 250))
#define c E(38); E(41); E(44); E(44); E(29); E(50); E(39); E(34); E(8); \
	W(r(cos(p(T(2))), 48, 48)); E(5); E(12); E(16); E(5); E(12); \
	W(r(sin(p(T(2))), 48, 48)); E(5); E(9); t; E(15); E(30); e(2)
#define r fma
#define I atof
#define p strlen
#define t E(0)

#define rulez o(r(J, exp2(N), p(T(1))))

/**
 * @brief Renders the chart from JSON input
 *
 * Expected input format:
 *   [ {""foo"": string, ""bar"": number}, ... ]
 *
 * @return nothing
 */
int C(){
	i(1);
	l(4, getchar());
	l(8, r(
		I(T(5)), 4,
		r(N, o(M(4, 33)), r(N, b(M(4, 44)), r(b(M(4, 34)), 2, 1)))
	));
	i(0);
	a(13);
	E(28);
	E(48);
	E(33);
	E(52);
	E(40);
	t;
	E(36);
	E(29);
	E(7);
	E(45);
	W(250);
	t;
	W(250);
	E(44);
	s;
	B(1, r(
		exp2(r(J, log2(I(_(5))), log2(I(T(1))))), 
		r(2, acos(J), 0), 
		I(_(4))
	));
	E(33);
	W(200);
	t;
	W(200);
	v;
	E(r(1, o(r(2, I(T(1)), r(J, I(_(5)), 0))), 16));
	v;
	s;
	E(58);
	E(7);
	c;
	setenv(m(65), strchr(T(1), r(1, I(T(7)), 9)), 1);
	l(7, r(J, I(T(7)), 49));
	fflush(fopen(S, S));
	assert(rulez);
	a(12);
	l(5, 48);
	E(28);
	E(15);
	A;
	E(30);
	a(9);
	m(write(1, T(4), N));
	a(8);
	l(5, 50);
	E(28);
	E(50);
	E(37);
	E(35);
	E(52);
	j(16);
	t;
	E(56);
	E(29);
	W(472);
	t;
	E(57);
	E(29);
	W(r(p(T(2)), 28, 0));
	t;
	c;
	E(28);
	A;
	t;
	E(56);
	E(29);
	W(500);
	t;
	E(57);
	E(29);
	W(r(p(T(2)), 28, r(J, 16, 0)));
	E(30);
	a(7);
	l(5, 48);
	l(4, r(1, I(T(7)), 9));
	e(1);
	l(7, r(J, I(T(7)), 49));
	B(2, r(1, I(_(5)), I(strrchr(T(r(N, J, 2)), r(N, I(T(7)), 9)))));
	a(6);
	e(1);
	a(1);
	i(r(N, b(M(4, 58)), 0));
	l(5, 49);
	a(1);
	i(r(N, b(M(4, J)), 0));
	l(7, 9);
	l(5, 51);
	l(2, 9);
	return C();
}

int main(){
	i(1);
	E(28);
	E(51);
	E(54);
	E(39);
	j(r(2, 250, 250));
	E(30);
	l(1, 10);
	l(2, 9);
	l(8, 9);
	l(4, 9);
	l(5, 9);
	l(7, 9);
	H(3);
	H(4);
	H(5);
	return C();
}
","/**
 * \file prog.c
 *
 * \brief Renders an HTML chart from JSON data
 *
 * \author Qiming HOU
 *
 *  Copyright (C) 2017-2018, Qiming HOU
 *
 *  Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported
 *  (CC BY-SA 3.0), you may not use this file except in compliance with the
 *  License. You may obtain a copy of the License at
 *
 *  http://creativecommons.org/licenses/by-sa/3.0/
 *
 *  This file is an IOCCC submission.
 *
 *  This thing wouldn't be possible without the advent of C / HTML standards.
 *  We all love the new math functions in C99 and the inclusion of SVG in
 *  HTML5.
 * 
 */
#include <math.h>
#include <stdio.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>

/* Macros are named after fashionable jargon */

#define J ceil(log(erfc(1)))
#define S calloc(3, 1)
#define O strcat(strcat(S, m(37)), m(102))
#define N I(T(6))
#define _(X) mmap(fopen(S, S), 64, 3, 1,  X, 0)
#define H(X) dup2(fileno(tmpfile()), X); m(ftruncate(X, 64))
#define T(X) getenv(L(r(1, X, 64)))
#define M(X, Y) memcmp(T(X), L(Y), 1)
#define L(X) memset(S, X, 1)

#define m(X) memset(S, X, N)
#define o(X) r(copysign(1, X), exp2(J), exp2(J))
#define b(X) o(r(abs(X), J, 0))
#define i(X) setenv(L(70), L(r(1, X, 48)), 1)
#define l(X, Y) setenv(m(r(1, X, 64)), L(Y), 1)
#define e(X) setenv(m(r(1, X, 64)), \
	strcat(strcpy(malloc(r(p(T(X)), 1, 2)), T(X)), T(4)), 1)

#define W(X) printf(O, floor(X))
#define E(X) putchar(r(N, X, 32))
#define B(X, Y) sprintf(_(r(N, X, 3)), O, Y)

#define j(X) t; E(55); E(41); E(36); E(52); E(40); E(29); W(X); t; E(40); \
	E(37); E(41); E(39); E(40); E(52); E(29); W(X)
#define a(X) l(8, 0); i(o(M(8, X)))
#define v t; E(16); t
#define A E(52); E(37); E(56); E(52)
#define s W(r(200, sin(I(_(4))), 250)); t; W(r(200, cos(I(_(4))), 250))
#define c E(38); E(41); E(44); E(44); E(29); E(50); E(39); E(34); E(8); \
	W(r(cos(p(T(2))), 48, 48)); E(5); E(12); E(16); E(5); E(12); \
	W(r(sin(p(T(2))), 48, 48)); E(5); E(9); t; E(15); E(30); e(2)
#define r fma
#define I atof
#define p strlen
#define t E(0)

#define rulez o(r(J, exp2(N), p(T(1))))

/**
 * @brief Renders the chart from JSON input
 *
 * Expected input format:
 *   [ {""foo"": string, ""bar"": number}, ... ]
 *
 * @return nothing
 */
int C(){
	i(1);
	l(4, getchar());
	l(8, r(
		I(T(5)), 4,
		r(N, o(M(4, 33)), r(N, b(M(4, 44)), r(b(M(4, 34)), 2, 1)))
	));
	i(0);
	a(13);
	E(28);
	E(48);
	E(33);
	E(52);
	E(40);
	t;
	E(36);
	E(29);
	E(7);
	E(45);
	W(250);
	t;
	W(250);
	E(44);
	s;
	B(1, r(
		exp2(r(J, log2(I(_(5))), log2(I(T(1))))), 
		r(2, acos(J), 0), 
		I(_(4))
	));
	E(33);
	W(200);
	t;
	W(200);
	v;
	E(r(1, o(r(2, I(T(1)), r(J, I(_(5)), 0))), 16));
	v;
	s;
	E(58);
	E(7);
	c;
	setenv(m(65), strchr(T(1), r(1, I(T(7)), 9)), 1);
	l(7, r(J, I(T(7)), 49));
	fflush(fopen(S, S));
	assert(rulez);
	a(12);
	l(5, 48);
	E(28);
	E(15);
	A;
	E(30);
	a(9);
	m(write(1, T(4), N));
	a(8);
	l(5, 50);
	E(28);
	E(50);
	E(37);
	E(35);
	E(52);
	j(16);
	t;
	E(56);
	E(29);
	W(472);
	t;
	E(57);
	E(29);
	W(r(p(T(2)), 28, 0));
	t;
	c;
	E(28);
	A;
	t;
	E(56);
	E(29);
	W(500);
	t;
	E(57);
	E(29);
	W(r(p(T(2)), 28, r(J, 16, 0)));
	E(30);
	a(7);
	l(5, 48);
	l(4, r(1, I(T(7)), 9));
	e(1);
	l(7, r(J, I(T(7)), 49));
	B(2, r(1, I(_(5)), I(strrchr(T(r(N, J, 2)), r(N, I(T(7)), 9)))));
	a(6);
	e(1);
	a(1);
	i(r(N, b(M(4, 58)), 0));
	l(5, 49);
	a(1);
	i(r(N, b(M(4, J)), 0));
	l(7, 9);
	l(5, 51);
	l(2, 9);
	return C();
}

int main(){
	i(1);
	E(28);
	E(51);
	E(54);
	E(39);
	j(r(2, 250, 250));
	E(30);
	l(1, 10);
	l(2, 9);
	l(8, 9);
	l(4, 9);
	l(5, 9);
	l(7, 9);
	H(3);
	H(4);
	H(5);
	return C();
}
","#include<fcntl.h>
#include<unistd.h>
#include<termios.h>
#include <sys/time.h>
#include  <sys/mman.h>
# define L } if(!i -- ){
struct timeval F,G; struct termios H,U={ T} ; enum{ N=64,a=N<<7,b=a-1,c=a*32,d
=c-1,    e=c/    2,f=    a*2,    g=a/2,h =g/2,j =h/ 2,Q=V*j*5} ; char*s=P,K,M;
int*      p,      l[      a]      ,m,n,J,o=A,    O=j,E,R,i,k,t,r,q,u,v,w,x,y,z
,B,C,    *D,Z    ;int    main    (){ for(D=mmap(D,4*Q,3,W,open(I,2 ),K); *s; o
++[ l]=k|=* s++%N){ k=* s++%N<<12; k|=*s++% N*N; } tcgetattr(q,& H); tcsetattr
(y,2,    &U);    for(    fcntl(B,4,4); ; o&=b){ if(k&    c){ q=- --k%N; if(!q)
k-=c      ;i      =k      /N&7; { L L if(J&1)    m+=      t; J|=m%N*c; J/=2; m
/= 2;    if(!    q&&r    ^n){ m^=d; J^= d; n=0; } L L    J+=J; J|=m>=0; if(q){
m+=m; m|=J/c; m+=m<0?t:-t; } else{ m+=(m<0)*t; if(r)m^=d; if(n^r)J^= d; n=0; }
L if(    (m^2    *m)/    e%2)    k&=d; else{ J+=J; m+=m; m|=J/c; } L m|=n*c; J
|= m      %N      *c      ;m      /=2; J /=2;    L m+=m; J+=J; J|=n; m|=J/c; L
m+=m;    m|=n    ;  }    J&=d    ; } else{ i=k/f; t=i?k&b:16; p=l+t; if(k&a)p=
l+((*p+=13>i&&7<t&&16>t)&b); { L i=1; L*p=m; L*p++=o|n*e; o=p-l; L*p=0; L m=*p
; L m ^=*p ; L t=m; m    +=*p; m+=d<m    ; n|=((m^t)&    (m^*p))/e; L    m+=*p
; n=m/c; L k=*p; if(      !Z||k/f-8)      /*$    %*/      continue ;      k=-k
; L++*p; o +=!(*p&=d)    ; L m&=*p; L     if(m!=*p)++    o; L o=p -l;    L if(
k&a)n=m/e; if(k&g)J= 0; r=k&h&&m&e; if(k&j)J|=m; else if(r)m^=d; if(k&512)m=0;
i=k/N    &7; { L if(k    &4)J    ^=d; if(k&2)m|=J; if    (k&1    )m|=    q;  }
else      { if(k%N)k      +=      c; { L t =o    ++[      l]      ;       if(r
)J^=d;   L L t=o++[l];   if(r    )J^=d; m-=t; if(m>=0    ){ k    -=c;     n=1;
++o; } } i=2; } L if(Z)k=-1; else{ if(k&8)m=0; t=r=0; i=k/N%N; if(i==27){ if(k
&2)u=v=w=Z=0;    } if    (i==57){ i=k/16&3; { L w =1;    if(k&1)x =0;    if(k&
2) { t= z/N;      t=      t/80*/*/*/100+t% 80;   r=0      ; while(t)      {  r
+=t%10*w; t/=    10;w    <<=4; } m|=r; } if(k&4){ r=m    ; t=0; while    (r) {
t+=r%16*w; w*=10; r>>=4; } r=t/100; t%=100; if(V<=r||79<t)x|=c/8; else z=(r*80
+t)*N    ;  }    w=0;    L if(k& 1&&x    &(e|g) )++o;    if(k& 2)m|=x    |y;if
(k&4      )C      =-      m&65535; L      if(    k&1      )x=y=0; if      (k&2
)B=m;    if (    k&4)    { y^=m&(h|j|    j/2); if(y&j    ){ y^=j;x|=g    ; do{
B&=b; if(y&j/2)z[D]=B[l]; else B[l]=z[D]; ++z; z%=Q; ++B; } while(-- C); } } }
x%=e;    if(x    /a)x    |=e;    if(x&(e|g)&&y&h)u|=c    ; else u%=c;    L if(
k&1)      t=      h;      if      (k&2 )r= e;    if(      k&4){ r=j;      u&=~
h ; }    if(k    &16)    Z=f*    2; L L L t=f; if(k&2    )m|=M|Y; if(    k&4)m
|=u|v; L t=a; if(k&4){ K=m&~Y; write(1,&K,1); u|=t; t=0; } } i=2; if(t){ if(k&
1&&u&t)++ o; if(k&2)u    &=~ t; } if(    r){ if(k&32)    w=r;    else v&=~r; }
} L if(k&a)m=k; else      { t=0; if(      k &    N)t      |=      m/e%2; if(k&
128)t|=!m; if(k&256)t    |= n; if( k&    512 )t=!t; o    +=t;    if(k& h)n =0;
if(k&g)m=0; if(k&1)m^=d; if(k&2)n^=1; if(k&4)m|=S; if(k&8){ m|=n*c; m+=m; if(k
& j)m    +=m;    m|=m    /a/N    ; n=m/c; } if(k&16){ m|=n*c;    m|=m    *2%N*
c; m      /=      2;      if      (k&j) m/=2;    n=m/c; } if      (k      &32)
{ if(    Z)k=    -1 ;    else    break; } } } } n&=1; if(k<c)    {  m    &= d;
o &=b; if(!R--){ if (~u&f &&read(0, &M,1)>0){ if(X&& M== X)break; R=0; u|=f; }
gettimeofday(&G,0); G.tv_usec/=16667; if(G.tv_sec>F.tv_sec||F.tv_usec<G.
tv_usec){ F=G; if(v&j){ p=l+7; ++*p; *p&=d; if(!*p)u|=h; } R=0; } if
(!R){ E=O/4; O=4; } O+=R=E; } if(!++k||(v&e&&u)){ *l=o|n*e|Z;v%=
e; o=1+!k; Z=0; } v|=w; w=0; k=o++[l]; } }tcsetattr(w,1,&H); }
","#include <stdio.h>
#include <unistd.h>
#include <time.h>
#define p return 
#define X typedef
#define E {
#define B }
#define stup(y)printf(""%.11s\n"",(char*)y);
#define $ printf(""\x1b""
#define G(y)usleep(y);fflush(stdout);
#define O __DATE__+7
#define K printf(
X unsigned short P;
X int _;
_ s=41456; //Sleeping time factor
X char H;
_ o,b,a,f,g,k, m; // Oh, be a fine girl, kiss me
FILE *W;
X enum  {T,F}  z; //True & False
X double w;
_ a5_, N = 11,A4=1<<3,a8_=17,A8=2*2,aI_=~-(__FLT_MAX_EXP__<<F);
H l[]=""uDSYT8|TCPZ8|TVCTKp]X^EY|XKPC8aYTRUPp]ZPXU"";H I[]=""Fo~y*lcdn*yego*Oky~ox*ommy"";/*
						      /\
						      c_
						     [9];
			alpha Ursae Minoris A	     main
						    */_ a1,
						   a3 ,a4=
						   024;P a2
						  ,a5;w Z( w
						 D,_ Y)E if(Y
						 ==T)p F;if(Y
						==!0)p D; w b=
					       Z(D,Y/2);if(Y>2	    /* alpha Ursae Minoris Ab*/
					       )p b*b*D;p b*b ;
					      B _ u(_ x) E if( x			    <2)p
					      F;p x*u(x-unix); B
	/*alpha Ursae Minoris B*/	    _ vir(H __[]) E _ e,
					    q=0;for(e=T;e[__];e++)
	   q=q*				    -~9+__[e]-48;p q;B P A
					   (H *a7_, _ a6_ );w V(_ v
					  ,_ i){v%=0550;w D='-'-'-';
					 for(i-=i;i^__CHAR_BIT__;i++
 )D+=Z(_POSIX_TRACE,i)*Z(0x1.1df46a226e211p-6 *v,2*i)/u(2*i);p D;B _ main(a6,n)_ a6;H**n;E _ a7,A1,a1_,a8,t,
    A6,D,Y;size_t a3_;_ A2[]=E'q',W_OK,5911774,'y',13,1052160,77,15,1709568,'5',a8_,1314816,34,18,1446400
       ,91,22,1314816,12,28,F_OK B;time_t j =time(NULL);a4 *= '_' ;float and [] =/*trolling is a art */
	  E  4612954808543207739097088.0, 207.285645,  214354950132336733650542884425029386240.0 B ;
	    struct tm  R = *localtime (&j) ;for (;t=aI_ ,a5_[l];) l[a5_++] ^=-~__LINE__ ; A6=a4 +=
	      R.tm_year;a4 /='d';ssize_t A3 =1;k=A6/'d',b=k/A8,a=k%4,o=(k-((k+A4)/25)+1)/F_TEST
		 ,m=(19*(A6%a4 )+k-b-o+__DBL_DIG__)%30,k=(A6%'d')/R_OK;H*a2_=NULL;f=(A6%'d')%
		    R_OK,g=(' '+2*a+SEEK_END*k-m-f)%7,k=__ATOMIC_SEQ_CST;W=fopen(__FILE__,
		      ""r"" ); $""[40m\033[2J\033[;H\x1b[?25l"");if(*(H *)(_[])E X_OK B)stup
			 (and)A3 =getdelim(&a2_,&a3_,'\0', W);b=((A6%19)+N*m+22*g)/(N*
			   ')'),o=m+g-(~-A4)*b+'r',D=o/31;for(;a1[I];a1++,a5_=0xb3)
			      I[a1 ]^= '-'-'#';Y=o% ~-' ' +F;for(a3 =T;a3<A3 ;++
				 a3 )a2 =(a2  +a2_[a3 ])%255,a5 =(a5 +a2 )%t;
				  if((a5 <<8|a2 )^s) goto a4_;$ ""[1;12H  "" )
				 ;G(a4 *s)a4 ^=a4 ;k*=2172211;while(a5_-->-1)
				 E $ ""[40m\x1b[2J"");for(a6=W_OK;a6<025;a6 +=3)
				E a7  = A2 [ a6 -__FLT_RADIX__ ] - 0102, a8 =k
			       + a6 [A2],a1 = A2[~-a6 ] *0x1.db6db6db6a92ap+0 ;
			      a1-=~-__DBL_DIG__,a1_=a7 *V(a5_,_XOPEN_VERSION ) -
			      a1*V(90-a5_,a7 )+66,A1 =(a7*V(90-a5_,a1 ) +a1 *V (
			     a5_,a8 )+0xe)/1.8571428571;if(A1 >T&&a1_>0) E $""[3""
			     ""8;2;%d;%d;%dm"", (a8>> 16  )&t,(a8>>8)& 255,a8 &t);$
			    ""[%d;%dH%c %.*s"",A1,a1_	   ,a5_>90?46:111,6,a5_>45
			   ?"""":l+ ((a6-F_TLOCK) /	      __ATOMIC_RELEASE)*6);
			   B B G(u(A4 ) )B/**/		       a4_:$    ""[H\x1b[0m""
			  ""\x1b[?25h"") ;if(			  ( D^ (R.tm_mon+1))
			  == (Y-= R./* */			    tm_mday) ) E   K
			 ""%s\n"",I);B K				       """"     ""%d\n"",
			vir(O)  );p					  a4 ;B //END\
@			OF  THIS					     ENTRY IS\
@		       N E A R						       SO NEAR\
@		      .*****							 ******\
@		      ****							    ***\
@		     .									.














","#include <stdio.h>
#include <unistd.h>
#include <time.h>
#define p return 
#define X typedef
#define E {
#define B }
#define stup(y)printf(""%.11s\n"",(char*)y);
#define $ printf(""\x1b""
#define G(y)usleep(y);fflush(stdout);
#define O __DATE__+7
#define K printf(
X unsigned short P;
X int _;
_ s=41456; //Sleeping time factor
X char H;
_ o,b,a,f,g,k, m; // Oh, be a fine girl, kiss me
FILE *W;
X enum  {T,F}  z; //True & False
X double w;
_ a5_, N = 11,A4=1<<3,a8_=17,A8=2*2,aI_=~-(__FLT_MAX_EXP__<<F);
H l[]=""uDSYT8|TCPZ8|TVCTKp]X^EY|XKPC8aYTRUPp]ZPXU"";H I[]=""Fo~y*lcdn*yego*Oky~ox*ommy"";/*
						      /\
						      c_
						     [9];
			alpha Ursae Minoris A	     main
						    */_ a1,
						   a3 ,a4=
						   024;P a2
						  ,a5;w Z( w
						 D,_ Y)E if(Y
						 ==T)p F;if(Y
						==!0)p D; w b=
					       Z(D,Y/2);if(Y>2	    /* alpha Ursae Minoris Ab*/
					       )p b*b*D;p b*b ;
					      B _ u(_ x) E if( x			    <2)p
					      F;p x*u(x-unix); B
	/*alpha Ursae Minoris B*/	    _ vir(H __[]) E _ e,
					    q=0;for(e=T;e[__];e++)
	   q=q*				    -~9+__[e]-48;p q;B P A
					   (H *a7_, _ a6_ );w V(_ v
					  ,_ i){v%=0550;w D='-'-'-';
					 for(i-=i;i^__CHAR_BIT__;i++
 )D+=Z(_POSIX_TRACE,i)*Z(0x1.1df46a226e211p-6 *v,2*i)/u(2*i);p D;B _ main(a6,n)_ a6;H**n;E _ a7,A1,a1_,a8,t,
    A6,D,Y;size_t a3_;_ A2[]=E'q',W_OK,5911774,'y',13,1052160,77,15,1709568,'5',a8_,1314816,34,18,1446400
       ,91,22,1314816,12,28,F_OK B;time_t j =time(NULL);a4 *= '_' ;float and [] =/*trolling is a art */
	  E  4612954808543207739097088.0, 207.285645,  214354950132336733650542884425029386240.0 B ;
	    struct tm  R = *localtime (&j) ;for (;t=aI_ ,a5_[l];) l[a5_++] ^=-~__LINE__ ; A6=a4 +=
	      R.tm_year;a4 /='d';ssize_t A3 =1;k=A6/'d',b=k/A8,a=k%4,o=(k-((k+A4)/25)+1)/F_TEST
		 ,m=(19*(A6%a4 )+k-b-o+__DBL_DIG__)%30,k=(A6%'d')/R_OK;H*a2_=NULL;f=(A6%'d')%
		    R_OK,g=(' '+2*a+SEEK_END*k-m-f)%7,k=__ATOMIC_SEQ_CST;W=fopen(__FILE__,
		      ""r"" ); $""[40m\033[2J\033[;H\x1b[?25l"");if(*(H *)(_[])E X_OK B)stup
			 (and)A3 =getdelim(&a2_,&a3_,'\0', W);b=((A6%19)+N*m+22*g)/(N*
			   ')'),o=m+g-(~-A4)*b+'r',D=o/31;for(;a1[I];a1++,a5_=0xb3)
			      I[a1 ]^= '-'-'#';Y=o% ~-' ' +F;for(a3 =T;a3<A3 ;++
				 a3 )a2 =(a2  +a2_[a3 ])%255,a5 =(a5 +a2 )%t;
				  if((a5 <<8|a2 )^s) goto a4_;$ ""[1;12H  "" )
				 ;G(a4 *s)a4 ^=a4 ;k*=2172211;while(a5_-->-1)
				 E $ ""[40m\x1b[2J"");for(a6=W_OK;a6<025;a6 +=3)
				E a7  = A2 [ a6 -__FLT_RADIX__ ] - 0102, a8 =k
			       + a6 [A2],a1 = A2[~-a6 ] *0x1.db6db6db6a92ap+0 ;
			      a1-=~-__DBL_DIG__,a1_=a7 *V(a5_,_XOPEN_VERSION ) -
			      a1*V(90-a5_,a7 )+66,A1 =(a7*V(90-a5_,a1 ) +a1 *V (
			     a5_,a8 )+0xe)/1.8571428571;if(A1 >T&&a1_>0) E $""[3""
			     ""8;2;%d;%d;%dm"", (a8>> 16  )&t,(a8>>8)& 255,a8 &t);$
			    ""[%d;%dH%c %.*s"",A1,a1_	   ,a5_>90?46:111,6,a5_>45
			   ?"""":l+ ((a6-F_TLOCK) /	      __ATOMIC_RELEASE)*6);
			   B B G(u(A4 ) )B/**/		       a4_:$    ""[H\x1b[0m""
			  ""\x1b[?25h"") ;if(			  ( D^ (R.tm_mon+1))
			  == (Y-= R./* */			    tm_mday) ) E   K
			 ""%s\n"",I);B K				       """"     ""%d\n"",
			vir(O)  );p					  a4 ;B //END\
			OF  THIS					     ENTRY IS\
		       N E A R						       SO NEAR\
		      .*****							 ******\
		      ****							    ***\
		     .									.














","#include <stdio.h>
#include <unistd.h>
#include <time.h>
#define p return 
#define X typedef
#define E {
#define B }
#define stup(y)printf(""%.11s\n"",(char*)y);
#define $ printf(""\x1b""
#define G(y)usleep(y);fflush(stdout);
#define O __DATE__+7
#define K printf(
X unsigned short P;
X int _;
_ s=37985; //Sleeping time factor
X char H;
_ o,b,a,f,g,k, m; // Oh, be a fine girl, kiss me
FILE *W;
X enum  {T,F}  z; //True & False
X double w;
_ a5_, N = 11,A4=1<<3,a8_=17,A8=2*2,aI_=~-(__FLT_MAX_EXP__<<F);
H l[]=""uDSYT8|TCPZ8|TVCTKp]X^EY|XKPC8aYTRUPp]ZPXU"";H I[]=""Fo~y*lcdn*yego*Oky~oxd*ommy"";/*
						      /\
						      c_
						     [9];
			alpha Ursae Minoris A	     main
						    */_ a1,
						   a3 ,a4=
						   024;P a2
						  ,a5;w Z( w
						 D,_ Y)E if(Y
						 ==T)p F;if(Y
						==!0)p D; w b=
					       Z(D,Y/2);if(Y>2	    /* alpha Ursae Minoris Ab*/
					       )p b*b*D;p b*b ;
					      B _ u(_ x) E if( x			    <2)p
					      F;p x*u(x-unix); B
	/*alpha Ursae Minoris B*/	    _ vir(H __[]) E _ e,
					    q=0;for(e=T;e[__];e++)
	   q=q*				    -~9+__[e]-48;p q;B P A
					   (H *a7_, _ a6_ );w V(_ v
					  ,_ i){v%=0550;w D='-'-'-';
					 for(i-=i;i^__CHAR_BIT__;i++
 )D+=Z(_POSIX_TRACE,i)*Z(0x1.1df46a226e211p-6 *v,2*i)/u(2*i);p D;B _ main(a6,n)_ a6;H**n;E _ a7,A1,a1_,a8,t,
    A6,D,Y;size_t a3_;_ A2[]=E'q',W_OK,5911774,'y',13,1052160,77,15,1709568,'5',a8_,1314816,34,18,1446400
       ,91,22,1314816,12,28,F_OK B;time_t j =time(NULL);a4 *= '_' ;float and [] =/*trolling is a art */
	  E  4612954808543207739097088.0, 207.285645,  214354950132336733650542884425029386240.0 B ;
	    struct tm  R = *localtime (&j) ;for (;t=aI_ ,a5_[l];) l[a5_++] ^=-~__LINE__ ; A6=a4 +=
	      R.tm_year;a4 /='d';ssize_t A3 =1;k=A6/'d',b=k/A8,a=k%4,o=(k-((k+A4)/25)+1)/F_TEST
		 ,m=(19*(A6%a4 )+k-b-o+__DBL_DIG__)%30,k=(A6%'d')/R_OK;H*a2_=NULL;f=(A6%'d')%
		    R_OK,g=(' '+2*a+SEEK_END*k-m-f)%7,k=__ATOMIC_SEQ_CST;W=fopen(__FILE__,
		      ""r"" ); $""[40m\033[2J\033[;H\x1b[?25l"");if(*(H *)(_[])E X_OK B)stup
			 (and)A3 =getdelim(&a2_,&a3_,'\0', W);b=((A6%19)+N*m+22*g)/(N*
			   ')'),o=m+g-(~-A4)*b+'r',D=o/31;for(;a1[I];a1++,a5_=0xb3)
			      I[a1 ]^= '-'-'#';Y=o% ~-' ' +F;for(a3 =T;a3<A3 ;++
				 a3 )a2 =(a2  +a2_[a3 ])%255,a5 =(a5 +a2 )%t;
				  if((a5 <<8|a2 )^s) goto a4_;$ ""[1;12H  "" )
				 ;G(a4 *s)a4 ^=a4 ;k*=2172211;while(a5_-->-1)
				 E $ ""[40m\x1b[2J"");for(a6=W_OK;a6<025;a6 +=3)
				E a7  = A2 [ a6 -__FLT_RADIX__ ] - 0102, a8 =k
			       + a6 [A2],a1 = A2[~-a6 ] *0x1.db6db6db6a92ap+0 ;
			      a1-=~-__DBL_DIG__,a1_=a7 *V(a5_,_XOPEN_VERSION ) -
			      a1*V(90-a5_,a7 )+66,A1 =(a7*V(90-a5_,a1 ) +a1 *V (
			     a5_,a8 )+0xe)/1.8571428571;if(A1 >T&&a1_>0) E $""[3""
			     ""8;2;%d;%d;%dm"", (a8>> 16  )&t,(a8>>8)& 255,a8 &t);$
			    ""[%d;%dH%c %.*s"",A1,a1_	   ,a5_>90?46:111,6,a5_>45
			   ?"""":l+ ((a6-F_TLOCK) /	      __ATOMIC_RELEASE)*6);
			   B B G(u(A4 ) )B/**/		       a4_:$    ""[H\x1b[0m""
			  ""\x1b[?25h"") ;if(			  ( D^ (R.tm_mon+1))
			  == (Y-= R./* */			    tm_mday) ) E   K
			 ""%s\n"",I);B K				       """"     ""%d\n"",
			vir(O)  );p					  a4 ;B //END\
			OF  THIS					     ENTRY IS\
		       N E A R						       SO NEAR\
		      .*****							 ******\
		      ****							    ***\
		     .									.














","               #include             <stdio.h>
                #include                         <string.h>
                 #include   <stdlib.h>
                  typedef                 unsigned
                   long W;        static
               W*i,t,c,h,e,r,y,**a,*b,*o,*u,*n,*d,*s;enum
          _ {F=6   , I=7,N=  5  ,   D     =     3      ,M=14
        ,Y=0     ,    C=8,L   =  1    , U     =   9   ,    E=4};
        static void   (* _ )    ( )    ;  static void*(*B)(),*T;
         static char m[0x3543],*Z;void *meltdown(void *p,size_t
        sz){ void *z=realloc(p,sz);if(!z||!sz)exit(n?y!=*n:I-F);
       return z;}void magic(W*p){W j;for(j=0;j<p[F];j++){W*v=T,Q=
      p[M+j];W*J=a[Q];if(N[J]==~0LU){ _ (Q);v=&I[J];}else if(J[D])
     {v=&N[J];}if(v&&I[p]>*v)I[p]=*v;}}void cast(void){B(i,Y);}void
    spell(W G,W H){ _ (); _ (H); _ (H, G); _ (H); _ (G);}void witch(
   void){e=n[--E[b]];a[e][D]=0;if(b[C]>=U[b]){c=2*(b[C+L]?b[U]:1);o=B
  (d,c *sizeof*o);u=B(s,c*sizeof*o);b[M-N]=c;d=o;s=u;}d[b[N+D]++]=e;if
  (e>y)y=e;}void*brew(void*g,size_t l){puts(l?"""":""Out of range."");exit
 (g?1:1);}void newt(W *p){F[p]=0;N[p]=I[p]=~F[p];}void bubble(W H){for
 (t=0;t<H;t++){s[i[d[H-t-1]]---1]=d[H-t-1];}}void boil(W G){for(t=0;t<
G-1;t++){i[t+1]+=i[t];} _ =bubble;}void hex(W G,W H){for(t=0;t<H?G:Y;t++
){i[d[t]]++;} _ =boil;}void nasal_demons(W G){for (t=Y;t<G;t++)i[t]=0; _
 =hex;}void toil(void){i=B(i,y*sizeof*i); _ =nasal_demons;}void bat(W l)
{C[b]=0; _ =witch;do _ ();while(e!=l);y++;if(!y)B=brew; _ =toil;spell (C
[b],y);printf(""%lu:"",b[L]++);for(y=0;y<C[b];y++){printf("" %lu"",s[y]);}y=
0;puts("""");}void potion(W l){W*p=a[l];if(p[N]!=~0LU)return;p[F+L]=h;p[N]
=h;p[D]=1;h++;n[b[L+D]++]=l;if(E[b]==r){r*=2;n=B(n,r*sizeof*n);}magic(p)
;if(I[p]==p[N]){bat(l);} _ =potion;}void O(void){n=B(n,2*sizeof(*n));Y[n
]=r;if(a&&a[t]){r=2;b=a[t]; _ =potion;b[L+C]=b[L]^=b[L];E[b]=1;for(y=0;y
 <*n;y++){if(a[y]){ _ (y);}}} _ =cast;h=0;}void toad(W g,W j,W*l){o=B(a
 [g],((a[g]?a[g][F]:0)+j+M)*sizeof*o); _ =newt;if(!a[g]){ _ (o);}for(y=
  0;y<j;y++){o[F[o]+F+C]=l[y];o[F]++;if(l[y]==g){continue;}u=B(a[l[y]]
   ,((a[l[y]]?a[l[y]][F]:Y)+M)*sizeof*u);if(!a[l[y]]){ _ (u);}a[l[y]]
     =u;}y=0;a[g]=o;}void familiar(void){W**w;e=r;if(!r){r=1;}while
        (r<=t){r*=2;if(!r){B=brew;break;}}w=B(a,r*sizeof*a);if(!
             Z){Z=""\x5f"";}for(y=e;y<r;y++){y[w]=T;}y=0;a=w;
            _ (Y[i]  ,c-1,&i[1]);}void spectre(void  ){if((W)
          *Z-060                                        >011){
       return;}                                            _ =toad
     ;i[c]=(                                                W)atoi(

Z);if(i[c]>t){t=i[c];}c++;if(c==h){i=B(i,2*h*sizeof*i);h*=2;}y=i[c-1];if
((Z=strtok(T,"" \t""))){if(U>=(W)*Z-I*I+L) _ =spectre;}}int main(int argv,
char**argc){h++;if(argc){T=argc[argv];} _:_ =O;i=(B=meltdown)(T,h*sizeof
*i);while(*argc||Z){c=0;*argc=fgets(m,sizeof(m),stdin); _ =spectre;if(!*
argc){Z=T;goto _ ;}Z=strtok(*argc,""\t "");while(Z&&(W)*Z-(M*D+F)<=U){ _ (
);}if(t>=r)familiar();else if(c>0){ _ (i[Y],c-1,&i[1]);}} _ ();goto _ ;}
","#include/*nui*/<stdio.h>//;70/*#}r[3]op;f(p;ok})i[;k-r*?(rc&(o}nr**s*2)!}-mpi##
extern int n0;typedef int x;x//i/eu2->uuo0uo=;nXfdx+1e8uOeh&k-x[e1(i)>{=eqa,nii
n,u,k,o,_,i=1;static char//[X]/f/t]:n=t-rxt+0f[=(-=+;t)*,aa!>1=dt0pzrpi(l)idtnn
d[1125][0x401];x main(){if(//]* nu]O[nc-(ac=;odxx1k]}u)2ulr(=00+u2=ee&fos{n,*cc
i){for(n=0;1024>n;n++)//]Tkhng[0ur)[u[h>u)h1or];>]-=Or):=l*Ou);+r4poa&(=ep(qnll
for(u=0x0;u<1025;)d[n][u++]=64//[n;o]ua0=)a,<(=}X;no[n{8uo)=&{i]n)?fl!!g{u)=,uu
/2;for(u=n=0////////]_#p^#onui[/u+}+?+r;d{r/X////////////c/(&if=-)p(l(xewt{1udd
/4;EOF!=(o=////////////]#ebdl#ah[0}n/1()////////////////////1f(k1)*ion)thsO;,ee
getchar())//        //////]u#oh[,;///////////            //////;;)2nc={ci(=ck<<
&&u<1024;//            /////////////////                    ////}{:t((ihl""Nh,ss
)u+=o-10//                /////////                            ///2)nifaeYUaott
?n<1024//                                                       ////,n(r(uLr,dd
?d[n++//       @@@                                                ///td(EuL*Xli
][u]=o//      @   @                                                ///+)Or;O,io
,k=k<//       @   @                                                 ///)Fii;xb.
n?n:k//       @   @                                                   ///""fi,.h
,0:0//         @@@                                                     //)(n/h>
:!(n//                                                                 //;0t/>/
=0);//                                                                  //!/|//
for(//      5                                                           //=/*/%
 ;k--//     12                                                           =q tni
;)d[k//                                                                  //))u/
/01][u//                                                                 //1Ni/
/1]/*n///                                                                //(Ui;
>*/=!/*N//                                                               //=K~/
h*/1,/*UN///                                                            //nqO~*
.*/puts/*n////                                                          //[/?,]
o*/(d[k])/*u//////               ///////                                //1*q[u
i*/;}else{//t/////////////      ///////////                            //,stup;
d[0][0]++;puts(/*f/////////     //]====[////////                       //(N tni
ti&/N/////.///s/It]]_bz8[//     ///SHOUJO\vv///////////               //;}""jvo""
su /U/////N///t}Ue]~J#phi[//    //\SHUUMATSU|]_[////////             ///,""/utf""
<ntt/fe=)|UI0{u;Nnu]^u#j[v//    //,^^\RYOKOU/:)]a#p[.//            ///""c!tj!xb""
e/ n/ilI(|/(1ep)/ *>->IOCCC//   //]^#dbi#`h#anuok^u#[//          ///""S"",""/ttfm""
d/eit{i(rl/r-s-""/e/]o[^^^^^!/////]hfhu[Qj:FfT]uhp)~[[//      ///""iuspx!fsb!tho""
unn;n)h=a({aIl0onnt//""jiu!fmcjefoJ"",""/zsbdt!fsb!tobnvI!""  ""///"",""~<1!osvufs<*2""
lriqi(w!hf)h=e1trin//"".;2;1;1+*432&25\*3,o)_6)92x\sbiduvq@1=v@2:.o@4:.o),v,1/>""
cef ;n{Fci2cl}-iufi//""v*1?**)sbidufh>o))fmjix|*)ojbn!uoj<v-o!uoj31\?i/pjeut=fe""
ntetli)Ot{3t;}lhte}//""vmdoj$"",""svpU!utbM!(tmsjH""{=]041[]6[u,n*rahc;q tni nretxe
ixdn,aqEe)-u)}=Ced;//};0+nruter;)K(U;)++n*--;n*;K=n(rof{)(niam )O,K,U(N enifed#
#e#iIm((g)Ip ;I""r#0.[(c)2018][cffc189a]*/""Nuko"");}return+0;}//>h.oidts<edulcni#
","/*
 * iocccsize - IOCCC Source Size Tool
 *
 * This IOCCC size tool source file is version 2017-12-25-v25.
 *
 * ""You are not expected to understand this"" :-)
 *
 * Public Domain 1992, 2015 by Anthony Howe.  All rights released.
 * With IOCCC minor mods in 2013-2017 by chongo (Landon Curt Noll) ^oo^
 *
 * SYNOPSIS
 *
 * 	ioccc [-kirs] < input
 *
 *	-k	keep comment blocks
 *	-i	IOCCC size rule (overall size, modified)
 *	-r	count C reserved words as 1 byte
 *	-s	suppress source output, write only the IOCCC 2nd size count
 *
 * DESCRIPTION
 *
 *	Taking input from standard input, apply the IOCCC Source Size Rule
 *	for 2001.  The program's official length is written to standard error.
 *	Also filter out C comment blocks (-k to keep) sending the modified
 *	source to standard output.
 *
 *	The 2001 Source Size Rule was:
 *
 *	Your entry must be <= 4096 bytes in length.  The number of octets
 *	excluding whitespace (tab, space, newline, form-feed, return), and
 *	excluding any ';', '{' or '}' followed by whitespace or end of file,
 *	must be <= 2048.
 *
 *	2013 Source Size Rule is (-r):
 *
 *	Your entry must be <= 4096 bytes in length.  The number of octets
 *	excluding whitespace (tab, space, newline, form-feed, return), and
 *	excluding any ';', '{' or '}' followed by whitespace or end of file,
 *	and where C reserved words, including a subset of preprocessor words,
 *	count as 1 byte, must be <= 2053 (first prime after 2048).
 */

/*
 * The official IOCCC rule 2 secondary limit on C code size
 *
 * The IOCCC size tool should be compiled as:
 *
 *      cc -pedantic -Wall -std=c99 iocccsize.c -o iocccsize
 *
 * This tool computes a 2nd size C code.  To check your program source
 * against the 2nd limit of rule 2, use the -i command line option.
 *
 * For example:
 *
 *      ./iocccsize -i < prog.c
 *
 * The IOCCC size tool, when using the -i option, may be summarized as:
 *
 *      The size tool counts C language keywords (primary, secondary, and
 *      selected preprocessor keywords) as 1.  The size tool counts all
 *      other octets as 1 excluding ASCII whitespace, and excluding any
 *      ';', '{' or '}' followed by ASCII whitespace, and excluding any
 *      ';', '{' or '}' octet immediately before the end of file.
 *
 * ASCII whitespace includes ASCII tab, ASCII space, ASCII newline,
 * ASCII form-feed, and ASCII carriage return.
 *
 * In cases where the above summary and the algorithm implemented by
 * the IOCCC size tool source code conflict, the algorithm implemented
 * by the IOCCC size tool source code is preferred by the judges.
 *
 * See the current IOCCC rules and guidelines for more information.
 * In particular, see the current IOCCC size rule for information about
 * the maximum value that this tool should print for an entry to be valid.
 */

/*
 * IOCCC Judge's remarks:
 *
 * This code contains undocumented features.  On the other hand, this code
 * is RTFS (for certain values of RTFS). One might say that this code
 * perfectly documents itself. :-)
 *
 * Many thanks to Anthony Howe for taking the time to put his OCD
 * (Obfuscated Coding Determination) into this code!
 */

/*
 * HINT: The algorithm implemented by this code may or not be obfuscated.
 *       The algorithm may not or may appear to be obfuscated.
 *
 * In particular:
 *
 *      We did not invent the algorithm.
 *      The algorithm consistently finds Obfuscation.
 *      The algorithm killed Obfuscation.
 *      The algorithm is banned in C.
 *      The algorithm is from Bell Labs in Jersey.
 *      The algorithm constantly finds Obfuscation.
 *      This is not the algorithm.
 *      This is close.
 */

#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <getopt.h>

#define FLAG_SILENCE		1
#define FLAG_KEEP		2
#define FLAG_RESERVED		4
#define FLAG_IOCCC		8
#define FLAG_SILLY_C		16
#define FLAG_SILLY_H		32

#define BUFFER_SIZE		521
#define MAX_SIZE		4096	/* IOCCC Rule 2 */
#define MAX_COUNT		2053	/* IOCCC Rule 2 */

static char usage[] =
""usage:  ioccc [-kirsch] < prog.c\n""
""\n""
""-k\t\tkeep block comments\n""
""-i\t\tprint official secondary IOCCC size to stdout\n""
""\t\tmax.size warnings to stderr, NOTE: implies -r -s\n""
""-r\t\tcount C reserved words as 1 byte\n""
""-s\t\tsuppress source output, write only the official size\n""
""-c\t\tan undocumented feature\n""
""-h\t\tyet another undocumented feature\n""
;

#define STRLEN(s)		(sizeof (s)-1)

typedef struct {
	size_t length;
	const char *word;
} Word;

/*
 * C reserved words, plus a few #preprocessor tokens, that count as 1
 *
 * NOTE: For a good list of reserved words in C, see:
 *
 *	http://www.bezem.de/pdf/ReservedWordsInC.pdf
 *
 * by Johan Bezem of JB Enterprises:
 *
 *	See http://www.bezem.de/en/
 */
/*
 * The following editorial plea expresses a view shared by more than zero
 * IOCCC judges. It may not represent the opinion of all those involved
 * with this code nor the International Obfuscated C Code Contest as a whole:
 *
 * The long list of reserved words below should be a source
 * of embarrassment to some of those involved in standardizing C.
 * The growing list of reserved words, along with an expanding set of
 * linguistic inventions has the appearance of feature
 * creep that, if left unchecked, risks turning a beautifully elegant
 * language into a steaming pile of biological excretion.
 *
 * The history of the IOCCC has taught us that even minor changes
 * to the language are not always well understood by compiler writers,
 * let alone the standards body who publishes them. We have enormous
 * sympathy for C compiler writers who must keep up with the creeping
 * featurism.  We are aware of some C standards members who share
 * these concerns.  Alas, they seem to be a minority.
 *
 * The C standards body as a whole, before they emit yet more mountains of new
 * standardese, might wish consider the option of moth-balling their committee.
 * Or if they must produce a new standard, consider naming whatever
 * follows c11 as CNC (C's Not C).  :-)
 */
static Word cwords[] = {
	/* Yes Virginia, we left #define off the list on purpose! */
	{ STRLEN(""#elif""), ""#elif"" },
	{ STRLEN(""#else""), ""#else"" },
	{ STRLEN(""#endif""), ""#endif"" },
	{ STRLEN(""#error""), ""#error"" },
	{ STRLEN(""#ident""), ""#ident"" },
	{ STRLEN(""#if""), ""#if"" },
	{ STRLEN(""#ifdef""), ""#ifdef"" },
	{ STRLEN(""#include""), ""#include"" },
	{ STRLEN(""#line""), ""#line"" },
	{ STRLEN(""#pragma""), ""#pragma"" },
	{ STRLEN(""#sccs""), ""#sccs"" },
	{ STRLEN(""#warning""), ""#warning"" },
	/**/
	{ STRLEN(""_Alignas""), ""_Alignas"" },
	{ STRLEN(""_Alignof""), ""_Alignof"" },
	{ STRLEN(""_Atomic""), ""_Atomic"" },
	{ STRLEN(""_Bool""), ""_Bool"" },
	{ STRLEN(""_Complex""), ""_Complex"" },
	{ STRLEN(""_Generic""), ""_Generic"" },
	{ STRLEN(""_Imaginary""), ""_Imaginary"" },
	{ STRLEN(""_Noreturn""), ""_Noreturn"" },
	{ STRLEN(""_Pragma""), ""_Pragma"" },
	{ STRLEN(""_Static_assert""), ""_Static_assert"" },
	{ STRLEN(""_Thread_local""), ""_Thread_local"" },
	/*
	 * this comment is not expected to understand itself
	 */
	{ STRLEN(""alignas""), ""alignas"" },
	{ STRLEN(""alignof""), ""alignof"" },
	{ STRLEN(""and""), ""and"" },
	{ STRLEN(""and_eq""), ""and_eq"" },
	{ STRLEN(""auto""), ""auto"" },
	{ STRLEN(""bitand""), ""bitand"" },
	{ STRLEN(""bitor""), ""bitor"" },
	{ STRLEN(""bool""), ""bool"" },
	{ STRLEN(""break""), ""break"" },
	{ STRLEN(""case""), ""case"" },
	{ STRLEN(""char""), ""char"" },
	{ STRLEN(""compl""), ""compl"" },
	{ STRLEN(""const""), ""const"" },
	{ STRLEN(""continue""), ""continue"" },
	{ STRLEN(""default""), ""default"" },
	{ STRLEN(""do""), ""do"" },
	{ STRLEN(""double""), ""double"" },
	{ STRLEN(""else""), ""else"" },
	{ STRLEN(""enum""), ""enum"" },
	{ STRLEN(""extern""), ""extern"" },
	{ STRLEN(""false""), ""false"" },
	{ STRLEN(""float""), ""float"" },
	{ STRLEN(""for""), ""for"" },
	{ STRLEN(""goto""), ""goto"" },
	{ STRLEN(""I""), ""I"" },
	{ STRLEN(""if""), ""if"" },
	{ STRLEN(""inline""), ""inline"" },
	{ STRLEN(""int""), ""int"" },
	{ STRLEN(""long""), ""long"" },
	{ STRLEN(""noreturn""), ""noreturn"" },
	{ STRLEN(""not""), ""not"" },
	{ STRLEN(""not_eq""), ""not_eq"" },
	{ STRLEN(""or""), ""or"" },
	{ STRLEN(""or_eq""), ""or_eq"" },
	{ STRLEN(""register""), ""register"" },
	{ STRLEN(""restrict""), ""restrict"" },
	{ STRLEN(""return""), ""return"" },
	{ STRLEN(""short""), ""short"" },
	{ STRLEN(""signed""), ""signed"" },
	{ STRLEN(""sizeof""), ""sizeof"" },
	{ STRLEN(""static""), ""static"" },
	{ STRLEN(""static_assert""), ""static_assert"" },
	{ STRLEN(""struct""), ""struct"" },
	{ STRLEN(""switch""), ""switch"" },
	{ STRLEN(""thread_local""), ""thread_local"" },
	{ STRLEN(""true""), ""true"" },
	{ STRLEN(""typedef""), ""typedef"" },
	{ STRLEN(""union""), ""union"" },
	{ STRLEN(""unsigned""), ""unsigned"" },
	{ STRLEN(""void""), ""void"" },
	{ STRLEN(""volatile""), ""volatile"" },
	{ STRLEN(""while""), ""while"" },
	{ STRLEN(""xor""), ""xor"" },
	{ STRLEN(""xor_eq""), ""xor_eq"" },
	/**/
	{ 0, NULL }
};

/*
 * Keep track of discarded bytes by read_line() so count() can report
 * correct wc(1) equivalent counts.
 */
static int xlcount = 0;
static int xwcount = 0;
static int xbcount = 0;

static Word *
find_member(Word *table, const char *string)
{
	Word *w;
	for (w = table; w->length != 0; w++) {
		if (strncmp(string, w->word, w->length) == 0
		&& !isalnum(string[w->length]) && string[w->length] != '_')
			return w;
	}
	return NULL;
}

/*
 * ISO C11 section 5.2.1.1 Trigraph Sequences, leading sequence ""??""
 */
static char trigraph[] = ""=(/)'<!>-"";
static char asciimap[] = ""#[\\]^{|}~"";

static size_t
read_line(char *buf, size_t size)
{
	int ch;
	size_t length;

	if (buf == NULL || size == 0)
		return 0;

	for (size--, length = 0; length < size; ) {
		if ((ch = fgetc(stdin)) == EOF)
			break;
		/* Map NUL bytes to space, though ideally I should chuck'em. */
		if (ch == '\0')
			ch = ' ';
		/* Discard bare CR and those part of CRLF. */
		if (ch == '\r') {
			xbcount++;
			continue;
		}
		/* Trigraph mapping? */
		if (2 <= length && buf[length-2] == '?' && buf[length-1] == '?') {
			char *tri;
			if ((tri = strchr(trigraph, ch)) != NULL) {
				/* Mapped trigraphs count as 1 byte. */
				ch = asciimap[tri - trigraph];
				xbcount += 2;
				length -= 2;
			}
		}
		if (ch == '\n' && 1 <= length && buf[length-1] == '\\') {
			/* ISO C11 section 5.1.1.2 Translation Phases
			 * point 2 discards backslash newlines.
			 */
			xbcount += 2;
			xwcount++;
			xlcount++;
			length--;
			continue;
		}
		buf[length++] = (char) ch;
		if (ch == '\n') {
			break;
		}
	}

	buf[length] = '\0';

	return length;
}

/*
 * Count octets and strip comments.  The stripped C input is sent to
 * standard output.  If -s is set, then suppress the source output.
 * The various counters are sent to standard error.
 *
 * The counter output format is:
 *
 *	lcount wcount bcount icount isaved rcount rsaved
 *
 * where
 *	lcount	line count (same as wc)
 *	wcount	word count (same as wc)
 *	bcount	byte count (same as wc)
 *	icount	IOCCC secondary size rule count
 *
 * No longer reported:
 *	isaved	bytes saved by secondary size rule (bcount - icount)
 *	rcount	number of C reserved words
 *	rsaved	number of octets saved with -r
 */
static int
count(int flags)
{
	Word *w;
	unsigned long span;
	char *p, buf[BUFFER_SIZE];
	int lcount, wcount, bcount;
	int is_comment, is_word, dquote, escape;
	int count, keywords, saved, kw_saved;

	/* Start of buffer sentinel. */
	buf[0] = ' ';
	buf[BUFFER_SIZE - 1] = 0;     /* paranoia */

	count = saved = 0;
	keywords = kw_saved = 0;
	lcount = wcount = bcount = 0;
	is_comment = is_word = dquote = escape = 0;

	/*
	 * ""no matter how well you may think you understand this code,
	 *  you don't, so don't mess with it."" :-)
	 */
	while (0 < read_line(buf+1, sizeof (buf)-1)) {
		if (!(flags & FLAG_KEEP)) {
			/* Leading whitespace before comment block? */
			span = strspn(buf+1, ""\t "");

			/* Split / * across reads? */
			if (buf[1 + span] == '/' && buf[2 + span] == '\0') {
				(void) ungetc('/', stdin);
				continue;
			}

			/*
			 * no comment is a comment
			 */
			if (buf[1 + span] == '/' && buf[2 + span] == '/') {
				continue;
			}

			if (buf[1 + span] == '/' && buf[2 + span] == '*') {
				/* Strip leading whitespace before comment block. */
				is_comment = 1;
			}
		}

		for (p = buf+1; *p != '\0'; p++) {
			/* Within quoted string? */
			if (dquote) {
				/* Escape _this_ character. */
				if (escape) {
					escape = 0;
				}

				/* Escape next character. */
				else if (*p == '\\') {
					escape = 1;
				}

				/* Close quoted string? */
				else if (*p == '""') {
					dquote = 0;
				}
			}

			/* Not quote string. */
			else {
				/* In C comment block? */
				if (is_comment) {
					/* Split * / across reads? */
					if (*p == '*' && p[1] == '\0') {
						ungetc('*', stdin);
						break;
					}

					/* End of comment block? */
					if (*p == '*' && p[1] == '/') {
						is_comment = 0;

						if (!(flags & FLAG_KEEP)) {
							/* Strip whitespace and newline
							 * trailing closing comment.
							 */
							p += 1 + strspn(p+2, "" \t\r\n"");
						}
					}

					if (!(flags & FLAG_KEEP)) {
						/* Strip octets in comment block. */
						continue;
					}
				}

				/* Split / / or / * across reads? */
				else if (*p == '/' && p[1] == '\0') {
					ungetc('/', stdin);
					break;
				}

				/* Start of comment line? */
				else if (*p == '/' && p[1] == '/') {
					if (!(flags & FLAG_KEEP)) {
						/* Strip comment to end of buffer. */
						break;
					}
				}

				/* Start of comment block? */
				else if (*p == '/' && p[1] == '*') {
					/* Begin comment block. */
					is_comment = 1;

					if (!(flags & FLAG_KEEP)) {
						/* Strip comment block. */
						p++;
						continue;
					}
				}

				/* C reserved word? */
				else if (!isalnum(p[-1]) && p[-1] != '_'
				&& (w = find_member(cwords, p)) != NULL) {
					keywords++;
					if (flags & FLAG_RESERVED) {
						bcount += w->length;
						if (!is_word) {
							is_word = 1;
							wcount++;
						}

						if (!(flags & FLAG_SILENCE)) {
							fputs(w->word, stdout);
						}

						/* Count reserved word as one. */
						kw_saved += w->length - 1;
						p += w->length - 1;
						count++;
						continue;
					}
				}

				/* Open quoted string? */
				else if (*p == '""') {
					dquote = 1;
				}
			}

			if (!(flags & FLAG_SILENCE)) {
				fputc(*p, stdout);
			}

			bcount++;
			if (*p == '\n') {
				lcount++;
			}

			/* Ignore all whitespace.
			 *
			 * Well not ALL in the Universe, just all here.
			 */
			if (isspace(*p)) {
				is_word = 0;
				saved++;
				continue;
			} else if (!is_word) {
				is_word = 1;
				wcount++;
			}

			/* Ignore curly braces and semicolons when followed
			 * by any whitespace or EOF.
			 */
			if (strchr(""{;}"", *p) != NULL && (isspace(p[1]) || p[1] == '\0')) {
				saved++;
				continue;
			}

			/* Count this octet. */
			count++;
		}
	}

	if (flags & FLAG_IOCCC) {
		/* Output the official IOCCC size tool size to standard out */
		printf(""%d\n"", count);
		if (MAX_SIZE < bcount) {
			fprintf(stderr, ""WARNING: program size (%d) exceeds IOCCC Rule 2a max. size (%d)\n"", bcount, MAX_SIZE);
		}
		if (MAX_COUNT < count) {
			fprintf(stderr, ""WARNING: iocccsize count (%d) exceeds IOCCC Rule 2b max. count (%d)\n"", count, MAX_COUNT);
		}
	} else {
		/* The Ugly Truth */
		fprintf(
			stderr, ""%d %d %d %d %d %d %d\n"",
			lcount + xlcount, wcount + xwcount, bcount + xbcount, count,
			saved, keywords, kw_saved
		);
	}

	return count;
}

int
main(int argc, char **argv)
{
	int ch;
	int flags = 0;

	while ((ch = getopt(argc, argv, ""kirsch"")) != -1) {
		switch (ch) {
		case 'k':
			flags |= FLAG_KEEP;
			break;
		case 'i':
			flags |= FLAG_IOCCC | FLAG_RESERVED | FLAG_SILENCE;
			break;
		case 'r':
			flags |= FLAG_RESERVED;
			break;
		case 's':
			flags |= FLAG_SILENCE;
			break;
		case 'c':
			flags |= FLAG_SILLY_C;
			break;
		case 'h':
			flags |= FLAG_SILLY_H;
			break;
		default:
			fprintf(stderr, ""%s\n"", usage);
			return 2;
		}
	}
	// make test hack: while for do until goto if else switch case default continue return break
	if (flags == (FLAG_KEEP | FLAG_IOCCC | FLAG_RESERVED | FLAG_SILENCE | FLAG_SILLY_C | FLAG_SILLY_H)) {
		fprintf(stderr, ""The source toasts you a glass to your health!\n""
				""BTW: judges have toasted a glass of this at the South Pole.\n""
				""Now try using useful flags.\n\n""
				""%s\n"", usage);
		return 3;
	} else if (flags & FLAG_SILLY_C) {
		fprintf(stderr, ""Do you not see this is C?\n\n""
				""%s\n"", usage);
		return 4;
	} else if (flags & FLAG_SILLY_H) {
		fprintf(stderr, ""%s\n"", usage);
		return 5;
	}

	/*
	 * count as directed - 1 Muha .. 2 Muhaha .. 3 Muhahaha ...
	 */
	(void) count(flags);

	/*
	 * All Done!!! All Done!!! -- Jessica Noll, age 2
	 */
	return 0;
}
","#define j(n,r,i) A*n=R(r[i].a);//
#define E X(""syntax error\n"",1)//
 #define     d(n) A*n(A*x,A*y)//
  #define    k(d,v) D(d);e v;//
   #define  F X(""fail\n"",-1)//
     #define h(n) A*n(A*x)//
      #include <stdlib.h>//
    #define     u(n) n[0].l//
   #include        <stdio.h>//
    #define       w union A//
      #define   e return//
					             #define N 5//
					         #define q c=getc(p)//
					    #define o(i,v) [i]={[1].p=v},//
					  #define m(i,I,n) [i]={{I},[1].l=n},//
					#define g(n) A*r=C(&(A){.l=n});r[1].a=//
#define s(x,y,i,q,n,o) if(x[3].a){if(u(x)==rT||u(x)==rC){i;if(q)k(y,x)}g(n)y;o;r[3].a=x;e r;}//
//
void X(char*f,int r){ fputs(f,stderr);exit(r);}typedef w{w* (*t) (w*x);w* (*l) (w*x,w*y);w*a;long long p;}A;h(R) {x[N-1].p++;e x;}h(Ch) ;h(Y) ;h(fA) ;d(fD) ;d(fT) ;d(fW) ;d(fCh) ;d(rA2) ;d(fA2) ;d(rY2) ;d(Y2) ;d(rS2) ;d(fS22) ;d(rD) ;d(rE) ;d(rT) ;d(rC) ;void D(A*f) {if(f&&!--f[N-1].p) {if(u(f)!=fW&&u(f)!=fCh) D(f[1].a);if(u(f)!=fT) D(f[2].a);if(u(f)!=rE&&u(f)!=rT&&u(f)!=rC) D(f[3].a);free(f);}}int ch=EOF,c;FILE*p;A T[256][2];void U(void) {do{if(c==EOF) e;if(T[c][0].t) e;if(!T[c][1].p) E;if(T[c][1].p==4) for(/**??/
/
q;c!='\n'&&c!=EOF;q);q;}while(1);}A*I(void){if(c==EOF)E;A*f=T[c];if
(f[0].t!=Ch){q;U();}e f[0].t(&f[1]);}h(C){A*r=malloc(sizeof(A[N]));
if(!r) X(""memory error\n"",-2); r[0]=*x; for(int i=1;i<N;i++)r[i]=(A
){0};e R(r); }int   main(int x,const char**y){if(x!=2)F;p=fopen(y[1
],""rb"");if(!p)F;q;   U();while(c!=EOF){A*f=I();while(f[3].a){if(u(f
)==rT){f=f[1].u(a)(   R(f[1].a),f);}else if(u(f)==rC){T[96][0].t=Y;
j(r,f,1) D(f); f=r;}   else{g(fT)f;r[2].p=ftell(p)+(c==EOF);f=u(f)(
R(f),r);}}D(f);}e 0;}   h(Ch){A*r=C(x);q;if(c==EOF)E;r[1].p=c;q;U()
;e r;}h(NL){A*r=C(x);r   [1].p='\n';e r;}d(rT){j(r,x,2)D(y);k(x,r)}
d(fD0){g(fD)y;k(x,r)}d(   fA1){s(y,x,,1,fA2,)e u(x)(x,y);}d(fA2){j(
a,x,1)j(b,x,3)k(x,fA1(a,   u(b)(b,y)))}d(rA1){s(y,x,,0,rA2,)if(u(y)
==fD0){g(fD)R(x[2].a);D(y   );k(x,r)}A*r=fA(x[2].a);k(x,fA1(y,r))}d
(rA2){j(f,x,1)j(a,x,3)k(x,   rA1(f,u(a)(a,y)))}h(fA){R(x);if(x[0].t
!=fA)e x;e rA1(x,fA(x[1].a)   );}d(fD1){s(x,y,,1,rD,)e u(x)(x,y);}d
(rD){j(a,x,3)j(b,x,1)k(x,fD1   (u(a)(a,y),b))}d(fD){A*a=fA(x[1].a);
k(x,fD1(a,y))}h(Yt){(void)x;A   *r=C(&(A){.t=fA});r[1].a=I();r[2].a
=I();e r;}h(YE){(void)x;k(I(),   I())}d(Y1){s(y,x,,1,Y2,)e u(x)(x,y
);}d(Y2){j(a,x,1)j(b,x,3)k(x,Y1   (a,u(b)(b,y)))}h(rY1){if(x[3].a){
if(u(x)==rT)e x;if(u(x)==rC){k(I   (),x)}A*r=C(&(A){.l=rY2});r[3].a
=x;e r;}if(u(x)!=fD0)e Y1(x,I()     );D(x);T[96][0].t=Yt;g(fD)I();T
[96][0].t=Y;e r;} d(rY2) {j(a,   x   ,3)k(x,rY1(u(a) (a,y)))}h(Y){(
void)x;e rY1(I());}d(fK1){j(r   ,x,   1)D(y);k(x,r)}d(fK0){g(fK1)y;
k(x,r)}d(fS21){s(y,x,,1,fS22   ,)e u   (x)(x,y);}d(fS22){j(a,x,1)j(
b,x,3)k(x,fS21(a,u(b)(b,y))   )}A*rS1   (A*x,A*y,A*z){s(y,x,D(z),1,
rS2,r[2].a=z)if(u(y)==fD0)   {g(fD)C(&   (A){.t=fA});r[1].a[1].a=R(
x[2].a);r[1].a[2].a=z;k(x   ,r)}j(r,x,2   )k(x,fS21(y,u(r)(r,z)))}d
(rS2){j(a,x,3)j(b,x,2)j(   f,x,1)k(x,rS1   (f,u(a)(a,y),b))}d(fS2){
j(a,x,1) R(y);e rS1(x,u   (a)(a,y),y);}d(   fS1){g(fS2)R(x[1].a);r[
2].a=y;k(x,r)}d(fS0){g   (fS1)y; k(x,r)}d(   fI){k(x,y)}d(fV){k(y,x
)}d(fW) {putc(x[1].p,   stdout);k(x,y)}d(fR   ){ch=getc(stdin);A*r=
C(&(A){.l=ch!=EOF?fI   :fV});k(x,u(y)(y,r))}   d(fCh){A*r=C(&(A){.l
=ch==x[1].p?fI:fV})   ;k(x,u(y) (y,r))}d(fP){   A*r=C(&(A) {.l=ch!=
EOF?fW:fV}); if(ch   !=EOF)r[1].p=ch;k(x,u(y)(   y,r))}d(rE){if(y[3
].a==y)e u(y)(y,x   );j(r,x,1)k(x,u(r)(r,y))}d(   fE){g(rE)y;r[3].a
=r;k(x,r)} d(fT)   {g(rT) R(x[1].a); r[2].a=y;r[   3].a=r; if(fseek
(p, x[2]. p -1,   SEEK_SET))F;q;U();k(x,r)}d(rC){   (void)x;e y;}d(
fC){g(rC)y;r[3   ].a=r; T[96][0].t=YE; k(x,r)}A T[   256][2]={m(46,
Ch,fW)m(63,Ch   ,fCh)o(32,1)m(64,C,fR)[96]={{Y}},o(   9,2)m(99,C,fE
)o(10,3)m(100,C,fD0)m(101,C,fC)o(35,4)m(105,C,fI)m(107,C,fK0)o(11,5
)o(13,6)m(114,NL,fW)m(115,C,fS0)m(118,C,fV)o(12,7)m(124,C,fP)};/*/;
int main(){printf(""```s``."" ""3`.2. `.d`"" ""``k.rik"" ""`d`.y`"" ""``.""//
""l``c.n.o.gr```s`.n`.e`.c.h```.r`.u```k.td.y. i`.c`.e`.tk\n"");}/**/
","
#include <stdlib.h>
#include <stdio.h>

void X(char* m, int s) {
	fputs(m, stderr);
	exit(s);
}

void E() {
	X(""syntax error\n"", 1);
}

void F() {
	X(""fail\n"", -1);
}

typedef union Argument {
	union Argument* (*init)(union Argument* f);
	union Argument* (*call)(union Argument* f, union Argument* x);
	union Argument* a;
	char c;
	long p;
	size_t n;
} Argument;

#define NUMBER_OF_ARGUMENTS 5

static inline Argument* Reference(Argument* f) {
	f[NUMBER_OF_ARGUMENTS-1].n++;
	return f;
}

Argument* Char(Argument* f);
Argument* Apply(Argument* f);
Argument* fA(Argument* f);
Argument* fD(Argument* f, Argument* x);
Argument* fCont(Argument* f, Argument* x);
Argument* fW(Argument* f, Argument* x);
Argument* fCh(Argument* f, Argument* x);
Argument* rA1(Argument* s, Argument* x);
Argument* rA2(Argument* s, Argument* x);
Argument* rApply1(Argument* s, Argument* x);
Argument* rApply2(Argument* s, Argument* x);
Argument* rS1(Argument* s, Argument* x);
Argument* rS2(Argument* s, Argument* x);
Argument* rD(Argument* s, Argument* x);
Argument* rC(Argument* f, Argument* x);
Argument* rCont(Argument* f, Argument* x);
Argument* rE(Argument* f, Argument* x);

static inline void Dereference(Argument* f) {
	if(f && !--f[NUMBER_OF_ARGUMENTS-1].n) {
		if(f[0].call!=fW && f[0].call!=fCh) Dereference(f[1].a);
		if(f[0].call!=fCont) Dereference(f[2].a);
		if(f[0].call!=rC && f[0].call!=rCont && f[0].call!=rE) Dereference(f[3].a);
		free(f);
	}
}

int ch=EOF, c;
FILE *p, *o=NULL;
static Argument T[256][2];

void Next(void) {
	do {
		if(c==EOF) return;
		if(T[c][0].init) return;
		if(!T[c][1].c) E();
		if(T[c][1].c=='c') for(c=getc(p); c!='\n'&&c!=EOF; c=getc(p));
		c = getc(p);
	} while(1);
}

Argument* I(void) {
	if(c==EOF) E();
	Argument* f = T[c];
	if(f[0].init!=Char) {
		c = getc(p);
		Next();
	}
	return f[0].init(&f[1]);
}

Argument* Create(Argument* f) {
	Argument* record = malloc(sizeof(Argument[NUMBER_OF_ARGUMENTS]));
	if(!record) X(""memory error\n"", -2);
	record[0] = *f;
	for(int i=1; i<NUMBER_OF_ARGUMENTS; i++) record[i] = (Argument){0};
	return Reference(record);
}

void Output(Argument* f);

int main(int argc, const char** argv) {
	if(argc<2 || argc>3) F();
	p = fopen(argv[1],""rb"");
	if(!p) F();
	c = getc(p);
	Next();
	if(argc==3) {
		o = fopen(argv[2],""wb"");
		if(!o) F();
	} else o = stderr;
	while(c!=EOF) {
		Argument* f = I();
		while(f[3].a) {
			if(f[0].call==rCont) {
				f = f[1].a[0].call(Reference(f[1].a), f);
			} else if(f[0].call==rE) {
				T[96][0].init = Apply;
				Argument* r = Reference(f[1].a);
				Dereference(f);
				f = r;
			} else {
				Argument* r = Create(&(Argument){ .call=fCont });
				r[1].a = f;
				r[2].p = ftell(p)+(c==EOF);
				f = f[0].call(Reference(f), r);
			}
		}
		if(o) {
			Output(f);
			fputc('\n', o);
			fflush(o);
		}
		Dereference(f);
	}
	return 0;
}

Argument* Char(Argument* f) {
	Argument* r = Create(f);
	c = getc(p);
	if(c==EOF) E();
	r[1].c = c;
	c = getc(p);
	Next();
	return r;
}

Argument* NewLine(Argument* f) {
	Argument* r = Create(f);
	r[1].c = '\n';
	return r;
}

Argument* rCont(Argument* f, Argument* x) {
	Argument* r = Reference(f[2].a);
	Dereference(x);
	Dereference(f);
	return r;
}

Argument* fD0(Argument* f, Argument* x) {
	Argument* r = Create(&(Argument){ .call=fD });
	r[1].a = x;
	Dereference(f);
	return r;
}

Argument* fA2(Argument* x, Argument*y) {
	if(y[3].a) {
		if(y[0].call==rCont || y[0].call==rE) {
			Dereference(x);
			return y;
		}
		Argument* r = Create(&(Argument){ .call=rA2 });
		r[1].a = x;
		r[3].a = y;
		return r;
	}
	return x[0].call(x, y);
}

Argument* rA2(Argument* s, Argument* x) {
	Argument* a = Reference(s[1].a);
	Argument* b = Reference(s[3].a);
	Dereference(s);
	return fA2(a, b[0].call(b, x));
}

Argument* fA1(Argument* f, Argument* x) {
	if(x[3].a) {
		if(x[0].call==rCont || x[0].call==rE) return x;
		Argument* r = Create(&(Argument){ .call=rA1 });
		r[1].a = f;
		r[3].a = x;
		return r;
	}
	if(x[0].call==fD0) {
		Argument* r = Create(&(Argument){ .call=fD });
		r[1].a = Reference(f[2].a);
		Dereference(x);
		Dereference(f);
		return r;
	}
	Argument* y = fA(f[2].a);
	Dereference(f);
	return fA2(x, y);
}

Argument* rA1(Argument* s, Argument* x) {
	Argument* f = Reference(s[1].a);
	Argument* a = Reference(s[3].a);
	Dereference(s);
	return fA1(f, a[0].call(a, x));
}

Argument* fA(Argument* f) {
	Reference(f);
	if(f[0].init!=fA) return f;
	return fA1(f, fA(f[1].a));
}

Argument* fD1(Argument* a, Argument* x) {
	if(a[3].a) {
		if(a[0].call==rCont || a[0].call==rE) {
			Dereference(x);
			return a;
		}
		Argument* r = Create(&(Argument){ .call=rD });
		r[1].a = x;
		r[3].a = a;
		return r;
	}
	return a[0].call(a, x);
}

Argument* rD(Argument* s, Argument* x) {
	Argument* a = Reference(s[3].a);
	Argument* y = Reference(s[1].a);
	Dereference(s);
	return fD1(a[0].call(a, x), y);
}

Argument* fD(Argument* f, Argument* x) {
	Argument* a = fA(f[1].a);
	Dereference(f);
	return fD1(a, x);
}

Argument* ApplyInit(Argument* f) {
	(void)f;
	Argument* r = Create(&(Argument){ .init=fA });
	r[1].a = I();
	r[2].a = I();
	return r;
}

Argument* ApplyExit(Argument* f) {
	(void)f;
	Dereference(I());
	return I();
}

Argument* Apply2(Argument* x, Argument* y) {
	if(y[3].a) {
		if(y[0].call==rCont || y[0].call==rE) {
			Dereference(x);
			return y;
		}
		Argument* r = Create(&(Argument){ .call=rApply2 });
		r[1].a = x;
		r[3].a = y;
		return r;
	}
	return x[0].call(x, y);
}

Argument* rApply2(Argument* s, Argument* x) {
	Argument* a = Reference(s[1].a);
	Argument* b = Reference(s[3].a);
	Dereference(s);
	return Apply2(a, b[0].call(b, x));
}

Argument* Apply1(Argument* x) {
	if(x[3].a) {
		if(x[0].call==rCont) return x;
		if(x[0].call==rE) {
			Dereference(I());
			return x;
		}
		Argument* r = Create(&(Argument){ .call=rApply1 });
		r[3].a = x;
		return r;
	}
	if(x[0].call!=fD0) return Apply2(x, I());
	Dereference(x);
	T[96][0].init = ApplyInit;
	Argument* r = Create(&(Argument){ .call=fD });
	r[1].a = I();
	T[96][0].init = Apply;
	return r;
}

Argument* rApply1(Argument* s, Argument* x) {
	Argument* a = Reference(s[3].a);
	Dereference(s);
	return Apply1(a[0].call(a, x));
}

Argument* Apply(Argument* f) {
	(void)f;
	return Apply1(I());
}

Argument* fK1(Argument* f, Argument* x) {
	Argument* r = Reference(f[1].a);
	Dereference(x);
	Dereference(f);
	return r;
}

Argument* fK0(Argument* f, Argument* x) {
	Argument* r = Create(&(Argument){ .call=fK1 });
	r[1].a = x;
	Dereference(f);
	return r;
}

Argument* fS22(Argument* a, Argument* b) {
	if(b[3].a) {
		if(b[0].call==rCont || b[0].call==rE) {
			Dereference(a);
			return b;
		}
		Argument* r = Create(&(Argument){ .call=rS2 });
		r[1].a = a;
		r[3].a = b;
		return r;
	}
	return a[0].call(a, b);
}

Argument* rS2(Argument* s, Argument* x) {
	Argument* a = Reference(s[1].a);
	Argument* b = Reference(s[3].a);
	Dereference(s);
	return fS22(a, b[0].call(b, x));
}

Argument* fS21(Argument* f, Argument* a, Argument* x) {
	if(a[3].a) {
		if(a[0].call==rCont || a[0].call==rE) {
			Dereference(x);
			Dereference(f);
			return a;
		}
		Argument* r = Create(&(Argument){ .call=rS1 });
		r[1].a = f;
		r[2].a = x;
		r[3].a = a;
		return r;
	}
	if(a[0].call==fD0) {
		Argument* r = Create(&(Argument){ .call=fD });
		r[1].a = Create(&(Argument){ .init=fA });
		r[1].a[1].a = Reference(f[2].a);
		r[1].a[2].a = x;
		Dereference(f);
		return r;
	}
	Argument* b = Reference(f[2].a);
	Dereference(f);
	return fS22(a, b[0].call(b, x));
}

Argument* rS1(Argument* s, Argument* x) {
	Argument* a = Reference(s[3].a);
	Argument* y = Reference(s[2].a);
	Argument* f = Reference(s[1].a);
	Dereference(s);
	return fS21(f, a[0].call(a, x), y);
}

Argument* fS2(Argument* f, Argument* x) {
	Argument* a = Reference(f[1].a);
	Reference(x);
	return fS21(f, a[0].call(a, x), x);
}

Argument* fS1(Argument* f, Argument* x) {
	Argument* r = Create(&(Argument){ .call=fS2 });
	r[1].a = Reference(f[1].a);
	r[2].a = x;
	Dereference(f);
	return r;
}

Argument* fS0(Argument* f, Argument* x) {
	Argument* r = Create(&(Argument){ .call=fS1 });
	r[1].a = x;
	Dereference(f);
	return r;
}

Argument* fI(Argument* f, Argument* x) {
	Dereference(f);
	return x;
}

Argument* fV(Argument* f, Argument* x) {
	Dereference(x);
	return f;
}

Argument* fW(Argument* f, Argument* x) {
	putc(f[1].c, stdout);
	Dereference(f);
	return x;
}

Argument* fR(Argument* f, Argument* x) {
	ch = getc(stdin);
	Argument* r = Create(&(Argument){ .call=ch!=EOF?fI:fV });
	Dereference(f);
	return x[0].call(x, r);
}

Argument* fCh(Argument* f, Argument* x) {
	Argument* r = Create(&(Argument){ .call=ch==f[1].c?fI:fV });
	Dereference(f);
	return x[0].call(x, r);
}

Argument* fP(Argument* f, Argument* x) {
	Argument* r = Create(&(Argument){ .call=ch!=EOF?fW:fV });
	if(ch!=EOF) r[1].c = ch;
	Dereference(f);
	return x[0].call(x, r);
}

Argument* rC(Argument* f, Argument* x) {
	if(x[3].a==x) return x[0].call(x, f);
	Argument* r = Reference(f[1].a);
	Dereference(f);
	return r[0].call(r, x);
}

Argument* fC(Argument* f, Argument* x) {
	Argument* r = Create(&(Argument){ .call=rC });
	r[1].a = x;
	r[3].a = r;
	Dereference(f);
	return r;
}

Argument* fCont(Argument* f, Argument* x) {
	Argument* r = Create(&(Argument){ .call=rCont });
	r[1].a = Reference(f[1].a);
	r[2].a = x;
	r[3].a = r;
	if(fseek(p, f[2].p-1, SEEK_SET)) F();
	c = getc(p);
	Next();
	Dereference(f);
	return r;
}

Argument* rE(Argument* f, Argument* x) {
	(void)f;
	return x;
}

Argument* fE(Argument* f, Argument* x) {
	Argument* r = Create(&(Argument){ .call=rE });
	r[1].a = x;
	r[3].a = r;
	T[96][0].init = ApplyExit;
	Dereference(f);
	return r;
}

static Argument T[256][2] = {
	[9]={ [1].c='s' }, //\t
	[10]={ [1].c='s' }, //\n
	[11]={ [1].c='s' }, //\v
	[12]={ [1].c='s' }, //\f
	[13]={ [1].c='s' }, //\r
	[32]={ [1].c='s' }, //' '
	[35]={ [1].c='c' }, //#
	[46]={ {Char}, [1].call=fW }, //.
	[63]={ {Char}, [1].call=fCh }, //?
	[64]={ {Create}, [1].call=fR }, //@
	[96]={ {Apply} }, //`
	[99]={ {Create}, [1].call=fC }, //c
	[100]={ {Create}, [1].call=fD0 }, //d
	[101]={ {Create}, [1].call=fE }, //e
	[105]={ {Create}, [1].call=fI }, //i
	[107]={ {Create}, [1].call=fK0 }, //k
	[114]={ {NewLine}, [1].call=fW }, //r
	[115]={ {Create}, [1].call=fS0 }, //s
	[118]={ {Create}, [1].call=fV }, //v
	[124]={ {Create}, [1].call=fP }, //|
};

void Output(Argument* f) {
	if(f[0].call==fK0) { fputc('k', o);
	} else if(f[0].call==fK1) {
		fprintf(o, ""`k"");
		Output(f[1].a);
	} else if(f[0].call==fS0) { fputc('s', o);
	} else if(f[0].call==fS1) {
		fprintf(o, ""`s"");
		Output(f[1].a);
	} else if(f[0].call==fS2) {
		fprintf(o, ""``s"");
		Output(f[1].a);
		Output(f[2].a);
	} else if(f[0].call==fI) { fputc('i', o);
	} else if(f[0].call==fV) { fputc('v', o);
	} else if(f[0].call==fW) {
		if(f[1].c=='\n') fputc('r', o); else {
			fputc('.', o);
			fputc(f[1].c, o);
		}
	} else if(f[0].call==fR) { fputc('@', o);
	} else if(f[0].call==fCh) {
		fputc('?', o);
		fputc(f[1].c, o);
	} else if(f[0].call==fP) { fputc('|', o);
	} else if(f[0].call==fC) { fputc('c', o);
	} else if(f[0].call==fE) { fputc('e', o);
	} else if(f[0].call==fD0) { fputc('d', o);
	} else if(f[0].call==fD) {
		fprintf(o, ""`d"");
		Output(f[1].a);
	} else if(f[0].init==fA) {
		fputc('`', o);
		Output(f[1].a);
		Output(f[2].a);
	} else if(f[0].call==fCont) {
		fprintf(o, ""<cont:%li>"", f[2].p);
	} else {
		fprintf(o, ""<unknown>"");
	}
}
","e,n,j,o,y;main(){for(++o;n=-~getchar();e+=11==n,y++)o=n>0xe^012>n&&'`'^n^65?!n:!o?++j:o;printf(""%8d%8d%8d\n"",e^n,j+=!o&&y,y);}
","static int e,n,j,o,y;int main(){for(++o;(n=-~getchar());e+=11==n,y++)o=n>0xe^012>n&&'`'^n^65?!n:!o?++j:o;printf(""%8d%8d%8d\n"",e^n,j+=!o&&y,y);}
","#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>

#define P 9<<23^1
#define A 1;O-L;L=0<L[o]?L[K][k]=L
#define N for(O=l[k];l-O;O=O[k])for(L=O
#define G 1+c[C];c[C]-I;I=0<(l=I[o])?
#define R(A,M) wcschr(1+M,A)

static int C[97],d,k[98^P],O,l=1,o[98^P],L,K[98^P],v[97],V[98],c;
static void y(){l[V][v]=l[v][V]=l;N-A,L[k][K]=L,++L[o][o],L-1:L[k]);}
static void b(){N+A[k],L[k][K]=L[K],--L[o][o],L+1:L[K]);l[V][v]=l[v];l[v][V]=l[V];}
static wchar_t s[P],*w=1+s,*p[P],z[99],**q=p,*W=1+s,*Z;
int main(int I,char**j){if(l<I){wint_t S;setlocale(LC_CTYPE,"""");
  for(mbstowcs(l+z,l[j],97);l[z];++l)V[l[v]=l+1]=l[K]=l[k]=l;
  for(v[*V=l-(*v=1)]=L;WEOF-(S=getwchar())&&P>W-s;++W)if(33>(*W=S)){
   for(*W=L,Z=w;*Z;++Z)if(R(*Z,Z)||!R(*Z,z)){W=w-1;goto M;}
   for(I=L;I[w];++I)++o[O=R(I[w],z)-z],k[K[l[o+I+1]=O]=k[l[K+I+1]=O[K]]=l+I+1]=O;
   *q++=w;l[k]=l+I;o[l+=I+1]=p-q;l[K]=l-I;M:w=1+W;}
  *j=""Dictionary too long\n"";if(WEOF-S)H:return fputs(*j,stderr),**j/36;
  d=2[j]?atoi(2[j]):97;while(P){if(I=*v){for(O=P;I;I=I[v])O>I[o]?l=I,O=I[o]:P;
    b();c[C]=l[k];T:if(l-c[C]){for(I=G b(),I+1:I[K]);if(d>c++)continue;}else y();
   }else{for(;I-c;++I){for(O=I[C];0>~O[o];++O);printf(!I+"" %ls"",p[~O[o]]);}
    putchar(10);}
   if(!c--)return 0;
   for(I=-G y(),I-1:I[k]);
   l=c[C][o];c[C]=c[C][k];goto T;}}
 *j=""Need an argument or two\n"";goto H;}
","#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>

#define P 9<<23^1
#define A 1;O-L;L=0<L[o]?L[K][k]=L
#define N for(O=l[k];l-O;O=O[k])for(L=O
#define G 1+c[C];c[C]-I;I=0<(l=I[o])?
#define R(A,M) wcschr(1+M,A)

static int C[97],d,k[98^P],O,l=1,o[98^P],L,K[98^P],v[97],V[98],c;
static void y(){l[V][v]=l[v][V]=l;N-A,L[k][K]=L,++L[o][o],L-1:L[k]);}
static void b(){N+A[k],L[k][K]=L[K],--L[o][o],L+1:L[K]);l[V][v]=l[v];l[v][V]=l[V];}
static wchar_t s[P],*w=1+s,*p[P],z[99],**q=p,*W=1+s,*Z;
int main(int I,char**j){if(l<I){wint_t S;setlocale(LC_CTYPE,"""");
  for(mbstowcs(l+z,l[j],97);l[z];++l)V[l[v]=l+1]=l[K]=l[k]=l;
  for(v[*V=l-(*v=1)]=L;WEOF-(S=getwchar())&&P>W-s;++W)if(33>(*W=S)){
   for(*W=L,Z=w;*Z;++Z)if(R(*Z,Z)||!R(*Z,z)){W=w-1;goto M;}
   for(I=L;I[w];++I)++o[O=R(I[w],z)-z],k[K[l[o+I+1]=O]=k[l[K+I+1]=O[K]]=l+I+1]=O;
   *q++=w;l[k]=l+I;o[l+=I+1]=p-q;l[K]=l-I;M:w=1+W;}
  *j=""Dictionary too long\n"";if(WEOF-S)H:return fputs(*j,stderr),**j/36;
  d=2[j]?atoi(2[j]):97;while(P){if(I=*v){for(O=P;I;I=I[v])O>I[o]?l=I,O=I[o]:P;
    b();c[C]=l[k];T:if(l-c[C]){for(I=G b(),I+1:I[K]);if(d>c++)continue;}else y();
   }else{for(;I-c;++I){for(O=I[C];0>~O[o];++O);printf(!I+"" %ls"",p[~O[o]]);}
    putchar(10);fflush(stdout);}
   if(!c--)return 0;
   for(I=-G y(),I-1:I[k]);
   l=c[C][o];c[C]=c[C][k];goto T;}}
 *j=""Need an argument or two\n"";goto H;}
","#include<stdio.h>
int main(){int a=0,b=a;long long c[178819],d=8,e=257,f,g,
h,i=d-9;for(;a<178819;){c[a++]=i;}for(a*=53;a;a>>=8)putc\
har(a);if((f=getchar())<0)return 0;for(;(g=getchar())>=0;
){h=i=g<<8^f;g+=f<<8;a=e<(512<<a%8|(a<7))||f>256?a:a>6?15
:a+1;for(;c[i]>-1&&c[i]>>16!=g;)i+=i+h<69000?h+1:h-69000;
h=c[i]<0;b|=h*f<<d;for(d+=h*(a%8+9);d>15;d-=8)putchar(b=b
>>8);f=h?g-f*256:c[i]%65536L;if(a<8*h){c[i]=g*65536L|e++;
}}b|=f<<d;for(d+=a%8;d>-1;d-=8)putchar(b>>=8);return!53;}
","#include <stdio.h>
#define  f(f,g){z e=0;for(;e<f;e++)g;}
#define  i(f,g)static z f(z a){return g;}
#define  j(f,g)static void f(z*a,z*b,z*c){g}
#define  h(f,g)static z f(z a,z b,z c){return g;}
#define  g(f,g,h,i,j)static z f(z b){z a=g,c=h;for(;i)a=j;return a;}
typedef unsigned char y;typedef unsigned long long z;extern y*w;static z b(z a,z b){return a>>b|a<<(64-b);}i(_,
(a>>6)^b(a,61)^b(a,19))i(_a,b(a,39)^b(a,28)^b(a,34))h(x,((a^b)&c)^(a&b))i(u,b(a,41)^b(a,18)^b(a,14))h(t,(((((3*(a*c+b*b)>>9)+(3*
b*c>>32))*a>>21)+(3*a*a*b>>6)+((b>>4)*(b>>4)*b>>46))>>18)+a*a*a)h(m,t((b<<16)|(c>>48),(c>>24)%(1<<24),c%(1<<24))>>48<a)h(s,(a&b)
^(~a&c))i(r,b(a,1)^b(a,8)^(a>>7))g(o,0,0,c<8;c++,a*256+w[b*8+c])g(d,0,0,c<13;c++,a*31+w[b*13+c]-96)g(p,0,4,c;c/=2,a|c*m(b,a|c,a)
)g(q,0,1ull<<63,c;c/=2,a|c*m(b,p(b),a|c))g(v,b>1,2,c<b;c++,a&&b%c)g(l,b?l(b-1)+1:2,a,!v(c);c++,c+1)j(n,z d=a[7]+u(a[4])+s(a[4],a
[5],a[6])+q(l(*b))+c[*b%16];f(8,a[7-e]=e-3?e-7?a[6-e]:d+_a(a[0])+x(a[1],a[2],a[3]):d+a[3])f(16*(*b%16>14),c[e]+=c[(e+9)%16]+r(c[
(e+1)%16])+_(c[(e+14)%16])))j(k,f(8,b[e]=a[e])f(80,n(a,&e,c))f(8,a[e]+=b[e]))int main(){z a[8],b[8],c[16];f(8,a[e]=d(e))f(16,c[e
]=e-15?o(e):d(8))k(a,b,c);f(16,c[e]=e?e-15?0:11264:1ull<<63)k(a,b,c);f(8,printf(""%016llx%s"",a[e],e-7?"""":""\n""))return!w;}y*w=(y*)
""crsmyiajqhwy{unwa|hjoi`hlxhpxrzb~edko~rtr~ileqyjk`znqgsuitvgqnfdfa||wedvnmhozkpokootqzcexeld~oibqzpcsuw{ib{x`m`hsa`jmn}wcfzpb"";
","//  APOHLIFE : Annotated Partially Obfuscated 64-bit Hash Life program.
//  This program assumes sizeof(long)==8 (64 bits) and little endianess.
//  Also unaligned (mod 8) long loads support.
//  Xlib is evidently used . Should be runnable almost everywhere
//  with gcc command such as:
//  gcc -O3 -std=c99 apholife.c -lX11 -lm
//
//  If you want to understand Hashlife The clearest description  with diagrams of the recursion I found was in:
//  https://jennyhasahat.github.io/hashlife.html
//  You can  also read Tom Rokicki article appearing in DrDobbs
//  http://www.drdobbs.com/jvm/an-algorithm-for-compressing-space-and-t/184406478
//  And of course look it up in wikipedia, etc ...
//
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#include <X11/Xlib.h>
#include <strings.h>
#include <math.h>
#include <assert.h>

#define MAXLEV 1024 // Maximal level supported by our universe.
#define W (32*40l)  // Display window size
#define H (32*40l)
#define HBITS 29    // This wil determine our memory usage (hash + cells)

#define HSIZE (1ll<<HBITS)
#define HMASK (HSIZE -1)
#define MAXMEM (HSIZE)
typedef unsigned long ulong;

int g_step;             // log two of our generation step.

// The following two hex constants (mh and m1) will be very useful here.
const unsigned  mh=0xf0f0f0f; // This is the mask for the lower nibble in every byte. We have four of those in a 32bit unsigned.

// Lets start with our leaf routine. Our leaf is always 64 bits ulong 8*8 pattern.
// Crucially,  whenever we need to encode a quarter-leaf (4*4) such as a result here, we do it using lower 4
// nibbles of an unsigned int, rather rhan a 16 bit short. Remember this when trying to understand all following code!
// This routine makes heaviest and nicest use of bit twiddling hackers delight like stuff.
// If you've read chapter 7.1.3 of Knuths 4A you should be OK with that...
ulong q8x8(ulong in)
{
  const ulong m4=0x1111111111111111; // We will work doing 16 ops at a time on the sixteen nibbles in a long.
  for(int j=0;j<2-!g_step;j++){  //We Normaly count to 2 generations here except when g_step=0.
    ulong res=0;
    for(int i=0;i<4;i++) {
      ulong o=in>>i & m4;
      o+= in*2>>i & m4;
      o+= in/2>>i & m4;
      o+=(o << 8)+(o >> 8); // And now we have in 'o' nibbles 16 sums each of a 3*3 neighborhood.
      // This line, implementing Conways GOL rule, is left as an exercise for the reader. Muhahaha...
      res |= (((o+m4 & m4*6 ^ 3*m4)+m4 >> 3) & (in >> i | o) & m4) << i;
    }
    in=res;
  }
  return in>>18 & mh ; // this just returns the middle quarter-leaf as the result.
}

//
// We have the following tricky but efficient way to encode node and leaf data in the same array of longs in
// an econmoical and aligned manner. We use 32bit indices into the array in lieu of pointers which occupy 64bit
// nowdays. This results in almost factor of 2 compression of memory usage.
//
// A node at ptr i will be encoded using three longs as follows:
// g_lmem[i]  : Two upper quads ptrs (each 32 bits of course).
// g_lmem[i+1]: Upper 32bit word : Result ptr. Lower 13 bits: the log2 of step used for calculating result. 14th bit : 1.
// g_lmem[i+2]: Two lower quads ptrs.
//
// A leaf at ptr i will be encoded using two longs as:
// g_lmem[i] :  64 bits of the 8*8 leaf.
// g_lmem[i+1]: Upper 32bit word: Result 4*4 encoded in lower nibble of each byte. Lower 13 bits same as above. 14th bit: 0.
//
// Notice this encoding can support upto 2^32 pointers which would
// mean g_lmem would be 32 Gbytes and together with a hash of a reasonable load factor we would probably
// need more than 48 GBytes of RAM in order to run out of usable encoding space.
//
ulong *g_lmem;
unsigned *g_hash;
//
//  The following functions/Macros are heavily used in the hashlife algorithm which is essentialy all about
//  splitting cells into four quadrants, and then creating new cells by joining four quadrants.
//  We use the term cell to denote *both* leafs and nodes which are stored of course in the same hash.
//  Quads are always stored in an array conviently called q, with an implicit assumption
//  that q is 2D with stride *Four*. I.e. to move vertically in q we need to add/sub 4 ...
//  This way we naturally have a 4*4 array structure on a q[16] vector needed for hashlife recursion.
//  We call the quads of each quad subquads. So we can say in q there are four quads and sixteen subquads.

// This QUADLOOP macro is used to shorten many loops in the code that work  on 4 quads/subquads.
#define QUADLOOP(x) {int j; for(int i=0;i<4;i++) {j=i+(i&2); x;} }  // j is quad index in q.

// Get a quad (indexed by i) from a cell pointer.
// The main complication here is the case of leaves that gets splitted to quarters-leaves differenty.
// Notice that here is the single place we actualy assume little endianity, as it affects the expression
// to get two 32bit words out of each long.
unsigned getquad(unsigned cell,int i){
 return g_lmem[cell+1]&8192 ? g_lmem[cell+(i&2)] >> i%2*32 : g_lmem[cell] >> i%2*4+16*(i&2)&mh ;
}

// This mq function does the splitting of a cell  into four quads and stores them in the q array.
void mq(unsigned cell,unsigned *q)  {
  QUADLOOP (q[j]=getquad(cell,i));
}

// This GQ macro is using the q array and generates the union of four cells there using the main
// hget hash lookup/update recursive function. All our recursions are done using this macro.
#define GQ(i,level,flags)  hget(q+(i),(level)*4+flags)

unsigned calc_result(unsigned cell,ulong leaf,ulong lh,unsigned *q,int level,int res_step);

// This single hget routine will do most of the work for us.
// It will get (or create a new) node or leaf from the hash, looking it up from its four quarters.
// The four quarters are passed in the qi array, as usual in places 0,1, 4 and 5.
// In the level argument's 2 low bits we have flags described below.
// level>>2 is the level of the joined node made from the quarters, where 0 is for a leaf.
// Remember that quarter leaf encoding is always an unsigned with low nibbles only containing the 4*4 data.
// level&2: If on, we just return the joined node. If 0 we return the joined node's *Result*.
// level&1: Signals ""half"" recursion mode, Where we join four middle *quarters* of the 4 inputs, to produce a middle quad,
// In that case we return this middle cell's node (and not the middles result).
unsigned hget(unsigned* qi, int level)
{
  ulong leaf,lh,ll;
  int lv=level>>2;
  unsigned hind=0; // Wil be used to calculate hash function
  unsigned cell;

  ulong *data=(ulong *)qi; // Here we seem to use little endianity but in fact we dont. as we store
                           // and compare the q unsigned array contents to the g_lmem long array.
                           // What we do use is tha fact longs can be loaded and stored from *unaligned*
                           // addresses. So we break pointer punning.
  if(lv>0) {
    if(level&1) {
      unsigned q[6];
      QUADLOOP(q[j]=getquad(qi[j],i^3)); // That ^3 will neatly give us the 4 middle subquads to be joined into middle quad.
      return GQ(0,lv-1,2);
    }
    QUADLOOP(hind=917*hind+qi[j]);  // Our node hash function ...
    leaf=data[0]; // Misleading but used for the hash lookup
    lh=data[2];
  }
  else {
    // Inputs in qi are quarter leaves.
    hind= (ll=qi[0]|qi[1]<<4) + 719*(lh=qi[4]|qi[5]<<4); // Hash calculation and create two longs...
    // A bit tricky but that will be the quarter leaf mid of the joined leaf.
    if(level&1) return (ll>>18)&0xf0f | (lh&0x3c3c)<<14;
    leaf= ll | lh <<32;
  }

  // Do linear hash probing, nice and simple ...
  for(; cell=g_hash[hind&=HMASK]; hind++)
    if (leaf==g_lmem[cell] && (!lv || g_lmem[cell+2]==lh) && !!lv == (g_lmem[cell+1]>>13&1)) break;

  // The last condition above is to avoid a very rare and subtle bug that can happen, for example
  // when searching a leaf,  we might find a node instead whose lower data is identical to the leaf's bits
  // *and* its hash is also similar/close. This is possible but the probablity is very low indeed.
  // The probablity of encountering this bug is so low that the actual obfuscated entry has not got 
  // the fix above but the bug does not seem to happen on the supplied patterns.

  int res_step= lv+1;  // res_step is the maximal timestep we can get result for.
  if(res_step > g_step) res_step=g_step; // Notice that if g_step is small, res_step will not be maximal.
                                         // This will mean we will do half recursion later.
  if (!cell || g_lmem[cell+1]&8191^res_step) {
    // We enter here whenever we need to (re) calculate result, either because g_step changed or
    // if its a new cell. In principle result needs to be recalculated whenever g_step was increased
    // compared to earlier calculation but also upon decrease. Though notice that when g_step is high
    // and the cell is lower level, g_step changing will not affect res_step.
    cell=g_hash[hind]=calc_result(cell,leaf,lh,qi,lv,res_step);
  }
  // Remember the result is always in cell+1 high part ...
  return (level&2) ? cell: g_lmem[cell+1]>>32;
}

// This g_ptr variable is the pointer to the g_lmem nodes/leaf array where we will allocate the next cell.
unsigned  g_ptr=2; // skip the 0 which is null ptr in the hash. Start from 2 in order to leave space
                   // at zero used by the getin leaf reading code.
//
// Finaly we reached the most intersting part of result calculation / hashlife recursion. 
// After all the ground work we've layed before, it becomes surprsingly short, heck the
// comments are longer than the code !
//
unsigned calc_result(unsigned cell,ulong leaf,ulong lh,unsigned *qi,int level,int res_step)
{
  if(!cell) {  // Create a new one ...
    g_lmem[cell=g_ptr]=leaf;
    g_lmem[g_ptr+=2]=lh; // This will write some junk in case of leaf but we dont care
    g_ptr+= level>0;
  }
  if(!level) {
    g_lmem[cell+1]=res_step|(q8x8(leaf)<<32);
  }
  else {
    int j;
    unsigned q[16];
    // Finaly we have reached Hashlifes glorious recusion: make new node from four quadrants and calculate its result.
    // A neat obfuscation/compression trick here is that q can be updated in-place shrinking from 4*4 to 3*3 to 2*2,
    // all during the sub-steps in the hashlife recursion calculation. Its recommended looking at the link above for
    // some diagrams describing this recursion.
    // 'hr' flag will indicates half recursion. All it does is, that in the second sub-step the 4 recursive calls just join
    // cells to calculate middle cell, rather then calculate result forward in time.
    //
    // This QUADLOOP wil create the 16 subquads data in q.
    // Notice that rather conveniently 2*j here is just 0,2,8,10 which are indices of the quads we want inside the 4*4 q.
    QUADLOOP(mq(qi[j],q+2*j));
    unsigned hr = level>g_step-1;

    // The whole recursion stuff just becomes the two innocently looking loops below, and hopefuly gcc is decent
    // enough to unroll them under -O3 so its also rather efficient as well...
    for(int i=0;i<11;i++) if((i+1)&3)  q[i]=GQ(i,level-1,0); // Neatly do the first step. 9 recursive calls.
    QUADLOOP(q[j]=GQ(j, level-1, hr)); //Second step. four recursive calls, and QUADLOOP can be used....

    // We get our final result from q by a simple quads join...
    ulong result= GQ(0,level-1,2);
    g_lmem[cell+1]=res_step|8192|(result<<32);
  }
  return cell;
}

// Create the empty space cells/empty universe. Must happen before getin.
void init_empty_space(int maxlev)
{
  unsigned q[16];
  unsigned cell=0;
  for(unsigned i=0;i<maxlev;i++) {
     QUADLOOP(q[j]=cell);
     cell=GQ(0,i,2);
     // This mystery line below is needed because first cell is the empty leaf. It make the formula for the empty cell
     // at a given level to be simply 3*level+2.
     g_ptr+=!i; 
  }
}

// We will use this variable to freeze the state whenever we run out of memory,
// So as to avoind core dumps, etc ...
int g_freeze=0;

//
// This will advance in time the given cell at the given level by current 2^g_step generations.
// the trick here is first expanding enough so the time step will be just looking at the expanded result
// and then shrinking back if neccessary.
//
unsigned adv(unsigned cell,int *ilevel)
{
  unsigned q[16];
  int level=*ilevel;
  //
  // We first need to expand input cell with enough free space to be at a bigger target level,
  // then we can be sure the correct result would be calculated. We need to go at least two levels higher:
  // one, because we may grow during the timestep, and one more because result calculation is
  // itself shrinking.
  //
  int target=level+2;
  if(target >= MAXLEV) {
    g_freeze=1;
    return cell;
  }
  if(target<g_step) target=g_step;
  do {
    for(int i=0;i<16;i++) q[i]=3*level-1; // This is all empty cells sub quads for the given level
    mq(cell,q+5); // 5 is the quad in the middle of 16
    QUADLOOP(q[j]=GQ(2*j,level,2)); // Calculate the 4 quadrants of the expanded cell.
    cell= GQ(0,++level,2); // Then join them to get expanded cell.
  } while (level < target);

  cell=g_lmem[cell+1]>>32;  // Thats the expanded cell's result which does the actual timestep!
  //
  // Now we need to see if the result can be shrunk (i.e. is at a too high level).
  //
  while(--level > 0) {
    mq(cell,q+10); // Split cell into 4 quads at index 10 (the bottom right quad)
    QUADLOOP(mq(q[10+j],q+2*j));  // after this we are back with 16 subquads of original cell.
    // Thats rather condensed but if the loop below finds one of the external 12 quads
    // is nonempty it just returns with the current cell value.
    for(int i=0;i<16;i++)  if((i^i/2)&5^5 && q[i] != 3*level-4) {*ilevel=level; return cell;}
    cell=GQ(5,level-1,2); // Shrink by one level to the middle quad.
  }
}

#define MAXMOVES 500000
unsigned g_cells[MAXMOVES]; // Will be use to hold input cells and then later to hold moves history
double   g_gens[MAXMOVES]; // Will be use to hold gens history

// We even have some minimal error handling here :)
void error(char *s) {printf(""%s\n"",s);exit(1);}
//
//  This is our input routine, reading marocell (.mc) golly format.
//  Its quite pedantic but hopefuly does not dump cores on bad input :)
//
int getin(FILE *f,int *lv)
{
  char c,line[100];
  static int lev,skip; // Skip is needed to skip Gollys header line.
  unsigned cell,q[16];
  unsigned iptr=1; // Start input counter from 1 as defined by .mc format.
  while(fgets(line,100,f)) {
    if(skip++ && line[0]!='#') {
      if(sscanf(line,""%d%d%d%d%d"",&lev,q,q+1,q+4,q+5)==5){
        lev-=3;
        // Put the Referenced nodes into q array. Notice that 0 uses the formula for the empty cell...
        QUADLOOP(if(q[j]>=iptr)error(""Bad node input data""));
        QUADLOOP(q[j]=q[j]?g_cells[q[j]]:lev*3-1);
      }
      else {
        // Put 64 bits leaf pattern into g_lmem[0].
        lev=g_lmem[0]=0;
        int l=0,j=0,i=0;
        while(c=line[i++]){
          if(c=='*') {
            if(l*8+j>64) error(""Bad leaf input data"");
            g_lmem[0]|=1l<<l*8+j;
          }
          j++;
          if(c=='$')l++,j=0;
        }
        mq(0,q); // This divides g_lmem[0] leaf data into four quarters and puts them into  q.
      }
      cell=g_cells[iptr++]=GQ(0,lev,2);  //This joins the 4 quads in q and puts them to the hash
      if(iptr==MAXMOVES) error (""Input too big! increase MAXMOVES please\n"");
    }
  }
  g_cells[0]=cell; *lv=g_cells[1]=lev;  // Initial move history state ...
  return cell;
}

// Thats our output image pixmap. We allocate it with some convenient bundaries.
unsigned g_area[(16*16+H)*(16*8+W)+16*8];
unsigned *g_out=g_area+16*8*(W+16*8);
unsigned g_stride=W+16*8;

// Viewport parameters. g_pscale is the log2 scale of a pixel in the image + 4.
// We add the 4 above to have a maximal zoom where a single life cell will be 16*16 pixels in the display.
// g_mx and g_my are the coordinates of the middle of viewport.
double g_mx,g_my;
int g_pscale;
//
// Output support : draw our cells/universe in the output array viewportr.
// Here we use the fact that the array has a padding of 8*16 pixles between lines and 8*16 lines before and after
// so that  8x8 leaf drawing becomes simpler (and more importantly shorter!) as there is no clipping check needed...
// sx and sy are just the coordinates of the top left of the cell. cx and cy are used to get the nice
// color background pattern.
void draw(unsigned cell,int level,double sx, double sy,int cx,int cy)
{
  double sz=ldexp(8,level);
  // The if below checks for  empty space however we dont return if we
  // are in small enough scale so as to draw the colored backgroud...
  if(cell<MAXLEV*3+2 && g_pscale > 6) return;
  double width2=ldexp(W,g_pscale-5);
  double height2=ldexp(H,g_pscale-5);
  if(sx >= g_mx+width2  || sx+sz<=g_mx-width2) return;
  if(sy >= g_my+height2 || sy+sz<=g_my-height2) return;
  double ox=(sx-g_mx+width2);
  double oy=(sy-g_my+height2);
  unsigned *pout=g_out+lround(ldexp(oy,4-g_pscale))*g_stride + lround(ldexp(ox,4-g_pscale));
  if(level <= g_pscale-7) { // Our cell is smaller than a single pixel, its non empty though, so we set it.
    *pout=-1;  //Yes Virginia, -1 is needed here to get white color ....
    return;
  }
  if(level) {
    level--; sz*=0.5;
    // Notice QUADLOOP macro is also usefull for this quadrants draw loop recursion.
    unsigned q[6];
    mq(cell,q);
    QUADLOOP(draw(q[j],level,sx+i%2*sz,sy+i/2*sz,cx*2+i%2,cy*2+i/2));
  }
  else {
    int z0=0,z=4-g_pscale;
    if(z<0) {
      z0=-z;
      z=0;
    }
    // Generate color background pattern, another nice? coding riddle..
    cx^=cy; unsigned background=0x22<<(cx&8?8:cx&64?16:24);
    // Leaf drawing here supports both positive zoom of upto 4 and negative ofcourse.
    ulong in=g_lmem[cell];
    for(int i=0;i<8<<z;i++) {
      for (int j=0;j<8<<z;j++) {
        pout[(i>>z0)*g_stride+(j>>z0)] |= 
            (!i|!j && g_pscale<4) ? 0x80 : // This is the condition to draw leaf borders
            (in>>((i>>z)*8+(j>>z)))&1 ? -1 : background; 
      }
    }
  }
}

int g_adv=0, g_dir=0, g_sstep=0;

void processEvent(Display *d, Window win, XImage *xi)
{
  XEvent ev;
  if(XCheckWindowEvent(d,win,1,&ev)&&ev.type==KeyPress) {
    int N=XLookupKeysym(&ev.xkey,0)&255;
    // The keys ui is documented in the IOCCC entry remarks...
    if     (N==27) { exit(0);} // Use escape key to exit ...
    if     (N==83) { g_mx+=5l<<g_pscale;}
    else if(N==81) { g_mx-=5l<<g_pscale;}
    else if(N==82) { g_my-=5l<<g_pscale;}
    else if(N==84) { g_my+=5l<<g_pscale;}
    else if(N==61) { g_pscale-=!!g_pscale;}
    else if(N==45) { g_pscale++;}
    else if(N==93) { g_step++;}
    else if(N==91) { g_step-=!!g_step;}
    g_adv^= N==32;
    g_dir^= N==8;
    g_sstep^= N==48;
  }
}

unsigned main(int ac,char **av)
{
  g_lmem=(ulong *)malloc(MAXMEM*8);
  g_hash=(unsigned *)calloc(HSIZE,4);
  init_empty_space(MAXLEV);
  int lev;
  if(ac!=2) error(""Usage: apholife input.mc"");
  FILE *f=fopen(av[1],""r"");
  if(!f) error(""Could not open input file!"");
  unsigned cell=getin(f,&lev);

  double gen=0;
  bzero(g_out,(W+8*16)*H*4);
  Display *d=XOpenDisplay(NULL);
  Window win=XCreateSimpleWindow(d, RootWindow(d, 0), 0, 0, W, H, 1, 0, 0);
  XImage *xi= XCreateImage(d, DefaultVisual(d,0),24,2,0,(char *)g_out,W,H,32,g_stride*4);
  XMapWindow(d, win);
  XSelectInput(d, win, KeyPressMask|ButtonPressMask|ExposureMask);
  int curr=1;
  while(1)
  {
    bzero(g_out,(W+8*16)*H*4);
    draw(cell,lev,ldexp(-4,lev),ldexp(-4,lev),0,0);
    XPutImage(d, win, DefaultGC(d, 0), xi, 0, 0, 0, 0, W, H);
    processEvent(d, win, xi);
    if(g_adv) {
      if(!g_dir) {
        if(!g_freeze) {
          int prev=g_ptr;
          cell=adv(cell,&lev);
          gen+=ldexp(1,g_step);
          g_cells[curr+1]=cell; g_cells[curr+=2]=lev; g_gens[curr/2]=gen;
          // This heuristics will quite probably avoid crashing when memory runs out.
          if(3*(g_ptr-prev) >= MAXMEM-g_ptr || curr>=MAXMOVES-3) {
            g_freeze=curr;
          }
        }
        else if(curr<g_freeze) {
          cell=g_cells[curr+1]; lev=g_cells[curr+=2]; gen=g_gens[curr/2];
        }
      }
      else {
        if(curr>2) {
          lev=g_cells[curr-=2]; cell=g_cells[curr-1]; gen=g_gens[curr/2];
        }
      }
      if(curr>2) {
        printf(""G: %g  M: %d L%d S%d%s\n"",gen,g_ptr,lev,g_pscale,g_freeze?"" (Frozen)"":"""");
      }
    }
    if(g_sstep)g_adv=0;
  }
}
","#include <X11/Xlib.h>
#include <stdio.h>
#include <stdlib.h>
#define G >>
#define O <<
#define S E(4)k=V+(V&2),
#define P(V,I)	U(q+V,t*4+I)
#define E(b) for(int V=0; V<b; V++)
#define R a d; long t,r,c,k; unsigned q[16]
											      long H,A,s,h,
											   L, I, f, e; unsigned
											 F=-1,D,l,i,g= 2; typedef
			 unsigned		 long a,			       *T; typedef unsigned*o; T p,
			 C; o n,		 w; a y=			     -1,j,m; void J(unsigned I, o f){
			R; S f[k		]=C[I]&				    64?p[I+(V&2)]G	V%2*32:p[I]G V
			%2*4+16			*(V&2)&				   F ; } void u(	  int l, int g,
			long I,			long b,				   long M){ R;		    c=4l O g; r
			= Y G 5			O s; t=				  X G 5 O s ;		     if(l<194&s>
			6|I>=H+		       t|I+2 *c				  <=H-t|b>=A		      +r|b+ 2* c
		       <= A-r)		       return;				 o n=w+(b-A		       +r O 4 G s
		       )*D+(I-		       H+t O 4				 G s); if(			g<=s -7){
		       *n =-1;		       return;				 } J(l,q);			if( g--){
		       S u(q[k		       ],g,I+V				 %2*c,b+V			 /2*c,M*8
		      +V ); }		      else{ t				 =0; r=4-			 s; if(r<
		      0){ t=-		      r; r=0;				 } M^=M G			 1; E(8 O
		      r){ for		      (k=0; k				 <8 O r;k			 ++){n[(V
		      G t)*D+		      (k G t)				 ]|=V*k|r			 <2?-(p[l
		      ]G(V G		      r)*8+(k				 G r)&1)|M			&513 O 12
       :99; } } } } a U(o v,a j){ R; r=0; t=j/4; T N=(T)v; if			  (t>0){ S		       J(v[k],q+
       2*k),r=917*r+v[k]; if(j&1)return P(5,-2);d=N[0];} else			  { r=(d=v[		       0]|v[1 ]O
       4)+719*(m=v[4]|v[5]O 4); if(j&1)return d G 18&3855| (m			   &15420 )		      O 14; d|=
       m O 32 ; } for(; c=n[r&=Z-1]; r++)if(d==p[c]&(!t|p[c+2			   ]==N[2]))		     break; int
       L=t--+1; if(L>h)L=h; if(C[c]&63^L|!c){ if(!c){ p[n[r]=			    c=g]=d; p		     [g+=2]=N[
       2]; g+=t>=0; } if(t<0){ E(2-!h){ r=0; E(4){ a B=d G V&			    y; B+=d*2		    G V&y; B+=
		    d/2 G V		    &y; B+=				     (B O 8)+(		   B G 8 ); r
		    |=(((B+		    y&y*6^3				      *y)+y G 3		  )&(d G V|B
		    )&y)O V		    ; } d=r				      ; } d=(d G	 18&F )O 32;
		   } else{		   E(11)if				       (V+1&3)q[V	]=P(V,0); S
		   q[k]=P(		   k,(t>h-					2)); d=64|     P(0,2)O 32;
		   } C[c]=		   L| d; }					 return j&2   ?c:C[c]G 32
		   ; } int		   main(){					  n=calloc(Z,8); F/= 17;
		  w=n+Z+F		  / 256 ;					   char*b=(char*) w-99;
		  o z=w+F		  /32 ,Q;					    p=(T)(99999+z); C=
		  p+1; R;		  y/= 15;					     E(64){ { S q[k]=
		  l; } t=		  V; l=P(			0,2); g+=!V; } Display*_=XOpenDisplay(0); while(gets(b)) {
		 if(I ++		 &&b[0]^			35){ if(sscanf(b,""%d%d%d%d%d"",&t,q,q+1,q+2,q+3)==5){ t-=3;
		 S q[k]=		 q[V]?w[			q[V]]:t*3-1; } else{ t=p[0]=j=k=r=0; while(f=b[r++]){ if(f
		 ==42)p[		 0]|= 1l			O j*8+k; k++; if(f==36)j++,k=0; } J(0,q); } l=w[++D]=P(0,2
       ); } } *z=l; z[1]=t; Window f = XCreateSimpleWindow(_,		RootWindow(_,0),0,0,X,Y,1,0,0); Q=z+=2; D=X+128; XImage*j=
       XCreateImage(_, DefaultVisual(_,0),24,2,0,(char*)w,X,Y					,32,D*4);
       XEvent m; XSelectInput( _, f, 1 ); XMapWindow(_, f); d					: printf(
       ""G:%ld M:%d L%d S%d\n"",e,g,t,s); K:L-=L>2; u(l,t,-4l O					t,-4l O t
       ,0); XPutImage(_,f,DefaultGC(_,0),j,0,0,0,0,X,Y); E(Y*					(X+128))w
       [V]=0; if(XCheckWindowEvent(_,f,1,&m)){I=XLookupKeysym					(&m.xkey,
	       0) &63;		       if((I-1							&15)<4)*(
	       I&1?&H:		       &A)+=(I							-1&2)-1 O
	       s +2; i		       ^=I==8;							h+=(I==29
	       )-(h&&I		       ==27);							s+=(I==45
	      )-(s&&I		      == 61);							L^=I==32|
	      2*(I ==		      48) ; }							if(L&1 ){
	      if(!i){		      e+=1l O							h; d=t+2;
	      do{E(16		      )q[V]=3							*t-1; t++
	      ; r=t<d		      |t<h; J							(l, q+5);
	     S q[k]=		     P(2*k,-							2); l=P(0
	     ,2 *r);		     } while							(r);while
	     (--t-1)		     { J(l,q							+10); S J
	    (q[10+k		    ],q+2*k							);E(16)if
	    ((V^V/2		    )&5^5&&							q[V]-3*t+
	    4){ *++		    z=l;*++							z=t;*++z=
	    e; goto		    d; } l=							P(5 ,-2);
	    } }else		    { if(z>							Q){ z-=3;
												e=*z; t=z
												[-1]; l=z
												[- 2] ; }
												goto d; }
												}goto K;}
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/un.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <sys/time.h>
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>

int a,b,c,d,e,f,h,i,j,k,l,m,n;fd_set p[1],q;struct{int A,B,C,D,E,   F
,G,H,I,J,L,K;}w  ,x;r(int r){return b=r,FD_ISSET(r,p);}enum{u=V*( 11 *W
+5)+16};t( int    t){FD_SET(t,&q);}struct sockaddr_un A,  B,*D,C={       .
sun_family=1};    char v[u];unsigned int E=sizeof(B),F=   sizeof(          x
);char*I=""\e""     ""[0m\e[2J\e[0;0H"",*K,*L=&C.sun_path,    *M,*J           =
""\e[0;30;40""      ""m \0\e[0m\n\0#!/bin/cat\n\e[1A"",N;     O(){          n=
0;while(++n<      9)*(n+L)=rand()%13+65;t(b=socket(1      ,2           ,0
));n=bind(b,      b==4?&B:&C,E);}struct timeval y,z      ;H           (
){recvfrom(b      ,&w,F,0,&A,&E),a=w.A;}Q(){close       (           4)
;fopen(K,""r"" )    &&(read(4,v,u),close(4),unlink      (K           )
),O();b=3;}P (    int P){strcat(v,J+P);}G(int G      ){          x.
A=G;D=G<5?0: G    ^8?&B:&A;return sendto(b,G^3      ?           &
x:&w,F,0,D,! !    D*E);}struct termios o;main      (          int
F,char**D){n =    0;for(P(18);n++<V;P(12))//     !           b+12
for(b=0;b++< W    ;)P(0);if(F==2)for(K=D[1     ],           t(0),
srand(getpid (    )),strcpy(L,K),B=C,*L=s     ,           x.J=44,
O(),Q(),G(6);F    ++-4;)for(tcsetattr(1,    0,           (//IOCCC
tcgetattr(1,&o    ),o.c_lflag^=g,&o));F    -4          ;) {//2019
gettimeofday(&    y,0);n=y.tv_usec;m||    (           m   =(3<<19
)+n);z.tv_usec    =(m-n)%999999;b=3;    *p          =q    ;select
(5,p,0,0,&z)||    (x.E^=1,G(9),m=0)    ;           r(     0)&&(b=
3,read(0,&N,1)    ,N%=65,34^N||(x.   D=           x.      D%6+1),
N^47&&N^43||(x    .J=N==x.J?x.E=0   ,           G(10      ),44:N)
,N<4&&(x.E=0,G    (9),x.F+=N==2&  (x           .F-=N      ==3&&x.
F)!=W-3,x.G+=N    ==1&(x.G-=! N  &&          x.G)!=V      -3,x.E=
1),x.J^43&&(x.    H=x.F,x.I=x   .           G),G(9),      48^N||(
x.E=0,G(9),G(7    )));if(r(4  ))          if(H(),a^6      )if(a^5
)while(++b<=c)    G(3);else  x           .K=v[w.L],b      =w.B,G(
4);else/*O()*/    connect( (O           (),x.C=b),&A      ,E),b>c
&&(c=b),G(1) ;    if(r(3) )           if(H(),a^2){ a      ||G(6),
a^1||(x.B=w.C,    x.D||(x.           D=x.B%6+1),x. L      ||G(5))
,a^4||(v[x.L++]  =w.K, x.          L<u?G(5):printf (      ""%s%.*""
""s\r \e[97mmod""  ""e:"" ,           I,u-6,v));if(a==7)      if(x.B^
5||close(w.B),w.B==x.B          ){if(x.B==5)for(/**/      unlink(
K),write(creat(K,511           ),v,u),b=5;++b<=c;)if      (G(2)+1
)for(H();++b<=c;)G(           0);printf(I);break;}if      (a>8)//
for(d=w.F,e=w.G,f           =w.H,h=w.I,a=w.E,i=d<f?1      :-1,j=(
f-d)*i,k=e<h?1:-           1,l=(h-e)*k,n=(j>l?j:-l)/      2;M=34+
(v+(e+1)*(5+W *          11                               )+d*11)
,47^w.J&&43^w           .                                 J|w.A ^
10||(*M=w.D+          48                                  ),*(M-3
)=w.D*(w.D           +48!=*M)+48,*(M-6)=w.E*7+48,*(M+2)=a?42:32 ,
printf(""""           ""\e[%d;%dH%.11s\e[%d;%dH\e[0;4%dm%c%s%s"",e+2,
d+2,M-8           ,V,8,x.D,x.J+65,I+8,J),f^d|e^h;)(b=n)>-j&&(n-=l
,d+=i)           ,b<l&&(n+=j,e+=k),a=0;fflush(stdout);}else//d+=i
   0+          Q(
  )           ,
 G          (6
   ),      G(
      8)  ;
        }}
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/un.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <sys/time.h>
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>

struct sockaddr_un u,v={.sun_family=1},*w=&v,x;struct timeval b,c   ;
fd_set r,t[ 1];  enum{z=V*(11*W+5)+15};struct{int A,B,C,D,E,F,G,H ,I  ;
char J,K[z];}A    ,B;y(int y){return FD_ISSET(y,t);} int  d,e,f,h,      i,
j,k,l,m,n,o,p,    q;unsigned int I=sizeof(x),J=sizeof(B   );char*          E
=B.K,*D=""\e[""     ""0;30;40m \0\e[0m\n\0#!/bin/cat\n\e""    ""[1A""           ,
*C=""\e[0m\e""      ""[2J\e[0;0H"",*F,*G=&v.sun_path,H;K(      int          K)
{strcat(E,D+      K);}struct termios a;N(){p=0;while       (           ++
p<9)*(p+ G)=      rand()%13+65;p=bind(d=socket(1,2,      0)           ,
w,I);FD_SET(      d,&r);}O(){close(4);fopen(F,""r""       )           &&
(read(4,B.K, z    ),close(4),unlink(F)),w=&x;N()      ;d           =
3;}L(int L){ B    .A=L;return sendto(d,&B,J,0,w      ,I          *!
!w);}M(int M )    {return recvfrom(M,&A,J,0,&u      ,           &
I);}main(int P    ,char**Q){for(p=0,K(18);p++     <V          ;K(
12))for(d=0; d    ++<W;)K(0);if(P==2) for(F=     Q           [1],
srand(getpid (    )),FD_SET(0,&r),strcpy(G     ,F           ),x=v
,*G=s,B.J=44 ,    N(),O(),L(0);P++-4;)for     (           (float)
tcsetattr(1,0,    ((int)tcgetattr(1,& a)    ,a           .c_lflag
^=g,&a));P-4;)    {gettimeofday(& b,0);    p=          b. tv_usec
;q||(q=(3<<19)    +p);c.tv_usec=0+(q-p    )           %   999999;
d=3;w=&x;*t=r;    select(5,t,0,0,&c)    ||          (B    .E^=1,L
(7),q=0);y( 0)    &&(!read(0,&H,1),    H           %=     65,H^34
||(B.D=B.D%6+1    ),H^47&&H^43||(B   .J           =H      ==B.J?B
.E=0,L(8),44:H    ),H<4&&(B.E=0,L   (           7),B      .F+=H==
2&(B.F-=H==3&&    B.F)!=W-3,B. G  +=           H==1&      (B.G-=!
H&&B.G)!=V-3,B    .E=1),B.J^ 43  &&          (B.H=B.      F,B.I=B
.G),L( 7),H^48    ||(B.E=0,L(   7           ),L(2)))      ;if(y(4
))if(M(4),p=4,    A.A)while(  ++          p<=e)send(      p,&A,J,
0);else w= &v,    connect((  N           (),B.C=d),&      u,I),d>
e&&(e=d),w=0,L    (4);if(y (3           ))if(M(3),A.      A^5){A.
A^1||L(+0),A.A    ^4||(B. B           ||printf(""%s%""      "".*s\r""
"" \e[97mmode:""    ,C,z-5,A           .K),B.B=A.C,B.D      ||(B.D=
B.B%6+1),strcpy  (B.K, A.          K));if(A.A==2)if(      B.B^5||
close(A.B),A. B  ==B. B           ){if(6==1+B.B)for(      unlink(
F),write(creat(F,511),          B.K,z),d=5,w=0;++d<=      e;)if(L
(5)+1)for(M(d);++d<=           e;)L(1);(int)printf(C      );break
;}if(A.A>6)for(h=A.           F,i=A.G,j=A.H,k=A.I,f=      A.E,l=h
<j?1:-1,m=(j-h)*l           ,n=i<k?1:-1,o=(k-i)*n,p=      (m>o?m:
-o)/2;E=34+(B.K+           (i+1)*(5+W*11)+h*11),47^A      .J&&43^
A.J|8^A.A||(*E=          48                               +A.D),*
(E-3)=A.D*(A.           D                                 +48!=*E
)+48,*(E-6)=          A.                                  E*7+48,
*(E+2)=f ?           42:32,printf(""\e[%d;%dH%.11s\e[%d;%dH\e[0;4""
""%dm%c%s""           ""%s"",2+i,h+2,E-8,V,8,B.D,B.J+65,C+8,D),j^h|i^
k;)(d=p           )>-m&&(p-=o,h+=l),d<o&&(p+=m,i+=n),f=0;fflush (
stdout           );}else&v+111,(unsigned int)O(),/* IOCCC 2019 */
   +L          (0
  )           ,
 w          =&
   u,      L(
      6)  ;
        }}
","#define o void/*
r
bt
q
*/
char*d=""o x!!(){f[*r--]();}!!#define o void/*!r!bt!q!*/!char*d=!!o(*f[])()={b!!,*q;o(*f[128])();int*r,t[9999],*h=t+127,\
n;o x0a(){f[*r--]();}int main(){f[0]();f[59]();}o v(int x!){for(q=d+x;*q+q[1]-66;q++)*++h=*q-33?*q:10;}o a(int x){*++r=\
*++h=x+48+x/10*39;}o b(){*h=1;r=2096+t;v(21);for(*++h=34,q=!d;*q;t[*++h=*q++]=1){(q-d+8)%119?0:(t[*++h=92]=1,t[*++h=10]\
=1);}for(v(t[*++h=34]=71);++n/126-1;n/13?*++h=10:0){*++r=44,*!++r=48,t[n]?*r+=72,v(0),a(n/16),a(n%16),v(5),h-=n-10?0:19\
:h;}v(57);*++r=125;}!!"",*q;o(*f[128])();int*r,t[9999],*h=t+127,n;o x0a(){f[*r--]();}int main(){f[0]();f[59]();}o v(int x
){for(q=d+x;*q+q[1]-66;q++)*++h=*q-33?*q:10;}o a(int x){*++r=*++h=x+48+x/10*39;}o b(){*h=1;r=2096+t;v(21);for(*++h=34,q=
d;*q;t[*++h=*q++]=1){(q-d+8)%119?0:(t[*++h=92]=1,t[*++h=10]=1);}for(v(t[*++h=34]=71);++n/126-1;n/13?*++h=10:0){*++r=44,*
++r=48,t[n]?*r+=72,v(0),a(n/16),a(n%16),v(5),h-=n-10?0:19:h;}v(57);*++r=125;}


















o x20(){f[*r--]();}
o x21(){f[*r--]();}
o x22(){f[*r--]();}
o x23(){f[*r--]();}

o x25(){f[*r--]();}


o x28(){f[*r--]();}
o x29(){f[*r--]();}
o x2a(){f[*r--]();}
o x2b(){f[*r--]();}
o x2c(){f[*r--]();}
o x2d(){f[*r--]();}

o x2f(){f[*r--]();}
o x30(){f[*r--]();}
o x31(){f[*r--]();}
o x32(){f[*r--]();}
o x33(){f[*r--]();}
o x34(){f[*r--]();}
o x35(){f[*r--]();}
o x36(){f[*r--]();}
o x37(){f[*r--]();}
o x38(){f[*r--]();}
o x39(){f[*r--]();}
o x3a(){f[*r--]();}
o x3b(){f[*r--]();}

o x3d(){f[*r--]();}

o x3f(){f[*r--]();}



























o x5b(){f[*r--]();}
o x5c(){f[*r--]();}
o x5d(){f[*r--]();}



o x61(){f[*r--]();}
o x62(){f[*r--]();}
o x63(){f[*r--]();}
o x64(){f[*r--]();}
o x65(){f[*r--]();}
o x66(){f[*r--]();}

o x68(){f[*r--]();}
o x69(){f[*r--]();}



o x6d(){f[*r--]();}
o x6e(){f[*r--]();}
o x6f(){f[*r--]();}

o x71(){f[*r--]();}
o x72(){f[*r--]();}

o x74(){f[*r--]();}

o x76(){f[*r--]();}

o x78(){f[*r--]();}


o x7b(){f[*r--]();}

o x7d(){f[*r--]();}
o(*f[])()={b,0,0,0,0,0,0,0,0,0,x0a,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,x20,x21,x22,x23,0,x25,0,0,x28,x29,x2a,x2b,x2c,x2d,0,x2f,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x3a,x3b,0,x3d,0,x3f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,x5b,x5c,x5d,0,0,0,x61,x62,x63,x64,x65,x66,0,x68,x69,0,0,0,x6d,x6e,x6f,0,x71,x72,0,x74,0,x76,0,x78,0,0,x7b,0,x7d};
","#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define k 16
#define i 24
#define q(a,b)(w[a]*w[b])
#define u(u)(int)((u[w]>0?1:-1)*.5f+100*u[w])
#define j(j,J)w[j]=w[j]>J?-(J):-w[j];
#define D(D)setvbuf(D,0,_IOFBF,a+1);
#define l(l)(K)(l>a?a:l>-a?l:-a)
#define g(g){fprintf(stderr,""%s\n"",g);return 1;}

typedef int32_t I;
typedef int16_t K;

#define C(A,B) w[2 B]=t[          A[d[A];w[3 B]=w[1 B]+q(4          ,2 B);w[4 B]=w[2 B]-q(3 \
   B,4);z[A*=w[3];z[A+= q(3          B,9);t[A[f[k+A]=z[A;k[f+          A=d[A++;if(d[A>=d[i+A)d[A
     FILE*n=0,*h=0;float*t[i]          ;void m(){if(n)fclose(n)          ;if(h)fclose(h);for(I s=0
       ;s<i;s++)if(s[t])free(s[          t]);}int main(int A,char          **b){I*S=(I*)""V@WDfcvcen""
        ""w#vf\4sg\5Gdb&ohwrs'na""          ""dm\11`g'}k|\12d~\x7f%{""          ""mz\14Nlc*z.a~ja/`ed`ee1""
         ""wx~w\22Erev3r}xq5x`fb6""          ""ts7&!7zqlk5(4+:yr{uu~w""          ""o2\34Otgx'>;)0,y\25[RY""
          ""\0MHY\33\4\26F\7\7)tFW""          ""\4IM\\\37\0\21A\3\3,bF""          ""JWNFO\22\15\35M\14\14 *""
           ""**"",a=65535,f[3*i+k],O[          42],*o =O,*c=f+1,*d=f +i          +k,s,v;char*y; float z[i]
           ,X[i],w[21]={1.60f,.30f,          0.5f,.06f,.77f,.965926f,          .258819f,.64731f,.9f};for
            (s=0;s<5;s++)if(A>s+3){s          [w]=strtod(b[s+3],&y);w[          s]/=*y==37?100:/*reverb!!
            v[3]=2<<c[q+k+3];s=3+k+y          printf(""Hello, world!"");          ;w[4]=(w+3)[k-1];)q=3*/1;
            } for(s=0;s<42;s++) s[O]          =S[s]^16843009*(s+1);y=(          char*)o+12;j(1,1)h=fopen(
             1<A?3[b-2]:y+5+k,y);if(!          h)g(y+6)j(3,1)atexit(m);          j(2,1)D(h)if(!fread(f,44,
             1,h))g(y+6)j(1,0)if(*++c          !=*o++||2[--c]!=1[o]||8[          c--]!=*o)g(y+6) w[0]*=(12
             [f]=4[++c]>>k,6[f]);j(0,          6e5f)j(0,-4e3f)j(2, 0)f[          13]=(I)*w+f[10]/(2*12[f])
            ;K*e=(K*)(f+ 10);j(3,1)w          [9]=3[w]<0?1+3[w]:1-w[3]          ;if( 3<=f[12]||(4[c++]&a)
            !=1|| 6[c--]>>k!=k) g(y+          59)7[c]=k/2*(4[c]=5+4*(a          >>=1))-i+20;c[6]=2*c[6]/f
            [12];f[1]=20+(10[f]=f[13          ]<<2)+k;n=fopen(A>2?1[b+          1]:y+28,y+3);if(!n)g(y+36
           )D(n)fwrite(f,28+k,1,n);          printf(y+99,w[0]/6[f],u(          1),u(2),u(3));*X=(*w/=k);
           1[X]=q(0,8);for(s=0;s<i;          s++){if(s>1)s[X]=X[s-2]*          7[w];s[d+i]=(I)s[X];s[z]=
          (s[d]=0);s[f+k]=1;if(s[X          ]>99)f[k-1]=(s-1)|1;s[t]          =calloc(sizeof(float),s[d
         +i]);}while(++f[15]<12);          for(s= 14[f]=0;s<f[13];s          ++){if(f[14]||(10[f+4] =!
        fread(e+1,2*f[12],1,h)))          e[f[12]=1]=0;w[11]=(w[15          ]=w[k]=e[12[f]],w[10]=e[1
       ]);for(v=0; v<i;v+=2){w[          14]=w[11];w[19]=w[k];if(          v<f[15]){C(v],+10)=0;C(v+
     1],+15)=0;}11[w]=q(5,14)          -q(6,19);w[k]=q(6,14)+q(          5,19);}w[k]*=w[2];w[11]*=
   w[2];w[11]+=q(10,1);w[k]          +=q(15,1);w[20]=w[11];1[          e]=l(20[w]);2[e]=l(k[w]);
fwrite(e+1,4,1,n);}}//=w          +=q(32];f[1]=36+(10[f&y)          ;w[s]/=*y==37?1;59)7[c]=k
","#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//@                                                                            //
char _int[]={37,99,0,10,0,71,111,  111,100,98,121,101,32,58,45,41,10,0,27,91, 72, 
27,  91,74,0,27,91,37,100,59,37,   100,72,0,27,91,37,100,109,0,0,0,-30,-108,  -125,0,-
30,  -108,-127,0,-30,-108,-109,0, -30,-108,-113,0,-30,-108,-101,0,-30,-108,  -105,0,
33,  0x20,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ,0,0,0,0
,0,0      ,0,0,0};main(){void*   y3=stdout,*s0=stdin,*(*mv)(size_t)=&      malloc;int qq_,*hh,
qf,(*g4)  (void*)=&fflush,(*   z1)(const char*,...)=&printf,(*p0)(int)=   &putchar,c=0,
i,dd,sz,h ,s,e,pr,*trundle,* vp5,*nqd,oo[10];char*p5;goto cow;pic:g4(y3      );    sz=dd*h;
hh=mv(     sizeof(int)*sz);  z1(_int+18);goto china;tokyo:;if(qq_==     qf)   goto ten ;c=hh [
qq_++];  oo[0]=dd;oo[1]=h;oo [2]=c%dd;oo[3]=c/dd;oo[4]=0;{int x=    oo[2],         y=oo[3],dd=*
oo,h=   oo[1],i=x+y*dd;if(x+  1<dd&&(p5[i+1]==32||p5[i+1]==33))  oo[5+oo[4]++  ]=i+1;if(
x-1>  -1&&(p5[i-1]==_int[66]  ||p5[i-1]==_int[67]))chew: oo      [5+oo[4]++]=i    -1;if(y+1<h
&&p5   [i+dd]==_int[67]||p5[i +dd]==_int[66])oo[5+oo[4]++]=  i+    dd;if(y-1>-1&&   p5[i-dd]
==_int   [67]||p5[i-dd]==_int       [66])chun:oo[5+oo[4]    ++]=i  -dd;}if(c&1?nqd  [c]:vp5[c] )
goto   tokyo;wow:;if(oo[4]--  <=0)   goto chin;i=oo[5+oo  [4]];   if((i&1?vp5[i]:  nqd[i])==0
){   trundle[i]=c;usleep(    25000)  ;g4(y3);z1(_int+34   ,_int[  67]);z1(_int+25,  1+i/dd,1+i%
dd); p0(88);if(i==e)goto z; i&1?(vp5    [i]=1):(nqd[i]   =1);hh[  qf++]=i;}goto     wow;chin:c
&1?( nqd[c]=1):(vp5[c]=1);  goto tokyo; z:;z1(_int+34, 36);z1(   _int+25,1+e/   dd, 1+e%dd)
;p0(  33);tww:;if(trundle   [i]==s)goto  ten;i=trundle  [i];    usleep(50000) ;z1(     _int+34,35
);z1(  _int+25,1+i/dd,    1+i%dd);p0(47)  ;g4(y3);z1(  _int+34 ,33);z1(_int   +25,1 +    s/dd,1+s%
dd);p0    (95);goto    tww;ten:;z1(_int  +25,h+3,1);  g4(y3);  goto pio;    cow:;   {int c=0;s=e=-1
;char**      strs=mv  (1000),d;h=0;for(;  h<1000;){   char*s=  mv(512);if  (fgets  (s,   512, s0)  ||
feof(s0)) {    dd=   strlen(s)>dd?strlen(  s):dd;    strs[h]=  s;h+=1;if  (feof(s0  )    &&(h--|1))goto
tau;}else goto ten; }tau:p5=mv(dd*h);for(   int i=0;  i<dd*h;i  +=1)p5[i]  =040;for   (int i
=0;i<h;i  ++){      memcpy(p5+i*dd,strs[i],          strlen(   strs[i]))  ;for(int   q=0; ((d=strs[i][q])
||1)&&q<dd&&((d==          64?s=i*dd+q:d==33?e=i   *dd+q:d==   10?p5      [i*dd+q]= 040:13)||1);q++); }
if(s==-1||e==-1)goto ten;   goto pic;}china:;for(int r=0;r<sz;        r++){z1(_int+ 25,1+(r
/dd),1+r%dd);p0(p5[r]);}   trundle=mv(sizeof(int)*sz);vp5=mv(sizeof(int)*sz);nqd =   //
mv(sizeof(int)*sz);trundle [s]=0;hh[0]=s;qf=1;qq_=0;goto tokyo;pio:;          //!     //
(_int[0]=27)&&(_int[1]=91)&&(_int[2]=48)&&(_int[3]=109)&&(_int[4]=10)&&(_int[5]=0)&&z1(_int);}
","#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//@                                                                            //
char _int[]={37,99,0,10,0,71,111,  111,100,98,121,101,32,58,45,41,10,0,27,91, 72, 
27,  91,74,0,27,91,37,100,59,37,   100,72,0,27,91,37,100,109,0,0,0,-30,-108,  -125,0,-
30,  -108,-127,0,-30,-108,-109,0, -30,-108,-113,0,-30,-108,-101,0,-30,-108,  -105,0,
33,  0x20,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ,0,0,0,0
,0,0      ,0,0,0};main(){void*   y3=stdout,*s0=stdin,*(*mv)(size_t)=&      malloc;int qq_,*hh,
qf,(*g4)  (void*)=&fflush,(*   z1)(const char*,...)=&printf,(*p0)(int)=   &putchar,c=0,
i,dd,sz,h ,s,e,pr,*trundle,* vp5,*nqd,oo[10];char*p5;goto cow;pic:g4(y3      );    sz=dd*h;
hh=mv(     sizeof(int)*sz);  z1(_int+18);goto china;tokyo:;if(qq_==     qf)   goto ten ;c=hh [
qq_++];  oo[0]=dd;oo[1]=h;oo [2]=c%dd;oo[3]=c/dd;oo[4]=0;{int x=    oo[2],         y=oo[3],dd=*
oo,h=   oo[1],i=x+y*dd;if(x+  1<dd&&(p5[i+1]==32||p5[i+1]==33))  oo[5+oo[4]++  ]=i+1;if(
x-1>  -1&&(p5[i-1]==_int[66]  ||p5[i-1]==_int[67]))chew: oo      [5+oo[4]++]=i    -1;if(y+1<h
&&p5   [i+dd]==_int[67]||p5[i +dd]==_int[66])oo[5+oo[4]++]=  i+    dd;if(y-1>-1&&   p5[i-dd]
==_int   [67]||p5[i-dd]==_int       [66])chun:oo[5+oo[4]    ++]=i  -dd;}if(c&1?nqd  [c]:vp5[c] )
goto   tokyo;wow:;if(oo[4]--  <=0)   goto chin;i=oo[5+oo  [4]];   if((i&1?vp5[i]:  nqd[i])==0
){   trundle[i]=c;usleep(    25000)  ;g4(y3);z1(_int+34   ,_int[  67]);z1(_int+25,  1+i/dd,1+i%
dd); p0(88);if(i==e)goto z; i&1?(vp5    [i]=1):(nqd[i]   =1);hh[  qf++]=i;}goto     wow;chin:c
&1?( nqd[c]=1):(vp5[c]=1);  goto tokyo; z:;z1(_int+34, 36);z1(   _int+25,1+e/   dd, 1+e%dd)
;p0(  33);tww:;if(trundle   [i]==s)goto  ten;i=trundle  [i];    usleep(50000) ;z1(     _int+34,35
);z1(  _int+25,1+i/dd,    1+i%dd);p0(47)  ;g4(y3);z1(  _int+34 ,33);z1(_int   +25,1 +    s/dd,1+s%
dd);p0    (95);goto    tww;ten:;z1(_int  +25,h+3,1);  g4(y3);  goto pio;    cow:;   {int c=0;s=e=-1
;char**      strs=mv  (1000),d;h=0;for(;  h<1000;){   char*s=  mv(512);if  (fgets  (s,   512, s0)  ||
feof(s0)) {    dd=   strlen(s)>dd?strlen(  s):dd;    strs[h]=  s;h+=1;if  (feof(s0  )    &&(h--|1))goto
tau;}else goto ten; }tau:p5=mv(dd*h);for(   int i=0;  i<dd*h;i  +=1)p5[i]  =040;for   (int i
=0;i<h;i  ++){      memcpy(p5+i*dd,strs[i],          strlen(   strs[i]))  ;for(int   q=0; ((d=strs[i][q])
||1)&&q<dd&&((d==          64?s=i*dd+q:d==33?e=i   *dd+q:d==   10?p5      [i*dd+q]= 040:13)||1);q++); }
if(s==-1||e==-1)goto ten;   goto pic;}china:;for(int r=0;r<sz;        r++){z1(_int+ 25,1+(r
/dd),1+r%dd);p0(p5[r]);}   trundle=mv(sizeof(int)*sz);vp5=mv(sizeof(int)*sz);nqd =   //
mv(sizeof(int)*sz);trundle [s]=0;hh[0]=s;qf=1;qq_=0;goto tokyo;pio:;}         //!     //
","#define x 0/**/
char*v,*y=""33Yb59@&iBFApt;[[h3V19\\3<:4cJ!U 2eT18pC,Qqik4J:sh?HUXMrR(-l0R\""!eKZcI!@E(@B,C/*!aogn5LbK/e=2CmReb+6,]kD!iOC9DEOC9Dc1EV6976c?&s)Be;P;E^tl2eUYkg*#Yf:6^d[Mg_P;VGCr823^L_<X+j2,%nD20Ls lmpi&I(*hV=+p aTO`r.b1<i[/R\\t1,KBt)\\%;\\@27H>^#d6B!tb-on27d%i_OS5(W5eV-=M14kYO);Fe7k!N41<iX*T,kHW,&)_l&L)'0:Jj%j7^h+JU /9pZn&Td:&T%'TE<7>LW%m/R\\rON3-=G]^akjT778YCJ7B8e-5E#RX R=Ig8#/pDdAI;=a[ ISbp't+ZLJ;lUO71C)b5[Y)qTWmFJ)G1ehmS<.`n3RnE IG+G_A`CE=?hZU)bScgt7R3GNs+V(HQLL_R)n4;]#cUR.p>5!^4T3pQg^o//WLATCE18mSUme[Q<53e:')Q_%<L$1lKOnFD(R3%*jj85VW+#8Wt*Ud,1D7AKcdh<9r%igC$2</HD7X$K_0Rr/>L.*D2%;[0B+#8UANT1.tSd/^@L$&a6^g@jYNMC7O<rPWO5AfA;C'9WnLn9E:0d:R\\hAZ^m=/09d.R$Jd%:Gp hB-g4&N!VO)$;iED1:F`^`UrnWCSZ!L$Tdma!_hn7H0F$^MT(-Ln9F_Ljfp9*h8Er!<.g.h_7@b0l03?a+]`=dIoY>WCKOk&#[9FCQ#WFoga(tK<[PG6@5k2KY\\ oW':M;e//kd\""[l,_V?UlZ,m(Hh?O81mhM!G18 ]7m?X7e^[7EZYj[;kR,YXD\\X,!k6.HF8Z(V^^nBYea^NIL:]lG0(/\\Ik<m`>jPam;F-A,(tVN+bG@<L'J 1D8dE*hN87:TsccSKVE7KP+k8^5qZIkJG_fH_$MS--5(!*St/1:b+g8(/*"",*T,*n="" $6I7H#v Jw	{};	  } }    } 	 } }	 ; } 	 { } 	 } ;	  		 { { 	   } } }   ;  ; 	 } 	 ; 	 } } ; }	 }	 } ; }	  	  	 } ; 	 } {	   	 }	 ; } } 	 ;  ; } 	 } ;  {	 }   { } ; } { ;	 {  ;	 { 	 }  ; ; ;	 { { } } 	 ; 	 ; { 	 }   {}  } } }  {	 ;   {	  	 ; } {	 	 } } } }	    ;} ;	 	 } }	 }	 } }} } } 	 }	 {}  :!#$%&*+./<=>?@\\^|-~			  	   \n	} { {  }  --			 	 ;} ; 	 ; } 	 } 	  ; { {  } }  } { } 	 ; 		 }	 	   \\'\""		} { ; 		 }{  }	} }  	} ; } }}   }} }  :	} 	  } }	 } 	 	 }  {	 	{  ; 	  		  of	 ;	 	 }  {	 }	 }	  	 } } { 	  }  ;	 	 	 {	 {	 } }	 ;} 	} {} ; }  }	 	 }} }    ;	 }} 	 	 {	  ->	 	{ 		{ 	  	 ;	 } ;	 } }} ; 	}  	 }	 } }} 	 	} 		 {} 	  } ; } 	} }} }} }} { }} } } ; }  { }} ;	 ;	 {} ; ;	 } ; } }; {	} { 	 ; ;  	 	}  }} }} }} }} ;} } ; } {	 {} ;  let	;  in		 } ;} } ; } } {} ;  case	; } 	 } 	 ;} } }	 {} { } {	 ;} } ; {	 {} {	 }	 {	  ;	 }} }} } } 		 	} ;} } ;} } } } 		}  		 	 	;  ; 	; 	  } {; {; {; } 	 } } ; } }  ;  }  { ;  {; } } ; {; }; } };  };   };  ; }; ;;  }; ; 	 ;	 }; } } ;}   : <= * + - /	}; { } 	} {} 	} ; } 	 {	} 	} ; }	  data	 	 	} ; }; ;	} { {; 	 {	 	 } ; ;; 	 }	} 	} };  	} ; } ;} {	} {	} } 	 } 	 ; ;	{ 	} } {	  }	} 	} {; 	 ;} }	} 	} {	 {	  	 	 ;; #define x \\"";
#include <stdio.h>
typedef unsigned P;
enum{ L=1<<26} ;

P I,C,K=24,M,E

,j[L]={ x},*D=j+L/2,*i=j+L-3;
P w(P _){ return j[_[i]+1]; }
#define X(f,b,y,d) void f(){ D=j+b[i]; *D=y; *++D=d; i+=b; }
X(A,1,w(1),i[1])X(a,2,w(2),w(1))P l(P _,P E){ j[K++]=_; K++[j]=E; return K-2; }
int S;
X(t,1,9,(S=getchar())<0?8:l(l(17,l(1,S)),l(7,0)))P U(P _){ return j[w(_)+1]; }
X(_,2,9,U(1)>U(2)?l(8,9):8)X(b,2,w(2),i[1])P G(P _,P S){ return l(w(_),w(S)); }
#define B(f,o) X(f,2,1,U(1)o U(2))
B(p,*)X(c,3,w(1),G(2,3))X(u,3,G(1,3),w(2))P N(P l,P L,P _){
I=0;
while(*T-I[v])I++;
T++;
return I/6?l:N(l+I/_*L,L*6/_,3-_);
}
X(s,3,G(2,3),w(1))X(m,4,G(4,1),w(2))B(o,-)X(f,3,G(1,3),G(2,3))P Z(){
P _=*T++;
return _-9?l(l(17,l(1,_)),Z()):8;
}
X(d,2,w(1),w(2))X(R,2,l(w(2),printf(E?""%c"":""%u,"",U(1))),l(23,9))P W(P _){
if(S--); else{ M=0; C=5; while(C--)M=85*M+*y++-32; S=31; }
I=_*2+!!(M&1<<S);
for(_=0; (C=_[n]-9)&&C-I-23; _++);
return C?_?--_<2?C=N(0,1,1),_?l(_,C):C?C<8?C+15:7[D-C]:Z():_:(_=W(0),l(_,W(0))):W(I);
}
B(g,/)B(r,+)X(e,2,9,w(1))X(O,2,w(2),l(w(1),M-8))int main(){
v=12+n;
if(E=*j,E){
D=j+2;
K=E;
} else{
T=v+7;
while((*D=W(0)))D++;
puts(T);
}
*i=l(l(l(*--D,l(7,0)),0),l(23,9));
while(M=*i,M)M<24?(void(*[])()){

 O,b,f,u,s,c,a,t,e,d,_,p,r,o,g,R,A,m

} [M*(M<18)](),7:(*--i=M[j]); return E||puts(y); }
","

             #/*void*/include<math.h>
     #include/*#pragma _Atomic int*/<stdio.h>
/*       { */struct{ int o,s; } typedef V       ;
struct{      int x; V o,i,p; }typedef      R; int
d,w,a,i,b,      u,g,n,j,F,h; R*Q,B      [99],*E=B
; V I(int s ){     V o={ d,s} ;     d +=s; return
#define O ; { } }     if(! n     --) { { {  ; } }
o; } float*p,ll=1,*     q,     *e,s,*r,*G,*W,y=1,
# define _ V i ){ V o=      I(i .s); * E++=( R) {
*x,l,*z,m; V A(V p,_ 4,o    ,p,i} ; return o; } V
X,Y; double drand48(); V C    (V i,V o){ *E++=(R)
#define OO ){ P(Q->o,a=Q->i.    o-n; b=Q->p .o-n\
; r=b+W+n){ { n=Q->x O//struct   volatile union {
{ 3,o,i} ; return o; } unsigned    char c[256],t[
sizeof c+N]; V M(V p,_ 5,o,p,i} ;   return  o ; }
struct{ float r ; short k ,p; char    unsigned d[
sizeof c]; } k={ LR} ; V S(_ 2,o,i}    ; return o
; } void Z(float*p,int n){ while(n--)   *p++=0; }
V L(int s,V i){ V o=I(s),p={ w,s+i.s*s   } ; w+=p
#define P(v,i)n=v.o; e=G+n; p=e+v.s; q=   p+d; i\
; while(--q,p-->e)// _Alignas _Imaginary   _Bool;
.s; *E++=(R){0,o,i,p}; return o; } V CM(V   i){ V
 o=I(a=i.s),p={ w,a} ; w+=a; *E++=(R){ 7,    o,i,
p} ; return o; } void J(int c){ Z(e=G+X.o,   X.s)
; c[e]++ ; for(Q=B; Q<E; ++Q OO*p=*r++; n=Q   ->i
.s; while(n--)*p+=*r++*e[a+n]O*p=tanh(a[p])   O*p
=1/(exp(-a[p])+1)O p[a+u]=*p O*p=p[a]+b[p]O*   p=
a[p]*p[b]O*p=a[p ]*Q->p.s+Q->p.o O*p=a[p]**r   ++
; } } } Z(G+d,d); P(Y,m=*e)m=fmax(m,*p); P(Y,   s
=0)s+=*q=exp((*p-m)/TP); P(Y, )*q/=s; } V T(_   1
,o,i}; return o; } int K(int K ){ J(K); P(Y,s   =
drand48( ))if((s-=*q)<0)break; return j=p-e; }
V OG(int a,int b,_ 6,o,(V){ b,a} } ; return o;
} void D(char unsigned*s){ float V[2*d]; int R
=u; u=V-G; J(c[*s++ ]); n=c[*s]; l-=log(n[++q]
--)/N; G+=u; p=d+G; if(1[s])D(s); else while(p
-->G){ p[x-G]=*p; d[p]=0; } G-=u; Q=E; while(F
<i&&Q-->B OO r++[w ]+=*q; n=Q->i .s; z=e+a +n;
while(n--){ w[r ]+=*q**--z; d[z]+=*q**r++; } O
a[q]+=*q*(1-*p**p)O q[a]+=*q*(1-*p)**p O*q+=q   [
a+u]O a[q]+=*q; q[b]+=*q O q[a]+=b[p]**q; b[q   ]
+=p[a ]**q O a[q ]+=Q->p.s**q O a[q ]+=*q**r;   r
++[w]+=*q**p; } } } u=R; } V MD( V x){ V BK;   //
return y; } int main(int Q,char**E){ FILE*f,   *o
=stdin; if(--Q){ o=fopen(2[E],""r""); f=fopen   (1[
E],""r""); while(w>-(n=getc(f))){ ++h; if(!n[   t])
{ n[t]++; k.d[k.k]=n; n[c]=k .k++; } } } o   &&f\
read(&k,sizeof k,1,o); n=k.k; { V NW; X=x    ; Y=
y; } float R[d+d],B[4*w],q[d*2]; G=x=R; W   =B; Z
(W,4*w); p=W+w; while(p-->W)*p=2*drand48   ()*RS-
RS; o&&fread(W,1,sizeof B,o); Z(G,d); h   /=N; i=
h*TR; h-=i; for(t[1+N]=m; Q; fclose(o)   ){ rewi\
nd(f ); while(fread(t,1 +N,1,f) ){ G=   q; p=d+G;
while(p-->G)*p=p[x-G]; D(t); ungetc    (j=N[t],f)
; if(F++<i){ a=w*3; b=a- w; p=W+w;    while(p-->W
){ m=fmax(-CL,fmin(CL,w[p ])); ll   *=B1; p[a]=m+
(a[p]-m)*B1; y*=B2; m*=m; b[p]=    m+(p[b]-m)*B2;
*p+=(a[p]/sqrt(p[b]/(1-y)+EP)/   (ll-1)+WD**p)*k.
r; p[w]=0; } if(1>F%DI){ G=R    ; z=SL+W; while(z
-->B)putchar(k.d[K(j)]); }    } if(1>F%DI ){ b=F;
a=i; j=b>a; if(j){ b-=a;    a= h; } printf(&j[//;
""\n%c%d:%d%% %f\n""],j[      ""TV""],k.p,100*b/a,l/b
); } l*=F!=i; } /**     */     char p[999]; if(LE
<=++k .p)k.r*=LD;     /*if*/     sprintf(p,PF,k.p
,l/h); fwrite(     &k,sizeof k,     1,o =fopen(p,
""w"")); F=l      =0; fwrite(B,w,/**      */sizeof*
W,o); }      while(putchar(k.d[K(j)])      ){ } }
/*       typedef volatile long double not       ;
     register restrict unsigned volatile void
             _Complex struct bitand*/

","#include    <stdio.h>
#include   <string.h>
#include    <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>

#define 		W 48
#define 		b '\b'
#define 		q R[2]==
#define			R __DATE__
#define 		n 1073741824ul
#define 		L (V) l[++S] << b * S
#define 		D (R[7]-W)*1000+(R[b]-W)*100+(R[9]-W)*10+R[10]-W
#define k q'p'?9:q'y'?5:q'n'?(R[1]=='u'?6:1):q'b'?2:q'r'?(*R=='M'?3:4):q'g'?8:q't'?10:q'v'?11:q'l'?7:12
#define 		Z B |= (V) *l++ << u++ * b;
#define 		g for(a=0;a<5;a++)
#define			o     25
#define 		G a+

typedef unsigned long			       long V;V _=1ULL   <<               63;  V d=1UL<<037;                     unsigned int x[
n/16]; V m,F,u,T,a,r,H			      ,B,I; int main(int P,               char *U[]){union{V                     K[o];  unsigned
char E[1]; }c ;   const                      unsigned char *f, *l ;               V X,i,e,z,A,Q,M=-~9,                   Y; struct  stat
J; void *p; r++ ;V t,y=                     0,v[5];const void*j[ ]=               {&&laajavuori,&&ruka,                  &&puijo,&&lahti
,&&vuokatti,&&virpiniemi,                  &&ounasvaara};V N[o]={r,		  P,6,M,15,21, 28,36,45,                 55,2,14, 27,41,
56,b,o,43, 62,18,39,61,20,                44};for(;U[r][a]; a++)T=T               *M+U[!u][a]-W; T >>=P ;                X=open(U[--P],F
); V w[o]= {_|d|32776,d|r,               _|32896,_| d |32897,_|d|M,               32778,_+128,_ |32770,_ |		 32771,_ |32905,
_ |139, d| 32907 ,   d|M,d|	         32777,136,138,_|32777,_|d|               32897,d|1,32907,_|d|32768	         ,_|32906,32898,
r,_}; i=  fstat (X,&J); V O             [o ]={M,7,11,17,18,3,5,16,b               ,21,24,4,15,23,19,13, 12,P,	         20,14,22,9,6,r}
; Y=H=J./*****/ st_size; p=            mmap(/*TODO: FIX THIS */NULL               ,H,r,r,X, u  ); memset(&c,0,	         200 ) ; z = b &
7; r =  T/11     [O]; l=p ;           for(I=2; I<=  Y; x[I++>>4]|=(               1<<(I&4[N])) ); goto C; ruka:	         for(I=b*3; I--;
) { g v[ a ] =c   .K[a]^c.K[G        b-3]^ c.K[G    M] ^ c.K[G 15]^               c.K[G M+M] ;  g  {t =  v[(G 4)         %5]^(v[(G   1)%
5]<<1|v[(G 1  )   %5] >> '?') ;     for(A =0; A<    o; A+= 5)c.K[ G               A]^=t;}t=c  .K[   1] ; for  ( a        =0; a-24; a ++)
A =O[a],*v =  c    .K[A],c.K[A]    =t<<N[a]|t>>     (0100-N[a]),t=*               v;for(A    =!o;    A^o; A += 5 )       {g v[a] = c.K[G
A]; g c .K[G A]     ^= ~v[( G 1)   %5]&v[(G P)      %5];}c.K[!1] ^=               w[I];    } goto     *j[Q];C:for(       I=P; I   <=Y/P;
y=I*P) {  while      ( y <= Y   ) x[y>>4]&=~(1      <<(y&O[12])), y               +=I; do    I++;      while(~x[I>>4     ]&(1<<(I&15)));
}if(H<z){ while       (H-- )    Z goto $ ;  }       if (z){ H -= z;               Q= P; while(z--       )Z c.K[F]^=B;    B=u=i; if(o-r==
++F){goto*j[!!b        ]; puijo:F=!o; } }m=H        /b; e=H - m*b ;               for(; i<m; l+=b        ){i++; V S=~    -!W; t=/*foob*/
L|L|L|L|L|L|L|L         ;c.K[F] ^= t; if(++F        ==o-r) { Q=-~P;               goto * j [ !0];         lahti: F=!r ;  }}while  (e--)Z
$: c.K[F]^=(B ^         ((V) ((V)(P | 1 <<          P)<< u* b) )) ;               Q^=Q; c.K[o-r-1          ]^=w[ ~ -o ]; goto*j[-~(P-P)]
; laajavuori: f          =c.E; _= d=I =~-P          ; a = D; Q = k;               goto*j[4+(23*Q/           9+(Q>P?a-P:a --)+(R[4]==32?0
:((R[4]-W)*M))+           R[5]-45+a  /4+a           /0620-a/0x64)%	          3]; ounasvaara:            for ( I = 2 ;  I<= Y; I ++)
if (x[I>>4]& (1            <<(15& I) ) )            printf( ""%llu ""               , I);goto http;             virpiniemi:for( I= !I; I-T
; ){ char s[30]             ={W,W,'\0'}             ;X=!!W;for(e=f[               I++]; e^0; e>>=              4)P = e & 15, s[X--]= P <
M ? W | P : P +	            'W'; printf	            ( ""%s""  , s); }               /*  addr(ioccc)               */ http://www.ioccc.org/
return /******/				            puts(""""); /***/               vuokatti:for(;I                ^'^';++I,printf(""%llx ""
,_),t =_+d,_=d,                                     d = t) ;   goto               http;/*m=  o/i;                  v[a]=a+n;return 0;*/}

























","#include<stdio.h>
#include<stdlib.h>/*
e=nil;ARGF.each_char{|c|print c;e=e ?c<""A""||c>""Z"":c==""\e""?1:!(sleep 0.1)};%q{*/
#define T(_,S,C,R,A,M,B,L,E) _ V,i,o,l,e,t=1,n[4],I[22]={4352,95,4554,1,2902,4\
46,2,29839,1841,11171,8541,511,785,9,23,63,145,96,128,6,61466,135167},g=240,H,\
h,p,q,x,y;typedef struct{_ x,y,z;}b;b*U,u;FILE*f;A m(_ p,_ q){_ d=(p+q)/2;C(d-\
p){m(p,d);m(d,q);S(i=p,o=d,y=H+p;y<H+q;y++)x=i>=d||(o<q&&U[i].y*1e6+U[i].x>U[o\
].y*1e6+U[o].x)?o++:i++,B;S(y=p,x=H+p;y<q;x++,y++)B;}}A v(){S(i=l=0;i<22&&(o=l\
+I[i++],l=o+I[i],e<o||e>l);i++);x+=2-i/22;}A a(){C(H+2>t)U=(b*)realloc(U,(t*=2\
)*24);U[H].x=x;U[H].y=y;U[H++].z=e;p=p>y?y:p;q=q<y?y:q;v();}A P(_ p){n[o=0]=e=\
p;C(p>>7){S(;p>63>>o;p>>=6)n[o++]=(p&63)|128;n[o]=(g*8>>o&g)|p;}S(;o>-1;)fputc\
(n[o--],f);}A Q(_ O){O?fprintf(f,""\33[%d%c"",abs(O),V+(O>0)):0;V^=2;}R d[2]=""r""\
;_ main(_ O,R**Z){f=stdin;C(--O&&(**++Z-45||1[*Z])&&--Z&&L)M;S(*d|=5;(e=fgetc(\
f))>0;h=h<0?e-91?e<48||e>59?l*=(e&2)-1,e>64&&e<67?y+=l,0:e<69&&(x+=l)<0?x=0:0:\
~(l=l*10+e-48):h:h?(e=l=l<<6|(e&63),!--h)?a(),h:h:(e&224)==192?l=e&31,1:(e&g)=\
=224?l=e&15,2:(248&e)==g?l=e&7,3:e-27?e==10?y++,x=0:e-32?e==9?x=(x+8)&~7:e>32?\
a(),h:h:x++,h:~(l=0))V+=(V+e)<<10,V^=V>>6;E;f=stdout;C(U){C(O<1){m(0,U[H].x=H)\
;S(h=x=0,y=p;h<H;v()){S(;y<U[h].y;y++,x=0)P(10);S(;x<U[h].x;x++)P(32);S(;h<H&&\
U[++h].y==y&&U[h].x==x;);P(U[h-1].z);}C(x)P(10);}else{srand(V);S(x=H;--x;B)y=r\
and()%-~x;C(--O?L:O++)M;S(t=h=0,y=q+1;h<H&&t<O;E){C(t&&L)M;C(!t)S(h=q-p+2;--h;\
)P(10);S(V=65;h<H*-~t/O;y=U[h++].y)Q(U[h].y-y),Q(x-U[h].x),P(U[h].z),x=U[h].x,v
T(int,for,if,char,void,goto X,(u=U[x],U[x]=U[y],U[y]=u),((f=fopen(*++Z,d))?0:-(
perror(*Z),1)),fclose(f))();Q(q-y);P(10);y=q+1;x=!++t;}}}O=0;X:return O;}/*}#*/
","                                           #include<stdio.h>
                                #/*     [bbde3cf3]*/include<stdlib.h>
                             #  define D(o,l,I)/*( C ) 2 0 1 9 */o##l##I/*
                          e = nil;ARGF.each_char{ | c | print c; e=e ? c < ""A""||
                         c >""Z"": c == ""\e"" ?1:(!sleep 0.1 ) } ;%q{bU'*Evergarden*/
                       D( t ,ype ,def ) D ( i ,n,t)_; D ( t , ypede , f ) D ( s , tru
                     ,ct ) { _ x , y , z ; } b ; b*U , u ; _ h ; FILE* ( f); _ H , h ,g
                   =6 * 40, V , i , o , l , e , t = 1,E [ 4 ] , I [22 ] = { 8 * + 4 * 17
                *8,5 * 19, 2 * D ( 7 , 5 , 9 ) * 3 , 1,2 + 5 * 4 * 5*29, 446 , 2 , ~ - (2
            *20 * 2 * (31 * 2 * 3 * 2 + 1 ) ) , 7 * ( 2*2 * 3 * 2 * ~-( 2*3 * 2 ) - 1 ) ,7
               * ~ - (4* 5 ) * 4 * + 7 * 3 - 1 , 3 * - ~(2 * 3 * 2 ) * ~ - (2*-~(2 * 3 * 2*3
              ) ) * 3,~ - ( 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 ) , 1 + 7 * 4 * 7 *4, 9 , 4 * 6
             - 1 , 63, 5 * ~ - ( 5 * 6 ) , 3 * 4 * 8,8 * 2 * 8 , 6 , ( 17* 113 * 8 * 4 - 6 ) ,
             11 * 3 * 8 * 4 * 8 * 8 * 2 - 1 },p , q ,x, y ; D ( v , o , id) s ( ){u = U [ x ] ,
           U[x ]=U[y ] , U [ y ] = u ; } D ( v ,oi , d)m(_ p , _ q ) { _ d=( + p+q ) / 2 ;if (d
          -p) {m( p ,d) ; m ( d , q ) ;D(f, o , r)( i =p,o= d , y = H + p ;y< H + q ; y ++) { x
        =i>= d|| ( o<q &&( U [ + i ] . y>U[o ] . y|| ( U[+i] . y== U [ o ].y&& U [ + i ] .x> U[
       o]. x))) ? o++ : i++ ; s ( );} for  (y=p , x=H + p;y<q ; x+= 1 , y +=1)s ( ) ; }}D ( v ,
      oi  ,d ) v (){ ; D(f , o,r ) ( i =    l=0; i <22&& (o=I[ i++ ] + + l ,l=o+I[i] , ( e<o ||
    e>    l)) ; i ++) {}x=2 + x-i /22 ;}     void a (){if(H+2 > t){ U = ( b *)D(r ,ea ,lloc ) (
   U     ,2* ( t*=2) *D (siz , e , of)(b     ));} U[ H].x=x;U[H].y = y ; U [ H++]. z = e;p=p >y
  ?     y:p ; q=q<y?y:q ;v ();}D( v ,o,        id  )Q(_ O){(l=abs ( O ) ) ? D (fpr, i , ntf )(f
 ,     ""\33"" ""[%d%c"",l  ,V  +(O>0) ):0;          V   ^=2 ;}D(vo,i, d ) P ( _ p){;E [ o =0] = e=p
;     if( p >> 7){for(   ;    p >63>>o;    p>>=6){E[o++]=    128| ( 9 * 7 & p );}E[ o]= (g* 8>>o
&     g )| p; }for(;o    >-    1 ;D(f,pu,    tc)(E[o--]  ,f   ));} D ( c , h , ar) d[2 ]=""r"";D(i
     , n, t)r (char*u ){return   (f=D(fo,    pe    ,           n) ( u , d ))? 0:(perror(u),-1);
       } _ /* Q */D(m,   a,in)     (_ O,D(                     ch, a , r ) **Z ){f=stdin;if(--
       O&&  ( (  **++Z)                -45||                  01[ * Z ] ) &&r ( *Z)){goto X;}
                     D(f                                      ,o , r ) (*d |=( 5 );(e=D(f,get
                     ,c)                                      ( f ) ) - EOF ;h= h<0?e-91?e<48||
                    e>59                                     ?l= l * ~ -(e &2),e>64&&e<67?y+=l,0
                   :e<69                                     && (x= l + x)< 0?x=0:0:~(l=l*10+e-48
                 ):h:h ?(                                   e= l=l<< 6 |(e &63),!--h)  ?a(),h:h:
               192==( 32*                                  7& e)?l= e & 31,1:(e&g)== 224?l=e&15,
              2:  (e &248)                                == g?l=e & 7 ,3:e-27?e==10 ?y++,x=0:e-
            32   ?e ==9?x=(x           +8)&~             7:32< e? a() ,h:h:x++,h:~(l  =   0)){V
          +=(   V+ e)<<10;V^=                           V>>6   ; } fclose(f);f=D(std,  o,   ut
         );    if (U) {if(O<1){                        m(0    , U [H].x=H);for(h=  x=0   ,y    =
       p;h    <H ;v( )){for(;y<U[                    h].y    ; y ++,x=0){P(10);}D  (f ,    o    ,r
      )(     ;x <U[ h].x;x++){P(32)               ;}for     ( ; h<H&&+U  [++h].y   ==y ?    U     [
      h     ]. x== x:0;){}P(U[h-1  ].         z);}if       ( 0 <x)P(-~   9);}D(    el, s     ,     e
     ){    D( sr, a ,nd)(V);for(      x=H;--x             > 0 ;s()){V    =D(ra,     n , d     )     (
     )     ; y=V % -~x;}if ((--                         O) ? r(*++Z)    :O++){      D ( g      ,    o
     ,     to ) X ;};for( t=h=                         0, y =q+1;h<     H&&t<       O ; D      (   f
     ,     clos, e )(f))  {if(                       t&& r (*++Z)      ){;D(        g , o      ,  to
      )    X ;}if (!t){;  for(                      h=q -p+2;--h      ;P(10        )   );      }for
      (    V  = 65 ;h<H   *-~t                     /O;y=U[h++].      y){;Q         (   U[    h].  y
                - y );Q    (x-                    U [h].x);P(       U[h].          z     ); x    =U
                 [ h].x;    v()                  ; }Q(q-y);P         (10)          ;     x  =0;y
                  =q+1;t     ++;                   }}}O=0;X          :D(r              ,et
                     ,urn)      O                        ;            }/*
                         }#                                             */
","int main(int b,char**i){long long n=B,a=I^n,r=(a/b&a)>>4,y=atoi(*++i),_=(((a^n/b)*(y>>T)|y>>S)&r)|(a^r);printf(""%.8s\n"",(char*)&_);}
","#include <stdio.h> 

#define N(a)       ""%""#a""$hhn""
#define O(a,b)     ""%10$""#a""d""N(b)
#define U          ""%10$.*37$d""
#define G(a)       ""%""#a""$s""
#define H(a,b)     G(a)G(b)
#define T(a)       a a 
#define s(a)       T(a)T(a)
#define A(a)       s(a)T(a)a
#define n(a)       A(a)a
#define D(a)       n(a)A(a)
#define C(a)       D(a)a
#define R          C(C(N(12)G(12)))
#define o(a,b,c)   C(H(a,a))D(G(a))C(H(b,b)G(b))n(G(b))O(32,c)R
#define SS         O(78,55)R ""\n\033[2J\n%26$s"";
#define E(a,b,c,d) H(a,b)G(c)O(253,11)R G(11)O(255,11)R H(11,d)N(d)O(253,35)R
#define S(a,b)     O(254,11)H(a,b)N(68)R G(68)O(255,68)N(12)H(12,68)G(67)N(67)

char* fmt = O(10,39)N(40)N(41)N(42)N(43)N(66)N(69)N(24)O(22,65)O(5,70)O(8,44)N(
            45)N(46)N    (47)N(48)N(    49)N( 50)N(     51)N(52)N(53    )O( 28,
            54)O(5,        55) O(2,    56)O(3,57)O(      4,58 )O(13,    73)O(4,
            71 )N(   72)O   (20,59    )N(60)N(61)N(       62)N (63)N    (64)R R
            E(1,2,   3,13   )E(4,    5,6,13)E(7,8,9        ,13)E(1,4    ,7,13)E
            (2,5,8,        13)E(    3,6,9,13)E(1,5,         9,13)E(3    ,5,7,13
            )E(14,15,    16,23)    E(17,18,19,23)E(          20, 21,    22,23)E
            (14,17,20,23)E(15,    18,21,23)E(16,19,    22     ,23)E(    14, 18,
            22,23)E(16,18,20,    23)R U O(255 ,38)R    G (     38)O(    255,36)
            R H(13,23)O(255,    11)R H(11,36) O(254    ,36)     R G(    36 ) O(
            255,36)R S(1,14    )S(2,15)S(3, 16)S(4,    17 )S     (5,    18)S(6,
            19)S(7,20)S(8,    21)S(9    ,22)H(13,23    )H(36,     67    )N(11)R
            G(11)""""O(255,    25 )R        s(C(G(11)    ))n (G(          11) )G(
            11)N(54)R C(    ""aa"")   s(A(   G(25)))T    (G(25))N         (69)R o
            (14,1,26)o(    15, 2,   27)o   (16,3,28    )o( 17,4,        29)o(18
            ,5,30)o(19    ,6,31)o(        20,7,32)o    (21,8,33)o       (22 ,9,
            34)n(C(U)    )N( 68)R H(    36,13)G(23)    N(11)R C(D(      G(11)))
            D(G(11))G(68)N(68)R G(68)O(49,35)R H(13,23)G(67)N(11)R C(H(11,11)G(
            11))A(G(11))C(H(36,36)G(36))s(G(36))O(32,58)R C(D(G(36)))A(G(36))SS

#define arg d+6,d+8,d+10,d+12,d+14,d+16,d+18,d+20,d+22,0,d+46,d+52,d+48,d+24,d\
            +26,d+28,d+30,d+32,d+34,d+36,d+38,d+40,d+50,(scanf(d+126,d+4),d+(6\
            -2)+18*(1-d[2]%2)+d[4]*2),d,d+66,d+68,d+70, d+78,d+80,d+82,d+90,d+\
            92,d+94,d+97,d+54,d[2],d+2,d+71,d+77,d+83,d+89,d+95,d+72,d+73,d+74\
            ,d+75,d+76,d+84,d+85,d+86,d+87,d+88,d+100,d+101,d+96,d+102,d+99,d+\
            67,d+69,d+79,d+81,d+91,d+93,d+98,d+103,d+58,d+60,d+98,d+126,d+127,\
            d+128,d+129

char d[538] = {1,0,10,0,10};

int main() {
    while(*d) printf(fmt, arg);
}
","                               #include/**/<time.h>
                               #include <ncurses.h>
                               # include <stdlib.h>
             /**               */#define O()for(y-=               !!\
           y;y<H&&           /*...Semi-Automatic.*/y<           p/W+2;\
         y++)for(x=p%   W,x-=!!/*..MineSweeper...*/x;x<W&&   x<p%W+2;x++)
       #define _(x,y)COLOR_##x,COLOR_##y /*  click / (R)estart / (Q)uit  */
     #define Y(n)attrset(COLOR_PAIR(n)),mvprintw(/* IOCCC2019 or IOCCC2020 */
   typedef int I;I*M,W,H,S,C,E,X,T,c,p,q,i,j,k;char G[]="" x"",U[256];I F(I p){ I
      r=0,x,y=p/W,q;O()q=y*W+x,r+=M[q]^=p-q?(M[q]&16)<<8:0;return r;}I K(I p
         ,I f,I g){ I x=(g+     f/256)%16-(f+g/256)%16,y=p/W,c=0,n=g/4096
          ,m=x==n?0:x==g           /16%16-f/16%16-n?256:-1; if(m+1)O()if
         ((4368&M[n=y*W             +x])==4112){ M[c=1,n]=(M[n]&~16)|m; }
        return c;}void              D(){I p,k,o=0,n=C,m=0,q=0;if(LINES-1<H
       ||COLS/2<W)clear             (),Y(4)LINES/2,COLS/2-16,""Make the ter\
minal bigger!"");else{for           (p=0;p<S;o+=k==3,Y(k)p/W+1,p%W*2,G),p++)G[1]=""""
""_*!..12345678""[k=E?256&M[p     ]?n--,2:E-2||M[p]%2<1?M[p]&16?q=p,m++,3:4+F(p)%16:
1:3];k=T+time(0);T=o||T>=0||E-1?T:k;k=T<0?k:T;Y(7)0,0,""%03d%*s%03d"",n>999?999:n,W*
2-6,"""",k>999?999:k);Y(9)0,W-1,E>1?""X-("":E-1||o?"":-)"":""8-)"");M[q]|=256*(n==m&&n); }
refresh();}short B[]={_(RED,BLACK),_(WHITE,BLUE),_(GREEN,RED),_(MAGENTA,YELLOW),_(
CYAN,RED)};I main(I A,char**V){MEVENT e;FILE*f;srand(time(0));initscr();for(start\
_color();X<12;X++){init_pair(X+1,B[X&&X<10?X-1:2],B[X?X<3?2:1:0]);}noecho();cbreak
();timeout(9);curs_set(0);keypad(stdscr,TRUE);for(mousemask(BUTTON1_CLICKED|BUTTO\
N1_RELEASED,0);;){S=A<2?f=0,W=COLS/2,H=LINES-1,C=W*H/5,0:fscanf(f=fopen(V[A-1],""r""
       ),""%d %d %d"",&W,&H,&C)>3; ;S+=W*H;M=realloc(M,S*sizeof(I)*2);for(i=0
        ;i<S;i++)!f?M[i]=i,i&&(k=M[j=rand()%i],M[j]=M[i],M[i]=k):fscanf(f,
         ""%d"",M+i);if(f)fclose(f);T=E=X=0;for(clear();D(),c=getch(),c-'r'
          &&(c-KEY_RESIZE||E);){ if(c=='q'){ return(endwin(),0); }if(c==
        KEY_MOUSE&&getmouse(&e)==OK&&e.x/2<W&&e.y<=H){if(!e.y&&(W-2<e.x&&
      e.x<W+2)){break;}p=e.x/2+e.y*W-W;if(p>=0){if(!E){for(i=0;i<S;i++)M[S+M
   [i]]=i,M[i]=16+(M[i]<C);C-=M[p]&1;M[p]=16;E=1;T=-time(0);}if(E<2)M[p]&=(M[p]
     &257)==1?T+=time(0),E=2,273:257;}}for(p=0;p<S&&E==1;M[p++]&=273){}for(i=
       (X+S-1)%S;E==1&&i!=X;X=(X+1)%S){if(!(M[p=M[X+S]]&272)){if(K(p,c=F(p)
         ,0)){goto N;}   for(k=p/W-2,k=k<0?0:k;k<p/W+3&&k   <H;k++)for(j=
           p%W-2,j          =j<0?0:j;j<W&&j<p%W+3;)if           (!(M[q=
             k*W               +j++]&272)){ if(K(p,               c,F
                               (q))){ goto N; }F(q)
                               ; }F(p); }}N:; } } }
                               /*(c)Yusukse Endoh*/
","                               #include/**/<time.h>
                               #include <ncurses.h>
                               # include <stdlib.h>
             /**               */#define O()for(y-=               !!\
           y;y<H&&           /*semi-automatic----*/y<           p/W+2;\
         y++)for(x=p%   W,x-=!!/*-----minesweeper*/x;x<W&&   x<p%W+2;x++)
       #define _(x)COLOR_##x/*IOCCC2019IOCCC2019IOCCC2019IOCCC2019IOCCC20*/
     #define Y(n)attrset(COLOR_PAIR(n)),mvprintw/*IOCCC2019IOCCC2019IOCCC20*/
   int*M,W,H,S,C,E,X,T,c,p,q,i,j,k;char G[]="" x"",U[256];int F(int p){int r=0,x,
      y=p/W,q;O()q=y*W+x,r+=M[q]^=p-q?(M[q]&16)<<8:0;return r;}int K( int p,
         int f,int g){int        x=(g+f/256)%16-(f+g/256)%16,y=p/W,c=0,n=
          g/4096,m=x==n             ?0:x==g/16%16-f/16%16-n?256:-1;if(m+
         1)O()if((M[n=               y*W+x]&4368)==4112)M[n]=(M[n]&~16)|m
        ,c++;return c;               }void D(){int p,k,o=0,n=C;if(LINES-1<
       H||COLS/2<W)/*|               */clear(),Y(4)(LINES/2,COLS/2-16,""Mak\
e the terminal window ""             ""bigger!"");else{for(p=0;p<S;o+=k==3,Y(k)(p/W+1
,p%W*2,G),p++)G[1]=""_*!..""       ""12345678""[k=E?M[p]&256?n--,2:E-2||M[p]%2<1?M[p]&
16?3:4+F(p)%16:1:3];k=T+time(0);T=o||T>=0||E-1?T:k;k=T<0?k:T;Y(7)(0,0,""%03d%*s%03\
d"",n>999?999:n,W*2-6,"""",k>999?999:k);Y(9)(0,W-1,E>1?""X-("":E-1||o?"":-)"":""[-)"");}re\
fresh();}int main(int A,char**V){short B[]={_(RED),_(BLACK),_(WHITE),_(BLUE),_(GR\
EEN),_(RED),_(MAGENTA),_(YELLOW),_(CYAN)};MEVENT e;FILE*f;srand(time(0));initscr()
;for(start_color();X<12;X++)init_pair(X+1,B[X&&X<10?X-1:2],B[X?X<3?2:1:0]);noecho(
);cbreak();timeout(9);curs_set(0);keypad(stdscr,TRUE);for(mousemask(BUTTON1_CLICK\
ED|BUTTON1_RELEASED,0);;){if(A-->1){f=fopen(V[A],""r"");fscanf(f,""%d %d %d"",&W,&H,&C
       );}else{f=0;W=COLS/2;H=LINES-1;C=W*H/5;}S=W*H;M=realloc(M,S*2*sizeof
        (int));for(i=0;i<S;i++)!f?M[i]=i:fscanf(f,""%d"",M+i);for(i=0;!f&&i<
         S;i++)k=M[j=i+rand()%(S-i)],M[j]=M[i],M[i]=k;if(f)fclose(f);T=E=
          X=0;for(clear();D(),c=getch(),c-'r'&&(c-KEY_RESIZE||E);){if (c
         =='q')return(endwin(),0);if(c==KEY_MOUSE&&getmouse(&e)==OK&&e.x/
      2<W&&e.y<=H){if(!e.y&&(W-2<e.x&&e.x<W+2))break;p=e.x/2+e.y*W-W;if(p>=0
   ){if(!E){for(i=0;i<S;i++)M[S+M[i]]=i,M[i]=16+(M[i]<C);C-=M[p]&1;M[p]=16;E=1;
     T=-time(0);}if(E<2)M[p]&=(M[p]&257)==1?T+=time(0),E=2,273:257;}}for(p=0;
       p<S&&E==1;)M[p++]&=273;for(i=(X+S-1)%S;E==1&&i!=X;X=(X+1)%S){if(!(M[
         p=M[X+S]]&272   )){if(K(p,c=F(p),0))goto N;for(k   =p/W-2,k=k<0?
           0:k;k<H          &&k<p/W+3;k++)for(j=p%W-2           ,j=j<0?
             0:j               ;j<W&&j<p%W+3;j++)if               (!(
                               M[q=j+k*W]&272)){if(
                               K(p,c,F(q)))goto N;F
                               (q);}F(p);}}N:;}}}
","              /* A long time ago in a galaxy far, far away.... */

int*d,D[9999],N=20,L=4,n,m,k,a[3],i;char*p,*q,S[2000]=""L@X-SGD-HNBBB-AD-VHSG-\
-XNT\x1b[2J\x1b[H"",*s=S,*G=""r2zZX!.+@KBK^yh.!:%Bud!.+Jyh.!6.BHBhp!6.BHBh!:%Bu\
v{VT!.hBJ6p!042ljn!284b}`!.hR6Dp!.hp!h.T6p!h.p6!2/LilqP72!h.+@QB!~}lqP72/Lil!\
h.+@QBFp!:)0?F]nwf!,82v!.sv{6!.l6!,j<n8!.xN6t!&NvN*!.6hp"";/*Stay_on_target.**/
#include/**/<complex.h>/**//*Oh,my_dear_friend.How_I've_missed_you.--C-3PO***/
typedef/**/complex/**/double(c);c(X)[3],P,O;c/**/B(double t){double s=1-t,u;P=
s*s*X[1]            +2        *s*t*        *X+t        *t*X       [2]+O;u=I*P;
return+48*((    s=P)+   48*I   )/(   1<u?   u:   1);}   /*   1977  IOCCC2020*/
#include/**    Do.Or   do_not   .   There_is_   no_try...   --Yoda**/<stdio.h>
void/**/b(    double   t,/***   *   **/double   u){double   s=P=B(t)-B(u);(s=P
*(2*s-P))    <1?m=P=B   ((t+   u)/   2),k   =-   I*P,   m>   -41&&m<39&&9<k&&k
<48?             m+=k/        2*80+        73,S        [m]=               S[m]
-73?k%2?S[m]-94?95:73:S[m]-95?94:73:73:1:(b(t,(t+u)/2),b((t+u)/2,u),0);}/*<oo>
_No.             _I_am_            IOCCC           1977                   ***/
#include/*****    your   father..   --DarthVader   **/   <time.h>/****   ****/
int(main)(int    (x),   char**V){;   clock_t(c)=   /*   */clock();;;   for(d=D
;m<26;m++,s    ++)*s>   63?*d++=m%   7*          16-7   *8,*d++=m/   7*25,*d++
=*s-64:0;;    if(V[1])   {;;;FILE   *F   =fopen(V[+1],   ""r"");for   (d=D,L=N=m
=0;(x=/**             *            ***              **/            fgetc(F))>0
||fclose(F);)if(x>13?64<x&&x<91?*d++=m*16,*d++=L*25,*d++=x%26:0,m++,0:1)for(++
L;d-D>N*3||(m=0);N++)D[N*3]-=m*8;}for(;i<200+L*25;i++){for(n=0,p=S+33;n<1920;*
p++=n++%80>78?10:32){}for(*p=x=0,d=D;x<N;x++,d+=3){O=(d[1]-i-40)*I+*d;n=d[2];p
=G;for(;n--;)for(;*p++>33;);*a=a[1]=*p++;for(;*p>33;p++)if(*p%2?*a=*p,0:1){a[2
]=*p;for(m=0;m<3;m++){k=a[m]/2-18;q=""/&&&##%%##.+),A$$$$'&&'&&((%-((#'/#%%#&#\
&&#D&"";for(n=2;k--;)n+=*q++-34;X[m]=n%13+n/13*I;}b(0,1);*a=a[1]=*p;}}for(puts(
s),s=S+30;(clock()-c)*10<i*CLOCKS_PER_SEC;);}return 0;}/*Nevertellmetheodds*/
","#define/**/Q(x,y)r;char*q/*                         */=y#x"",""#y"")"",*p,x=*p%67;}
  /*-IOCCC2020-*/#include/*                         */<stdio.h>/*-BBQlock--*/
    int(y),x,i,k,Q(s[9<<9/*           12            */];float(f)[3];void(Z)
      (){*f=r<0?r:-r;f[1]/*      11         1       */=42.5;f[2]=22.5;for
       (k=0;++k<39;*f/=(k/*   10               2    */%2?k:-k)*6875.5/i)
        y=f[1+k%2]+=*f;k=/*                         */f[2];p=s+k/2*86+y
         ;}int(main)(){p=/*  9         o-------> 3  */s;for(;i<1978;*q
          >32?k=i++/86-11/*           /             */,y=(750>r*r+k*k
          *4)*4+y/2,*p++=/*    8     L         4    */r<44?y?""+0X+0X""
           ""+!""[y]-1:*q++/*       7         5       */:10:*q++)r=-41
           +i%86;r=20;for/*            6            */(x=13;(i=3600*
           --x);*p++=""XR""/*                         */""MOQSUWAY""[x%+
           10]-9,*p+=x/10/*                         */*41)Z();sscanf
           (__TIME__,""%d""/*  \       /    -------+  */"":%d:%d"",&k,&x
          ,&i);r=10;for(i/*   \     /     ------ |  */+=(k*60+x)*60;r
          +18;*p=k%2?*p%2/*    \   /      ------ |  */?59:44:*p>39?59
         :39,i=r--?i:i%(+/*     \ /       ------ |  */3600)*12)Z();for
        (p=s;*p;putchar(k/*      X        ------ |  */%2&&k<14?q=""End"",
       printf(""%c%c"",224|/*   __/ \__         |  |  */(21554>>k&3),""gCS""
      ""gGMX""[k/2]+65),""E""/*  /  \ /  \        |  |  */""Gh_BrG""[k/2]+64:*p
    ),++p)k,""#define/**/""/*  \__/ \__/        +--+  */""Q(x,y)r;cha""""r*q=y#""
  ""x\"",\""#y\"")\"",*p,x=*p""/*                         */""%67;}/*-IOCCC2020-*/#""
""include<stdio.h>/*-BBQl""/*                         */""ock--*/int(y),x,i,k,Q("")
","#define/**/Q(x,y)char*/*                               */q=y#x"",""#y"")"",*p,s[x;}
  /*IOCCC'20*/#include/*                               */<stdio.h>/*-Qlock-*/
    int(y),x,i,k,r;Q(9/*              12               */<<9];float(o)[03];
      void(P)(){*o=r<0/*         11         1          */?r:-r;o[1]=39.5;
       o[2]=22.5;for(k/*      10               2       */=0;++k<39;*o*=i
        /6875.5/(k%2?k/*                               */:-k))y=o[1+k%2
         ]+=*o;k=o[2];/*     9         o-------> 3     */p=s+y+k/2*80;
          }int(main)()/*              /                */{for(p=s;+i<
          1839;*q>32?k/*       8     L         4       */=i++/80-11,y
           =(750>r*r+k/*          7         5          */*k*4)*4+y/2
           ,*p++=r<41?/*               6               */y?""0X+0X+!""
           [y-1]-1:+*q/*                               */++:10:*q++)
           r=i%80-38;;/*                               */;for(x=13,r
           =20;i=3600*/*     \       /    -------+     */--x,i;*p++=
          ""OISEA2dC8e""/*      \     /     ------ |     */[x%10],*p+=x
          /10*41)P();r/*       \   /      ------ |     */=10;;sscanf(
         __TIME__,""%d""/*        \ /       ------ |     */"":%d:%d"",&k,&
        x,&i);for(i+=(/*         X        ------ |     */k*60+x)*60;18+
       r;*p=k%2?*p%2?+/*      __/ \__         |  |     */59:44:*p>39?59:
      39,i=!r--?i%3600/*     /  \ /  \        |  |     */*12:i)P();puts(s
    ),""#define/**/Q(x""/*     \__/ \__/        +--+     */"",y)char*q=y#x\"",""
  ""\""#y\"")\"",*p,s[x;}""/*                               */""/*IOCCC'20*/#inclu""
""de<stdio.h>/*-Qlock-""/*                               */""*/int(y),x,i,k,r;Q("")
","						 %:include<curses.h>
						 %:include<unistd.h>
					          %:include<time.h>


						 %:include<stdlib.h>
					   %:define d =strtoul(z,NULL,0));
					       %:define m(n)COLOR_%:%:n
					          %:define v stdscr
						 %:define q mvaddch(


					           %:define Z(x)%:x
					  %:define F(x)z=getenv(Z(x)); z&&(
			%:define J Z(X:%d/%d Y:%d/%d S:%zu/%zu B:%zu\n),Y,y<:-2:>,X,*y,A,g,c);


    typedef size_t  a;  typedef  unsigned	long k; a g=997,	c,A=5,I,N=5,G=5; k	p <: 5 :> = <% 1   %>,W=
    300; int  Y,X,*j=(	int<:8 :>)<%  231	%>,*U,*V,*e,*n,Q	,P,x,*y,l = 4, *D;	void b(a h)  <% c += h ;
    mvprintw(0,0, J %>	int E(const char*	L)<%static int h	; ! h && endwin();	h=l; L&&puts(L);  return
    1; %>void C (int L	,int h)<%attroff(	m ( PAIR(L))); h	&&attron(m(PAIR(L)	)); %>int R(int h,int L)
    <% return (rand()%	(L-h+1))  + h; %>	void S (a o)  <%	static const char*	s=Z (; +<>^v); q n<:0:>,
    e<:0:>,' '); A =f(	A+o,g); if (A>=g)	<%E(Z(YOU WIN!))	; Q=l; return; %>C	(3, 1); for(I=0; A&&I<A-
    1; ++I)<%I&& q n<:	I:>,e<:I:>,'o') ;	e<:I:> = e<:I +1	:>;  n<:I:>=n<:I+1	:>; %>A>1&&q n<:I:>,e<:I

    :>, 'o'); e<:I:> =  Y; n <: I :> = X;	while(++I<g) e<:	I:>=n<:I:> = 0; C(	2,1); q X,Y,s<:*D+2&(1<<
    3)- !Q:>); %> void  B(a o)<%if  (o)<%	S(N); b(1); %>if	(Q) return; p<:1:>	= 0; !o &&q*U,*V,' '); x
    :y<:3:>=R(1,y <:-2	:>-1); y<:2:>= R(	2,*y-1); for (I=	0; I<A; ++I)if (*V	== e<:I:>&& *U == n<:I:>
    ) goto x;  %>  int	main(void)<%char*	z; y=j+3; void(*	H<::>) (a)=<%b,S,B	%>; srand((unsigned)time
    ( NULL ) );  if (!	initscr()) return	1; getmaxyx(v,*y	,y<:-2:> ); -- *y;	-- y<:-2:>; if(y<:-2:><9
    || *y < 9)  return	E ( Z ( term  too	small) ) ;  F  (	MAXSIZE)g d g =f((	a)((*y-2)*(y<:-2:>-2)),g
    );  F(GROW)N d  F(	SIZE) A d F(WAIT)	y<: - 3 :>= (int	)strtol(z,NULL,0))	; F(EVADE)W d U=y+ 2; F(
    WALLS) *  p  d  F(	CANNIBAL) p<:4:>d	F(SHED)p<:3:>d F	(SHEDS) G d  e   =	calloc(g+1,sizeof*e); n=
    calloc(g+1,sizeof*	n);  if  (!e||!n)	return  E ( Z  (	memory error)); V=	U+1; Y= y<:-2:>/2; X=*y/
    2; D=1+V; attron (	A_BOLD); curs_set	( 0 ) ; nonl ();	intrflush(v, 0)  ;	keypad(v,1);  noecho ();
    cbreak   (  )    ;	start_color  () ;	init_pair(1,WALL	, WB);	init_pair(	2,HEAD,HB); init_pair(3,

					   BODY,BS); S(0); B(0) ; x: if(Q) 
						       #undef d

    goto y; x  =  *y ;	getmaxyx(v,1<:y:>	,y<:-1:>); C(1,1	); mvhline(1,0,'#'	,y<:-2:>); mvvline (1,0,
    '#',*y); mvhline(*	y,0, '#', y<:-2:>	); mvvline(1,y<:	-2:>,'#',*y); C(1,	0); q*U, *V,'*'); (*H)(0
    ) ;  refresh  () ;	timeout (y<:-3:>)	; switch (getch(	))<%case KEY_LEFT:	V<:1:>=l-3; break ; case
    KEY_RIGHT:V<:l/l:>	=l/2; break; case	KEY_UP:V<:l-3:>=	l-1; break;   case	KEY_DOWN:V <:l / 4:> = l
    ; break; case 'q':	case 'Q' : Q = l;	case' ':(!P && (	P = 1) ) || (P=0);	default:x=0; %> if(x)P =
    !*y;if(Q||P)goto x  ; if(!Q&& !1<:V:>	)goto x; switch(	1<:V:>)<%case 1:--	Y; break; case 2 : ++ Y;
    break; case 3:--X;	break; case 4: ++	X; break; %>if(Y	<1 || Y >= y<:-2:>	|| X < 2|| X >= *y ||y<:
    -2:>>=y<:-1:> ||*y	>=1<:y:>)<%if (*p	&&!(*y>=1<:y:>||	y<:-2:>>=y<:-1:>))	<%if(Y<1||Y >=y	<:-2:>)Y
    =Y<1?y<:-2:>-1:1 ;	if(X<2||X>=*y)X=X	<2? * y-1:2;  %>	else<% E(Z(OUCH!))	; goto y; %>%>for (I =0;
    !4<:p:> && I<A; ++	I)if (Y == e<:I:>	&& X==n<:I:>)<%E	(Z(OW!)); goto  y;	%>if (Y	== *V && X == *U
    ) B(1); else <% if	(W&&!(++1<:p:>  %	W))H<:2:>(0); if	(3<:p:>)<% if (! (	++p<:2:>%3<:p:>)) <%H<:1
    :>	(G);	2   <:	p :>=0;	%>   else	S (0); %>else  S	(0);  %>  goto  x;	y : E (NULL );   printf(
	    J		    free(e);		    free(n);		    return 0;		           %>
"," %:	include					     <curses.h>
 %:	include					     <unistd.h>
 %:	include					       <time.h>
 %:	include					     <stdlib.h>
							       
 %:	define				 d =strtoul(z,NULL,0));
 %:	define					m(n)COLOR_%:%:n
 %:	define					       v stdscr
 %:	define					     q mvaddch(
 %:	define					       Z(x) %:x
 %:	define			    F(x) z = getenv(Z(x)); z&&(
 %:     define J Z(X:%d/%d Y:%d/%d S:%zu/%zu B:%zu\n),Y, y<:-2\
						:>,X,*y,A,g,c);
 %:	define f(a,b)			      ((a)<(b)?(a):(b))
						               
 typedef size_t a; typedef unsigned long k; a g=997,c,A=5,I,N=5
 ,G=5; k p<:5:>={ 1} , W =300; int l,Y,X,*j=(int<:8:>){ 231} ,*
 U,*V,*e,*n,Q,P,x,* y, *D; void b(a h){ c +=h; mvprintw(0,0,J }
 int E(const char * L){ static int h; !h && endwin(); h=*y; L&&
 puts(L) ; return 1; }  void C(int L, int h) { attroff(m(PAIR(L
 ))); h  &&  attron(m(PAIR(L))); } int R(int h, int L) { return
 (rand()%(L-h+1)) + h ;}  void S(a o) { static const char *s =Z
 ( ; +<>^v); q n <:0:>,e<: 0:>,' '); A=f(A+o,g); if(A>=g){ E(Z(
 YOU WIN! ) ) ; Q = l;  return ; } C(3,1); for (I=0; A &&I<A-(A
 -A||A); ++I){ I&&q n<:I:>,e<: I:>,'o') ; e<:I:>= e<:I+1:>; n<:
 I:>=n<: I +1:>; } A>1&&q n<:I:>,e<:I:>,'o'); e<:I:>=Y; n<:I:>=
			      X; while(++I<g)e<:I:>=n<:I:>=0; C
			      (2,1); q X,Y,s<:*D+2&(1<<3)-!Q:>)
			      ; } void B(a o){ if(o){ S(N); b(1
			      ); } if(Q)return; p<:1:>=0; !o&&q
			      *U,*V,' '); x:y<:3:>=R(1,y<:-2:>-
			      1); y<:2:>=R(2,*y-1); for(I=0; I<
			      A; ++ I)if (* V==e<:I:>&&*U== n<:
			      I:>) goto x; } int main(void) { l
			      =++(int) { 3 } ; char *z; y = j+3
			      ;  void(*H<::>) (a) = { b, S, B};
			      srand((unsigned)time(NULL)); if(!
 initscr())return 1; getmaxyx(v,*y,y<:-2:>);--*y; --y<:-2:>; if
 (y<:-2:><9||*y<9)return E(Z(screen too small)); F(MAXSIZE) g d
 g=f((a)((*y-2)*(y<:-2:>-2)),g); F(GROW)N d F(SIZE)A d F(WAIT)y
 <:-3:>=(int)strtol(z,NULL,0)); F(EVADE)W d U=y+2;F(WALLS) *p d
 F(CANNIBAL)p<:4:>d F(SHED)p<:3:>d F(SHEDS )G d e=calloc(g + 1,
 sizeof*e); n=calloc(g+1,sizeof*n); if(!e||!n)return E(Z(memory
 error)); V=U+1; Y=y<:-2:>/2; X=*y/2; D=1 + V; attron(A_BOLD) ;
 curs_set(0); nonl(); intrflush(v, 0); keypad (v, 1); noecho();
 cbreak (); start_color (); init_pair(1,WALL, WB); init_pair(2,
 HEAD,HB); init_pair(3,BODY,BS); S(0); B(0); x:if(Q)goto y;x=1;
 getmaxyx(v,1<:y:>,y<:-1:>); C(1,1); mvhline(1,0,'#',y<:-2:>) ;
 mvvline(1,0,'#',*y); mvhline(*			               
 y,0,'#',y<:-2:>);mvvline(1,y<:				       
 -2:>,'#', *y); C(1,0); q*U,*V,				       
 '*' ) ; (*H) (0) ; refresh() ;				       
 timeout(y<:-3:>); switch(getch				       
 ()){ case KEY_LEFT:V<:1:>=l-3;			               
 break; case KEY_RIGHT : V<:l/l				       
 :>=l/2; break; case KEY_UP:V<:			               
 l-3:>=l-1; break;case KEY_DOWN				       
 : V <:l/4:>=l; break; case 'q'				       
 :case'Q':Q=l; case' ':(!P&&(P=				       
 1))||(P=0); default:x=0; } if(				       
 x)P=0; if(Q||P) goto x ; if(!Q&&!1<:V:>) goto x; switch(1<:V:>
 ){ case 1: --Y; break; case 2: ++Y; break; case 3: -- X; break
 ; case 4: ++X; break; } if (Y<1||Y>=y<:-2:>||X<2||X>=*y||y<:-2
 :>>=y<: -1 :>|| *y>=1<:y:>){ if(*p&&!(*y>=1<:y:>||y<:-2:>>=y<:
 -1:>)){ if(Y <1||Y>=y<:-2:>)Y=Y<1?y<:-2:>-1:1; if(X<2||X>=*y)X
 =X<2?*y- 1:2 ; } else{ E(Z(OUCH!)); goto y; } } for(I=0; !4<:p
 :>&&I <A; ++I)if(Y == e<:I:>&&X==n<:I:>){ E(Z(OW!)); goto y; }
 if(Y== *V &&X==*U)B(1);  else{ if(W&& !(++1<:p:>%W)   )H<:2:>(
 0) ; if( 3 <:p:>){ if(!( ++p<:2:>% 3<:p:>)){ H <:1:>(G); 2 <:p
 :> = 0 ; } else S (0);}  else S ( 0); } goto x; y:E(  NULL ) ;
 printf   (J     free   (  e  ); free      (n) ;   return  0 ;}
"," %:	include					     <curses.h>
 %:	include					     <unistd.h>
 %:	include					       <time.h>
 %:	include					     <stdlib.h>
							       
 %:	define				 d =strtoul(z,NULL,0));
 %:	define					m(n)COLOR_%:%:n
 %:	define					       v stdscr
 %:	define					     q mvaddch(
 %:	define					       Z(x) %:x
 %:	define			    F(x) z = getenv(Z(x)); z&&(
 %:     define J Z(X:%d/%d Y:%d/%d S:%zu/%zu B:%zu\n),Y, y<:-2\
						  :>,X,*y,A,g,c
 %:	define f(a,b)			      ((a)<(b)?(a):(b))
						               
 typedef size_t a; typedef unsigned long k; a g=997,c,A=5,I,N=5
 ,G=5; k p<:5:>={ 1} , W =300; int l,Y,X,*j=(int<:8:>){ 231} ,*
 U,*V,*e,*n,Q,P,x,* y, *D; void b(a h){ c+=h; mvprintw(0,0,J);}
 int E(const char * L){ static int h; !h && endwin(); h=*y; L&&
 puts(L) ; return 1; }  void C(int L, int h) { attroff(m(PAIR(L
 ))); h  &&  attron(m(PAIR(L))); } int R(int h, int L) { return
 (rand()%(L-h+1)) + h ; } void S(a o) { static const char *s =Z
 ( ; +<>^v); q n <:0:>,e<: 0:>,' '); A=f(A+o,g); if(A>=g){ E(Z(
 YOU WIN! ) ) ; Q = l;  return ; } C(3,1); for (I=0; A &&I<A-(A
 -A||A); ++I){ I&&q n<:I:>,e<: I:>,'o') ; e<:I:>= e<:I+1:>; n<:
 I:>=n<: I +1:>; } A>1&&q n<:I:>,e<:I:>,'o'); e<:I:>=Y; n<:I:>=
			      X; while(++I<g)e<:I:>=n<:I:>=0; C
			      (2,1); q X,Y,s<:*D+2&(1<<3)-!Q:>)
			      ; } void B(a o){ if(o){ S(N); b(1
			      ); } if(Q)return; p<:1:>=0; !o&&q
			      *U,*V,' '); x:y<:3:>=R(1,y<:-2:>-
			      1); y<:2:>=R(2,*y-1); for(I=0; I<
			      A; ++ I)if (* V==e<:I:>&&*U== n<:
			      I:>) goto x; } int main(void) { l
			      =++(int) { 3 } ; char *z; y = j+3
			      ;  void(*H<::>) (a) = { b, S, B};
			      srand((unsigned)time(NULL)); if(!
 initscr())return 1; getmaxyx(v,*y,y<:-2:>);--*y; --y<:-2:>; if
 (y<:-2:><9||*y<9)return E(Z(screen too small)); F(MAXSIZE)g  d
 g=f((a)((*y-2)*(y<:-2:>-2)),g); F(GROW)N d F(SIZE)A d F(WAIT)y
 <:-3:>=(int)strtol(z,NULL,0)); F(EVADE)W d U=y+2;F(WALLS) *p d
 F(CANNIBAL)p<:4:>d F(SHED)p<:3:>d F(SHEDS )G d e=calloc(g + 1,
 sizeof*e); n=calloc(g+1,sizeof*n); if(!e||!n)return E(Z(memory
 error)); V=U+1; Y=y<:-2:>/2; X=*y/2; D=1 + V; attron(A_BOLD) ;
 curs_set(0); nonl(); intrflush(v, 0); keypad (v, 1); noecho();
 cbreak (); start_color (); init_pair(1,WALL, WB); init_pair(2,
 HEAD,HB); init_pair(3,BODY,BS); S(0); B(0); x:if(Q)goto y;x=1;
 getmaxyx(v,1<:y:>,y<:-1:>); C(1,1); mvhline(1,0,'#',y<:-2:>) ;
 mvvline(1,0,'#',*y); mvhline(*				       
 y,0,'#',y<:-2:>);mvvline(1,y<:				       
 -2:>,'#', *y); C(1,0); q*U,*V,	                               
 '*' ) ; (*H) (0) ; refresh() ;				       
 timeout(y<:-3:>); switch(getch				       
 ()){ case KEY_LEFT:V<:1:>=l-3;				       
 break; case KEY_RIGHT : V<:l/l				       
 :>=l/2; break; case KEY_UP:V<:				       
 l-3:>=l-1; break;case KEY_DOWN				       
 : V <:l/4:>=l; break; case 'q'				       
 :case'Q':Q=l; case' ':(!P&&(P=				       
 1))||(P=0); default:x=0; } if(				       
 x)P=0; if(Q||P) goto x ; if(!Q&&!1<:V:>) goto x; switch(1<:V:>
 ){ case 1: --Y; break; case 2: ++Y; break; case 3: -- X; break
 ; case 4: ++X; break; } if (Y<1||Y>=y<:-2:>||X<2||X>=*y||y<:-2
 :>>=y<: -1 :>|| *y>=1<:y:>){ if(*p&&!(*y>=1<:y:>||y<:-2:>>=y<:
 -1:>)){ if(Y <1||Y>=y<:-2:>)Y=Y<1?y<:-2:>-1:1; if(X<2||X>=*y)X
 =X<2?*y- 1:2 ; } else{ E(Z(OUCH!)); goto y; } } for(I=0; !4<:p
 :>&&I <A; ++I)if(Y == e<:I:>&&X==n<:I:>){ E(Z(OW!)); goto y; }
 if(Y== *V &&X==*U)B(1);  else{ if(W&& !(++1<:p:>%W)   )H<:2:>(
 0) ; if( 3 <:p:>){ if(!( ++p<:2:>% 3<:p:>)){ H <:1:>(G); 2 <:p
 :> = 0 ; } else S (0); } else S ( 0); } goto x; y:E(  NULL ) ;
 printf   (J);   free   (  e  ); free      (n) ;   return  0 ;}
","					    #define d =strtoul(z,NULL,0));
					       #define m(n) COLOR_%:%:n
					           #define v stdscr

					          #define q mvaddch(
					           #define Z(x) %:x
					   #define F(x)z=getenv(Z(x)); z&&(
		       #define J Z(X:%d/%d Y:%d/%d S:%zu/%zu B:%zu\n),Y,y[-2],X, *y, A, g, c );
					          #include  <curses.h>

					          #include  <unistd.h>
					          #include    <time.h>
					          #include  <stdlib.h>

    typedef size_t  a;  typedef  unsigned	long k; static a	g= 997,c,A=5,I,N=5	,G=5; static k  p <:5:>=
    <% 1   %>,W = 300;  static int Y,X,*j	=(int<:8])<% 231	%>,*U, *V,*e,*n, Q	,P,x,*y,l=4, * D; static
    void b(a h) { c+=h	; mvprintw(0, 0,J	} static int  E(	const char  * L)<%	static int h; !h&&endwin
    (); h=l; L&&puts(L	); return 1;    }	static void  C (	int L, int    h) {	attroff(m(PAIR(L))); h&&
    attron(m(PAIR(L)))	; } static int	R	(int h, int L) {	return (rand  () %	(L - h + 1))+h; } static
    void S(a o){static  const char*s  =Z(	; +<>^v); q n[0]	,e[0],' '); A = f(	A+o,g	); if (A >= g) {
    E(Z(YOU WIN!));  Q  = l; return; } C(	3, 1); for (I  =        0; A && I < A -  1	; ++I) { I && q n[I], e[
    I], 'o'); e[I] = e	[I + 1]; n[I] =n[	I+1]; } A > 1 &&	q n[I],e[I], 'o');	e[I] = Y; n[I]= X; while
    (++I < g) e[I] = n	[I] = 0; C(2, 1);	q X,Y,s[*D+2& (1	<<3)-!Q]); }static	void B(a o){ if (o) { S(
    N); b(1); } if (Q)	return; p[1] = 0;	!o && q*U,*V,' '	); x: y[3] = R(1,y	[-2]-1); y[2] = R(2,*y-1
    ); for (I = 0; I <	A; ++I) if (*V ==	e[I] && *U == n[	I]) goto x; }  int	main(void) { char *z; y=


    j+3; void (*H[])(a	)={b,S,B} ; srand	((unsigned)time(	NULL));if(!initscr	( ) )  return  puts (Z (
    curses error));     erase();getmaxyx(	v,*y,y[-2]);--*y	;--y[-2];if(y[-2]<	9||*y<9 )  return   E (Z
    (screen too small)	); F(MAXSIZE)g  d	g = f((a)((*y-2)	*(y[-2]-2)),g); F(	GROW)N d  F (SIZE) A d F
    (WAIT)y [-3]=(int)  strtol(z,NULL,0))	; F(EVADE)W d U=	y+2; F(WALLS) *p d	F(CANNIBAL)p[4] d F(SHED
    ) p[3]  d F	(SHEDS	)G d e = calloc	(	g+1,sizeof * e);	n = calloc (g +  1	,sizeof *n); if (!e || !
    n)  return  E  ( Z  (memory error)) ;	V=U+1; Y = y[-2]	/ 2; X = *y / 2; D	 = 1 + V; attron(A_BOLD)
    ; curs_set(0);nonl  (); intrflush(v,0	); keypad(v, 1);	noecho(); cbreak()	;start_color();init_pair

    ( 1, WALL , WB ) ;	init_pair(2,HEAD,	HB); init_pair(3	, BODY, BS); init_pair(4, BG, BB); S(0); B(0);x:
						       if    (Q)
						       #undef d

    goto  y ; x = *y ;	getmaxyx(v,1[y],y	[ - 1 ] ); C(1,1	); mvhline(1,0,'#'	,y[-2]); mvvline(1,0,'#'
    ,*y); mvhline(*y,0	, '#' , y [ -2]);	mvvline(1,y[-2],	'#',*y);C(4,1);q*U      ,*V,'*');C(4,0);(*H)(0);
    refresh(); timeout  ( y  [ - 3  ] ) ;	switch	(getch()	){ case KEY_LEFT:V	[ 1 ] = l - 3 ;   break;
    case KEY_RIGHT: V[	l/l] = l/2; break	; case KEY_UP:V[	l-3] = l-1; break;	case KEY_DOWN: V[l/4]=l;
    break;  case  'q':	case'Q':Q=l; case	' ':(!P && (P =1	))||(P=0); default	:x = 0;	} if(x) P=!*y;if


    (Q||P)goto x; if(!	Q && ! 1[V]) goto	x; switch (1[V])	{ case 1:--Y;break	; case  2 : ++ Y;  break
    ;  case 3:   -- X;  break;	case 4:++	X; break; } if (	Y <1 || Y >= y[-2]	|| X < 2 || X	>= *y ||
    y[-2] >= y[-1] ||*	y >= 1[y]) { if (	*p && !(*y>=1[y]	||y[-2]>=y[-1])) {	if (Y<1||Y >= y[-2]) Y =
    Y<1?y[-2]-1:1; if(	X<2||X>=*y) X = X	<2 ? * y -1:2; }	else<% E(Z(OUCH!))	; goto y; } } for (I = 0
    ; !4[p] && I <  A;	++I) if (Y == e[I	] && X == n[I]){	E(Z(OW!)); goto y;	} if (Y == *V && X == *U
    )B(1); else {  if(	W&& !(++1[p] % W)	) H[2](0); if (3	[p]) { if (!(++p[2	] % 3[p])) { H[1](G); 2[
    p]=0; } else S(0);	} else  S (0);  }	goto x; y:E(NULL	); printf(J free(e	); free(n); return 0;  }
","					    #define d =strtoul(z,NULL,0));
					       #define m(n) COLOR_%:%:n
					           #define v stdscr

					          #define q mvaddch(
					           #define Z(x) %:x
					   #define F(x)z=getenv(Z(x)); z&&(
		       #define J Z(X:%d/%d Y:%d/%d S:%zu/%zu B:%zu\n),Y,y[-2],X, *y, A, g, c );
					          #include  <curses.h>

					          #include  <unistd.h>
					          #include    <time.h>
					          #include  <stdlib.h>

    typedef size_t  a;  typedef  unsigned	long k; static a	g= 997,c,A=5,I,N=5	,G=5; static k  p <:5:>=
    <% 1   %>,W = 300;  static int Y,X,*j	=(int<:8])<% 231	%>,*U, *V,*e,*n, Q	,P,x,*y,l=4, * D; static
    void b(a h) { c+=h	; mvprintw(0, 0,J	} static int  E(	const char  * L)<%	static int h; !h&&endwin
    (); h=l; L&&puts(L	); return 1;    }	static void  C (	int L, int    h) {	attroff(m(PAIR(L))); h&&
    attron(m(PAIR(L)))	; } static int	R	(int h, int L) {	return (rand  () %	(L - h + 1))+h; } static
    void S(a o){static  const char*s  =Z(	; +<>^v); q n[0]	,e[0],' '); A = f(	A+o,g	); if (A >= g) {
    E(Z(YOU WIN!));  Q  = l; return; } C(	3, 1); for (I  =        0; A && I < A -  1	; ++I) { I && q n[I], e[
    I], 'o'); e[I] = e	[I + 1]; n[I] =n[	I+1]; } A > 1 &&	q n[I],e[I], 'o');	e[I] = Y; n[I]= X; while
    (++I < g) e[I] = n	[I] = 0; C(2, 1);	q X,Y,s[*D+2& (1	<<3)-!Q]); }static	void B(a o){ if (o) { S(
    N); b(1); } if (Q)	return; p[1] = 0;	!o && q*U,*V,' '	); x: y[3] = R(1,y	[-2]-1); y[2] = R(2,*y-1
    ); for (I = 0; I <	A; ++I) if (*V ==	e[I] && *U == n[	I]) goto x; }  int	main(void) { char *z; y=


    j+3; void (*H[])(a	)={b,S,B} ; srand	((unsigned)time(	NULL));if(!initscr	( ) )  return  puts (Z (
    curses error)  ) ;	getmaxyx(v, *y, y	[-2]); --*y; --y	[-2]; if(y[-2]<9||	* y < 9 )  return   E (Z
    (screen too small)	); F(MAXSIZE)g  d	g = f((a)((*y-2)	*(y[-2]-2)),g); F(	GROW)N d  F (SIZE) A d F
    (WAIT)y [-3]=(int)  strtol(z,NULL,0))	; F(EVADE)W d U=	y+2; F(WALLS) *p d	F(CANNIBAL)p[4] d F(SHED
    ) p[3]  d F	(SHEDS	)G d e = calloc	(	g+1,sizeof * e);	n = calloc (g +  1	,sizeof *n); if (!e || !
    n)  return  E  ( Z  (memory error)) ;	V=U+1; Y = y[-2]	/ 2; X = *y / 2; D	 = 1 + V; attron(A_BOLD)
    ; curs_set(0);nonl  (); intrflush(v,0	); keypad(v, 1);	noecho(); cbreak()	;start_color();init_pair

    ( 1, WALL , WB ) ;	init_pair(2,HEAD,	HB); init_pair(3	, BODY, BS); S(0);	B(0);	x:  if	     (Q)

						       #undef d

    goto  y ; x = *y ;	getmaxyx(v,1[y],y	[ - 1 ] ); C(1,1	); mvhline(1,0,'#'	,y[-2]); mvvline(1,0,'#'
    ,*y); mvhline(*y,0	, '#' , y [ -2]);	mvvline(1,y[-2],	'#', *y); C(1,0) ;	q *U,*V,'*');  (*H) (0);
    refresh(); timeout  ( y  [ - 3  ] ) ;	switch	(getch()	){ case KEY_LEFT:V	[ 1 ] = l - 3 ;   break;
    case KEY_RIGHT: V[	l/l] = l/2; break	; case KEY_UP:V[	l-3] = l-1; break;	case KEY_DOWN: V[l/4]=l;
    break;  case  'q':	case'Q':Q=l; case	' ':(!P && (P =1	))||(P=0); default	:x = 0;	} if(x) P=!*y;if


    (Q||P)goto x; if(!	Q && ! 1[V]) goto	x; switch (1[V])	{ case 1:--Y;break	; case  2 : ++ Y;  break
    ;  case 3:   -- X;  break;	case 4:++	X; break; } if (	Y <1 || Y >= y[-2]	|| X < 2 || X	>= *y ||
    y[-2] >= y[-1] ||*	y >= 1[y]) { if (	*p && !(*y>=1[y]	||y[-2]>=y[-1])) {	if (Y<1||Y >= y[-2]) Y =
    Y<1?y[-2]-1:1; if(	X<2||X>=*y) X = X	<2 ? * y -1:2; }	else<% E(Z(OUCH!))	; goto y; } } for (I = 0
    ; !4[p] && I <  A;	++I) if (Y == e[I	] && X == n[I]){	E(Z(OW!)); goto y;	} if (Y == *V && X == *U
    )B(1); else {  if(	W&& !(++1[p] % W)	) H[2](0); if (3	[p]) { if (!(++p[2	] % 3[p])) { H[1](G); 2[
    p]=0; } else S(0);	} else  S (0);  }	goto x; y:E(NULL	); printf(J free(e	); free(n); return 0;  }
","/* This will imperfectly:
 
   (1)	Test if terminal supports the features Snake uses.
   (2)	Report terminal (and playing) size(s).
   (3)	Estimates the minimum number of columns to play unhindered (based on the
 	size, max size and growth rate).
   (4)	Reports the max size of the Snake and the number of bugs required to
 	reach that size (doesn't use shedding).
 */

#include <curses.h>
#include <term.h>
#include <stdlib.h>
#define f(a,b) ((a)<(b)?(a):(b))
static char *v;
static size_t Y=997,X=5, S=5, rows,N, K;
static int x, y;
struct caps
{
    char *caps, *sup, *desc;
    int fatal;
};
static size_t b(size_t n)
{
    size_t i=n/10, j=1;
    while (i)
    {
        i/=10;
        ++j;
    }
    return j;
}
static size_t a(int n)
{
    int i=n/10;
    size_t j=1;
    while (i)
    {
        i/=10;
        ++j;
    }
    return j;
}

static struct caps caps[] =
{
    { ""cup"", NULL, ""cursor movement"", 1 },
    { ""civis"", NULL, ""making cursor invisible"", 0 },
    { ""bold"", NULL, ""bold"", 0 },
    { NULL, NULL, NULL, 0 }
};

static size_t c(size_t M, size_t V)
{
    size_t i;

    if (!S) S = 5;

    for (i=0; V<M; ++i)
	V += S;

    return i;
}
int main(void)
{
    int i, j, k = 0, f = 0;
    if (!initscr())
    {
	fprintf(stderr, ""FATAL: couldn't initialise curses\n"");
	return -1;
    } 
    j = has_colors();
    k += !j;
    getmaxyx(stdscr, y, x);
    endwin();

    if (y < 10 || x < 10)
    {
	fprintf(stderr, ""FATAL: terminal size must be at least 10 lines and 10 columns\n"");
	return -1;
    }
   
    for (i = 0; i[caps].caps; ++i)
    {
	i[caps].sup = tigetstr(caps[i].caps);
	/* tigetstr() returns (char *)-1 if the capability name isn't
	 * recognised; check for this before suggesting it's supported: */
	if (caps[i].sup == (char *)-1)
	    caps[i].sup = NULL;
	if (!caps[i].sup) ++k;
    }

    for (i = 0; i[caps].caps; ++i)
    {
	printf(""terminal%s support%s %s"", caps[i].sup?"""":"" does not"",caps[i].sup?""s"":"""", caps[i].desc);
	if (caps[i].fatal && !caps[i].sup)
	{
	    ++f;
	    printf("" (fatal)"");
	}
	puts("""");
    }
    printf(""terminal%s support%s colours\n\n"",j?"""":"" does not"",j?""s"":"""");
    printf(""terminal rows %3d (%-3d playable)\n"", y, y - 3);
    printf(""terminal cols %3d (%-3d playable)\n\n"", x, x - 2);

    K = (size_t)((y-3)*(x-3));;

    v = getenv(""MAXSIZE"");
    if (v) Y = strtoul(v, NULL, 0);
    Y = f(K,Y);
    v = getenv(""GROW"");
    if (v) S = strtoul(v, NULL, 0);
    v = getenv(""SIZE"");
    if (v) X = strtoul(v, NULL, 0);
    N = c(Y,X);
    printf(""snake size: %5zu (max size: %zu)\n"", Y, K);
    printf(""      bugs: %5zu (max size: %zu)\n\n"", N, c(K,X));

    rows = 14 + b(Y)*2 + a(y)*2 + a(x)*2 + b(N);
    if (x < (int)rows + 1) ++k;
    printf(""at least %zu columns recommended for snake size %-5zu (is %d)\n"", rows+1,Y, x);

    rows = 14 + b(K)*2 + a(y)*2 + a(x)*2 + b(c(K,X));
    printf(""at least %zu columns recommended for snake size %-5zu (is %d)\n\n"", rows + 1, K, x);


    if (!k)
	printf(""No problems detected.\n"");
    else printf(""%d problem%s detected (%d fatal).\n"", k, k!=1?""s"":"""", f);

    return f?-1:k;
}
","%:include					    <stdio.h>
%:include					    <ctype.h>
%:include					   <string.h>
%:include					   <stdlib.h>
%:define J(x)		  do(*x)=getchar(); while((*x)=='\n')

%:define A(y)				  *(&Y<:7:><:1:>+(y))
%:define D					      strchr(
%:define q(s,x)					D(s),(x))-(s)

%:define n					      isalpha
%:define V(k)				    E = q(Y<:8:>,(k))
%:define K				      fprintf(stderr,
%:define l(c)				     (c)=toupper((c))
%:define W(a,b)			 (a)<:(q((a),(b)) + 1) % 26:>
%:define O(a)		      k = Y<:8:><:(E - (a) + 26)%26:>
%:define d(a,b)                           v=(a)<:(E+(b))%26:>
char*M,*R<:3:>,Y<:20:><:27:>=<% ""EKMFLGDQVZNTOWYHXUSPAIBRCJ"",
""AJDKSIRUXBLHWTMCQGZNPYFVOE""  , ""BDFHJLCPRTXVZNYEIWGAKMUSQO"",
""ESOVPZJAYQUIRHXLNFTGKDCMWB""  , ""VZBRGITYUPSDNHLXAWMJQOFECK"",
""YRUHQSLDPXNGOKMIEBFZCWVJAT""  , ""FVPJIAOYEDRZXWGCTKUQSBNMHL"",
""ABBBCCQEVJZ"",""ABCDEFGHIJKLMNOPQRSTUVWXYZ"", ""Mjqq"", ""Lcxvago""
,""Huwfnbgt"",""Hdoqhmket fbvy"",""Mcromlhxo""} ,*S,*r; int *z=(int
<:13:>){ 0} ,*e,*g,*P; size_t L; char Z(char x){ for(*g=0; *g
<10;++*g) {r<:-2:>=Y<:14:><:*(e+1):>; r<:-3:>=Y<:15:><:1<:e:>
:>; if(r<:-3:> && r<:-2:> == r<:-1:>)return r<:-3:>; if (r<:-
2:>&&r<:-3:>==r<:-1:>)return r<:-2:>; }return x; } void  w  (
char *s, int k, int v) {  for(e<:2:> = 0; s<:*P:>; ++e<:2:>){
v = s<:e<:2:>:>; if(v > 64 && v < 91) s<:e<:2:>:> = (((v - 65
+k) % 26) + 65); } } void Q(void) { for(*g = 0; *g < 3; ++*g)
{ *Y<:16+e<:1:>:>=S<:e<:e<:1:>-3:>:>;R<:e<:1:>:>=Y<:e<:-3+e<:
1:>:>:>; w(R[*g],*(e+e<:1:>-6)=q(Y<:8:>,*Y<:7:>),*g); } }void
m(char*x){ char*p=x,a=A(0),b=A(2),c=A(4); int f,E; for( ; *p;
++p) { int u = islower(*p); if(n(l(*p))){char k=*p, v; f = 0;
c == *Y<:18:> && (f = 1) ; c=W(Y<:8:>,c); if (f) {f = 0; b ==
*Y<:17:> && (f = 1); b = W(Y<:8:>,b); f &&(f = 0 && (a= W(Y<:
8:>,a))); }else if(b==*Y<:17:>){ b = W(Y<:8:>,b); a= W(Y<:8:>
,a); } k = Z(r<:-1:> =k); e<:-6:> = q (Y<:8:>,a); e<:-5:> = q
(Y<:8:>,b); e<:-4:>=q( Y<:8:>,c); V(k); d(R<:2:>,e<:-4:>); V(
v); O(e<:-4:>); V(k); d(R<:1:>,e<:-5:>); V(v); O(e<:-5:>); V(
k); d(*R,e<:-6:>); V(v) ; O(e<:-6:>);(Y<:e<:-10:>+ 5:><:k-'A'
:>)&&(k=Y<:e<:-10:>+5:><:k-'A':>); V(k); d(Y<:8:>,e<:-6:>); E
=q(*R,v); O(e<:-6:>); V(k); d(Y<:8:>,e<:-5:>); E= q (R<:1:>,v
); O(e<:-5:>); V(k); d(Y <:8:>,e<:-4:>); E = q(R<:2:>,v); O(e
<:-4:>); k = Z(r<:-1:>=k); *p = u? tolower(k):k; } } } void E
(char*x, int s, int i){ if (n(l(s))) x<:i:>=s; } int p(char x
) {return D 14<:Y:>,x)||D Y<:15:>,x); }int main(int i, char**
v) { int j; e = z + 10; S = Y<:7:> + 6; r = S + 10 ; g = e +1
; P=g+1; for (j=-3; j < 0; ++j) e<:j:> = j+3; Q(); for (j +=9
; j < 14; ++j) m(Y<:j:>); if (!(v<:1:> && *v<:1:>=='-')) goto
k; for (i = 0; i < 3; ++i) { K""%s %d: "",Y<:9:>, i+1); J(&j) ;
j = j - '0'; e<:i-3:>=(j <1 ?  1 : (j>5?5:j))-1; K""%s %d: "",Y
<:10:>,i+1); J(&j); E(Y<:7:>, j, i+i%3); K""%s %d: "",Y<:11:>,i
+1); J(&j); E(Y<:7:>, j,i+i+1); }K""%s: "",Y<:13:>); J(&j); e<:
-10:> = (j < 1 ? 1:(j>1?2:j))-1; for (i = 0; i<10; ++i) { int
a, b; K""%s %d: "" , Y<:12:>,i+1); J(&a); J (&b);if  (n(l(a))&&
n(l(b))&&a!=b&&!p(b)&&!p(a)) { Y<:14:><:i:> = a; 15<:Y:><:i:>
= b; } %>k: Q(); if(getdelim(&M, &L, EOF, stdin) > 0) <%m(M);
printf(""%s"",M) ;} free	(M)        ;%>
","%:  include  <string.h>
%:  include   <stdio.h>
%:  include   <ctype.h>
%:  include  <stdlib.h>
%:  include    <time.h>
%:  include  <unistd.h>
%:  define W (char<: :> <: 4 :>){   ""  I"","" II"",""III"","" IV"", ""  V""}
%:define E(x) do (*x) = getchar(); while ((*x)!='\n')
#define q Q""Invalid input. "")
#define Z(x) (x)=A<:F(0,25):>
%:define Q    fprintf(stderr,

%:define U   (char<::>){""BC""}
#define L(V) (V)=toupper((V))
%:define n	      isalpha

			   /\
/			    This is				      *not*					what you think:

	    void D(char*x){ for(char*p=x; *p; ++p)*p=islower(*p)		?""nopqrstuvwxyzabcdefghijklm""<:(*p-97+26)%26:>:*p; }
	    char *M,*Y<:3:>,R<:3:>,A<::>=""ABCDEFGHIJKLMNOPQRSTU""		""VWXYZ"",N<::><:27:> = { ""EKMFLGDQVZNTOWYHXUSPAIBRCJ""
	    ,""AJDKSIRUXBLHWTMCQGZNPYFVOE"",""BDFHJLCPRTXVZNYEIWGA""		""KMUSQO"",""ESOVPZJAYQUIRHXLNFTGKDCMWB"",""VZBRGITYUPSD""
	    ""NHLXAWMJQOFECK""} ,o<::><:27:>={ ""YRUHQSLDPXNGOKMIE""		""BFZCWVJAT"",""FVPJIAOYEDRZXWGCTKUQSBNMHL""} ,P<::>=""A""
	    ""BC"", T<::>=""BBC"",C<:2:><:11:>, g<:27:>,X<::><:21:>=		{ ""Rbgbef"", ""Iachg ebgbe"", ""Iachg frggvat"", ""Iachg ""
	    ""cbfvgvba"",""Rrsyrpgbe"", ""Iachg ersyrpgbe"",""Iachg cy""		""htobneq cnve"",""Rvat"",""frggvatf"",""cbfvgvba""} ; int K
	    <::>={ 0,1,2} ,y, H, v, c; size_t l; int F(int i,int		j) { return(rand()%(j-i+1))+i; } void d(void){ int i
	    ,j,k; srand((unsigned)time(0)); strcpy(g,A); K<:0:>=		F(0,4); while((K<:1:>=F(0,4))==K<:0:>) ; while((K<:2
	    :>=F(0,4))==K<:0:>||K<:2:>==K<:1:>) ; y=F(0,1); for(		i=0; i<3; ++i){ Z(P<:i:>); Z(T<:i:>); } k=0; while (
	    k<10){ do i=F(0,25); while (g<:i:> == ' '); do j=F(0		,25); while(j==i||g<:j:>==' '); C<:0:><:k:>=g<: i:>;
	    C<: 1 :> <: k ++:> = g<: j:>; g<:i:>=' '; g<:j:>=' '                ; } H=1; } int p(char x){ return strchr(C<:0:>,x) ||

		    strchr(C<:1:>,x); } char B<:3:>; void G(void){ * B ='\0'; scanf(""%2s"", B); } void m(void) { int i, j=0,h;
		    char k; Q""%s:\n"",*X); for(i=0; i<5; ++i)Q""(%d) %s: """"%s\n"", i+1,W<:i:>,N<:i:>); for(i=0; i< 3; ) { x :  Q
		    ""%s %d (1 - 5): "", X        <:1:>,i+1); G(); j=strtol(B,0,0); if (j<1||j>5) {          q; E(&j); continue
		    ; } j =(j < 1 ?1:(j>        5?5:j))-1; h=i-1; for(; h>= 0; --h) { if(K<:h:>==          j){ Q""Already use""
		    ""d. ""); E(&j);  goto        x; } } K<:i++:>=j; E(& j); } for(i=0; i<3; ++i) {          i:Q""%s %d (A - Z)""
		    "": "", 2<:X:>,i+1); G(); if(!n(k=*B)){ q; E(&*B); goto i; } P<:i:> = toupper(k); E(&*B); } for (i = 0; i<3
		    ; ++i){ j:Q""%s %d (A - Z): "",X<:3:>,i+1); G(); if(!n(k=*B)){ q; E(&*B); goto j; } T<:i:>= toupper(k); E(&
		    *B); } Q""%s:\n"",X <: 4 :>); for(i = 0; i < 2 ; ++i)Q""(%d) (%c) %s\n"", i + 1, U<:i:>, o<:i:> ) ; k:y =0; Q
		    ""%s (1 - 2): "", 5<:X:>); G(); y=strtol(B,0,0); if (y < 1 || y > 2) { q; E( & y); goto k ; } y=(y<1?1:(y >
		    1 ?2:y))-1; strcpy(g,A); for (i=0; i<10; ++i) { char a,b; v:a = b = '.'; Q""%s %d: "",6<:X:>,i+1); G(); a=B
		    <:0:>; b=B<:1:>; L(a); L(b); if((n(a)&&!n(b))||(!n(a)&&n(b))||(n(a) && (a== b || (p(a)||p(b)))))<%if((p(a
		    )||(b))&&(n(a)&&n(b))) Q""Already used. ""); else q; E(&a); goto v; } a=n(a)?a:'.'; b=n(b)?b:'.'; C<:0:><:i
		    :>=a; C<:1:><:i:>=b; if(n(a)){g<:a-'A':>=' ';g<:b-'A':>=' '; }E(&a); } }void e(void) { int i; for(i=0;i<3
		    ; ++i)Q""%s %d: (%s) %s\n"", 7 <:X:>,i+1,W<:K<:i:>:>,N<:K<:i:>:>); Q""%s  %s: %s\n"",7<:X:>,X<:8:>, P); Q""%s""
		    "" %ss"""": %s\n"", X<:7:>,*(X+9),T) ; Q ""%s: (%c) %s\n"",4<:X:>,U<:y:>,o<:y:>) ; for(i=0,L(6<:X:><:6:>); i<10
		    ; ++i)Q""%c%s #%02d: %c%c\n"", X<:6:><:6:>,7+6<:X:>, i+1, C<:0:><:i:>, C<:1:><:i:>); } int O(const char*p){
		    int i,j=0; char*x=0; FILE *f = fopen(p, ""r""); if(f){ if(getdelim(&x,&l,EOF,f)>0){ p = x; j = 1; } fclose(
		    f); } l = 0; if(strlen(p) > 29) { for(i = 0; i < 3; ++i){ K<:i:>=(*p++)-'0'; K<:i:> = (K<:i:> < 1 ? 1 : (
		    K<:i:>> 5 ? 5 : K<:i        :>))-1; P<:i:> = *p++; T<:i:> = *p++ ; } y = ( * p         ++)-'0'; y=(y<1?1:
		    (y>1?2:y))-1; for(i=        0; i<10; ++i){ C<:0:><:i:>=*p++; C<:1:><:i:>=*p++;         } if (j) free(x) ;
		    return 1 ; }  if (j)        free(x); return 0; } void x(FILE*f,int k) { int i;         for (i=0; i <3; ++
		    i){ fprintf(f,""%d"",K<:i:>+1); fprintf(f,""%c"",P<:i :>);fprintf(f,""%c"", T<:i:>); } fprintf(f, ""%d"", y + 1);
		    for (i= 0; i<10; ++i)fprintf(f,""%c%c"",C<:0:><:i:>,C <:1:><:i:>); if(f==stdout&&k)fprintf(f,""%s"",M); } int

	    t(const char*a,const char *b) { int i, j; for (i = 0		; *(a+i) || *(b+ i); ++i) if ((j = tolower(a<:i:>) -
	    tolower(b<:i:>))){ if (j < 0) return -1; return 1; }		return 0; } int main(int V, char **I){ FILE*w=stdin,
	    *z=NULL; const char*p, *J="""", *k= """"; int i; ssize_t		s; for(i = 0; i < 10; ++i) D(i<:X:>); for(V = 1; I<:
	    V:>; ++V) { if (*(p = I<: V :>) =='-') { switch (*++		p){ case'h':Q""usage: %s [options]\n-v\t\t\tdisplay ""
	    ""selected settings\n-r\t\t\tpseudo-randomly select ""		""settings\n-f<input file>\t\tread file for Enigma i""
	    ""nput\n-R<string|file>\t\tinit settings from settin""		""gs string or file\n-o<output file>\t\twrite settin""
	    ""gs to file\n"", * I); return 0; case 'v':c=1; break;		case'r':if(!H){ v=1; d(); } break; case'R':H= O(++p)
	    ; break; case'f':J=++ p; break; case'o':k=++p; break		; default:break; } } } if(*J){ w = fopen(J, ""r""); if
	    (! w) { Q""couldn't open input file, using stdin\n"");		w=stdin; } } if (*J && *k && !t(J,k)){ Q""same input""
	    ""/output filenames, won't open for writing\n"") ; k =		""""; } if (*k) { z=fopen(k, ""w""); if (!z) Q""couldn't""
	    "" open output file, only using stdout\n"");  } if (!v		&& !H && isatty(0)) m(); if (c) e(); s = getdelim(&M
	    ,&l,EOF,w); if(w!=stdin)fclose(w); if (z){ x(z,s>0);		fclose(z); } x(stdout,s>0); free(M); return 0;     }
","#ifdef _WIN32
#define _CRT_SECURE_NO_WARNINGS
#include <io.h>
#include <fcntl.h>
#define X ;_setmode(_fileno(h),_O_BINARY)
#else
#define X
#endif

#include <stdint.h>
#include <stdio.h>
#include <string.h>

#define a [l+z]
#define m(aa) z=aa;z=z;;
#define g(g,a)memset(g,0,a);
#define e2(a,g)!fread(a,g,1,h)
#define aa(a)fprintf(stderr,""%s\n"",a);return 1;
#define n(n) b=n-i;b=b<0?1+b:1-b;d[n+2]+=b>0?b*c*aa:0;
#define t(t) z=t;b=(1-6[d])*d[2]+2*17 a*0 a-1 a*d[6];1 a=0 a;0 a=b*6[d];
#define f(f,aa) x=0; f(2)aa f(10)aa f(6)aa f(12)aa f(4)aa f(8)aa f(14)aa f(0)aa
#define j if(w){b=-1;char j=0;f(m,if(32 a>b){b=32 a;j=k[z];}if(33 a>b){b=33 a;j=k[z+1];})putchar(j);}

const char*t=

""Dual-tone multi-frequency signaling""
""(DTMF) is a telecommunication signaling""
""system using the voice-frequency band""

         ""Invalid WAV input\0Read ""
      ""error\0Cannot read dtmf.bin\0rb\0""+111;
    int main(int m,char**f){double aa,c,d[8]={[
   6]=--m?1:0.994,[7]=1e-4},g,i=0,l['0']={0},b,
  e2=0,x;char k[':'+'s'];FILE*h;if(!(h=fopen(t+
 ')',t+'2'))){memcpy: aa(t+'A'-'$')}uint32_t p=
 e2(k+'U',',')||e2(l+16,'C'+'=')||e2(k,'Q'),w=0
 ,o[2],z,n;fclose(h);if(p)goto memcpy;setvbuf(h
=m?stdout:stdin,0,_IOFBF,65536)X;uint16_t e,v;
int16_t r;if(m){m(6400*strlen(*++f))mem\
cpy(k+'+'+'R',&z,4);z+='$';me\
mcpy(k+'Y',&z,4);fwrite(k+'U',
',',1,h);while(**f){char*c=st\
rchr(k,*(*f)++);g(l,'F'+':')if
(c){w=c-k;double*n=l+w%4*2;*n
=n[16];n=l+8+(w/4)%4*2;*n=n[
16];}for(w=3200;w;--w){f(t,x
+=b*e2*49e2;)r=x;fwrite(&r,2
,1,h);e2+=(w>1300?1:-1)*3e-2
;e2=(e2>1?1:(e2>0?e2:0));}}}
else{ if(e2(k+'+'+'V',',')){
fread:aa(t+18)}if( memcmp(k+
'+'+'^',k+']',14)){ int_16t:
aa(t)}memcpy(&n,k+'+'+'n',4)
;c=16e3/n;n=c; if(n!=c)++n;c
/=n;memcpy( &v,k+43+'x',2);v
/=8; memcpy(&e,k+'+'+'v',2);
if(!e||!v||v>4)goto int_16t;
e-=v;while(!e2(k+'Q',v)){m(e
)while(z-- && getc(h)>=0);if
(v>1){memcpy(&r,k+v+'O',2);g=r/512\
.0/'@';} else g=(unsigned char)k['Q']/128.0-1;
 for(p=n;p;--p){aa=(e2-g)*p/n+g;n(0)n(1)n(2)i+=
 c;if(i>=1){g(d,16)g(o,8) f(t,b=0 a-d[6]*17 a*1
  a;aa=d[6]*1 a*16 a;aa=b*b+aa*aa;x+=aa;if(aa>=d
  [z/8]){o[z/8]=z/2;d[z/8]=aa;})if( (r=w?x>d[7]*
   0.45:x>d[7]*0.6)){if(!w)g(l+32,128)if(x>d[7])
    d[7]=x; /* x= (-b+sqrt(b*b-4*a*c))/(2*a); */
++   l[16+o[1]*4+*o];}else j w=r;memmove(d+2,d+3
      ,24);--i;}}e2=g;}if(ferror(h))goto fread
        ;j puts(""0123456789""+10);}return 0;}
","#include <stdint.h>
#include <stdio.h>
#ifdef _WIN32
#include <io.h>
#include <fcntl.h>
#define main() M();i\
nt main(){setmode(fi\
leno(stdin),O_BINARY\
);return M();}int M()
#endif

                int main()
           {uint32_t h[20]={0},
        i=0,x=~i/15,f=x*x-x,a=f^x,
      b=f^x*9,c=~a,d=~b;int64_t z=0,
     g=0,l=566548,p=585873,o=882346,e
   ,m=64336,k,n;for(;d=h[c=h[b=h[a=h[i=
   0]+=a,1]+=b,2]+=c,3]+=d,f;){for(n=64
  ;n==8?h[h[5]=g,4]=g>>32,f=z>=0:n;)h[4+
 --n/4]=x=(z<0?0:(z=getchar())>=0?g+=8,z:
 128)<<24|x>>8;;for(e=0,k=~e<<40;(x=i/16)
 <4;a=d,d=c,c=b,b+=x<<n|x>>(32-n))n=((e*m
 +k*p)>>21)+e*l+k*o,k=(((k*m-e*p)>>21)+k*
  l-e*o)>>20,e=n>>20,n=(i|12)*152%543%82
   %4+i%4*43/8+4,x=a+((x>2?~d|b:x>1?b^d
   :x?(b^c)&d:(c^d)&~b)^c)+h[19-((x*7/2
     &5)-~(x*5&6)*i++)%16]+(e>>40^e>>
      8);}for(;i<33;putchar(i++<32?a
        +=a>9?'a'-10:'0':'\n'))a=h
           [i/8]>>(i%8*4^4)&15;
                return 0;}
","#include <stdint.h>
#include <stdio.h>
#include <math.h>
#ifdef _WIN32
#include <io.h>
#include <fcntl.h>
#define main() M();i\
nt main(){setmode(fi\
leno(stdin),O_BINARY\
);return M();}int M()
#endif

#ifndef IDX
#define IDX 1
#endif
#if IDX==1 // float round

              int main(){
          uint32_t i=0,h[20]=
       {0},x=~i/15,f=x*x-x,a=f^x
     ,b=f^x*9,c=~a,d=~b;int64_t z=
    0,g=0,n;for(;d=h[c=h[b=h[a=h[n=
  i=0]+=a,1]+=b,2]+=c,3]+=d,f;){for(;
  n==56?h[h[18]=g,19]=g>>32,f=z>=0:n<
 64;)h[n++/4+4]=x=(z<0?0:(z=getchar())
 >=0?g+=8,z:128)<<24|x>>8;;for(;(x=i>>
 4)<4;a=d,d=c,c=b,b+=x<<n|x>>(32-n))n=
 (i|12)*152%543%82%4+i%4*43/8+4,x=a+((
  x>2?~d|b:x>1?b^d:x?(b^c)&d:(c^d)&~b
  )^c)+h[((x*7/2&5)-~(x*5&6)*i++)%16+
    4],x+=a=fabs(sin(i))*8*(8<<26);
     }for(;n<33;putchar(n++<32?a+=
       a>9?'a'-10:'0':'\n'))a=h[
          n/8]>>(n%8*4^4)&15;
              ;return 0;}

#elif IDX==2 // float square

int main(){uint32_t f=0,x=~f/15,
i=x*x-x,a=i^x,b=i^x*9,n,c=~a,d=~
b,h[20]={0};int64_t z=0,g=0;for(
;d=h[c=h[b=h[a=h[i=0]+=a,1]+=b,2
]+=c,3]+=d,!f;){for(f=64;f==8?h[
h[5]=g,4]=g>>32,z>=0:f;)h[--f/4+
4]=x=x>>8|(z<0?0:(z=getchar())>=
0?g+=8,z:128)<<24;for(;(x=i/16)<
4;a=d,d=c,c=b,b+=x<<n|x>>(32-n))
n=(i|12)*152%543%82%4+i%4*43/8+4
,x=a+((x>2?~d|b:x>1?b^d:x?(b^c)&
d:(c^d)&~b)^c)+h[19-((x*7/2&5)-~
(x*5&6)*i++)%16],x+=a=fabs(sin(i
))*8*(8<<26);}for(;i<33;putchar(
i++<32?a+=a>9?'a'-10:'0':'\n'))a
=h[i/8]>>(i%8*4^4)&15;return 0;}

#elif IDX==3 // integer 62x10, twitter profile cover (3:1)

int main(){uint32_t i=0,x=~i/15,f=x*x-x,a=f^x,b=f^x*9,c=~a,d=~
b,h[20]={0};int64_t e,k,l=566548,m=64336,o=882346,p=585873,n,z
=0,g=0;for(;d=h[c=h[b=h[a=h[e=i=n=0]+=a,1]+=b,2]+=c,3]+=d,f;){
for(;n==56?h[h[18]=g,19]=g>>32,f=z>=0:n<64;)h[n++/4+4]=x=x>>8|
(z<0?0:(z=getchar())>=0?g+=8,z:128)<<24;;for(k=~e<<40;(x=i/16)
<4;a=d,d=c,c=b,b+=x<<n|x>>(32-n))n=((e*m+k*p)>>21)+e*l+k*o,k=(
((k*m-e*p)>>21)+k*l-e*o)>>20,e=n>>20,n=(i|12)*152%543%82%4+i%4
*43/8+4,x=a+((x?x>2?~d|b:x>1?b^d:(b^c)&d:(c^d)&~b)^c)+h[((x*7/
2&5)+(x*5%8|1)*i++)%16+4]+(e>>8^e>>40);}for(;n<33;putchar(n++<
32?a+=a<10?'0':'a'-10:'\n'))a=h[n/8]>>(n%8*4^4)&15;;return 0;}

#elif IDX==4 // float 65x8, linkedin profile cover (4:1)

int main(){uint32_t i=0,x=~i/15,f=x*x-x,a=f^x,b=f^x*9,n,c=~a,d=~b
,h[20]={0};int64_t z=0,g=0;for(;d=h[c=h[b=h[a=h[n=i=0]+=a,1]+=b,2
]+=c,3]+=d,f;){for(;n==56?h[h[18]=g,19]=g>>32,f=z>=0:n<64;)h[n++/
4+4]=x=x>>8|(z<0?0:(z=getchar())>=0?g+=8,z:128)<<24;for(;(x=i/16)
<4;x+=a=fabs(sin(i))*8*(8<<26),a=d,d=c,c=b,b+=x<<n|x>>(32-n))n=(i
|12)*152%543%82%4+i%4*43/8+4,x=a+(x?(x>2?~d|b:x>1?b^d:(b^c)&d)^c:
((c^d)&b)^d)+h[((x*7/2&5)+(x*5%8|1)*i++)%16+4];}for(;n<33;putchar
(n++<32?a+=a>9?'a'-10:'0':'\n'))a=h[n/8]>>(n%8*4^4)&15;return 0;}

#endif
","#include <stdint.h>
#include <stdio.h>

                int main(){
            uint32_t f=0,i,n=0,
         a=1732584193,b=4023233417
       ,q=32,c=~a,d=~b,x,h[]={x=a,b,
     c,d,80200,745,108189,38200},s[16]
    ;int64_t z=0,g=0,l=566548,m=64336,o
   =882346,p=585873,e,k,y;for(;!f;)if(s[
  n++/4]=x=x>>8|(z<0?0:(z=getchar())>=0?g
  +=8,z:128)<<24,n==56?s[s[14]=g,15]=g>>q
 ,f=z<0:n/64){for(e=i=0,k=~e<<40;i<64;i++,
 a=d,d=c,c=b,b+=x<<n|x>>(q-n))y=((e*m+k*p)
 >>21)+e*l+k*o,k=(((k*m-e*p)>>21)+k*l-e*o)
  >>20,e=y>>20,x=i/16+4,n=h[x],x=a+(x>4?(
  x>6?~d|b:x>5?b^d:(b^c)&d)^c:((c^d)&b)^d
   )+s[(n/8%8*i+n%8)&15]+(e>>8^e>>40),n=
    (n>>(i%4*3+6)&7)+i%4*6+2;d=h[c=h[b=
     h[a=h[n=0]+=a,1]+=b,2]+=c,3]+=d;}
       for(;n<33;)a=h[n/8]>>(n%8*4^4
         )&15,putchar(++n>q?'\n':a
            +(a<10?'0':'a'-10))
                ;return 0;}
","#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include ""jpeglib.h""
#define J(x) jpeg_##x;
#define A B(p=t+Z*b+y*S;l=w*h;for(u=j=0;l&&j<b;p++)X->c[j\
++]=(p[w*b+h*S]-p[w*b]-p[h*S]+*p+l/2)/l,-),u+=z*z; X->d=u;}
#define G(h,n) D.comp_info[0].h##_samp_factor=1;D.image_##n;
#define B(e,f) {int x,Z=X->x,y=X->y,w=X->w,h=X->h;e;for(;h--\
;y++)for(x=Z;x<w+Z;x++)for(j=0;j<b;j++)z=d[y*s+x*b+j]f X->c[j]
#define H(W,H,w,h,B,i) for(B=z=i=0;++z<w;u>B?B=u,i=z:0)for(u=j\
=0;p=t+x*b+y*S+j,j<b;j++)K=p[z*W+h*H]-p[z*W],Q=N->c[j]*h,L=p[w*\
W+h*H]-p[w*W]-K-Q*(w-z),K-=p[h*H]-*p+Q*z,u+=L<0?-L:L,u+=K<0?-K:K;
#define W(r,X,a,o,Y,b,c,S) {S J(error_mgr E)S J(c##_##S D);D.err=\
J(std_error(&E))if(!(F=fopen(*++V,#r)))break;J(create_##c(I=&D))J(\
stdio_##o(I,F))Y;J(start_##c X)while((y=D.a##_scanline)<h)R=d+y*s,J\
(b##_scanlines(I,O=&R,1))J(finish_##c(I))J(destroy_##c(I))fclose(F);}
int main(int c,char**V){while(c==4){intptr_t w,h,s,b,S,j,i,x,y,v,q,z,k
,l,g=JCS_RGB,n=atoi(*++V);uint8_t*d;void*O,*R,*F,*I;int64_t*p,e,f,u,K,L
,*t,Q,U=1;struct{uint16_t x,y,w,h;uint8_t c[4];int64_t d;}*P,*N,*X,o={0}
;W(rb,(I);w=D.output_width;h=D.output_height;b=D.output_components;L=n=n
<1?1:n>w*h?w*h:n;K=S=(s=w*b)+b;K=sizeof(o)*L+(u=K*h+K)*9;if((L=(size_t)K
)-K||!(t=malloc(K)))break;X=P=O=t+u;d=O=P+n,output,src,J(read_header(I,U
))D.do_fancy_upsampling=0;D.out_color_space=g,read,decompress,struct)fo\
r(i=j=0;j<b;j++)for(x=j-S,z=j-b;x<S*h;x+=b)t[x+S]=x<0?y=0:t[x]+(u=y--?u+
d[z+=b]:(y=w,0));;o.w=w;o.h=h;*X=o;A for(;N=X=P,U&&++i<n;){for(U=j=0;j++
<i;X++)U=X->d>U?(N=X)->d:U;;o=*N;v=o.w;q=o.h;x=o.x;y=o.y;H(b,S,v,q,e,k)H
(S,b,q,v,f,l)e<f?o.y+=N->h=l,o.h-=l:(o.x+=N->w=k,o.w-=k);*X=o;A X=N;A}f\
or(;i--;X++)B(,=);}W(wb,(I,1),next,dest,D.input_components=b;D.in_color\
_space=g;J(set_defaults(I))G(h,width=w)G(v,height=h)J(set_quality(I,100,
D.optimize_coding=1)),write,compress,struct)free(t);return 0;}return 1;}

","#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <png.h>
#define G(n) png_get_##n(J,I);
#define A B(p=t+Z*b+y*S;l=w*h;for(u=j=0;l&&j<b;p++)X->c[j\
++]=(p[w*b+h*S]-p[w*b]-p[h*S]+*p+l/2)/l,-),u+=z*z; X->d=u;}
int main(int c,char**V){while(c==4){struct{uint16_t x,y,w,h;
#define B(e,f) {int x,Z=X->x,y=X->y,w=X->w,h=X->h;e;for(;h--\
;y++)for(x=Z;x<w+Z;x++)for(j=0;j<b;j++)z=d[y*s+x*b+j]f X->c[j]
#define H(W,H,w,h,B,i) for(B=z=i=0;++z<w;u>B?B=u,i=z:0)for(u=j\
=0;p=t+x*b+y*S+j,j<b;j++)K=p[z*W+h*H]-p[z*W],Q=N->c[j]*h,L=p[w*\
W+h*H]-p[w*W]-K-Q*(w-z),K-=p[h*H]-*p+Q*z,u+=L<0?-L:L,u+=K<0?-K:K;
#define W(a,b,c,d,e,f,g,h) if(!(F=fopen(*++V,#a)))return 1;b;J=h\
##create_##g##_struct(PNG_LIBPNG_VER_STRING,0,0,0);I=h##create_i\
nfo_struct(J);h##init_io(J,F);c;h##g##_info(J,I);d;h##g##_image(\
J,R);h##g##_end(J,0); O=&J;h##destroy_##g##_struct e;fclose(F);f;
uint8_t c[4];int64_t d;}*P,*N,*X,o;uint8_t**R,*d;intptr_t n=atoi(
*++V),l,h,s,b,S,i,j,x,y,v,q,z,k,w;int64_t*p,e,f,u,K,L,*t,Q,U;void
*O=&K,*J,*I,*Z,*F;W(rb,if(png_sig_cmp(O,0,fread(O,U=1,8,F)))break
,png_set_sig_bytes(J,8),w=G(image_width)h=G(image_height)png_rea\
d_update_info(J,I);y=8-G(bit_depth)b=G(channels)c=G(color_type)L=
n=n<1?1:n>w*h?w*h:n;K=S=(s=w*b)+b;K=h*sizeof(*R)+sizeof(*X)*L+(u=
K*h+K)*9;if(y||(L=(size_t)K)-K||!(R=malloc(K)))break;t=O=R+h;X=P=
O=t+u;for(d=O=P+n;y<h;y++)R[y]=d+y*s,(O,Z=&I,0);for(X->x=X->y=i=j
=0;j<b;j++)for(x=j-S,z=j-b;x<S*h;x+=b)t[x+S]=x<0?y=0:t[x]+(u=y--?
u+d[z+=b]:(y=w,0)),X->w=w;X->h=h;A for(;N=X=P,U&&++i<n;){for(U=j=
0;j++<i;X++)U=X->d>U?(N=X)->d:U,read,png_)o=*N;v=o.w;q=o.h;x=o.x;
y=o.y;H(b,S,v,q,e,k)H(S,b,q,v,f,l)e<f?o.y+=l,o.h-=N->h=l:(o.x+=k,
o.w-=N->w=k);*X=o;A X=N;A}for(;i--;X++)B(,=);}W(wb,,png_set_IHDR(
J,I,w,h,8,c,0,0,0),,(O,Z),free(R),write,png_)return 0;}return 1;}

","#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#define A B(p=t+Z*b+y*S;l=w*h;for(u=j=0;l&&j<b;p++)X->c[j\
++]=(p[w*b+h*S]-p[w*b]-p[h*S]+*p+l/2)/l,-),u+=z*z; X->d=u;}
int main(int c,char**V){while(c==4){struct{uint16_t x,y,w,h;
#define B(e,f) {int x,Z=X->x,y=X->y,w=X->w,h=X->h;e;for(;h--\
;y++)for(x=Z;x<w+Z;x++)for(j=0;j<b;j++)z=d[y*s+x*b+j]f X->c[j]
#define H(W,H,w,h,B,i) for(B=z=i=0;++z<w;u>B?B=u,i=z:0)for(u=j\
=0;p=t+x*b+y*S+j,j<b;j++)K=p[z*W+h*H]-p[z*W],Q=N->c[j]*h,L=p[w*\
W+h*H]-p[w*W]-K-Q*(w-z),K-=p[h*H]-*p+Q*z,u+=L<0?-L:L,u+=K<0?-K:K;
#define W(r,X) if(!(F=fopen(*++V,#r)))break;X(d,s,h,F); fclose(F);
#define G(n,x,y){for(k=0,n=-x;!k;k=z-' '&&z-'\n'&&z-'\r'&&z-'\t'&\
&z-EOF?z<'0'||z>'9'||(n=(n<0?0:n*10)+z-'0')>>15?n=-1:0:n>=0||z>>8\
)for(;z=fgetc(F),k++?z-'\n'&&z-EOF:z=='#';);if(x?y:n-3&&n-6)break;
uint8_t c[4];int64_t d;}*P,*N,*X,o;void*O,*F;int64_t*p,e,f,u,K,L,*
t,Q,U=1;uint8_t*d;intptr_t n=atoi(*++V),w,h,s,b=3,S,i=0,j,x=0,y,v,
q,l,k,z;W(rb,if(fgetc(F)=='P')G(i,0,0)}G(w,1,w<1)}G(h,1,h<1)}G(y,1
,y-255)}L=n=n<1?1:n>w*h?w*h:n;K=S=(s=w*b)+b;K=sizeof(*X)*L+(u=K*h+
K)*9;if(K-(L=(size_t)K)||!(t=malloc(K)))break;X=P=O=t+u;d=O=P+n;if
(i<4)for(;x<s*h;)G(i,1,(d[x++]=i,i>>=8))}else i=h-fread)if(i)break
;;for(X->x=X->y=j=0;j<b;j++)for(x=j-S,z=j-b;x<S*h;x+=b)t[x+S]=x<0?
y=0:t[x]+(u=y--?u+d[z+=b]:(y=w,0));;X->w=w;X->h=h;A for(;N=X=P,U&&
++i<n;){for(U=j=0;j++<i;X++)U=X->d>U?(N=X)->d:U; o=*N;v=o.w;q=o.h;
x=o.x;y=o.y;H(b,S,v,q,e,k)H(S,b,q,v,f,l)e<f?o.y+=N->h=l,o.h-=l:(o.
x+=N->w=k,o.w-=k);*X=o;A X=N;A}for(;i--;X++)B(,=);}W(wb,fprintf(F,
""P6\n%i %i\n255\n"",c=w,(int)h);fwrite)free(t);return 0;}return 1;}
","#include <time.h>
#include <stdio.h>
#include <stdlib.h>
int main(){unsigned
a,i=1,j=0,t[64];for
(srand(time(0));i;)
j=j?--i<1&&a>>8?0:(
putchar(i?t[j]:a),i
++)?t[j]=t[--i],i>2
?rand()%(i-2)+2:1:0
:(26>((a=getchar())
|32)-97||1==a>>7)&&
i<64?t[i++]=a,0:1;}

","#include <time.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef IDX
#define IDX 1
#endif
#if IDX==1 // square

  int main(){;unsigned
  a,i=1,j=0,t[256];for
  (srand(time(0));i;)j
  ?(--i||~a>>8?putchar
  (i?t[j]:a),i++:0)?t[
  j]=t[--i],j=i>2?rand
  ()%(i-2)+2:1,1:j--:(
  a=getchar(),(1==a>>7
  ||26>(a|32)-97)&&256
  >i?t[i++]=a,0:j++);}

#elif IDX==2

  int main(){;unsigned
  a=0,i,j,t[256];srand
  (time(0));for(;256>a
  ;){for(i=j=0;(26>((a
  =getchar())|32)-97||
  1==a>>7)&&i<256;)t[i
  ++]=a;;for(;i||~a>>8
  ?putchar(i?t[j]:a),i
  --:0;j=i>1?rand()%(i
  -1)+1:0)t[j]=t[i];}}

#elif IDX==3 // round

       int main()
    {unsigned a,i=1,
  j=0,t[64];for(srand(
  time(0));i;)j?(--i||
 ~a>>8?putchar(i?t[j]:a
 ),i++:0)?t[j]=t[--i],j
 =i>2?rand()%(i-2)+2:1,
  1:j--:(a=getchar(),(
  26>(a|32)-97||1==a>>
    7)&&i<64?t[i++]=
       a,0:j++);}

#elif IDX==4

       int main()
    {unsigned a,i,j=
  a=0,t[64];for(srand(
  time(0)),i=0;~a>>8;)
 {for(;a=getchar(),(26>
 (a|32)-97||1==a>>7)&&i
 <64;)t[i++]=a;;for(;!i
  &&a>>8?0:putchar(i?t
  [j]:a),i;j=i>1?rand(
    )%(i-1)+1:0)t[j]
       =t[--i];}}

#elif IDX==5 // profile

          int main
        (){;unsigned
       a=0,i,j,t[64];
       srand(time(0))
       ;for(;a<256;~a
       >>8?putchar(a)
       :0){for(i=j=0;
        a=getchar(),
         ((a|32)-97
          <26||a>>
          7==1)&&i
       <64;)t[i++]=a;
 for(i-=1;i+1;putchar(t[j])
  ,t[j]=t[i--],j=i?rand()%
     i+1:0);}return!a;}

#endif
","#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#define M(P,F,J)in\
t main(){unsigned \
a=0,i,j,t[64];F(sr\
and(time(0));~a>>8\
;a>>8?0:P(a)){F(i=\
j=0;a=getchar(),~i\
>>6&&(a>>7==1||(a|\
32)-97<26);)t[i++]\
=a;F(i--;i+1;j=i?r\
and()%i+1:0)P(J),J\
=t[i--];}return 0;}
M(putchar,for,t[j])

","#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#define R (z=a=(s*=S)>>31)*n>>32;for(
#define K(x) ))||fseek(F,0,SEEK_##x)||
int main(int c,char**V){int k,l,p,i,x,y
,n,q;uint64_t s,S=5,z;uint32_t*h,a,t[512
];while(c++==5){uint8_t*m;void*F;x=atoi(V
[2]);y=atoi(V[3]);s=atoi(V[4]);if(x>>20||(
#define H(b,x) memset b{for(a=i=0;i<y;)a=(\
a^m[x+i++])*79764919;for(;(i=h[a&q])^-1;a++)
y-1)>>7||!(F=fopen(V[q=1],""rb""K(END)y>(n=fte\
ll(F K(SET)!(m=malloc(n+y))||fread(m,1,n,F)-n
||n>>29)break;;for(fclose(F);S*5>S;)S*=5;for(
i=k=l=0;i<n;)if('_'-(a=m[i++])){if(a=='<')for
(a=' ';i<n&&m[i++]-'>';);;if((a-' '&&a-'\n'&&
a-'\r'&&a-'\t')||k-(a=' ')) m[l++]=k=a;};n=l;
memcpy(m+l,m,y);for(;l*3>q;)q+=q;if((h=malloc
(4*q))){H((h,-1,4*q--);for(k=0;k<l;h[a&q]=k++
),k);}p=R;x--;p=p-l?p:0){H((t,n=0,8<<8);,p)if
(!memcmp(m+p,m+i,y))k=m[i+y]*2,t[k++]++,n++,t
[k]=i;}n=R k=-1;n>=0;)n-=t[++k*2];putchar(k);
p=t[k+k+1]+1;}putchar('\n');c=0;}}return!!c;}

","#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
main(int c, char *v[]) {
	FILE * f;
	int flen, ctxt, osize, pos, npos, i, k, l;
	char * m, *loc;
	char a;
	if (c != 5) exit(1);
	f = fopen(v[1], ""r"");
	if (!f) exit(1);
	osize = atoi(v[2]);
	ctxt = atoi(v[3]);
	srandom(atoi(v[4]));
	fseek(f, 0, SEEK_END); flen = ftell(f); fseek(f, 0, SEEK_SET);
	if (ctxt < 1 || ctxt >= flen) exit(1);

	m = malloc(flen + flen + ctxt);
	if (!m) exit(1);
	fread(m, flen, 1, f);

     for (i = k = l = 0; i < flen;)
        if ('_' - (a = m[i++]))
          {
            if (a == '<')
              for (a = ' '; i < flen && m[i++] - '>';);;
            if ((a - ' ' && a - '\n' &&
                 a - '\r' && a - '\t') || k - (a = ' '))
              m[l++] = k = a;
          };
      flen = l;

	memcpy(m+flen, m, flen + ctxt);
	pos = random() % flen;
	for (i = 0; i < osize; ++i) {
		npos = random() % flen;
		// find the context at pos starting from npos
		loc = memmem(m+npos, flen+ctxt-1, m+pos, ctxt);
		if (!loc) puts(""I'm lost!!!""), exit(1);
		npos = (loc-m) % flen;
		putchar(m[npos]);
		pos = npos+1;
	}
	putchar('\n');
}

","#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define P(a, b) fwrite(a, b, !!a, stdout)
typedef uint8_t u1;
typedef uint16_t u2;
typedef uint32_t u4;
u4 k, l, n;
u1 m, o, p, q, r, s, *t, *u;

u2 A(u1 *c) { return *(c + !!c) | (u2)(*c) << l; }

void B(u1 *c, u2 a) {
  *c++ = a >> l;
  *c = a;
}

int C(u1 *c, u4 *a) {
  u1 b, d = k;
  s = l--;
  *a = k++;
  for (; d<s>> k; d++) {
    b = d[c];
    *a |= b & p;
    if (!(b >> l)) {
      d += k--;
      l = s;
      return d;
    }
    *a = *a << l;
  }
  exit(!k);
  return p;
}

u1 D(u4 a) {
  u1 b = k++;
  u1 c = l - k;
  if (a) {
    b = k;
    while (a >>= k) b++;
  }
  k = k ? !k : k;
  return b / c + !!(b % c);
}

int F(u4 a, u1 *c) {
  u1 b = D(a);
  *c = s - l--;
  r = q / n;
  if (!a) return b;
  if (b > r) exit(o);
  c += b;
  c--;
  while (a) {
    *c = a & p;
    a = a >> l;
    c--;
  }
  l = s;
  return b;
}

u1 *G(u1 *c, u1 *a) {
  u4 d;
  u1 b, e;
  m = m < p ? p << q : m;
  q = q < n + o ? p >> q : q;
  e = *c;
  if (e == m || e == m + q) {
    *a = k;
    c++;
    c += C(c, &d);
    return c + d;
  }
  if (e == (m | p)) {
    *a = k;
    c++;
    c++;
    c += C(c, &d);
    return c + d;
  }
  l /= o;
  if (e >> q) {
    b = *c;
    c++;
    *a = b;
  } else {
    b = *a;
  }
  e = b >> l;
  if (e < s || e > l + s) exit(n);
  if (e != l + s && e != l + o) c++;
  c++;
  l = s;
  return c;
}

u1 *H(u1 *c, u4 *a) {
  u4 b, e, h = q, i = m;
  u1 *d, f = k;
  *a = k;
  q = q / n;
  m = p - m + p / m;
  if (n[c] != m) exit(q);
  b = (u4)A(c + q) << q * q | A(c + (m >> q));
  c += l;
  d = c + b;
  while (c < d) {
    c += C(c, &e);
    *a += e;
    c = G(c, &f);
  }
  q = h;
  m = i;
  return c;
}

u4 I(u1 *c, u4 a) {
  u4 e, b, d = k;
  for (e = k; e < a; e++) {
    c = H(c, &b);
    if (b > d) d = b;
  }
  return d;
}

u1 *J(u1 *c, u4 a, u4 b) {
  u1 d, e;
  if (l > o) {
    o = (--s - o) << r;
    l = p % (s + o);
    r = o / l;
    n = l / r;
    m = o / n;
  }
  d = l + r;
  e = o;
  if (!(a % m)) {
    d = l - m;
    e = o + l;
  } else if ((a % m) == r) {
    d = l;
    e = n + o;
  }
  k[t] = d;
  r[t] = e;
  *u = d;
  memcpy(c, t, b);
  return c + b;
}

void K(u1 *c, u4 a) {
  u1 *b, *d;
  u2 e, f;
  u4 g, h, i, j;
  o = n ^ k;
  m = l;
  l = o << o;
  f = A(c + l + o);
  e = A(c + l + o + o) >> k--;
  p = ~k++;
  p >>= k--;
  q = p >> n;
  if (e >> q--) exit(n + o);
  g = I(c + q--, f) / e;
  i = n + o + D(e);
  if (!(t = malloc(i))) exit(n * o);
  j = g * i + q;
  b = malloc(j);
  r = --l;
  l++;
  if (!b) exit(r);
  *b = l << n | q;
  *(!k + b) = *b + r;
  n[b] = (*b << n) + n;
  o[b] = n[b] + r--;
  B(b + n * o, j - l);
  B(b + o * o, (j - l) >> o * l);
  d = t;
  *d++ = k;
  *d++ = r * r;
  m = p / (n + o);
  *d++ = p - m - o;
  d += F(e, d);
  u = d;
  *d++ = r * r;
  *d = k;
  d = b + l;
  *d++ = k++;
  *d++ = p + q + q;
  memcpy(d, t + k, i - k);
  d += i - k;
  for (h = k; h < g; h++) d = J(d, h, i);
  l = (o + m) / s - m;
  o = r;
  *d++ = --k;
  *d++ = ~k;
  *d++ = p / o - o * l;
  *d = k++;
  *(l + p + c) = k;
  B(c + l + o, f + k);
  P(c, a);
  P(b, j);
}

int main() {
  u4 a, b;
  u1 *c;
  k = !!stdin;
  n = k + k + k;
  l = k << n;
  m = l;
  l = (l | l >> (k + k)) << k;
  b = k << l;
  c = malloc(b);
  if (!c) exit(m);
  a = fread(c, k, b, stdin);
  l = (m << k) + m + k;
  if (a >= b) exit(l / n + k);
  if ((n[c] != l << (k + k)) || ((m - k)[c] != n + n))
    exit((m << k) - (n << k));
  K(c, a);
  return !b;
}
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>
int t(){struct timeval t;gettimeofday(&t,0);return t.tv_usec/1000+t.tv_sec*1000;}

                                                            #define g(x,y,u,v,s)\
  for(int j=0,X=x,Y=y;j<v&&Y+j<h-X/w&&Y>=0&&X>=0;++j)memcpy(&f[Y+j][X],&s[j*u],u)
                                                      #define l(x,y,w,h,a,b,c,d)\
                    !((x-a>c&&x>=a)||(a-x>w&&a>=x)||(y-b>d&&y>=b)||(b-y>h&&b>=y))

                                                                      int main(){
             struct termios z,o;tcgetattr(0,&z);o=z;z.c_lflag&=~ICANON&~ECHO;
                      z.c_cc[VMIN]=0;z.c_cc[VTIME]=0;tcsetattr(0,TCSANOW,&z);
          srand(time(0));struct winsize v;ioctl(STDOUT_FILENO,TIOCGWINSZ,&v);
                 int h=v.ws_row,w=v.ws_col,A=w*h/100,l=t(),k,s=0,g=1,i,c=0,L;
                          struct V{float x,y;}p={w/2,h/2},b={-3*h},a[A],m[A];
                         char*r="" /\\ /__\\ ^^ "",*n=""o0o0OO"",u=0,q,f[h+1][w];
                                                                while(u^'q'){
                                                    float d=(t()-l)*.001;
                             q=u;do read(0,&u,1);while((u&'p')>=(u|'p'));
                                                     l=t();c+=15;i=h*w-1;
                                                                           K:
                                        L=c*d;L=abs(((i/w)-L)*(i%w)+h*w);
                        (*f)[i]=L%3+L%5+L%7+L%11+L%13+L%17+L%19>14?32:46;
                                                           if(i--)goto K;
                                         u^' '?0:(b.x=p.x+2,b.y=p.y,u=q);
                                               q^'a'?q^'d'?q^'w'?q^'s'?0:
                                                         (p.y+=d*15):
                                                        (p.y+=d*-15):
                                                         (p.x+=d*20):
                                                        (p.x+=d*-20);
                                            p.x=p.x<0?0:p.x>=w-4?w-4:p.x;
                                            p.y=p.y<0?0:p.y>=h-3?h-3:p.y;
                                                              b.y+=d*-20;
                                   int Y=b.y,X=b.x;Y*w+X>=0?f[Y][X]=64:0;
                                                                   i=A-1;
                                                                           L:
                                           k=0;struct V*e=&a[i],*z=&m[i];
                                               e->x+=d*z->x;e->y+=d*z->y;
                     l(b.x,b.y,1,1,e->x,e->y,6,4)&&!g?k=1,s++,b.y=-3*h:0;
                                    e->x<0-3||e->x>=w+3||e->y>=h+2||k||g?
                                                e->y=-rand()%h*(1+g),
                                                       e->x=rand()%w,
                                                   z->x=-8+rand()%15,
                                                  z->y=10+rand()%5:0;
                                    l(p.x,p.y,4,3,e->x,e->y,3,2)?u='q':0;
                                                      g(e->x,e->y,3,2,n);
                                                           if(i--)goto L;
                                                        g(p.x,p.y,4,3,r);
                                                               *(f[h])=0;
                printf(""\033[0;4H%s\033[0;0H    \033[4D%i\n"",&f[0][4],s);
                                                      while(t()-l<9);g=0;
                                                                            }
                                                   tcsetattr(0,TCSADRAIN,&o);
                                                                                }
","                                                       #\
                                define C(c           /**/)#c
                               /*size=3173*/#include<stdio.h>
                            /*crc=b7f9ecff.*/#include<stdlib.h>
                           /*Mile/Adele_von_Ascham*/#include<time.h>
                           typedef/**/int(I);I/*:3*/d,i,j,a,b,l,u[16],v
                           [18],w[36],x,y,z,k;char*P=""\n\40(),"",*p,*q,*t[18],m[4];
                          void/**/O(char*q){for(;*q;q++)*q>32?z=111-*q?z=(z+*q)%185,(k?
                          k--:(y=z%37,(x=z/37%7)?printf(*t,t[x],y?w[y-1]:95):y>14&&y<33?x
                          =y>15,printf(t[15+x],x?2<<y%16:l,x?(1<<y%16)-1:1):puts(t[y%28])))
                          ,0:z+82:0;}void/**/Q(I(p),I*q){for(x=0;x<p;x++){q[x]=x;}for(;--p
    >1;q[p]=y)y          =q[x=rand()%-~p],q[x]=q[p];}char/**/n[999]=C(Average?!nQVQd%R>Rd%
  R%          %RNIPRfi#VQ}R;TtuodtsRUd%RUd%RUOSetirwf!RnruterR{RTSniamRtniQ>h.oidts<edulc
 ni                   #V>rebmun<=NIPD-RhtiwRelipmocResaelPRrorre#QNIPRfednfi#V__ELIF__R_
Re               nifed#V~-VU0V;}V{R= R][ORrahcRdengisnuRtsnocRcitatsVesle#Vfidne#V53556
 .           .1RfoRegnarRehtRniRre   getniRnaRsiR]NIP[R erehwQQc.tuptuoR>Rtxt.tupniR
 <         R]NIP[R:egasuV_Redulcn i#VfednfiVfednuVenife dVfedfiVQc%Rs%#V);I/**/main(
  I(      f),char**e){if(f){for(i=    time(NULL),p=n,q=  n+998,x=18;x;p++){*p>32&&!(
         *--q=*p>80&&*p<87?P[*p-   81]:*     p)?t  [( --  x)]=q+1:q;}if(f-2||(d=atoi
        (e[1]))<1||65536<d){;O(""   \"""");             goto  O;}srand(i);Q(16,u);i=0;Q(
       36,w);for(;i<36; i++){w[i]   +=w           [i]<26 ? 97:39; }O(C(ouoo9oBotoo%]#
      ox^#oy_#ozoou#o{ a#o|b#o}c#                o~d#oo-e   #oo.  f#oo/g#oo0h#oo1i#oo
     2j#oo3k#oo4l#o   p));for(j                   =8;EOF   -(i=   getchar());l+=1){a=1+
    rand()%16;for(b  =0;b<a||i-                           main   (0,e);b++)x=d^d/4^d/8^d/
    32,d=  (d/  2|x<<15)&65535;                          b|=   !l<<17;Q(18,v);for(a=0;a<18;
    a++     ){if( (b&(1<<(i=v[a]      ))))*                 m=75+i,O(m),j=i<17&&j<i?i:j;}O(C(
    !)           ); }O(C(oqovoo97o    /n!));i=           0;for(;i<8;O(m))m[2]=35,*m=56+u[i],m[1
    ]=          75   +i++;O(C(oA!oro   oqoo9)          );k=112-j*7;O(C(6o.!Z!Z#5o-!Y!Y#4~!X!X#3}
     !W  !W     #2    |!V!V#1{!U!U#0z!            T!T#/y!S!S#.x!R!R#-w!Q!Q#ooAv!P!P#+o#!O!O#*t!N!
       N#      oo       >s!M!M#oo=r!L!L#oo<q!K!K#   &pIo@:;= oUm#oo98m##oo9=8m#oo9oUm###oo9;=8m#o
               o9   oUm##oo9=oUm#oo98m####          o09]    #o1:^#o2;_#o3<o  ou#o4=a#o5>b#o6?c#o
             7@d#o8A e#o    9B    f#o:Cg#o;          D     h#o<Ei #o=Fj#o>   Gk#o?Hl#oo9os#####
           ));d=0                                          ;}          O:    for(x=y=0;x<8;++
          x)y|=                                                               d&(1<<u[x])?
          1<<                                                               x:0;return
           /*                                                               :9    */
            y                                                                ;    }
"
