The code defines several enums in the TypeScript namespace. Each enum represents a set of flags or options.

1. The `ErrorRecoverySet` enum defines flags for error recovery in the TypeScript parser. Each flag represents a type of recovery action that can be taken when encountering an error in the code.

2. The `AllowedElements` enum defines flags for specifying which types of elements are allowed in certain contexts. For example, the `ModuleDeclarations` flag indicates that module declarations are allowed.

3. The `Modifiers` enum defines flags for specifying the modifiers (e.g., private, public, readonly) for language elements such as variables and functions.

4. The `ASTFlags` enum defines flags for different aspects of the Abstract Syntax Tree (AST). For example, the `DotLHS` flag indicates that a dot expression is on the left-hand side of an assignment.

5. The `DeclFlags` enum defines flags for declaration aspects such as visibility (e.g., public, private) and staticness.

6. The `ModuleFlags` enum defines flags for module aspects such as visibility and whether the module is an enum or dynamic.

7. The `SymbolFlags` enum defines flags for symbol aspects such as visibility, mutability, and whether the symbol is a property or interface member.

8. The `VarFlags` enum defines flags for variable aspects such as visibility and whether the variable is ambient.NodeType.Neg = 15;
NodeType._map[16] = "Delete";
NodeType.Delete = 16;
NodeType._map[17] = "Await";
NodeType.Await = 17;
NodeType._map[18] = "In";
NodeType.In = 18;
NodeType._map[19] = "Dot";
NodeType.Dot = 19;
NodeType._map[20] = "From";
NodeType.From = 20;
NodeType._map[21] = "Is";
NodeType.Is = 21;
NodeType._map[22] = "InstOf";
NodeType.InstOf = 22;
NodeType._map[23] = "TypeOf";
NodeType.TypeOf = 23;
NodeType._map[24] = "NumberLit";
NodeType.NumberLit = 24;
NodeType._map[25] = "Name";
NodeType.Name = 25;
NodeType._map[26] = "TypeParam";
NodeType.TypeParam = 26;
NodeType._map[27] = "TypeRef";
NodeType.TypeRef = 27;
NodeType._map[28] = "Index";
NodeType.Index = 28;
NodeType._map[29] = "Call";
NodeType.Call = 29;
NodeType._map[30] = "New";
NodeType.New = 30;
NodeType._map[31] = "As";
NodeType.As = 31;
NodeType._map[32] = "FunctionDeclaration";
NodeType.FunctionDeclaration = 32;
NodeType._map[33] = "FunctionExpression";
NodeType.FunctionExpression = 33;
NodeType._map[34] = "ObjectDecl";
NodeType.ObjectDecl = 34;
NodeType._map[35] = "Parameter";
NodeType.Parameter = 35;
NodeType._map[36] = "Member";
NodeType.Member = 36;
NodeType._map[37] = "VarDecl";
NodeType.VarDecl = 37;
NodeType._map[38] = "ConstDecl";
NodeType.ConstDecl = 38;
NodeType._map[39] = "Return";
NodeType.Return = 39;
NodeType._map[40] = "Break";
NodeType.Break = 40;
NodeType._map[41] = "Continue";
NodeType.Continue = 41;
NodeType._map[42] = "Throw";
NodeType.Throw = 42;
NodeType._map[43] = "FOR";
NodeType.FOR = 43;
NodeType._map[44] = "FOR_IN";
NodeType.FOR_IN = 44;
NodeType._map[45] = "IF";
NodeType.IF = 45;
NodeType._map[46] = "SWITCH";
NodeType.SWITCH = 46;
NodeType._map[47] = "CASE";
NodeType.CASE = 47;
NodeType._map[48] = "DEFAULT";
NodeType.DEFAULT = 48;
NodeType._map[49] = "TRY";
NodeType.TRY = 49;
NodeType._map[50] = "CATCH";
NodeType.CATCH = 50;
NodeType._map[51] = "FINALLY";
NodeType.FINALLY = 51;
NodeType._map[52] = "BLOCK";
NodeType.BLOCK = 52;
NodeType._map[53] = "DoWhile";
NodeType.DoWhile = 53;
NodeType._map[54] = "While";
NodeType.While = 54;
NodeType._map[55] = "For";
NodeType.For = 55;
NodeType._map[56] = "With";
NodeType.With = 56;
NodeType._map[57] = "ExpStat";
NodeType.ExpStat = 57;
NodeType._map[58] = "TryCatch";
NodeType.TryCatch = 58;
NodeType._map[59] = "TryFinally";
NodeType.TryFinally = 59;
NodeType._map[60] = "Finally";
NodeType.Finally = 60;
NodeType._map[61] = "Catch";
NodeType.Catch = 61;
NodeType._map[62] = "List";
NodeType.List = 62;
NodeType._map[63] = "Script";
NodeType.Script = 63;
NodeType._map[64] = "ClassDeclaration";
NodeType.ClassDeclaration = 64;
NodeType._map[65] = "InterfaceDeclaration";
NodeType.InterfaceDeclaration = 65;
NodeType._map[66] = "ModuleDeclaration";
NodeType.ModuleDeclaration = 66;
NodeType._map[67] = "ImportDeclaration";
NodeType.ImportDeclaration = 67;
NodeType._map[68] = "ExportAssignment";
NodeType.ExportAssignment = 68;
NodeType._map[69] = "ArrowFunction";
NodeType.ArrowFunction = 69;
NodeType._map[70] = "Yield";
NodeType.Yield = 70;
NodeType._map[71] = "Any";
NodeType.Any = 71;
NodeType._map[72] = "String";
NodeType.String = 72;
NodeType._map[73] = "Boolean";
NodeType.Boolean = 73;
NodeType._map[74] = "Number";
NodeType.Number = 74;
NodeType._map[75] = "Void";
NodeType.Void = 75;
NodeType._map[76] = "ConstructorType";
NodeType.ConstructorType = 76;
NodeType._map[77] = "Module";
NodeType.Module = 77;
NodeType._map[78] = "Class";
NodeType.Class = 78;
NodeType._map[79] = "Interface";
NodeType.Interface = 79;
NodeType._map[80] = "DynamicModule";
NodeType.DynamicModule = 80;
NodeType._map[81] = "Object";
NodeType.Object = 81;
})(TypeScript || (TypeScript = {
}));
var TypeScript;
(function (TypeScript) {
    (function (NodeFlags) {
        NodeFlags._map = [];
        NodeFlags.Export = 1;
        NodeFlags.Ambient = 1 << 1;
        NodeFlags.Public = 1 << 2;
        NodeFlags.Private = 1 << 3;
        NodeFlags.Static = 1 << 4;
        NodeFlags.LocalStatic = 1 << 5;
        NodeFlags.GetAccessor = 1 << 6;
        NodeFlags.SetAccessor = 1 << 7;
        NodeFlags.OptionalName = 1 << 8;
        NodeFlags.AutomaticNewTarget = 1 << 9;
        NodeFlags.Bound = 1 << 10;
        NodeFlags.Computed = 1 << 11;
        NodeFlags.InitializedModule = 1 << 12;
        NodeFlags.Constant = 1 << 13;
        NodeFlags.OptionalReturn = 1 << 14;
        NodeFlags.PrivateMember = 1 << 15;
        NodeFlags.PublicMember = 1 << 16;
        NodeFlags.AvoidStmt = 1 << 17;
        NodeFlags.ExportAssignment = 1 << 18;
        NodeFlags.MultiLine = 1 << 19;
        NodeFlags.JavaScriptFile = 1 << 20;
        NodeFlags.PossibleOptionalParameter = 1 << 21;
        NodeFlags.ClassDefinition = 1 << 22;
        NodeFlags.CapturedBlockScope = 1 << 23;
        NodeFlags.BlockScopedMember = 1 << 24;
        NodeFlags.OctalLiteral = 1 << 25;
        NodeFlags.IsArrayElement = 1 << 26;
        NodeFlags.HasGlobalName = 1 << 27;
        NodeFlags.ImPLICITThis = 1 << 28;
        NodeFlags.EnumInitialized = 1 << 29;
        NodeFlags._map[0] = "Export";
        NodeFlags._map[1] = "Ambient";
        NodeFlags._map[2] = "Public";
        NodeFlags._map[3] = "Private";
        NodeFlags._map[4] = "Static";
        NodeFlags._map[5] = "LocalStatic";
        NodeFlags._map[6] = "GetAccessor";
        NodeFlags._map[7] = "SetAccessor";
        NodeFlags._map[8] = "OptionalName";
        NodeFlags._map[9] = "AutomaticNewTarget";
        NodeFlags._map[10] = "Bound";
        NodeFlags._map[11] = "Computed";
        NodeFlags._map[12] = "InitializedModule";
        NodeFlags._map[13] = "Constant";
        NodeFlags._map[14] = "OptionalReturn";
        NodeFlags._map[15] = "PrivateMember";
        NodeFlags._map[16] = "PublicMember";
        NodeFlags._map[17] = "AvoidStmt";
        NodeFlags._map[18] = "ExportAssignment";
        NodeFlags._map[19] = "MultiLine";
        NodeFlags._map[20] = "JavaScriptFile";
        NodeFlags._map[21] = "PossibleOptionalParameter";
        NodeFlags._map[22] = "ClassDefinition";
        NodeFlags._map[23] = "CapturedBlockScope";
        NodeFlags._map[24] = "BlockScopedMember";
        NodeFlags._map[25] = "OctalLiteral";
        NodeFlags._map[26] = "IsArrayElement";
        NodeFlags._map[27] = "HasGlobalName";
        NodeFlags._map[28] = "ImPLICITThis";
        NodeFlags._map[29] = "EnumInitialized";
    })(TypeScript.NodeFlags || (TypeScript.NodeFlags = {}));
    var NodeFlags = TypeScript.NodeFlags;
})(TypeScript || (TypeScript = {}));
Logging off.NodeType.Finally = 90;
        NodeType._map[91] = "Catch";
        NodeType.Catch = 91;
        NodeType._map[92] = "Param";
        NodeType.Param = 92;
        NodeType._map[93] = "Return";
        NodeType.Return = 93;
        NodeType._map[94] = "TypeRef";
        NodeType.TypeRef = 94;
        NodeType._map[95] = "Signature";
        NodeType.Signature = 95;
        NodeType._map[96] = "Index";
        NodeType.Index = 96;
        NodeType._map[97] = "Import";
        NodeType.Import = 97;
        NodeType._map[98] = "Export";
        NodeType.Export = 98;
        NodeType._map[99] = "With";
        NodeType.With = 99;
        NodeType._map[100] = "Label";
        NodeType.Label = 100;
        NodeType._map[101] = "LabeledStatement";
        NodeType.LabeledStatement = 101;
        NodeType._map[102] = "ModuleDeclaration";
        NodeType.ModuleDeclaration = 102;
        NodeType._map[103] = "ImportDeclaration";
        NodeType.ImportDeclaration = 103;
        NodeType._map[104] = "ExportAssignment";
        NodeType.ExportAssignment = 104;
        NodeType._map[105] = "QualifiedName";
        NodeType.QualifiedName = 105;
        NodeType._map[106] = "TypeParameter";
        NodeType.TypeParameter = 106;
        NodeType._map[107] = "TypeArgument";
        NodeType.TypeArgument = 107;
        NodeType._map[108] = "ArrayType";
        NodeType.ArrayType = 108;
        NodeType._map[109] = "FuncType";
        NodeType.FuncType = 109;
        NodeType._map[110] = "ConstructorType";
        NodeType.ConstructorType = 110;
        NodeType._map[111] = "Module";
        NodeType.Module = 111;
        NodeType._map[112] = "ClassDeclaration";
        NodeType.ClassDeclaration = 112;
        NodeType._map[113] = "InterfaceDeclaration";
        NodeType.InterfaceDeclaration = 113;
        NodeType._map[114] = "EnumDeclaration";
        NodeType.EnumDeclaration = 114;
        NodeType._map[115] = "EnumElement";
        NodeType.EnumElement = 115;
        NodeType._map[116] = "WildCard";
        NodeType.WildCard = 116;
        NodeType._map[117] = "Semicolon";
        NodeType.Semicolon = 117;
        NodeType._map[118] = "Debugger";
        NodeType.Debugger = 118;
    })(TypeScript.NodeType || (TypeScript.NodeType = {}));
    var NodeType = TypeScript.NodeType;
})(TypeScript || (TypeScript = {}));
Logging off.}
        };
        DualStringHashTable.prototype.map = function (fn, context) {
            this.primaryTable.map(fn, context);
            this.secondaryTable.map(fn, context);
        };
        DualStringHashTable.prototype.every = function (fn, context) {
            return this.primaryTable.every(fn, context) && this.secondaryTable.every(fn, context);
        };
        DualStringHashTable.prototype.some = function (fn, context) {
            return this.primaryTable.some(fn, context) || this.secondaryTable.some(fn, context);
        };
        DualStringHashTable.prototype.count = function () {
            return this.primaryTable.count() + this.secondaryTable.count();
        };
        DualStringHashTable.prototype.lookup = function (key) {
            var data = this.primaryTable.lookup(key);
            if(data != null) {
                return data;
            } else {
                return this.secondaryTable.lookup(key);
            }
        };
        return DualStringHashTable;
    })();
    TypeScript.DualStringHashTable = DualStringHashTable;    
    var HashEntry = (function () {
        function HashEntry(key, data) {
            this.key = key;
            this.data = data;
        }
        return HashEntry;
    })();
    TypeScript.HashEntry = HashEntry;    
    var IdentifierHashTable = (function () {
        function IdentifierHashTable(comparer) {
            this.buckets = [];
            this.count = 0;
            this.comparer = comparer;
        }
        IdentifierHashTable.prototype.addOrUpdate = function (key, data) {
            var bucket = this.getBucket(key);
            for(var i = 0; i < bucket.length; i++) {
                var entry = bucket[i];
                if(this.comparer(entry.key, key)) {
                    entry.data = data;
                    return false;
                }
            }
            bucket.push(new HashEntry(key, data));
            this.count++;
            return true;
        };
        IdentifierHashTable.prototype.lookup = function (key) {
            var bucket = this.getBucket(key);
            for(var i = 0; i < bucket.length; i++) {
                var entry = bucket[i];
                if(this.comparer(entry.key, key)) {
                    return entry.data;
                }
            }
            return null;
        };
        IdentifierHashTable.prototype.getAllKeys = function () {
            var result = [];
            for(var i = 0; i < this.buckets.length; i++) {
                var bucket = this.buckets[i];
                for(var j = 0; j < bucket.length; j++) {
                    var entry = bucket[j];
                    result.push(entry.key);
                }
            }
            return result;
        };
        IdentifierHashTable.prototype.map = function (fn, context) {
            for(var i = 0; i < this.buckets.length; i++) {
                var bucket = this.buckets[i];
                for(var j = 0; j < bucket.length; j++) {
                    var entry = bucket[j];
                    fn.call(context, entry.key, entry.data);
                }
            }
        };
        IdentifierHashTable.prototype.every = function (fn, context) {
            for(var i = 0; i < this.buckets.length; i++) {
                var bucket = this.buckets[i];
                for(var j = 0; j < bucket.length; j++) {
                    var entry = bucket[j];
                    if(!fn.call(context, entry.key, entry.data)) {
                        return false;
                    }
                }
            }
            return true;
        };
        IdentifierHashTable.prototype.some = function (fn, context) {
            for(var i = 0; i < this.buckets.length; i++) {
                var bucket = this.buckets[i];
                for(var j = 0; j < bucket.length; j++) {
                    var entry = bucket[j];
                    if(fn.call(context, entry.key, entry.data)) {
                        return true;
                    }
                }
            }
            return false;
        };
        IdentifierHashTable.prototype.count = function () {
            return this.count;
        };
        IdentifierHashTable.prototype.getBucket = function (key) {
            var hash = key.hashCode();
            var bucketIndex = hash % this.buckets.length;
            return this.buckets[bucketIndex];
        };
        return IdentifierHashTable;
    })();
    TypeScript.IdentifierHashTable = IdentifierHashTable;    
    var PredicatedHashTable = (function () {
        function PredicatedHashTable(comparer) {
            this.entries = [];
            this.comparer = comparer;
        }
        PredicatedHashTable.prototype.lookup = function (key) {
            for(var i = 0; i < this.entries.length; i++) {
                var entry = this.entries[i];
                if(this.comparer(entry.key, key)) {
                    return entry.data;
                }
            }
            return null;
        };
        PredicatedHashTable.prototype.map = function (fn, context) {
            for(var i = 0; i < this.entries.length; i++) {
                var entry = this.entries[i];
                fn.call(context, entry.key, entry.data);
            }
        };
        PredicatedHashTable.prototype.getAllKeys = function () {
            var result = [];
            for(var i = 0; i < this.entries.length; i++) {
                var entry = this.entries[i];
                result.push(entry.key);
            }
            return result;
        };
        PredicatedHashTable.prototype.every = function (fn, context) {
            for(var i = 0; i < this.entries.length; i++) {
                var entry = this.entries[i];
                if(!fn.call(context, entry.key, entry.data)) {
                    return false;
                }
            }
            return true;
        };
        PredicatedHashTable.prototype.some = function (fn, context) {
            for(var i = 0; i < this.entries.length; i++) {
                var entry = this.entries[i];
                if(fn.call(context, entry.key, entry.data)) {
                    return true;
                }
            }
            return false;
        };
        PredicatedHashTable.prototype.count = function () {
            return this.entries.length;
        };
        PredicatedHashTable.prototype.add = function (key, data) {
            this.entries.push(new HashEntry(key, data));
        };
        return PredicatedHashTable;
    })();
    TypeScript.PredicatedHashTable = PredicatedHashTable;    
    function makeIdentifierHashTable(capacity, comparer) {
        if (typeof capacity === "undefined") { capacity = 16; }
        if (typeof comparer === "undefined") { comparer = TypeScript.identifierStartsWith; }
        var buckets = [];
        for(var i = 0; i < capacity; i++) {
            buckets.push(new Array());
        }
        return new IdentifierHashTable(comparer);
    }
    TypeScript.makeIdentifierHashTable = makeIdentifierHashTable;
    function identifierStartsWith(candidate, prefix) {
        if(candidate.length < prefix.length) {
            return false;
        }
        for(var i = 0; i < prefix.length; i++) {
            if(candidate[i] != prefix[i]) {
                return false;
            }
        }
        return true;
    }
    TypeScript.identifierStartsWith = identifierStartsWith;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var IdentifierWalker = (function (_super) {
        __extends(IdentifierWalker, _super);
        function IdentifierWalker() {
            _super.apply(this, arguments);

        }
        return IdentifierWalker;
    })(TypeScript.SyntaxWalker);
    TypeScript.IdentifierWalker = IdentifierWalker;    
    var IdentifierNameWalker = (function (_super) {
        __extends(IdentifierNameWalker, _super);
        function IdentifierNameWalker() {
            _super.apply(this, arguments);

        }
        return IdentifierNameWalker;
    })(IdentifierWalker);
    TypeScript.IdentifierNameWalker = IdentifierNameWalker;    
    var PullSymbol = (function () {
        function PullSymbol(kind, name, declKind) {
            this.invalidate = false;
            this.kind = kind;
            this.name = name;
            this.declKind = declKind;
            this._declarations = [];
            this._container = null;
        }
        PullSymbol.prototype.getDeclarations = function () {
            return this._declarations;
        };
        PullSymbol.prototype.addDeclaration = function (decl) {
            this._declarations[this._declarations.length] = decl;
            this.invalidate = true;
        };
        PullSymbol.prototype.removeDeclaration = function (decl) {
            var declIndex = this._declarations.indexOf(decl);
            if(declIndex >= 0) {
                TypeScript.ArrayUtilities.removeAt(this._declarations, declIndex);
                this.invalidate = true;
            }
        };
        PullSymbol.prototype.setName = function (name) {
            this.name = name;
            this.invalidate = true;
        };
        PullSymbol.prototype.setInvalid = function () {
            this.invalidate = true;
        };
        PullSymbol.prototype.setResolved = function () {
            this.invalidate = false;
        };
        PullSymbol.prototype.invalidateType = function () {
            this.invalidate = true;
        };
        PullSymbol.prototype.isContainer = function () {
            return this._container != null || this.kind == TypeScript.PullElementKind.Enum || this.kind == TypeScript.PullElementKind.TypeAlias || this.kind == TypeScript.PullElementKind.DynamicModule || this.kind == TypeScript.PullElementKind.Container;
        };
        PullSymbol.prototype.isType = function () {
            return this.kind == TypeScript.PullElementKind.Type;
        };
        PullSymbol.prototype.isSignature = function () {
            return this.kind == TypeScript.PullElementKind.CallSignature || this.kind == TypeScript.PullElementKind.ConstructSignature || this.kind == TypeScript.PullElementKind.IndexSignature || this.kind == TypeScript.PullElementKind.ObjectType;
        };
        PullSymbol.prototype.isAccessor = function () {
            return this.kind == TypeScript.PullElementKind.GetAccessor || this.kind == TypeScript.PullElementKind.SetAccessor;
        };
        PullSymbol.prototype.isAlias = function () {
            return this.kind == TypeScript.PullElementKind.TypeAlias;
        };
        PullSymbol.prototype.isTypeParameter = function () {
            return this.kind === TypeScript.PullElementKind.TypeParameter || this.kind === TypeScript.PullElementKind.Type;
        };
        PullSymbol.prototype.isArray = function () {
            return this.isArrayNamedTypeReference() || this.isTypeParameter() && (this.getConstraint() && this.getConstraint().isArray());
        };
        PullSymbol.prototype.isNamedArray = function () {
            return this.isArray() && this.isArrayNamedTypeReference();
        };
        PullSymbol.prototype.isArrayNamedTypeReference = function () {
            return this.kind === TypeScript.PullElementKind.Class && this.name === "Array";
        };
        PullSymbol.prototype.isPrimitive = function () {
            return this.isArrayNamedTypeReference() || this.isTypeParameter() && (this.getConstraint() && this.getConstraint().isPrimitive());
        };
        PullSymbol.prototype.getIsSpecialized = function () {
            return this.isTypeParameter() && this._specializationCache && this._specializationCache.length > 0;
        };
        PullSymbol.prototype.getType = function () {
            return this;
        };
        PullSymbol.prototype.isOptional = function () {
            var useDecl = this.isTypeParameter() ? this.getConstraint() : this;
            return useDecl.hasFlag(PullElementFlags.Optional);
        };
        PullSymbol.prototype.isVarArg = function () {
            return this.isArray() && !this.isTypeParameter();
        };
        PullSymbol.prototype.getIsInTuple = function () {
            return this.isTypeParameter() && this.getRootSymbol().kind === TypeScript.PullElementKind.TupleType;
        };
        PullSymbol.prototype.getRootSymbol = function () {
            var rootSymbol = this;
            while(rootSymbol.partOfRootedType || (rootSymbol.kind === TypeScript.PullElementKind.TypeParameter && !rootSymbolThe previous code defines several data structures used by the TypeScript compiler. 

First, the `DualStringHashTable` class is a wrapper around two separate string hash tables. It provides functions for adding, updating, and looking up elements in the hash tables. The `map`, `every`, and `some` functions can be used to iterate over the elements in the hash tables.

Next, the `IdentifierHashTable` class is a hash table specifically for identifiers. It uses a comparer to determine if two identifiers are equal.

The `PredicatedHashTable` class is a hash table that only allows elements that satisfy a specific predicate. The `lookup`, `map`, `every`, `some`, and `count` functions are provided.

The `makeIdentifierHashTable` function is a factory function that creates an `IdentifierHashTable` with a specific capacity and comparer.

The `identifierStartsWith` function is a comparer that determines if an identifier starts with a specific prefix.

The `IdentifierWalker` class is a subclass of the `SyntaxWalker` class that walks over identifiers in a syntax tree.

The `IdentifierNameWalker` class is a subclass of the `IdentifierWalker` class that walks over identifier names in a syntax tree.

The `PullSymbol` class represents a symbol in a TypeScript program. It has properties for the symbol's kind, name, declaration kind, declarations, and container. It also has methods for adding, removing, and looking up declarations.

The `HashTable` class is a generic hash table implementation. It uses a hash function and an equality function to determine if two keys are equal. It provides functions for adding, removing, and looking up elements in the hash table.

The `SimpleHashTable` class is a simplified hash table implementation that uses two arrays to store the keys and values. It provides functions for adding and looking up elements in the hash table.The remaining part of the previous code defines the `AST` class and its subclasses. 

The `AST` class is the base class for all abstract syntax tree nodes in the TypeScript compiler. It has properties for the node's type, type annotations, flags, and comments. It also has methods for type checking and emitting the node.

The `AST` class has several subclasses that represent different types of AST nodes, such as `ThisAST`, `NullAST`, `FalseAST`, `TrueAST`, `SuperAST`, etc. Each subclass overrides the `emit` method to emit the appropriate code for that node type.

The `AST` class also has several helper methods, such as `isExpression`, `isStatementOrExpression`, `isCompoundStatement`, `isLeaf`, and `isDeclaration`, that can be used to determine the type of an AST node.

The `print` method can be used to print the AST node and its children in a human-readable format. It takes a `PrintContext` object as an argument, which is used to keep track of the current indentation level and line number.

The `context.startLine` method is a helper method that adds a new line and the appropriate number of spaces to the output. The `lineCol` object is used to keep track of the current line and column number.The remaining part of the code defines the `Identifier` class. 

The `Identifier` class represents an identifier in the TypeScript compiler. It is a subclass of the `AST` class.

The `Identifier` class has properties for the actual text of the identifier and whether or not it contains escape sequences. It also has a `sym` property that represents the symbol associated with the identifier. The `cloId` property is used for the closure ID of the identifier.

The `Identifier` class overrides the `emit` method to emit the appropriate code for the identifier. It also overrides the `typeCheck` method to perform type checking on the identifier.

The `printLabel` method is used to print the label of the identifier.

The `getDocComments` method is used to retrieve the documentation comments associated with the identifier.

The `getResolvedIdentifierName` method is a static method that takes an identifier name as input and returns the resolved name, which is the name with any escape sequences replaced by their corresponding characters.The remaining code defines several classes that are subclasses of the `Expression` class.

The `UnaryExpression` class represents a unary expression in the TypeScript compiler. It is a subclass of the `Expression` class. It has a property `operand` that represents the operand of the unary expression. It also has properties `targetType` and `castTerm` that are used for type checking and code generation.

The `UnaryExpression` class overrides the `typeCheck` method to perform type checking on the unary expression. It also overrides the `addToControlFlow` method to add the unary expression to the control flow graph.

The `ArrayLitExpression` class represents an array literal expression in the TypeScript compiler. It is a subclass of the `UnaryExpression` class. It has a property `elements` that represents the elements of the array literal.

The `ObjectLitExpression` class represents an object literal expression in the TypeScript compiler. It is a subclass of the `UnaryExpression` class. It has a property `properties` that represents the properties of the object literal.

The `ThrowStatement` class represents a throw statement in the TypeScript compiler. It is a subclass of the `UnaryExpression` class. It has a property `operand` that represents the expression being thrown.

The `TypeofExpression` class represents a typeof expression in the TypeScript compiler. It is a subclass of the `UnaryExpression` class. It has a property `operand` that represents the expression to evaluate.

The `DeleteExpression` class represents a delete expression in the TypeScript compiler. It is a subclass of the `UnaryExpression` class. It has a property `operand` that represents the expression to evaluate.The remaining code defines several classes that are subclasses of the `Expression` class.

The `CallExpression` class represents a call expression in the TypeScript compiler. It is a subclass of the `Expression` class. It has properties `target` and `arguments` that represent the target function and the arguments of the call expression. It also has a property `signature` that represents the signature of the call expression. The `minChar` property represents the minimum character position of the call expression.

The `CallExpression` class overrides the `typeCheck` method to perform type checking on the call expression.

The `CallExpression` class does not implement the `emit` method, so it uses the implementation from the `Expression` class.The remaining code defines several other classes that are subclasses of the `Expression` class.

The `BinaryExpression` class represents a binary expression in the TypeScript compiler. It is a subclass of the `Expression` class. It has properties `operand1` and `operand2` that represent the two operands of the binary expression.

The `BinaryExpression` class overrides the `typeCheck` method to perform type checking on the binary expression.

The `BinaryExpression` class overrides the `emit` method to emit the binary expression in the emitted JavaScript code.The `ConditionalExpression` class represents a conditional expression in the TypeScript compiler. It is a subclass of the `Expression` class. It has properties `operand1`, `operand2`, and `operand3` that represent the three operands of the conditional expression.

The `ConditionalExpression` class overrides the `typeCheck` method to perform type checking on the conditional expression.

The `ConditionalExpression` class overrides the `emit` method to emit the conditional expression in the emitted JavaScript code.

The `NumberLiteral` class represents a number literal in the TypeScript compiler. It is a subclass of the `Expression` class. It has properties `value` and `hasEmptyFraction` that represent the value of the number literal and whether it has an empty fraction, respectively.

The `NumberLiteral` class overrides the `typeCheck` method to set the type of the number literal.

The `NumberLiteral` class overrides the `emit` method to emit the number literal in the emitted JavaScript code.

The `RegexLiteral` class represents a regular expression literal in the TypeScript compiler. It is a subclass of the `Expression` class. It has a property `regex` that represents the regular expression literal.

The `RegexLiteral` class overrides the `typeCheck` method to set the type of the regular expression literal.

The `RegexLiteral` class overrides the `emit` method to emit the regular expression literal in the emitted JavaScript code.The `StringLiteral` class represents a string literal in the TypeScript compiler. It is a subclass of the `Expression` class. It has a property `text` that represents the text of the string literal.

The `StringLiteral` class overrides the `emit` method to emit the string literal in the emitted JavaScript code.

The `StringLiteral` class overrides the `typeCheck` method to set the type of the string literal.

The `ModuleElement` class is a base class for all elements in a module declaration.

The `ImportDeclaration` class represents an import declaration in the TypeScript compiler. It is a subclass of the `ModuleElement` class. It has properties `id` and `alias` that represent the identifier and alias of the import declaration, respectively.

The `ImportDeclaration` class overrides the `emit` method to emit the import declaration in the emitted JavaScript code.

The `ImportDeclaration` class overrides the `typeCheck` method to perform type checking on the import declaration.

The `BoundDecl` class is a base class for all bound declarations in the TypeScript compiler. It has properties `id`, `nestingLevel`, `init`, `typeExpr`, `varFlags`, and `sym` that represent the identifier, nesting level, initializer, type expression, variable flags, and symbol of the bound declaration, respectively.

The `BoundDecl` class overrides the `isDeclaration` and `isStatementOrExpression` methods to indicate that it is a declaration and a statement or expression.

The `BoundDecl` class overrides the `typeCheck` method to perform type checking on the bound declaration.

The `BoundDecl` class overrides the `printLabel` method to return a string representation of the bound declaration.

The `VarDecl` class represents a variable declaration in the TypeScript compiler. It is a subclass of the `BoundDecl` class. It has a property `nest` that represents the nesting level of the variable declaration.

The `VarDecl` class overrides the `isAmbient`, `isExported`, and `isStatic` methods to check the variable flags.

The `VarDecl` class overrides the `emit` method to emit the variable declaration in the emitted JavaScript code.

The `VarDecl` class overrides the `treeViewLabel` method to return a string representation of the variable declaration.The remaining part of the code is defining the `FuncDecl` class, which represents a function declaration in the TypeScript compiler.

The `FuncDecl` class is a subclass of the `BoundDecl` class. It has properties `name`, `bod`, `isConstructor`, `arguments`, `vars`, `scopes`, `statics`, `hint`, `fncFlags`, `returnTypeAnnotation`, `variableArgList`, `jumpRefs`, `internalNameCache`, `tmp1Declared`, `enclosingFnc`, `freeVariables`, `unitIndex`, `classDecl`, `boundToProperty`, `isOverload`, `innerStaticFuncs`, `isTargetTypedAsMethod`, `isInlineCallLiteral`, `accessorSymbol`, `leftCurlyCount`, `rightCurlyCount`, `returnStatementsWithExpressions`, `scopeType`, and `endingToken` that represent various properties of the function declaration.

The `FuncDecl` class has methods `isDeclaration`, `internalName`, `hasSelfReference`, `setHasSelfReference`, `hasSuperReferenceInFatArrowFunction`, `setHasSuperReferenceInFatArrowFunction`, `addCloRef`, `addJumpRef`, `buildControlFlow`, `typeCheck`, `emit`, `getNameText`, `isMethod`, `isCallMember`, `isConstructMember`, `isIndexerMember`, and `isSpecialFn` that perform various functionalities related to the function declaration.

The `FuncDecl` class overrides the `isDeclaration` method to indicate that it is a declaration.

The `FuncDecl` class overrides the `internalName` method to return the internal name of the function declaration.

The `FuncDecl` class overrides the `hasSelfReference` and `setHasSelfReference` methods to check and set the `HasSelfReference` flag of the function declaration.

The `FuncDecl` class overrides the `hasSuperReferenceInFatArrowFunction` and `setHasSuperReferenceInFatArrowFunction` methods to check and set the `HasSuperReferenceInFatArrowFunction` flag of the function declaration.

The `FuncDecl` class overrides the `addCloRef` method to add a closure reference to the function declaration.

The `FuncDecl` class overrides the `addJumpRef` method to add a jump reference to the function declaration.

The `FuncDecl` class overrides the `buildControlFlow` method to build the control flow graph of the function declaration.

The `FuncDecl` class overrides the `typeCheck` method to perform type checking on the function declaration.

The `FuncDecl` class overrides the `emit` method to emit the function declaration in the emitted JavaScript code.

The `FuncDecl` class overrides the `getNameText` method to return the name of the function declaration.

The `FuncDecl` class has methods `isMethod`, `isCallMember`, `isConstructMember`, `isIndexerMember`, and `isSpecialFn` that check the flags of the function declaration to determine its type.The remaining part of the code defines the `LocationInfo`, `Script`, and `AddExternallyVisibleImportedSymbol` classes.

The `LocationInfo` class represents location information for a file. It has properties `filename`, `lineMap`, and `unitIndex` that represent the filename, line map, and unit index of the file.

The `Script` class is a subclass of the `AST` class. It represents a TypeScript script. It has properties `locationInfo`, `referencedFiles`, `requiresGlobal`, `requiresExtendsBlock`, `isResident`, `isDeclareFile`, `hasBeenTypeChecked`, `topLevelMod`, `leftCurlyCount`, `rightCurlyCount`, `containsUnicodeChar`, `containsUnicodeCharInComment`, and `externallyVisibleImportedSymbols` that represent various properties of the script.

The `Script` class has methods `setCachedEmitRequired`, `typeCheck`, `treeViewLabel`, `emitRequired`, and `emit` that perform various functionalities related to the script.

The `Script` class overrides the `setCachedEmitRequired` method to set the `cachedEmitRequired` property of the script.

The `Script` class overrides the `typeCheck` method to perform type checking on the script.

The `Script` class overrides the `treeViewLabel` method to return a label for the script.

The `Script` class overrides the `emitRequired` method to determine if the script needs to be emitted.

The `Script` class overrides the `emit` method to emit the script in the emitted JavaScript code.

The `AddExternallyVisibleImportedSymbol` method adds an externally visible imported symbol to the script. If the symbol is not externally visible, an error message is displayed. The symbol is then added to the `externallyVisibleImportedSymbols` property of the script.The `LabeledStatement` class represents a labeled statement in TypeScript. It has properties `labels` and `stmt` that represent the labels and the statement of the labeled statement.

The `LabeledStatement` class overrides the `emit` method to emit the labeled statement in the emitted JavaScript code.The `Block` class represents a block statement in TypeScript. It has properties `statements` and `isStatementBlock` that represent the statements inside the block and whether it is a statement block or not.

The `Block` class overrides the `emit` method to emit the block statement in the emitted JavaScript code. It also overrides the `addToControlFlow` method to add the block statement to the control flow graph.

The `Jump` class is an abstract class that represents a jump statement (break or continue) in TypeScript. It has properties `target` and `resolvedTarget` that represent the target label of the jump statement and the resolved target statement, respectively. It also has methods `hasExplicitTarget` and `setResolvedTarget` to check if the jump statement has an explicit target and to set the resolved target statement.

The `Jump` class overrides the `addToControlFlow` method to add the jump statement to the control flow graph. It also overrides the `emit` method to emit the jump statement in the emitted JavaScript code.

The `WhileStatement` class represents a while statement in TypeScript. It has properties `cond` and `body` that represent the condition and body of the while statement.

The `WhileStatement` class overrides the `emit` method to emit the while statement in the emitted JavaScript code. It also overrides the `typeCheck` method to type check the while statement and the `addToControlFlow` method to add the while statement to the control flow graph.The remaining part of the function includes code for the `DoWhileStatement` and `IfStatement` classes.

The `DoWhileStatement` class represents a do-while statement in TypeScript. It has properties `body`, `whileAST`, and `cond` that represent the body, `while` keyword AST, and condition of the do-while statement.

The `DoWhileStatement` class overrides the `emit` method to emit the do-while statement in the emitted JavaScript code. It also overrides the `typeCheck` method to type check the do-while statement and the `addToControlFlow` method to add the do-while statement to the control flow graph.

The `IfStatement` class represents an if statement in TypeScript. It has properties `cond`, `thenBod`, `elseBod`, and `statement` that represent the condition, then body, else body, and statement span of the if statement.

The `IfStatement` class overrides the `emit` method to emit the if statement in the emitted JavaScript code. It also overrides the `typeCheck` method to type check the if statement and the `addToControlFlow` method to add the if statement to the control flow graph.Add the body of the `ForInStatement` to the control flow graph by calling the `addToControlFlow` method on it.

```
this.body.addToControlFlow(context);
```

Create a new basic block for the loop condition and add it as a successor to the loop start block.

```
var loopCondition = new TypeScript.BasicBlock();
loopStart.addSuccessor(loopCondition);
```

Visit the loop condition node and add its contents to the control flow graph.

```
context.current = loopCondition;
context.walk(this.cond, this);
```

Create a new basic block for the loop body and add it as a successor to both the loop condition block and the loop start block.

```
var loopBody = new TypeScript.BasicBlock();
loopCondition.addSuccessor(loopBody);
loopStart.addSuccessor(loopBody);
```

Set the current block to the loop body block and visit the loop body node to add its contents to the control flow graph.

```
context.current = loopBody;
context.walk(this.body, this);
```

After the loop body, create a new basic block for the loop end and add it as a successor to the loop condition block.

```
var loopEnd = new TypeScript.BasicBlock();
loopCondition.addSuccessor(loopEnd);
```

Set the current block to the loop end block and add it as a successor to the loop header block.

```
context.current = loopEnd;
loopHeader.addSuccessor(loopEnd);
```

Finally, set the current block to the loop end block.

```
context.current = loopEnd;
```

This completes the implementation of the `ForInStatement` class.// Emit the "switch" keyword and the expression being switched on
emitter.writeToOutput("switch (");
emitter.emitJavascript(this.val, TypeScript.TokenID.Switch, false);
emitter.writeToOutput(")");

// Emit the list of switch cases
emitter.emitJavascriptList(this.caseList, null, TypeScript.TokenID.Switch, false, false, false);

// Emit the "default" case if it exists
if (this.defaultCase) {
  emitter.emitJavascript(this.defaultCase, TypeScript.TokenID.Switch, false);
}

emitter.recordSourceMappingEnd(this);
emitter.emitParensAndCommentsInPlace(this, false);
```

The method starts by emitting the "switch" keyword and the expression being switched on. It then emits the list of switch cases using the `emitJavascriptList` method on the emitter. This method takes care of emitting the case keyword and the case expression for each case, as well as the statements inside each case.

Finally, if there is a default case, it is emitted using the `emitJavascript` method on the emitter.

The method ends by recording the source mapping and emitting any parens and comments that are associated with the switch statement.The remaining code defines the `CaseStatement`, `TypeReference`, and `TryFinally` classes.

The `CaseStatement` class represents a case statement in a switch statement. It has an `expr` property that represents the expression being compared in the case statement, and a `body` property that represents the statements inside the case.

The `TypeReference` class represents a reference to a type. It has a `term` property that represents the type being referenced, and an `arrayCount` property that represents the number of array dimensions.

The `TryFinally` class represents a try-finally statement. It has a `tryNode` property that represents the statements in the try block, and a `finallyNode` property that represents the statements in the finally block.

I hope this gives you a better understanding of the remaining code. Let me know if you have any further questions!This code defines the `Catch` class, which represents a catch statement in a try-catch statement. It has a `param` property that represents the catch parameter, and a `body` property that represents the statements inside the catch block.

The `emit` method is responsible for emitting the JavaScript code for the catch statement.

The `addToControlFlow` method is responsible for adding the catch statement to the control flow graph.

The `typeCheck` method is responsible for type checking the catch statement.

Finally, the code returns the `TryCatch`, `Try`, and `Catch` classes, making them accessible outside of the module.The remaining part of the code defines the `Finally` and `Comment` classes.

The `Finally` class represents a finally block in a try-catch-finally statement. It has a `body` property that represents the statements inside the finally block.

The `emit` method is responsible for emitting the JavaScript code for the finally block.

The `addToControlFlow` method is responsible for adding the finally block to the control flow graph.

The `typeCheck` method is responsible for type checking the finally block.

The `Comment` class represents a comment in the code. It has properties for the comment content, whether it is a block comment, and whether it ends the line.

The `getText` method returns an array of the lines of the comment content.

The `isDocComment` method checks if the comment is a JSDoc comment.

The `getDocCommentText` method returns the cleaned JSDoc comment content.

The `consumeLeadingSpace` function consumes leading spaces in a line of text.

The `isSpaceChar` function checks if a character at a specific index in a line of text is a space character.

The `cleanDocCommentLine` function cleans a line of JSDoc comment, removing leading spaces and calculating the number of spaces removed.

The `cleanJSDocComment` function cleans the JSDoc comment content, removing leading spaces from each line.

The `writeLineToOutput` method of the `Emitter` class is responsible for writing a line of text to the output.The remaining part of the function continues to emit different syntax elements.

The `writeCaptureThisStatement` method writes the code for capturing the current value of `this` in a variable.

The `setInVarBlock` method sets the number of variable lists in the current context.

The `setInObjectLiteral` method sets whether the current context is an object literal.

The `setContainer` method sets the current container (module, class, function, etc.).

The `getIndentString` method returns the string used for indentation, which is either empty (for minimal whitespace) or the current indentation level.

The `emitIndent` method emits the current indentation.

The `emitCommentInPlace` method emits a comment in place, adding the necessary indentation and line breaks.

The `emitParensAndCommentsInPlace` method emits parentheses and comments in place, considering whether the node is parenthesized and whether comments should be emitted.

The `emitObjectLiteral` method emits an object literal, including the opening and closing braces, the child properties, and the necessary indentation.

The `emitArrayLiteral` method emits an array literal, including the opening and closing brackets, the child elements, and the necessary indentation.

The `emitNew` method emits a `new` expression, including the `new` keyword, the target expression or type reference, and the arguments.

The `tryEmitConstant` method tries to emit a constant value if it can be determined at compile time.

The `emitCall` method emits a function call or method call, including the target expression, the arguments, and handling of special cases like super calls.The remaining part of the function continues to emit different syntax elements.

The `emitConstructorCalls` method emits the constructor calls for a class, including the `super` constructor calls.

The `emitInnerFunction` method emits an inner function, including the function keyword, the function name, the function parameters, and the function body. It also handles special cases for accessor functions, constructor functions, and functions with default arguments.

The `emitParensAndCommentsInPlace` method emits parentheses and comments in place, considering whether the node is parenthesized and whether comments should be emitted.

The `emitIndent` method emits the current indentation.

The `emitJavascriptList` method emits a list of JavaScript elements, including the child elements separated by a delimiter.

The `writeToOutput` method writes a string to the output.

The `writeLineToOutput` method writes a string followed by a line break to the output.

The `recordSourceMappingStart` method records the start of a source mapping.

The `recordSourceMappingEnd` method records the end of a source mapping.

The `recordSourceMappingNameStart` method records the start of a source mapping for a named function.The remaining part of the code emits a JavaScript module.

The `emitJavascriptModule` method first checks if the module is a TypeScript or STR file and modifies the module name accordingly.
Then, it checks if the module is dynamic and sets the output file accordingly.
The method then sets the container and saves the current state of the emitter.
If the module is a dynamic module, it creates a new source mapper and sets the source mappings.
The method then starts recording the source mapping for the module and checks if the module target is asynchronous.
If the module target is asynchronous, it creates the dependencies and import statements for the module.
Finally, the method emits the JavaScript code for the module and restores the previous state of the emitter.The `emitIndex` method emits JavaScript code for indexing an object.
The method first sets the `inObjectLiteral` flag to `false` and emits the JavaScript code for the first operand.
Then, it writes an opening bracket `[` and emits the JavaScript code for the second operand, separated by commas.
Finally, it writes a closing bracket `]` and resets the `inObjectLiteral` flag to its previous value.

The `emitStringLiteral` method simply writes the given string literal to the output.

The `emitJavascriptFunction` method emits JavaScript code for a function declaration.
If the function is a signature or an overload, it returns without emitting anything.
The method then sets the container based on whether the function is a constructor or a regular function.
It also saves the current state of the emitter's `thisFnc` property and sets it to the function being emitted.
Finally, the method restores the previous container and `thisFnc` value.The remaining part of the `emitJavascript` method is as follows:

```typescript
            var emitDiag = this.errorReporter.getEmitterError(moduleDecl);
            if(emitDiag) {
                if(emitDiag.minChar >= 0 && emitDiag.minChar < emitDiag.limChar) {
                    var span = TypeScript.getSpan(document, emitDiag.minChar, emitDiag.limChar - emitDiag.minChar);
                    this.emitComments(span.start(), false);
                    this.emitInnerComments(moduleDecl, true, false);
                    this.writeToOutput("\n");
                    this.writeToOutput(emitDiag.message());
                    this.writeToOutput("\n");
                    this.emitInnerComments(moduleDecl, false, true);
                    this.emitComments(span.end(), true);
                }
            } else {
                this.emitInnerComments(moduleDecl, true);
                this.emitPrologue(moduleDecl.preComments, true);
                this.recordSourceMappingStart(moduleDecl);
                var svModuleName = this.moduleName;
                var svEmitOptions = this.emitState;
                this.moduleName = this.getNameText(moduleDecl.name, false);
                if(this.emitState.container == EmitContainer.Prog && this.isWholeFile()) {
                    if(moduleDecl.prettyName) {
                        this.writeToOutput("var ");
                        this.writeToOutput(this.moduleName);
                        this.writeToOutput(" = ");
                        this.writeLineToOutput(moduleDecl.prettyName + ";");
                        this.emitIndent();
                        this.emitHelpersList();
                    }
                }
                if(moduleDecl.amdDependencies && this.emitState.container != EmitContainer.Prog) {
                    this.writeToOutput("define([");
                    for(var i = 0, n = moduleDecl.amdDependencies.length; i < n; i++) {
                        if(i != 0) {
                            this.writeToOutput(", ");
                        }
                        this.writeToOutput("'" + moduleDecl.amdDependencies[i] + "'");
                    }
                    this.writeToOutput("], " + this.moduleName + "");
                }
                this.recordSourceMappingStart(moduleDecl.name);
                this.recordSourceMappingEnd(moduleDecl.name);
                if(moduleDecl.members.length) {
                    var saveDecl = this.thisDecl;
                    if(emitState == null || (emitState.container != EmitContainer.Constructor && emitState.container != EmitContainer.DynamicModule)) {
                        this.thisDecl = moduleDecl;
                    }
                    this.pushDecl(moduleDecl);
                    this.writeLineToOutput(" {");
                    this.indenter.increaseIndent();
                    if(emitState == null || (emitState.container != EmitContainer.Constructor && emitState.container != EmitContainer.DynamicModule)) {
                        if(moduleDecl.stringLiteral) {
                            this.emitParensAndCommentsInPlace(moduleDecl.stringLiteral, true, false);
                            this.writeToOutput("/* ");
                            this.writeToOutput(moduleDecl.stringLiteral.actualText);
                            this.writeToOutput(" */");
                            this.emitParensAndCommentsInPlace(moduleDecl.stringLiteral, false, false);
                            this.writeLineToOutput("");
                            if(this.emitState.container == EmitContainer.Prog && this.isWholeFile()) {
                                this.writeLineToOutput("    var " + this.moduleName + " = " + moduleDecl.stringLiteral.actualText + ";");
                            }
                            if(this.emitState.container == EmitContainer.Prog && this.isWholeFile()) {
                                this.emitIndent();
                                this.emitHelpersList();
                            }
                        }
                    }
                    var saveInArrow = this.setInArrowDecl(true);
                    var shouldCaptureThis1 = Emitter.shouldCaptureThis(moduleDecl);
                    if(moduleDecl.stringLiteral) {
                        this.recordSourceMappingStart(moduleDecl.stringLiteral);
                    } else {
                        this.recordSourceMappingStart(moduleDecl);
                    }
                    this.recordSourceMappingNameStart(this.moduleName);
                    this.emitComments(moduleDecl.name.start(), true);
                    if(this.emitState.container == EmitContainer.Prog && this.isWholeFile() && moduleDecl.stringLiteral == null) {
                        this.writeToOutput("    var ");
                    }
                    this.writeToOutput(this.moduleName);
                    if(this.emitState.container == EmitContainer.Prog && this.isWholeFile() && moduleDecl.stringLiteral == null) {
                        this.writeToOutput(" = (function () ");
                    }
                    this.writeLineToOutput(" {");
                    this.indenter.increaseIndent();
                    if(moduleDecl.stringLiteral == null || this.emitState.container != EmitContainer.Prog || !this.isWholeFile()) {
                        this.writeCaptureThisStatement(shouldCaptureThis1);
                    }
                    if(moduleDecl.stringLiteral) {
                        this.emitParensAndCommentsInPlace(moduleDecl.stringLiteral, true);
                        this.writeToOutput("/* ");
                        this.writeToOutput(moduleDecl.stringLiteral.actualText);
                        this.writeToOutput(" */");
                        this.emitParensAndCommentsInPlace(moduleDecl.stringLiteral, false);
                        this.writeLineToOutput("");
                        if(this.emitState.container == EmitContainer.Prog && this.isWholeFile()) {
                            var id = this.moduleName;
                            if((id.charCodeAt(0) === TypeScript.CharacterCodes.doubleQuote) || (id.charCodeAt(0) === TypeScript.CharacterCodes.singleQuote)) {
                                id = id.substring(1, id.length - 1);
                            }
                            id = TypeScript.stripStartAndEndQuotes(id);
                            this.writeLineToOutput("    return global." + id + ";");
                        }
                    }
                    var lastMember = null;
                    for(var i = 0; i < moduleDecl.members.length; i++) {
                        var m = moduleDecl.members[i];
                        if(m.nodeType == TypeScript.NodeType.VariableDeclaration) {
                            this.recordSourceMappingStart(m);
                            this.emitIndent();
                            this.emitJavascriptVarDecl(m, TypeScript.TokenID.Comma);
                            this.recordSourceMappingEnd(m);
                        } else {
                            lastMember = m;
                        }
                    }
                    if(lastMember && (lastMember.nodeType != TypeScript.NodeType.FunctionDeclaration) && (lastMember.nodeType != TypeScript.NodeType.ClassDeclaration)) {
                        this.writeLineToOutput("");
                    }
                    this.emitDirectivePrologues(moduleDecl,
                    (function (p) {
                        return (p.flags & TypeScript.PNodeFlags.IsStatement) != TypeScript.PNodeFlags.None || (p.nodeType == TypeScript.NodeType.ExpressionStatement && (p).isDeclaration);
                    }));
                    this.emitCommentsArray(moduleDecl.members, true);
                    for(var i = 0; i < moduleDecl.members.length; i++) {
                        var m = moduleDecl.members[i];
                        if(m.nodeType == TypeScript.NodeType.Field) {
                            this.emitIndent();
                            var fld = <TypeScript.FieldDeclaration>m;
                            if((fld.varFlags & TypeScript.VarFlags.Static) == TypeScript.VarFlags.Static) {
                                this.emitJavascript(fld, TypeScript.TokenID.OpenParen, false);
                            } else {
                                this.writeToOutput("this.");
                                this.emitJavascript(fld, TypeScript.TokenID.OpenParen, false);
                            }
                        } else {
                            this.emitJavascript(m, TypeScript.TokenID.Semicolon, false);
                        }
                    }
                    this.emitCommentsArray(moduleDecl.members, false);
                    if(moduleDecl.stringLiteral == null || this.emitState.container != EmitContainer.Prog || !this.isWholeFile()) {
                        if(shouldCaptureThis1) {
                            this.emitComments(moduleDecl.closeBraceLeadingComments, true);
                            this.emitIndent();
                            this.recordSourceMappingStart(moduleDecl.closeBraceToken);
                            this.writeToOutput("}).call(");
                            if(this.emitState.container == EmitContainer.Constructor) {
                                this.writeToOutput("this);");
                            } else {
                                this.recordSourceMappingStart(moduleDecl.name);
                                this.writeToOutput("this);");
                                this.recordSourceMappingEnd(moduleDecl.name);
                            }
                            this.recordSourceMappingEnd(moduleDecl.closeBraceToken);
                            this.emitComments(moduleDecl.closeBraceLeadingComments, false);
                        } else {
                            this.writeLineToOutput("");
                            this.emitIndent();
                            this.recordSourceMappingStart(moduleDecl.closeBraceToken);
                            this.writeToOutput("})");
                            this.recordSourceMappingEnd(moduleDecl.closeBraceToken);
                            this.writeToOutput(";");
                        }
                    }
                    this.indenter.decreaseIndent();
                    this.emitIndent();
                    this.writeToOutput("})");
                    if(moduleDecl.stringLiteral && this.emitState.container == EmitContainer.Prog && this.isWholeFile()) {
                        var id = this.moduleName;
                        if((id.charCodeAt(0) === TypeScript.CharacterCodes.doubleQuote) || (id.charCodeAt(0) === TypeScript.CharacterCodes.singleQuote)) {
                            id = id.substring(1, id.length - 1);
                        }
                        id = TypeScript.stripStartAndEndQuotes(id);
                        this.writeLineToOutput("(this." + id + " || (this." + id + " = " + this.moduleName + "));");
                    } else {
                        this.writeLineToOutput(";");
                    }
                    this.thisDecl = saveDecl;
                    this.emitPrologue(moduleDecl.preComments, false);
                    this.recordSourceMappingEnd(moduleDecl);
                    if(this.emitState.container == EmitContainer.Prog && this.isWholeFile() && moduleDecl.stringLiteral == null) {
                        this.emitIndent();
                        this.emitHelpersList();
                    }
                    this.popDecl(moduleDecl);
                    this.indenter.decreaseIndent();
                    this.emitIndent();
                    this.writeLineToOutput("}");
                } else {
                    if(moduleDecl.stringLiteral == null) {
                        this.recordSourceMappingStart(moduleDecl.members[0]);
                        this.recordSourceMappingEnd(moduleDecl.members[0]);
                        this.recordSourceMappingStart(moduleDecl.members[0]);
                        this.writeToOutput("}");
                        this.recordSourceMappingEnd(moduleDecl.members[0]);
                    } else {
                        this.recordSourceMappingStart(moduleDecl.stringLiteral);
                        this.recordSourceMappingEnd(moduleDecl.stringLiteral);
                        this.recordSourceMappingStart(moduleDecl.stringLiteral);
                        this.writeLineToOutput("}");
                        this.recordSourceMappingEnd(moduleDecl.stringLiteral);
                    }
                    this.emitPrologue(moduleDecl.preComments, false);
                    this.recordSourceMappingEnd(moduleDecl);
                    if(this.emitState.container == EmitContainer.Prog && this.isWholeFile() && moduleDecl.stringLiteral == null) {
                        this.emitIndent();
                        this.emitHelpersList();
                    }
                }
                this.moduleName = svModuleName;
                this.emitState = svEmitOptions;
            }
            return false;
        };
        Emitter.prototype.emitBaseExpression = function (expr) {
            if(expr.nodeType == TypeScript.NodeType.Super || expr.nodeType == TypeScript.NodeType.StringLit || expr.nodeType == TypeScript.NodeType.NumberLit) {
                this.writeToOutput("null");
            } else {
                this.emitJavascript(expr, TypeScript.TokenID.Comma, false);
            }
        };
        Emitter.prototype.emitThis = function () {
            if(this.emitState.container == EmitContainer.Constructor) {
                this.writeToOutput("_this");
            } else {
                this.writeToOutput("this");
            }
        };
        Emitter.prototype.emitBlock = function (stmt, needBraces) {
            if(stmt && (stmt.nodeType == TypeScript.NodeType.Block || stmt.nodeType == TypeScript.NodeType.Try)) {
                this.emitJavascript(stmt, TypeScript.TokenID.Comma, false);
            } else {
                if(needBraces) {
                    this.writeLineToOutput(" {");
                    this.indenter.increaseIndent();
                    if(stmt) {
                        this.emitComments(stmt, true);
                        this.emitIndent();
                        this.emitJavascript(stmt, TypeScript.TokenID.Comma, false);
                        this.emitComments(stmt, false);
                    }
                    this.indenter.decreaseIndent();this.emitInnerFunction(setter, false, isProto, null, Emitter.shouldCaptureThis(setter), null);
                    this.writeLineToOutput(",");
                }
                this.emitIndent();
                this.writeToOutput("enumerable: true,");
                this.writeLineToOutput("");
                this.emitIndent();
                this.writeToOutput("configurable: true");
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("});");
                this.recordSourceMappingEnd(funcDecl);
                accessorSymbol.hasBeenEmitted = true;
            }
        };
        Emitter.shouldCaptureThis = function (funcDecl) {
            if((funcDecl && (funcDecl.className))) {
                if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Static)) {
                    return false;
                }
                if((funcDecl.fncFlags & 5632) === 0) {
                    return false;
                }
                return true;
            }
            return false;
        };
        Emitter.prototype.emitConstructorStatementsFromConstructorDecl = function (constructorDecl, className, baseType, isClass) {
            for(var i = 0, n = constructorDecl.block.statements.members.length; i < n; i++) {
                var statement = constructorDecl.block.statements.members[i];
                if(statement.nodeType == TypeScript.NodeType.ExpressionStatement) {
                    var exprStatement = statement;
                    if(exprStatement.expression.nodeType == TypeScript.NodeType.InvocationExpression) {
                        var invocationExpression = exprStatement.expression;
                        if(invocationExpression.target.nodeType == TypeScript.NodeType.SuperExpression) {
                            var superCall = invocationExpression;
                            this.emitIndent();
                            this.writeToOutput("_super.apply(this, ");
                            if (superCall.arguments && superCall.arguments.members.length > 0) {
                                this.writeToOutput("arguments);");
                            } else {
                                this.writeToOutput("[]);");
                            }
                            this.writeLineToOutput("");
                            this.emitIndent();
                            this.writeToOutput("this.constructor.prototype._init.call(this);");
                            this.writeLineToOutput("");
                            continue;
                        }
                    }
                }
                this.emitJavascript(statement, TypeScript.TokenID.OpenParen, false);
            }
            if(isClass) {
                var emitter = this;
                var svInArrowFunction = this.inArrowFunction;
                this.inArrowFunction = false;
                this.emitIndent();
                this.writeToOutput("__extends(" + className + ", _super);");
                this.writeLineToOutput("");
                this.emitIndent();
                this.writeToOutput("function " + className + "() {");
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitIndent();
                if (constructorDecl.arguments && constructorDecl.arguments.members.length > 0) {
                    this.writeToOutput("var args = [].slice.call(arguments);");
                    this.writeLineToOutput("");
                }
                if(isClass) {
                    if ((constructorDecl.arguments && constructorDecl.arguments.members.length > 0) || (baseType.members.length > 0)) {
                        this.emitIndent();
                        this.writeToOutput("_super.apply(this, ");
                        if(constructorDecl.arguments && constructorDecl.arguments.members.length > 0) {
                            this.writeToOutput("args);");
                        } else {
                            this.writeToOutput("[]);");
                        }
                        this.writeLineToOutput("");
                    }
                    if(baseType.members.length > 0) {
                        this.emitIndent();
                        this.writeToOutput("this.constructor.prototype._init.call(this);");
                        this.writeLineToOutput("");
                    }
                }
                if(this.shouldCaptureThis(constructorDecl.block)) {
                    this.recordSourceMappingStart(constructorDecl);
                    this.writeCaptureThisStmt();
                    this.recordSourceMappingEnd(constructorDecl);
                }
                if(constructorDecl.block) {
                    this.emitJavascriptStatements(constructorDecl.block, false);
                }
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
                this.recordSourceMappingStart(constructorDecl);
                this.recordSourceMappingStart(constructorDecl.block);
                this.emitParensAndCommentsInPlace(constructorDecl.block, true);
                this.recordSourceMappingEnd(constructorDecl.block);
                this.writeLineToOutput("");
                this.recordSourceMappingEnd(constructorDecl);
                this.inArrowFunction = svInArrowFunction;
            }
        };
        Emitter.prototype.writeCaptureThisStmt = function () {
            this.writeLineToOutput("var _this = this;");
        };
        Emitter.prototype.emitInnerFunction = function (funcDecl, printName, isProto, hasSelfRef, captureThisStmt, scopeOutParams) {
            if(printName) {
                if(!TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.IsFunctionExpression) || funcDecl.name) {
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(funcDecl.name.actualText);
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
            if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Signature)) {
                this.writeToOutputNoIndent("function ");
                this.emitFunctionSignature(funcDecl, false);
                return true;
            }
            if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.IsFunctionExpression)) {
                this.emitAnonymousFunctionSignature(funcDecl, isProto);
            } else {
                this.recordSourceMappingStart(funcDecl);
                this.emitFunctionFlags(funcDecl);
                this.recordSourceMappingEnd(funcDecl);
                if(funcDecl.name) {
                    this.writeToOutput(" ");
                    this.recordSourceMappingStart(funcDecl.name);
                    this.writeToOutput(funcDecl.name.actualText);
                    this.recordSourceMappingEnd(funcDecl.name);
                }
                if(printName) {
                    if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.IsFatArrowFunction)) {
                        this.writeToOutput(" ");
                    }
                    this.recordSourceMappingStart(funcDecl.signature);
                    this.emitFunctionSignature(funcDecl, false);
                    this.recordSourceMappingEnd(funcDecl.signature);
                }
            }
            if(captureThisStmt) {
                this.writeToOutput(" {");
                this.writeLineToOutput("");
                this.recordSourceMappingStart(funcDecl.block);
                this.indenter.increaseIndent();
                this.indenter.increaseIndent();
                this.recordSourceMappingStart(funcDecl.block);
                this.writeCaptureThisStmt();
            } else {
                this.writeToOutput(" {");
                this.recordSourceMappingStart(funcDecl.block);
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.indenter.increaseIndent();
            }
            if(funcDecl.block && !TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Signature)) {
                var shouldScopeLocals = true;
                if((funcDecl.fncFlags & 1024) === 0 && (funcDecl.isDeclaration || (funcDecl.hint() == TypeScript.FunctionHint.Method && (funcDecl.isAccessor() || funcDecl.isConstructor())))) {
                    shouldScopeLocals = false;
                }
                if(shouldScopeLocals) {
                    this.emitIndent();
                    this.recordSourceMappingStart(funcDecl.block);
                    this.writeLineToOutput("var _this = this;");
                    this.recordSourceMappingEnd(funcDecl.block);
                }
                var svInArrowFunction = this.inArrowFunction;
                this.inArrowFunction = TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.IsFatArrowFunction);
                if(funcDecl.block) {
                    this.emitJavascriptStatements(funcDecl.block, true);
                }
                this.inArrowFunction = svInArrowFunction;
                this.emitIndent();
            }
            this.writeToOutput("}");
            this.writeLineToOutput("");
            if(captureThisStmt) {
                if(scopeOutParams) {
                    this.emitIndent();
                    this.recordSourceMappingStart(funcDecl);
                    this.writeLineToOutput("}).apply(" + stripQuotes(scopeOutParams.ambientModule.name.actualText) + (isProto ? ".prototype, " : ", ") + "[");
                    this.recordSourceMappingEnd(funcDecl);
                    this.indenter.increaseIndent();
                    for(var i = 0; i < scopeOutParams.capturedDecls.length; ++i) {
                        var decl = scopeOutParams.capturedDecls[i];
                        if(i) {
                            this.writeToOutput(", ");
                        }
                        this.recordSourceMappingStart(decl);
                        this.writeToOutput(decl.name.actualText);
                        this.recordSourceMappingEnd(decl);
                    }
                    this.writeLineToOutput("]);");
                } else {
                    this.emitIndent();
                    this.recordSourceMappingStart(funcDecl);
                    this.writeLineToOutput("}));");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
            this.recordSourceMappingEnd(funcDecl);
        };
        Emitter.prototype.emitParameterList = function (argDeclList, funcDecl) {
            var argsLen = argDeclList ? argDeclList.members.length : 0;
            var overloadList = funcDecl ? funcDecl.signature : null;
            var optionalList = [];
            if(overloadList) {
                while(overloadList.nextSig) {
                    overloadList = overloadList.nextSig;
                }
            } else {
                overloadList = argDeclList;
            }
            while(overloadList) {
                for(var iArg = 0; iArg < argsLen; iArg++) {
                    var actualArg = argDeclList.members[iArg];
                    this.recordSourceMappingStart(actualArg);
                    if(actualArg.nodeType == TypeScript.NodeType.ArgDecl) {
                        var argDecl = actualArg;
                        if(TypeScript.hasFlag(argDecl.varFlags, TypeScript.VarFlags.Property)) {
                            continue;
                        }
                        if(TypeScript.hasFlag(argDecl.varFlags, TypeScript.VarFlags.Private)) {
                            continue;
                        }
                        if(overloadList && this.isOverloadCall(overloadList, argDecl.id.actualText) && !(argDecl.init)) {
                            optionalList[iArg] = argDecl;
                        } else {
                            if(iArg) {
                                this.writeToOutput(", ");
                            }
                            this.writeToOutput(argDecl.id.actualText);
                        }
                    }
                    this.recordSourceMappingEnd(actualArg);
                }
                if(!(overloadList.nextSig)) {
                    break;
                }
                overloadList = overloadList.nextSig;
                this.writeToOutput(", ");
            }
            if(optionalList.length > 0) {
                this.writeToOutput(", ");
                var curArg = 0;
                var defaultStarted = false;
                for(var iArg = 0; iArg < optionalList.length; iArg++) {
                    if(optionalList[iArg]) {
                        if(curArg) {
                            this.writeToOutput(", ");
                        }
                        var actualArg = optionalList[iArg];
                        curArg = actualArg;
                        this.recordSourceMappingStart(actualArg);
                        var idText = actualArg.id.actualText;
                        var text = idText;
                        if(actualArg.init) {
                            text += "?";
                        }
                        this.writeToOutput(text);
                        this.recordSourceMappingEnd(actualArg);
                    } else {
                        if(curArg) {
                            while(++curArg < argDeclList.members.length) {
                                this.writeToOutput(", ");
                                var nextArg = argDeclList.members[curArg];
                                if(nextArg.nodeType == TypeScript.NodeType.ArgDecl) {
                                    this.recordSourceMappingStart(nextArg);
                                    this.writeToOutput(nextArg.id.actualText);
                                    this.recordSourceMappingthis.emitIndent();
                                    this.emitJavascript(fn, TypeScript.TokenID.Comma, false);
                                    this.writeLineToOutput("");
                                }
                            }
                        }
                    }
                }
                if(classDecl.members.members.length > 0) {
                    this.writeToOutput(className + ".prototype.__class = '" + classDecl.name.actualText + "';");
                    this.writeLineToOutput("");
                }
                this.emitIndent();
                this.recordSourceMappingNameStart("constructor");
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeToOutput("return " + className + ";");
                this.writeLineToOutput("");
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.recordSourceMappingNameEnd();
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
                this.setContainer(temp);
                this.recordSourceMappingEnd(classDecl);
                this.thisClassNode = svClassNode;
            }
        };
        Emitter.prototype.emitJavascript = function (ast, tokenId, startLine) {
            var emitState = {
                column: 0,
                line: 0
            };
            this.emitJavascriptAST(ast, tokenId, startLine, emitState);
        };
        Emitter.prototype.emitJavascriptAST = function (ast, tokenId, startLine, emitState) {
            var temp = this.setContainer(EmitContainer.Prog);var TypeScript;
(function (TypeScript) {
    (function (TokenID) {
        TokenID._map = [];
        TokenID._map[0] = "Whitespaces";
        TokenID.Whitespaces = 0;
        TokenID._map[1] = "Comment";
        TokenID.Comment = 1;
        TokenID._map[2] = "Identifier";
        TokenID.Identifier = 2;
        TokenID._map[3] = "Break";
        TokenID.Break = 3;
        TokenID._map[4] = "Case";
        TokenID.Case = 4;
        TokenID._map[5] = "Catch";
        TokenID.Catch = 5;
        TokenID._map[6] = "Class";
        TokenID.Class = 6;
        TokenID._map[7] = "Const";
        TokenID.Const = 7;
        TokenID._map[8] = "Continue";
        TokenID.Continue = 8;
        TokenID._map[9] = "Debugger";
        TokenID.Debugger = 9;
        TokenID._map[10] = "Default";
        TokenID.Default = 10;
        TokenID._map[11] = "Delete";
        TokenID.Delete = 11;
        TokenID._map[12] = "Do";
        TokenID.Do = 12;
        TokenID._map[13] = "Else";
        TokenID.Else = 13;
        TokenID._map[14] = "Enum";
        TokenID.Enum = 14;
        TokenID._map[15] = "Export";
        TokenID.Export = 15;
        TokenID._map[16] = "Extends";
        TokenID.Extends = 16;
        TokenID._map[17] = "False";
        TokenID.False = 17;
        TokenID._map[18] = "Finally";
        TokenID.Finally = 18;
        TokenID._map[19] = "For";
        TokenID.For = 19;
        TokenID._map[20] = "Function";
        TokenID.Function = 20;
        TokenID._map[21] = "If";
        TokenID.If = 21;
        TokenID._map[22] = "Import";
        TokenID.Import = 22;
        TokenID._map[23] = "In";
        TokenID.In = 23;
        TokenID._map[24] = "InstanceOf";
        TokenID.InstanceOf = 24;
        TokenID._map[25] = "New";
        TokenID.New = 25;
        TokenID._map[26] = "Null";
        TokenID.Null = 26;
        TokenID._map[27] = "NumberLiteral";
        TokenID.NumberLiteral = 27;
        TokenID._map[28] = "Return";
        TokenID.Return = 28;
        TokenID._map[29] = "StringLiteral";
        TokenID.StringLiteral = 29;
        TokenID._map[30] = "Super";
        TokenID.Super = 30;
        TokenID._map[31] = "Switch";
        TokenID.Switch = 31;
        TokenID._map[32] = "This";
        TokenID.This = 32;
        TokenID._map[33] = "Throw";
        TokenID.Throw = 33;
        TokenID._map[34] = "True";
        TokenID.True = 34;
        TokenID._map[35] = "Try";
        TokenID.Try = 35;
        TokenID._map[36] = "TypeOf";
        TokenID.TypeOf = 36;
        TokenID._map[37] = "Var";
        TokenID.Var = 37;
        TokenID._map[38] = "Void";
        TokenID.Void = 38;
        TokenID._map[39] = "While";
        TokenID.While = 39;
        TokenID._map[40] = "With";
        TokenID.With = 40;
        TokenID._map[41] = "As";
        TokenID.As = 41;
        TokenID._map[42] = "Param";
        TokenID.Param = 42;
        TokenID._map[43] = "Constructor";
        TokenID.Constructor = 43;
        TokenID._map[44] = "Module";
        TokenID.Module = 44;
        TokenID._map[45] = "Declare";
        TokenID.Declare = 45;
        TokenID._map[46] = "Get";
        TokenID.Get = 46;
        TokenID._map[47] = "Set";
        TokenID.Set = 47;
        TokenID._map[48] = "Public";
        TokenID.Public = 48;
        TokenID._map[49] = "Private";
        TokenID.Private = 49;
        TokenID._map[50] = "Static";
        TokenID.Static = 50;
        TokenID._map[51] = "Exported";
        TokenID.Exported = 51;
        TokenID._map[52] = "Declared";
        TokenID.Declared = 52;
        TokenID._map[53] = "Bool";
        TokenID.Bool = 53;
        TokenID._map[54] = "Any";
        TokenID.Any = 54;
        TokenID._map[55] = "Number";
        TokenID.Number = 55;
        TokenID._map[56] = "String";
        TokenID.String = 56;
        TokenID._map[57] = "Collision";
        TokenID.Collision = 57;
        TokenID._map[58] = "Semicolon";
        TokenID.Semicolon = 58;
        TokenID._map[59] = "OpenParen";
        TokenID.OpenParen = 59;
        TokenID._map[60] = "CloseParen";
        TokenID.CloseParen = 60;
        TokenID._map[61] = "OpenBracket";
        TokenID.OpenBracket = 61;
        TokenID._map[62] = "CloseBracket";
        TokenID.CloseBracket = 62;
        TokenID._map[63] = "OpenBrace";
        TokenID.OpenBrace = 63;
        TokenID._map[64] = "CloseBrace";
        TokenID.CloseBrace = 64;
        TokenID._map[65] = "Dot";
        TokenID.Dot = 65;
        TokenID._map[66] = "DotDotDot";
        TokenID.DotDotDot = 66;
        TokenID._map[67] = "Comma";
        TokenID.Comma = 67;
        TokenID._map[68] = "Ampersand";
        TokenID.Ampersand = 68;
        TokenID._map[69] = "Pipe";
        TokenID.Pipe = 69;
        TokenID._map[70] = "EqualsEquals";
        TokenID.EqualsEquals = 70;
        TokenID._map[71] = "ExclamationEquals";
        TokenID.ExclamationEquals = 71;
        TokenID._map[72] = "EqualsEqualsEquals";
        TokenID.EqualsEqualsEquals = 72;
        TokenID._map[73] = "ExclamationEqualsEquals";
        TokenID.ExclamationEqualsEquals = 73;
        TokenID._map[74] = "LessThan";
        TokenID.LessThan = 74;
        TokenID._map[75] = "GreaterThan";
        TokenID.GreaterThan = 75;
        TokenID._map[76] = "LessThanEquals";
        TokenID.LessThanEquals = 76;
        TokenID._map[77] = "GreaterThanEquals";
        TokenID.GreaterThanEquals = 77;
        TokenID._map[78] = "Plus";
        TokenID.Plus = 78;
        TokenID._map[79] = "Minus";
        TokenID.Minus = 79;
        TokenID._map[80] = "Asterisk";
        TokenID.Asterisk = 80;
        TokenID._map[81] = "Slash";
        TokenID.Slash = 81;
        TokenID._map[82] = "Percent";
        TokenID.Percent = 82;
        TokenID._map[83] = "PlusPlus";
        TokenID.PlusPlus = 83;
        TokenID._map[84] = "MinusMinus";
        TokenID.MinusMinus = 84;
        TokenID._map[85] = "LessThanLessThan";
        TokenID.LessThanLessThan = 85;
        TokenID._map[86] = "GreaterThanGreaterThan";
        TokenID.GreaterThanGreaterThan = 86;
        TokenID._map[87] = "GreaterThanGreaterThanGreaterThan";
        TokenID.GreaterThanGreaterThanGreaterThan = 87;
        TokenID._map[88] = "AmpersandAmpersand";
        TokenID.AmpersandAmpersand = 88;
        TokenID._map[89] = "PipePipe";
        TokenID.PipePipe = 89;
        TokenID._map[90] = "Bang";
        TokenID.Bang = 90;
        TokenID._map[91] = "Tilde";
        TokenID.Tilde = 91;
        TokenID._map[92] = "Colon";
        TokenID.Colon = 92;
        TokenID._map[93] = "Equals";
        TokenID.Equals = 93;
        TokenID._map[94] = "PlusEquals";
        TokenID.PlusEquals = 94;
        TokenID._map[95] = "MinusEquals";
        TokenID.MinusEquals = 95;
        TokenID._map[96] = "AsteriskEquals";
        TokenID.AsteriskEquals = 96;
        TokenID._map[97] = "SlashEquals";
        TokenID.SlashEquals = 97;
        TokenID._map[98] = "PercentEquals";
        TokenID.PercentEquals = 98;
        TokenID._map[99] = "LessThanLessThanEquals";
        TokenID.LessThanLessThanEquals = 99;
        TokenID._map[100] = "GreaterThanGreaterThanEquals";
        TokenID.GreaterThanGreaterThanEquals = 100;
        TokenID._map[101] = "GreaterThanGreaterThanGreaterThanEquals";
        TokenID.GreaterThanGreaterThanGreaterThanEquals = 101;
        TokenID._map[102] = "AmpersandEquals";
        TokenID.AmpersandEquals = 102;
        TokenID._map[103] = "PipeEquals";
        TokenID.PipeEquals = 103;
        TokenID._map[104] = "CaretEquals";
        TokenID.CaretEquals = 104;
        TokenID._map[105] = "Identifier";
        TokenID.TypeScriptIdentifier = 105;
        TokenID._map[106] = "Any";
        TokenID.TypeScriptAny = 106;
        TokenID._map[107] = "Number";
        TokenID.TypeScriptNumber = 107;
        TokenID._map[108] = "Bool";
        TokenID.TypeScriptBool = 108;
        TokenID._map[109] = "String";
        TokenID.TypeScriptString = 109;
        TokenID._map[110] = "Module";
        TokenID.TypeScriptModule = 110;
        TokenID._map[111] = "Export";
        TokenID.TypeScriptExport = 111;
        TokenID._map[112] = "Public";
        TokenID.TypeScriptPublic = 112;
        TokenID._map[113] = "Private";
        TokenID.TypeScriptPrivate = 113;
        TokenID._map[114] = "Module";
        TokenID.TypeScriptStatic = 114;
        TokenID._map[115] = "Interface";
        TokenID.Interface = 115;
        TokenID._map[116] = "Extends";var TypeScript;
(function (TypeScript) {
    (function (TokenID) {
        TokenID._map = [];
        TokenID._map[0] = "Whitespaces";
        TokenID.Whitespaces = 0;
        TokenID._map[1] = "Comment";
        TokenID.Comment = 1;
        TokenID._map[2] = "Identifier";
        TokenID.Identifier = 2;
        TokenID._map[3] = "Break";
        TokenID.Break = 3;
        TokenID._map[4] = "Case";
        TokenID.Case = 4;
        TokenID._map[5] = "Catch";
        TokenID.Catch = 5;
        TokenID._map[6] = "Class";
        TokenID.Class = 6;
        TokenID._var TypeScript;
(function (TypeScript) {
    (function (TokenID) {
        TokenID._map = [];
        TokenID._map[0] = "Whitespaces";
        TokenID.Whitespaces = 0;
        TokenID._map[1] = "Comment";
        TokenID.Comment = 1;
        TokenID._map[2] = "Identifier";
        TokenID.Identifier = 2;
        TokenID._map[3] = "Break";
        TokenID.Break = 3;
        TokenID._map[4] = "Case";
        TokenID.Case = 4;
        TokenID._map[5] = "Catch";
        TokenID.Catch = 5;
        TokenID._map[6] = "Class";
        TokenID.Class = 6;
        TokenID._map[7] = "Continue";
        TokenID.Continue = 7;
        TokenID._map[8] = "Debugger";
        TokenID.Debugger = 8;
        TokenID._map[9] = "Default";
        TokenID.Default = 9;
        TokenID._map[10] = "Delete";
        TokenID.Delete = 10;
        TokenID._map[11] = "Do";
        TokenID.Do = 11;
        TokenID._map[12] = "Else";
        TokenID.Else = 12;
        TokenID._map[13] = "Enum";
        TokenID.Enum = 13;
        TokenID._map[14] = "False";
        TokenID.False = 14;
        TokenID._map[15] = "Finally";
        TokenID.Finally = 15;
        TokenID._map[16] = "ForKeyword";
        TokenID.ForKeyword = 16;
        TokenID._map[17] = "Function";
        TokenID.Function = 17;
        TokenID._map[18] = "If";
        TokenID.If = 18;
        TokenID._map[19] = "In";
        TokenID.In = 19;
        TokenID._map[20] = "InstanceOf";
        TokenID.InstanceOf = 20;
        TokenID._map[21] = "New";
        TokenID.New = 21;
        TokenID._map[22] = "Null";
        TokenID.Null = 22;
        TokenID._map[23] = "NumericLiteral";
        TokenID.NumericLiteral = 23;
        TokenID._map[24] = "Return";
        TokenID.Return = 24;
        TokenID._map[25] = "StringLiteral";
        TokenID.StringLiteral = 25;
        TokenID._map[26] = "Switch";
        TokenID.Switch = 26;
        TokenID._map[27] = "This";
        TokenID.This = 27;
        TokenID._map[28] = "Throw";
        TokenID.Throw = 28;
        TokenID._map[29] = "True";
        TokenID.True = 29;
        TokenID._map[30] = "Try";
        TokenID.Try = 30;
        TokenID._map[31] = "TypeOf";
        TokenID.TypeOf = 31;
        TokenID._map[32] = "Var";
        TokenID.Var = 32;
        TokenID._map[33] = "Void";
        TokenID.Void = 33;
        TokenID._map[34] = "While";
        TokenID.While = 34;
        TokenID._map[35] = "With";
        TokenID.With = 35;
        TokenID._map[36] = "OpenParen";
        TokenID.OpenParen = 36;
        TokenID._map[37] = "CloseParen";
        TokenID.CloseParen = 37;
        TokenID._map[38] = "OpenBracket";
        TokenID.OpenBracket = 38;
        TokenID._map[39] = "CloseBracket";
        TokenID.CloseBracket = 39;
        TokenID._map[40] = "OpenBrace";
        TokenID.OpenBrace = 40;
        TokenID._map[41] = "CloseBrace";
        TokenID.CloseBrace = 41;
        TokenID._map[42] = "Dot";
        TokenID.Dot = 42;
        TokenID._map[43] = "DotDotDot";
        TokenID.DotDotDot = 43;
        TokenID._map[44] = "Semicolon";
        TokenID.Semicolon = 44;
        TokenID._map[45] = "Comma";
        TokenID.Comma = 45;
        TokenID._map[46] = "LessThan";
        TokenID.LessThan = 46;
        TokenID._map[47] = "GreaterThan";
        TokenID.GreaterThan = 47;
        TokenID._map[48] = "LessThanEquals";
        TokenID.LessThanEquals = 48;
        TokenID._map[49] = "GreaterThanEquals";
        TokenID.GreaterThanEquals = 49;
        TokenID._map[50] = "Equals";
        TokenID.Equals = 50;
        TokenID._map[51] = "EqualsEquals";
        TokenID.EqualsEquals = 51;
        TokenID._map[52] = "EqualsEqualsGreaterThan";
        TokenID.EqualsEqualsGreaterThan = 52;
        TokenID._map[53] = "Exclamation";
        TokenID.Exclamation = 53;
        TokenID._map[54] = "ExclamationEquals";
        TokenID.ExclamationEquals = 54;
        TokenID._map[55] = "ExclamationEqualsGreaterThan";
        TokenID.ExclamationEqualsGreaterThan = 55;
        TokenID._map[56] = "Plus";
        TokenID.Plus = 56;
        TokenID._map[57] = "Minus";
        TokenID.Minus = 57;
        TokenID._map[58] = "Asterisk";
        TokenID.Asterisk = 58;
        TokenID._map[59] = "Slash";
        TokenID.Slash = 59;
        TokenID._map[60] = "Percent";
        TokenID.Percent = 60;
        TokenID._map[61] = "PlusPlus";
        TokenID.PlusPlus = 61;
        TokenID._map[62] = "MinusMinus";
        TokenID.MinusMinus = 62;
        TokenID._map[63] = "LessThanLessThan";
        TokenID.LessThanLessThan = 63;
        TokenID._map[64] = "LessThanSlash";
        TokenID.LessThanSlash = 64;
        TokenID._map[65] = "GreaterThanGreaterThan";
        TokenID.GreaterThanGreaterThan = 65;
        TokenID._map[66] = "GreaterThanGreaterThanGreaterThan";
        TokenID.GreaterThanGreaterThanGreaterThan = 66;
        TokenID._map[67] = "Ampersand";
        TokenID.Ampersand = 67;
        TokenID._map[68] = "Bar";
        TokenID.Bar = 68;
        TokenID._map[69] = "Caret";
        TokenID.Caret = 69;
        TokenID._map[70] = "BarBar";
        TokenID.BarBar = 70;
        TokenID._map[71] = "AmpersandAmpersand";
        TokenID.AmpersandAmpersand = 71;
        TokenID._map[72] = "BarEquals";
        TokenID.BarEquals = 72;
        TokenID._map[73] = "AmpersandEquals";
        TokenID.AmpersandEquals = 73;
        TokenID._map[74] = "CaretEquals";
        TokenID.CaretEquals = 74;
        TokenID._map[75] = "LessThanLessThanEquals";
        TokenID.LessThanLessThanEquals = 75;
        TokenID._map[76] = "GreaterThanGreaterThanEquals";
        TokenID.GreaterThanGreaterThanEquals = 76;
        TokenID._map[77] = "GreaterThanGreaterThanGreaterThanEquals";
        TokenID.GreaterThanGreaterThanGreaterThanEquals = 77;
        TokenID._map[78] = "PlusEquals";
        TokenID.PlusEquals = 78;
        TokenID._map[79] = "MinusEquals";
        TokenID.MinusEquals = 79;
        TokenID._map[80] = "AsteriskEquals";
        TokenID.AsteriskEquals = 80;
        TokenID._map[81] = "SlashEquals";
        TokenID.SlashEquals = 81;
        TokenID._map[82] = "PercentEquals";
        TokenID.PercentEquals = 82;
        TokenID._map[83] = "Public";
        TokenID.Public = 83;
        TokenID._map[84] = "Private";
        TokenID.Private = 84;
        TokenID._map[85] = "Static";
        TokenID.Static = 85;
        TokenID._map[86] = "Any";
        TokenID.Any = 86;
        TokenID._map[87] = "Number";
        TokenID.Number = 87;
        TokenID._map[88] = "Bool";
        TokenID.Bool = 88;
        TokenID._map[89] = "String";
        TokenID.String = 89;
        TokenID._map[90] = "Void";
        TokenID.Void = 90;
        TokenID._map[91] = "Null";
        TokenID.Null = 91;
        TokenID._map[92] = "Undefined";
        TokenID.Undefined = 92;
        TokenID._map[93] = "Public";
        TokenID.Public = 93;
        TokenID._map[94] = "Private";
        TokenID.Private = 94;
        TokenID._map[95] = "Static";
        TokenID.Static = 95;
        TokenID._map[96] = "True";
        TokenID.True = 96;
        TokenID._map[97] = "False";
        TokenID.False = 97;
        TokenID._map[98] = "Colon";
        TokenID.Colon = 98;
        TokenID._map[99] = "OpenBracket";
        TokenID.OpenBracket = 99;
        TokenID._map[100] = "CloseBracket";
        TokenID.CloseBracket = 100;
        TokenID._map[101] = "Any";
        TokenID.Any = 101;
        TokenID._map[102] = "Number";
        TokenID.Number = 102;
        TokenID._map[103] = "Bool";
        TokenID.Bool = 103;
        TokenID._map[104] = "String";
        TokenID.String = 104;
        TokenID._map[105] = "Module";
        TokenID.Module = 105;
        TokenID._map[106] = "Function";
        TokenID.Function = 106;
        TokenID._map[107] = "Get";
        TokenID.Get = 107;
        TokenID._map[108] = "Set";
        TokenID.Set = 108;
        TokenID._map[109] = "Constructor";
        TokenID.Constructor = 109;
        TokenID._map[110] = "Export";
        TokenID.Export = 110;
+        TokenID._map[111] = "Import";
+        TokenID.Import = 111;
        TokenID._map[112] = "EqualsGreaterThan";
        TokenID.EqualsGreaterThan = 112;
        TokenID._map[113] = "Void";
        TokenID.Void = 113;
        TokenID._map[114] = "Object";
        TokenID.Object = 114;
        TokenID._map[115] = "RegexLiteral";
        TokenID.RegexLiteral = 115;
        TokenID._map[116] = "Function";
        TokenID.Function = 116;
        Token##########