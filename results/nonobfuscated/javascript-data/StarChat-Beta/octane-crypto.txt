Analyze the following piece of code: 


var Crypto = new BenchmarkSuite('Crypto', [266181], [
  new Benchmark("Encrypt", true, false, 3900, encrypt),
  new Benchmark("Decrypt", true, false, 220, decrypt)
]);



var dbits;
var BI_DB;
var BI_DM;
var BI_DV;

var BI_FP;
var BI_FV;
var BI_F1;
var BI_F2;

var canary = 0xdeadbeefcafe;
var j_lm = ((canary&0xffffff)==0xefcafe);

function BigInteger(a,b,c) {
  this.array = new Array();
  if(a!= null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null && "string"!= typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}

function nbi() { return new BigInteger(null); }


function am1(i,x,w,j,c,n) {
  var this_array = this.array;
  var w_array    = w.array;
  while(--n >= 0) {
    var v = x*this_array[i++]+w_array[j]+c;
    c = Math.floor(v/0x4000000);
    w_array[j++] = v&0x3ffffff;
  }
  return c;
}

function am2(i,x,w,j,c,n) {
  var this_array = this.array;
  var w_array    = w.array;
  var xl = x&0x7fff, xh = x>>15;
  while(--n >= 0) {
    var l = this_array[i]&0x7fff;
    var h = this_array[i++]>>15;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x7fff)<<15)+w_array[j]+(c&0x3fffffff);
    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
    w_array[j++] = l&0x3fffffff;
  }
  return c;
}

function am3(i,x,w,j,c,n) {
  var this_array = this.array;
  var w_array    = w.array;

  var xl = x&0x3fff, xh = x>>14;
  while(--n >= 0) {
    var l = this_array[i]&0x3fff;
    var h = this_array[i++]>>14;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x3fff)<<14)+w_array[j]+c;
    c = (l>>28)+(m>>14)+xh*h;
    w_array[j++] = l&0xfffffff;
  }
  return c;
}

function am4(i,x,w,j,c,n) {
  var this_array = this.array;
  var w_array    = w.array;

  var xl = x&0x1fff, xh = x>>13;
  while(--n >= 0) {
    var l = this_array[i]&0x1fff;
    var h = this_array[i++]>>13;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x1fff)<<13)+w_array[j]+c;
    c = (l>>26)+(m>>13)+xh*h;
    w_array[j++] = l&0x3ffffff;
  }
  return c;
}


setupEngine = function(fn, bits) {
  BigInteger.prototype.am = fn;
  dbits = bits;

  BI_DB = dbits;
  BI_DM = ((1<<dbits)-1);
  BI_DV = (1<<dbits);

  BI_FP = 52;
  BI_FV = Math.pow(2,BI_FP);
  BI_F1 = BI_FP-dbits;
  BI_F2 = 2*dbits-BI_FP;
}

function toRadix(b) {
  if(b == 16) return "0123456789abcdef";
  if(b == 8) return "01234567";
  if(b == 2) return "01";
  return "0123456789";
}

function fromRadix(s,b) {
  var i;
  if(b == 16) {
    for(i = 0; i < s.length; i++)
      if(s.charAt(i)!= "0" && s.charAt(i)!= "1" && s.charAt(i)!= "2" && s.charAt(i)!= "3" && s.charAt(i)!= "4" && s.charAt(i)!= "5" && s.charAt(i)!= "6" && s.charAt(i)!= "7" && s.charAt(i)!= "8" && s.charAt(i)!= "9" && s.charAt(i)!= "a" && s.charAt(i)!= "b" && s.charAt(i)!= "c" && s.charAt(i)!= "d" && s.charAt(i)!= "e" && s.charAt(i)!= "f") return null;
    return i;
  }
  if(b == 8) {
    for(i = 0; i < s.length; i++)
      if(s.charAt(i)!= "0" && s.charAt(i)!= "1" && s.charAt(i)!= "2" && s.charAt(i)!= "3" && s.charAt(i)!= "4" && s.charAt(i)!= "5" && s.charAt(i)!= "6" && s.charAt(i)!= "7") return null;
    return i;
  }
  if(b == 2) {
    for(i = 0; i < s.length; i++)
      if(s.charAt(i)!= "0" && s.charAt(i)!= "1") return null;
    return i;
  }
  for(i = 0; i < s.length; i++)
    if(s.charAt(i) < "0" || s.charAt(i) > "9") return null;
  return i;
}

function int2char(n) {
  return n < 16? "0" + n.toString(16) : n.toString(16);
}

function intAt(s,i) {
  var c = s.charAt(i);
  return c >= "0" && c <= "9"? c.charCodeAt(0) - "0".charCodeAt(0) :
         c >= "a" && c <= "f"? c.charCodeAt(0) - "a".charCodeAt(0) + 10 :
         c >= "A" && c <= "F"? c.charCodeAt(0) - "A".charCodeAt(0) + 10 :
         0;
}

function charAt(s,i) {
  var c = s.charCodeAt(i);
  return c < 16? "0" + c.toString(16 Analyze the following piece of code:  2*dbits-BI_FP;
}


var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr,vv;
rr = "0".charCodeAt(0);
for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

function int2char(n) { return BI_RM.charAt(n); }
function intAt(s,i) {
  var c = BI_RC[s.charCodeAt(i)];
  return (c==null)?-1:c;
}

function bnpCopyTo(r) {
  var this_array = this.array;
  var r_array    = r.array;

  for(var i = this.t-1; i >= 0; --i) r_array[i] = this_array[i];
  r.t = this.t;
  r.s = this.s;
}

function bnpFromInt(x) {
  var this_array = this.array;
  this.t = 1;
  this.s = (x<0)?-1:0;
  if(x > 0) this_array[0] = x;
  else if(x < -1) this_array[0] = x+DV;
  else this.t = 0;
}

function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

function bnpFromString(s,b) {
  var this_array = this.array;
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 256) k = 8;   else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else { this.fromRadix(s,b); return; }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while(--i >= 0) {
    var x = (k==8)?s[i]&0xff:intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if(sh == 0)
      this_array[this.t++] = x;
    else if(sh+k > BI_DB) {
      this_array[this.t-1] |= (x&((1<<(BI_DB-sh))-1))<<sh;
      this_array[this.t++] = (x>>(BI_DB-sh));
    }
    else
      this_array[this.t-1] |= x<<sh;
    sh += k;
    if(sh >= BI_DB) sh -= BI_DB;
  }
  if(k == 8 && (s[0]&0x80)!= 0) {
    this.s = -1;
    if(sh > 0) this_array[this.t-1] |= ((1<<(BI_DB-sh))-1)<<sh;
  }
  this.clamp();
  if(mi) BigInteger.ZERO.subTo(this,this);
}

function bnpClamp() {
  var this_array = this.array;
  var c = this.s&BI_DM;
  while(this.t > 0 && this_array[this.t-1] == c) --this.t;
}

function bnToString(b) {
  var this_array = this.array;
  if(this.s < 0) return "-"+this.negate().toString(b);
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1<<k)-1, d, m = false, r = "", i = this.t;
  var p = BI_DB-((i*BI_DB)%k);
  if(i-- > 0) {
    if(p < BI_DB && (d = this_array[i]>>p) > 0) { m = true; r = int2char(d); }
    while(i >= 0) {
      if(p < k) {
        d = (this_array[i]&((1<<p)-1))<<(k-p);
        d |= this_array[--i]>>(p+=BI_DB-k);
      }
      else {
        d = (this_array[i]>>(p-=k))&km;
        if(p <= 0) { p += BI_DB; --i; }
      }
      if(d > 0) m = true;
      if(m) r += int2char(d);
    }
  }
  return m?r:"0";
}

function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

function bnAbs() { return (this.s<0)?this.negate():this; }

function bnCompareTo(a) {
  var this_array = this.array;
  var a_array = a.array;
  var r = this.s-a.s;
  if(r!= 0) return r;
  var i = this.t;
  r = i-a.t;
  if(r!= 0) return (this.s<0)?-r:r;
  while(--i >= 0) if((r=this_array[i]-a_array[i])!= 0) return r;
  return 0;
}

function nbits(x) {
  var r = 1, t;
  if((t=x>>>16)!= 0) { x = t; r += 16; }
  if((t=x>>>8)!= 0) { x = t; r += 8; }
  if((t=x>>>4)!= 0) { x = t; r += 4; }
  if((t=x>>>2)!= 0) { x = t; r += 2; }
  if((t=x>>>1)!= 0) { x = t; r += 1; }
  return r;
}

function bnpBitLength() {
  if(this.t <= 0) return 0;
  return (this.DB*(this.t-1))+nbits(this.array[this.t-1]^(this.s&BI_DM));
}

function bnpMod(m) {
  var this_array = this.array;
  var r = nbi(), x, i = 0, k;
  if(this.t <= 0) return r;
  if(m.t <= 0) return r;
  var m_array = m.array;
  while(i < this.t) Analyze the following piece of code:  == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1<<k)-1, d, m = false, r = "", i = this.t;
  var p = BI_DB-(i*BI_DB)%k;
  if(i-- > 0) {
    if(p < BI_DB && (d = this_array[i]>>p) > 0) { m = true; r = int2char(d); }
    while(i >= 0) {
      if(p < k) {
        d = (this_array[i]&((1<<p)-1))<<(k-p);
        d |= this_array[--i]>>(p+=BI_DB-k);
      }
      else {
        d = (this_array[i]>>(p-=k))&km;
        if(p <= 0) { p += BI_DB; --i; }
      }
      if(d > 0) m = true;
      if(m) r += int2char(d);
    }
  }
  return m?r:"0";
}

function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

function bnAbs() { return (this.s<0)?this.negate():this; }

function bnCompareTo(a) {
  var this_array = this.array;
  var a_array = a.array;

  var r = this.s-a.s;
  if(r!= 0) return r;
  var i = this.t;
  r = i-a.t;
  if(r!= 0) return r;
  while(--i >= 0) if((r=this_array[i]-a_array[i])!= 0) return r;
  return 0;
}

function nbits(x) {
  var r = 1, t;
  if((t=x>>>16)!= 0) { x = t; r += 16; }
  if((t=x>>8)!= 0) { x = t; r += 8; }
  if((t=x>>4)!= 0) { x = t; r += 4; }
  if((t=x>>2)!= 0) { x = t; r += 2; }
  if((t=x>>1)!= 0) { x = t; r += 1; }
  return r;
}

function bnBitLength() {
  var this_array = this.array;
  if(this.t <= 0) return 0;
  return BI_DB*(this.t-1)+nbits(this_array[this.t-1]^(this.s&BI_DM));
}

function bnpDLShiftTo(n,r) {
  var this_array = this.array;
  var r_array = r.array;
  var i;
  for(i = this.t-1; i >= 0; --i) r_array[i+n] = this_array[i];
  for(i = n-1; i >= 0; --i) r_array[i] = 0;
  r.t = this.t+n;
  r.s = this.s;
}

function bnpDRShiftTo(n,r) {
  var this_array = this.array;
  var r_array = r.array;
  for(var i = n; i < this.t; ++i) r_array[i-n] = this_array[i];
  r.t = Math.max(this.t-n,0);
  r.s = this.s;
}

function bnpLShiftTo(n,r) {
  var this_array = this.array;
  var r_array = r.array;
  var bs = n%BI_DB;
  var cbs = BI_DB-bs;
  var bm = (1<<cbs)-1;
  var ds = Math.floor(n/BI_DB), c = (this.s<<bs)&BI_DM, i;
  for(i = this.t-1; i >= 0; --i) {
    r_array[i+ds+1] = (this_array[i]>>cbs)|c;
    c = (this_array[i]&bm)<<bs;
  }
  for(i = ds-1; i >= 0; --i) r_array[i] = 0;
  r_array[0] = c;
  r.t = this.t+ds+1;
  r.s = this.s;
  r.clamp();
}

function bnpRShiftTo(n,r) {
  var this_array = this.array;
  var r_array = r.array;
  r.s = this.s;
  var ds = Math.floor(n/BI_DB);
  if(ds >= this.t) { r.t = 0; return; }
  var bs = n%BI_DB;
  var cbs = BI_DB-bs;
  var bm = (1<<bs)-1;
  r_array[0] = this_array[ds]>>bs;
  for(var i = ds+1; i < this.t; ++i) {
    r_array[i-ds-1] |= (this_array[i]&bm)<<cbs;
    r_array[i-ds] = this_array[i]>>bs;
  }
  if(bs > 0) r_array[this.t-ds-1] |= (this.s&bm)<<cbs;
  r.t = this.t-ds;
  r.clamp();
}

function bnpSubTo(a,r) {
  var this_array = this.array;
  var a_array = a.array;
  var r_array = r.array;
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this_array[i]-a_array[i];
    r_array[i++] = c&BI_DM;
    c >>= BI_DB;
  }
  if(a.t < this.t) {
    c -= a.s;
    while(i < this.t) {
      c += this_array[i];
      r_array[i++] = c&BI_DM;
      c >>= BI_DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c -= a_array[i];
      r_array[i++] = c&BI_DM;
      c >>= BI_DB;
    }
    c -= a.s;
  }
  r.s = (c<0)?-1:0;
  if(c < -1) r_array[i++] = BI_DV+c;
  else if(c > 0) r_array[i++] = c;
  r.t = i;
  r.clamp();
}

function bnpMultiplyTo(a,r) {
  var this_array = this.array;
  var a_array = a.array;
  var r_array = r.array;
  var i = 0, c = 0;
  var t, tmp = BI_DM;
  while(i < this.t) {
    t = a_array[i]*this_array[i]+r_array[i]+c Analyze the following piece of code: i+ds+1] = (this_array[i]>>cbs)|c;
    c = (this_array[i]&bm)<<bs;
  }
  for(i = ds-1; i >= 0; --i) r_array[i] = 0;
  r_array[ds] = c;
  r.t = this.t+ds+1;
  r.s = this.s;
  r.clamp();
}

function bnpRShiftTo(n,r) {
  var this_array = this.array;
  var r_array = r.array;
  r.s = this.s;
  var ds = Math.floor(n/BI_DB);
  if(ds >= this.t) { r.t = 0; return; }
  var bs = n%BI_DB;
  var cbs = BI_DB-bs;
  var bm = (1<<bs)-1;
  r_array[0] = this_array[ds]>>bs;
  for(var i = ds+1; i < this.t; ++i) {
    r_array[i-ds-1] |= (this_array[i]&bm)<<cbs;
    r_array[i-ds] = this_array[i]>>bs;
  }
  if(bs > 0) r_array[this.t-ds-1] |= (this.s&bm)<<cbs;
  r.t = this.t-ds;
  r.clamp();
}

function bnpSubTo(a,r) {
  var this_array = this.array;
  var r_array = r.array;
  var a_array = a.array;
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this_array[i]-a_array[i];
    r_array[i++] = c&BI_DM;
    c >>= BI_DB;
  }
  if(a.t < this.t) {
    c -= a.s;
    while(i < this.t) {
      c += this_array[i];
      r_array[i++] = c&BI_DM;
      c >>= BI_DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c -= a_array[i];
      r_array[i++] = c&BI_DM;
      c >>= BI_DB;
    }
    c -= a.s;
  }
  r.s = (c<0)?-1:0;
  if(c < -1) r_array[i++] = BI_DV+c;
  else if(c > 0) r_array[i++] = c;
  r.t = i;
  r.clamp();
}

function bnpMultiplyTo(a,r) {
  var this_array = this.array;
  var r_array = r.array;
  var x = this.abs(), y = a.abs();
  var y_array = y.array;

  var i = x.t;
  r.t = i+y.t;
  while(--i >= 0) r_array[i] = 0;
  for(i = 0; i < y.t; ++i) r_array[i+x.t] = x.am(0,y_array[i],r,i,0,x.t);
  r.s = 0;
  r.clamp();
  if(this.s!= a.s) BigInteger.ZERO.subTo(r,r);
}

function bnpSquareTo(r) {
  var x = this.abs();
  var x_array = x.array;
  var r_array = r.array;

  var i = r.t = 2*x.t;
  while(--i >= 0) r_array[i] = 0;
  for(i = 0; i < x.t-1; ++i) {
    var c = x.am(i,x_array[i],r,2*i,0,1);
    if((r_array[i+x.t]+=x.am(i+1,2*x_array[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
      r_array[i+x.t] -= x.DV;
      r_array[i+x.t+1] = 1;
    }
  }
  if(r_array[i+x.t] += x.am(i,x_array[i],r,2*i,0,1)) >= x.DV {
    r_array[i+x.t] -= x.DV;
    r_array[i+x.t+1] = 1;
  }
  if(r.t > 0) r.t--;
  r.clamp();
}

function bnpDivRemTo(m,d,r) {
  var pm = m.abs();
  if(pm.t <= 0) return;
  var pd = d.abs();
  if(pd.t < 2) return;
  var pl = pm.t;
  var pt = pd.t;
  if(pl < pt) return;
  var pdiv = new Array(pt);
  var pmod = new Array(pt);
  var dmod = new Array(pt);
  var u1 = new Array(pl);
  var u2 = new Array(pl);
  var v1 = new Array(pt);
  var v2 = new Array(pt);

  var i = 0;
  while(i < pt) dmod[i] = pd.am(0,pd.t-i,dmod,i,0,1);
  i = pl-1;
  while(i >= 0) {
    u1[i] = pm.am(0,pl-i,u1,i,0,1);
    if(u1[i] === 0) {
      while(i >= 0 && u1[i] === 0) {
        i--;
        u1[i] = pm.am(0,pl-i,u1,i,0,1);
      }
      i++;
    }
  }
  i = pt-1;
  while(i >= 0) {
    v1[i] = dmod[i];
    while(v1[i] === 0 && i >= 0) i--;
    if(i < 0) break;
    v2[i] = dmod[i];
    while(v2[i] === pd.am(0,pt-i,dmod,i,v2[i],1) && i >= 0) {
      v1[i]++;
      v2[i] = dmod[i];
      i--;
    }
  }
  i = pl-1;
  while(i >= 0) {
    pdiv[i] = u1[i];
    pmod[i] = v1[i];
    i--;
  }
  if(r!== undefined) {
    var ts = Math.max(pl,pt);
    r.t = ts;
    while(--ts >= 0) r.am(0,ts,r,ts,pmod[ts],pdiv[ts]);
    if(pmod[pl-1] > 0) r.am(0,pl,r,pl,pmod[pl-1],pdiv[pl-1]);
    r.s = (pdiv[0] < 0)?-1:0;
  }
  return pdiv;
}

function b Analyze the following piece of code:  >= BI_DV) {
      r_array[i+x.t] -= BI_DV;
      r_array[i+x.t+1] = 1;
    }
  }
  if(r.t > 0) r_array[r.t-1] += x.am(i,x_array[i],r,2*i,0,1);
  r.s = 0;
  r.clamp();
}

function bnpDivRemTo(m,q,r) {
  var pm = m.abs();
  if(pm.t <= 0) return;
  var pt = this.abs();
  if(pt.t < pm.t) {
    if(q!= null) q.fromInt(0);
    if(r!= null) this.copyTo(r);
    return;
  }
  if(r == null) r = nbi();
  var y = nbi(), ts = this.s, ms = m.s;
  var pm_array = pm.array;
  var nsh = BI_DB-nbits(pm_array[pm.t-1]);	  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
  else { pm.copyTo(y); pt.copyTo(r); }
  var ys = y.t;

  var y_array = y.array;
  var y0 = y_array[ys-1];
  if(y0 == 0) return;
  var yt = y0*(1<<BI_F1)+((ys>1)?y_array[ys-2]>>BI_F2:0);
  var d1 = BI_FV/yt, d2 = (1<<BI_F1)/yt, e = 1<<BI_F2;
  var i = r.t, j = i-ys, t = (q==null)?nbi():q;
  y.dlShiftTo(j,t);

  var r_array = r.array;
  if(r.compareTo(t) >= 0) {
    r_array[r.t++] = 1;
    r.subTo(t,r);
  }
  BigInteger.ONE.dlShiftTo(ys,t);
  t.subTo(y,y);	  while(y.t < ys) y_array[y.t++] = 0;
  while(--j >= 0) {
        var qd = (r_array[--i]==y0)?BI_DM:Math.floor(r_array[i]*d1+(r_array[i-1]+e)*d2);
    if((r_array[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	      y.dlShiftTo(j,t);
      r.subTo(t,r);
      while(r_array[i] < --qd) r.subTo(t,r);
    }
  }
  if(q!= null) {
    r.drShiftTo(ys,q);
    if(ts!= ms) BigInteger.ZERO.subTo(q,q);
  }
  r.t = ys;
  r.clamp();
  if(nsh > 0) r.rShiftTo(nsh,r);	  if(ts < 0) BigInteger.ZERO.subTo(r,r);
}

function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a,null,r);
  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
  return r;
}

function Classic(m) { this.m = m; }
function cConvert(x) {
  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp&0x7fff;
  this.mph = this.mp>>15;
  this.um = (1<<(BI_DB-15))-1;
  this.mt2 = 2*m.t;
}

function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t,r);
  r.divRemTo(this.m,null,r);
  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
  return r;
}

function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}

// xR/R mod m
function montReduce(x) {
  var i = x.t-1;
  var r = x[i];
  if(i > 0) {
    var j = this.m.t-1;
    while(r < x[--i]) {
      r = (r*2+x[i])%this.m.am(i,x,i,j,0,this.m.t);
    }
    x[i] = r;
  }
  while(x.t > 0 && x[0] == 0) x.shiftRightTo(1);
}

// x/R mod m
function montSqrTo(x,r) {
  x.squareTo(r);
  this.reduce(r);
}

// x^2/R mod m
function montMulTo(x,y,r) {
  x.multiplyTo(y,r);
  this.reduce(r);
}

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

function nbi() { return new BigInteger(null); }

// Copyright (c) 2005-2009  <NAME>
// All Rights Reserved.
// See "LICENSE" for details.

// Basic JavaScript BN library - subset useful for RSA encryption.

// Bits per digit
var dbits;

// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary&0xffffff) == 0xefcafe);

// (public) Constructor
function BigInteger(a,b,c) {
  if(a!= null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null && "string"!= typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}

// return new Analyze the following piece of code:  = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

function bnpInvDigit() {
  var this_array = this.array;
  if(this.t < 1) return 0;
  var x = this_array[0];
  if((x&1) == 0) return 0;
  var y = x&3;		  y = (y*(2-(x&0xf)*y))&0xf;	  y = (y*(2-(x&0xff)*y))&0xff;	  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	      y = (y*(2-x*y%BI_DV))%BI_DV;		    return (y>0)?BI_DV-y:-y;
}

function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp&0x7fff;
  this.mph = this.mp>>15;
  this.um = (1<<(BI_DB-15))-1;
  this.mt2 = 2*m.t;
}

function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t,r);
  r.divRemTo(this.m,null,r);
  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
  return r;
}

function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}

function montReduce(x) {
  var x_array = x.array;
  while(x.t <= this.mt2)	    x_array[x.t++] = 0;
  for(var i = 0; i < this.m.t; ++i) {
        var j = x_array[i]&0x7fff;
    var u0 = (j*this.mpl+(((j*this.mph+(x_array[i]>>15)*this.mpl)&this.um)<<15))&BI_DM;
        j = i+this.m.t;
    x_array[j] += this.m.am(0,u0,x,i,0,this.m.t);
        while(x_array[j] >= BI_DV) { x_array[j] -= BI_DV; x_array[++j]++; }
  }
  x.clamp();
  x.drShiftTo(this.m.t,x);
  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

function bnpIsEven() {
  var this_array = this.array;
  return ((this.t>0)?(this_array[0]&1):this.s) == 0;
}

function bnpExp(e,z) {
  if(e > 0xffffffff || e < 1) return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
  g.copyTo(r);
  while(--i >= 0) {
    z.sqrTo(r,r2);
    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
    else { var t = r; r = r2; r2 = t; }
  }
  return z.revert(r);
}

function bnModPowInt(e,m) {
  var z;
  if(m.isEven()) z = new Classic(m);
  else z = new Montgomery(m);
  return this.exp(e,z);
}

BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;
BigInteger.prototype.modPowInt = bnModPowInt;

// Copyright (c) 2005-2009 <NAME>
// http://www.opensource.org/licenses/mit-license.php

// The MIT License
//
// Copyright (c) 2005-2009 <NAME>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// http://www.webtoolkit.info/

// Thanks to:
//  <NAME> for his base64 encoder
//  <NAME> for his canvastext extension
//  <NAME> for his hex conversion routines

// Version: 1.01

// Changelog:
// 1.01:
// - Fixed a bug when encoding a single 0 byte

// Usage:
//  For encoding, call LZString.encode(string_to_encode);
//  For decoding, call LZString.decode(base64_string_to_decode);

var LZString = {
	//LZ-based compression algorithm
	compressToBase64: function(input){
		if (input == null) return "";
		var compressed = LZString._compress(input);
		return LZString._encode(compressed);
	},
	decompressFromBase64: function(input){
		if (input == null) return "";
		var decompressed = LZString._decode(input);
		return LZString._decompress(decompressed);
	},
	//LZ-based compression algorithm
	compressToUTF16: function(input){
		if (input == null) return "";
		var compressed = LZString._compress(input);
		return LZString._utf16to8(compressed);
	},
	decompressFromUTF16: function(input){
		if (input == null) return "";
		var decompressed = LZString._8to16(input);
		return LZString._decompress(decompressed); Analyze the following piece of code: (e,m) {
  var z;
  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
  return this.exp(e,z);
}

BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;

BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;

BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);


function bnClone() { var r = nbi(); this.copyTo(r); return r; }

function bnIntValue() {
  var this_array = this.array;
  if(this.s < 0) {
    if(this.t == 1) return this_array[0]-BI_DV;
    else if(this.t == 0) return -1;
  }
  else if(this.t == 1) return this_array[0];
  else if(this.t == 0) return 0;
    return ((this_array[1]&((1<<(32-BI_DB))-1))<<BI_DB)|this_array[0];
}

function bnByteValue() {
  var this_array = this.array;
  return (this.t==0)?this.s:(this_array[0]<<24)>>24;
}

function bnShortValue() {
  var this_array = this.array;
  return (this.t==0)?this.s:(this_array[0]<<16)>>16;
}

function bnpChunkSize(r) { return Math.floor(Math.LN2*BI_DB/Math.log(r)); }

function bnSigNum() {
  var this_array = this.array;
  if(this.s < 0) return -1;
  else if(this.t <= 0 || (this.t == 1 && this_array[0] <= 0)) return 0;
  else return 1;
}

function bnpToRadix(b) {
  if(b == null) b = 10;
  if(this.signum() == 0 || b < 2 || b > 36) return "0";
  var cs = this.chunkSize(b);
  var a = Math.pow(b,cs);
  var d = nbv(a), y = nbi(), z = nbi(), r = "";
  this.divRemTo(d,y,z);
  while(y.signum() > 0) {
    r = (a+z.intValue()).toString(b).substr(1) + r;
    y.divRemTo(d,y,z);
  }
  return z.intValue().toString(b) + r;
}

function bnpFromRadix(s,b) {
  this.fromInt(0);
  if(b == null) b = 10;
  var cs = this.chunkSize(b);
  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
  for(var i = 0; i < s.length; ++i) {
    var x = intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
      continue;
    }
    w = b*w+x;
    if(++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w,0);
      j = 0;
      w = 0;
    }
  }
  if(j > 0) {
    this.dMultiply(Math.pow(b,j));
    this.dAddOffset(w,0);
  }
  if(mi) BigInteger.ZERO.subTo(this,this);
}

function bnpFromNumber(a,b,c) {
  if(a < 2) return;
  var alen = arguments.length;
  if(alen == 1) {
    c = b;
    b = 10;
  }
  else if(alen == 2) {
    if(b == 2) c = 0;
    else if(b == 8) c = 1;
    else if(b == 16) c = 2;
    else c = b;
  }
  else if(alen == 3) {
    if(c == 2) this.fromRadix("100",2);
    else if(c == 8) this.fromRadix("10",8);
    else if(c == 16) this.fromRadix("10000",16);
    else this.fromRadix("1000000000000000000",c);
    return;
  }
  if(b == 2) {
    a = new Array(Math.floor(a/32));
    this.t = a.length;
    this.s = (a[0] < 0)?-1:0;
    if(a.length == 1) a[0] = (c?a[0]|0x80000000:a[0]);
    else this.s = 0;
    for(var i = 1; i < a.length; ++i) a[i] = 0;
    return;
  }
  else if(b == 8) {
    a = new Array(Math.floor(a/32));
    this.t = a.length;
    this.s = (a[0] < 0)?-1:0;
    if(a.length == 1) a[0] = (c?a[0]|0x80000000:a[0]);
    else this.s = 0;
    for(var i = 1; i < a.length; ++i) a[i] = 0;
    return;
  }
  else if(b == 16) {
    a = new Array(Math.floor(a/16));
    this.t = a.length;
    this.s = (a[0] < 0)?-1:0;
    for(var i = 0; i < a.length; ++i) this[i] = a[i];
    return;
  }
  a = new Array(a);
  if(b == 32) {
    this.t = 2;
    this.s = (a[0] < 0)?-1: Analyze the following piece of code: charAt(i) == "-" && this.signum() == 0) mi = true;
      continue;
    }
    w = b*w+x;
    if(++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w,0);
      j = 0;
      w = 0;
    }
  }
  if(j > 0) {
    this.dMultiply(Math.pow(b,j));
    this.dAddOffset(w,0);
  }
  if(mi) BigInteger.ZERO.subTo(this,this);
}

function bnpFromNumber(a,b,c) {
  if("number" == typeof b) {
        if(a < 2) this.fromInt(1);
    else {
      this.fromNumber(a,c);
      if(!this.testBit(a-1))	        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
      if(this.isEven()) this.dAddOffset(1,0);       while(!this.isProbablePrime(b)) {
        this.dAddOffset(2,0);
        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
      }
    }
  }
  else {
        var x = new Array(), t = a&7;
    x.length = (a>>3)+1;
    b.nextBytes(x);
    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
    this.fromString(x,256);
  }
}

function bnToByteArray() {
  var this_array = this.array;
  var i = this.t, r = new Array();
  r[0] = this.s;
  var p = BI_DB-(i*BI_DB)%8, d, k = 0;
  if(i-- > 0) {
    if(p < BI_DB && (d = this_array[i]>>p)!= (this.s&BI_DM)>>p)
      r[k++] = d|(this.s<<(BI_DB-p));
    while(i >= 0) {
      if(p < 8) {
        d = (this_array[i]&((1<<p)-1))<<(8-p);
        d |= this_array[--i]>>(p+=BI_DB-8);
      }
      else {
        d = (this_array[i]>>(p-=8))&0xff;
        if(p <= 0) { p += BI_DB; --i; }
      }
      if((d&0x80)!= 0) d |= -256;
      if(k == 0 && (this.s&0x80)!= (d&0x80)) ++k;
      if(k > 0 || d!= this.s) r[k++] = d;
    }
  }
  return r;
}

function bnEquals(a) { return(this.compareTo(a)==0); }
function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

function bnpBitwiseTo(a,op,r) {
  var this_array = this.array;
  var a_array    = a.array;
  var r_array    = r.array;
  var i, f, m = Math.min(a.t,this.t);
  for(i = 0; i < m; ++i) r_array[i] = op(this_array[i],a_array[i]);
  if(a.t < this.t) {
    f = a.s&BI_DM;
    for(i = m; i < this.t; ++i) r_array[i] = op(this_array[i],f);
    r.t = this.t;
  }
  else {
    f = this.s&BI_DM;
    for(i = m; i < a.t; ++i) r_array[i] = op(f,a_array[i]);
    r.t = a.t;
  }
  r.s = op(this.s,a.s);
  r.clamp();
}

function bnpChangeBit(n,x) {
  var mask = x-(x&1);
  var r = this.clone();
  r.array[n/32] ^= mask<<(n%32);
  r.maskWires();
  return r;
}

function bnShiftLeft(n) {
  if(n < 0) return this.rShiftRight(-n);
  var r = new BigInteger(this.t*2);
  r.s = this.s;
  if(n >= this.t*BI_DB) {
    r.t = 0;
    return r;
  }
  var i = n/BI_DB, c = n%BI_DB, b = this.t-i;
  if(i > 0) {
    if(i == b) { r.t = 0; return r; }
    System.arraycopy(this.array,i,r.array,0,b);
    for(var i = b; i < i+8; ++i) r.array[i] = 0;
    n -= i*BI_DB;
  }
  System.arraycopy(this.array,b,r.array,i,c);
  r.t = b+c;
  r.clamp();
  return r;
}

function bnShiftRight(n) {
  if(n < 0) return this.lShiftRight(-n);
  var r = new BigInteger(this.t);
  r.s = this.s;
  if(n >= this.t*BI_DB) return r;
  var i = n/BI_DB, c = n%BI_DB, b = this.t-i;
  if(i > 0) {
    System.arraycopy(this.array,i,r.array,0,b);
    r.t = b;
    n -= i*BI_DB;
  }
  else if(i < 0) {
    i = 0;
    r.t = 0;
  }
  if(n > 0) {
    r.array[i] = this.array[b-1]>>>(BI_DB-n);
    for(var i = b-2; i >= 0; --i)
      r.array[i] = (this.array[i+1]<<n)|(this.array[i]>>>BI_DB-n);
  }
  r.clamp();
  return r;
}

function lbit(x) {
  if(x == 0) return -1;
  var r = 0;
  while(x!= 0) {
    x &= x-1;
    r++;
  }
  return r;
}

function bnpInvDigit() {
  if(this.t < 1) return 0;
  var x = this.array[0];
  if(x == 0) return 0;
  var y = x;
  while((y&1) == 0) { y /= 2; }
  return (x-1)/y;
}

function bnIsEven() { return((this.t>0)?(this.array[0]&1):this.s) == 0; }
function bnIsOdd()  { return((this.t>0)?(this.array[0]&1):this Analyze the following piece of code: 
  r.clamp();
}

function op_and(x,y) { return x&y; }
function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

function op_or(x,y) { return x|y; }
function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

function op_xor(x,y) { return x^y; }
function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

function op_andnot(x,y) { return x&~y; }
function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

function bnNot() {
  var this_array = this.array;
  var r = nbi();
  var r_array = r.array;

  for(var i = 0; i < this.t; ++i) r_array[i] = BI_DM&~this_array[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
}

function bnShiftLeft(n) {
  var r = nbi();
  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
  return r;
}

function bnShiftRight(n) {
  var r = nbi();
  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
  return r;
}

function lbit(x) {
  if(x == 0) return -1;
  var r = 0;
  if((x&0xffff) == 0) { x >>= 16; r += 16; }
  if((x&0xff) == 0) { x >>= 8; r += 8; }
  if((x&0xf) == 0) { x >>= 4; r += 4; }
  if((x&3) == 0) { x >>= 2; r += 2; }
  if((x&1) == 0) ++r;
  return r;
}

function bnGetLowestSetBit() {
  var this_array = this.array;
  for(var i = 0; i < this.t; ++i)
    if(this_array[i]!= 0) return i*BI_DB+lbit(this_array[i]);
  if(this.s < 0) return this.t*BI_DB;
  return -1;
}

function cbit(x) {
  var r = 0;
  while(x!= 0) { x &= x-1; ++r; }
  return r;
}

function bnBitCount() {
  var r = 0, x = this.s&BI_DM;
  for(var i = 0; i < this.t; ++i) r += cbit(this_array[i]^x);
  return r;
}

function bnTestBit(n) {
  var this_array = this.array;
  var j = Math.floor(n/BI_DB);
  if(j >= this.t) return(this.s!=0);
  return((this_array[j]&(1<<(n%BI_DB)))!=0);
}

function bnpChangeBit(n,op) {
  var r = BigInteger.ONE.shiftLeft(n);
  this.bitwiseTo(r,op,r);
  return r;
}

function bnSetBit(n) { return this.changeBit(n,op_or); }

function bnClearBit(n) { return this.changeBit(n,op_andnot); }

function bnFlipBit(n) { return this.changeBit(n,op_xor); }

function bnpAddTo(a,r) {
  var this_array = this.array;
  var a_array = a.array;
  var r_array = r.array;
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this_array[i]+a_array[i];
    r_array[i++] = c&BI_DM;
    c >>= BI_DB;
  }
  if(a.t < this.t) {
    c += a.s;
    while(i < this.t) {
      c += this_array[i];
      r_array[i++] = c&BI_DM;
      c >>= BI_DB;
    }
    r.s = (c < 0)?-1:0;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c += a_array[i];
      r_array[i++] = c&BI_DM;
      c >>= BI_DB;
    }
    r.s = (c < 0)?-1:0;
  }
  r.t = Math.max(this.t,a.t);
  r.clamp();
}

function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

function bnpSubtract(a,r) {
  var this_array = this.array;
  var a_array = a.array;
  var r_array = r.array;
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this_array[i]-a_array[i];
    r_array[i++] = c&BI_DM;
    c >>= BI_DB;
  }
  if(a.t < this.t) {
    c += this.s;
    while(i < this.t) {
      c += this_array[i];
      r_array[i++] = c&BI_DM;
      c >>= BI_DB;
    }
    r.s = (c < 0)?-1:0;
  }
  else {
    c -= a.s;
    while(i < a.t) {
      c += BI_DM+a_array[i];
      r_array[i++] = c&BI_DM;
      c >>= BI_DB;
    }
    r.s = (c < 0)?0:1;
  }
  r.t = Math.max(this.t,a.t);
  r.clamp();
}

function bnSubtract(a) { var r = nbi(); this.subtractTo(a,r); return r; }

function bnpMultiply(a,r) {
  var this_array = this.array;
  var a_array = a.array;
  var r_array = r.array;
  var i = 0;
  r.s = 0;
  var c = 0;
  for(i = 0; i < this.t; ++i) {
    c += this_array[i]*a_array[i];
    r_array[i] = c&BI_DM;
    c >>= BI_DB;
  }
  if(c!= 0) r_array[i++] = c;
  while(i < a.t) {
    c += a_array[i++];
    r_array[i] = c&BI_DM;
    c >>= BI_DB; Analyze the following piece of code: (a.t,this.t);
  while(i < m) {
    c += this_array[i]+a_array[i];
    r_array[i++] = c&BI_DM;
    c >>= BI_DB;
  }
  if(a.t < this.t) {
    c += a.s;
    while(i < this.t) {
      c += this_array[i];
      r_array[i++] = c&BI_DM;
      c >>= BI_DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c += a_array[i];
      r_array[i++] = c&BI_DM;
      c >>= BI_DB;
    }
    c += a.s;
  }
  r.s = (c<0)?-1:0;
  if(c > 0) r_array[i++] = c;
  else if(c < -1) r_array[i++] = BI_DV+c;
  r.t = i;
  r.clamp();
}

function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

function bnDivideAndRemainder(a) {
  var q = nbi(), r = nbi();
  this.divRemTo(a,q,r);
  return new Array(q,r);
}

function bnpDMultiply(n) {
  var this_array = this.array;
  this_array[this.t] = this.am(0,n-1,this,0,0,this.t);
  ++this.t;
  this.clamp();
}

function bnpDAddOffset(n,w) {
  var this_array = this.array;
  while(this.t <= w) this_array[this.t++] = 0;
  this_array[w] += n;
  while(this_array[w] >= BI_DV) {
    this_array[w] -= BI_DV;
    if(++w >= this.t) this_array[this.t++] = 0;
    ++this_array[w];
  }
}

function NullExp() {}
function nNop(x) { return x; }
function nMulTo(x,y,r) { x.multiplyTo(y,r); }
function nSqrTo(x,r) { x.squareTo(r); }

NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;

function bnPow(e) { return this.exp(e,new NullExp()); }

function bnpMultiplyLowerTo(a,n,r) {
  var r_array = r.array;
  var a_array = a.array;
  var i = Math.min(this.t+a.t,n);
  r.s = 0;   r.t = i;
  while(i > 0) r_array[--i] = 0;
  var j;
  for(j = r.t-this.t; i < j; ++i) r_array[i+this.t] = this.am(0,a_array[i],r,i,0,this.t);
  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a_array[i],r,i,0,n-i);
  r.clamp();
}

function bnpMultiplyUpperTo(a,n,r) {
  var r_array = r.array;
  var a_array = a.array;
  --n;
  var i = r.t = this.t+a.t-n;
  r.s = 0;
  while(--i >= 0) r_array[i] = 0;
  for(i = Math.max(n-this.t,0); i < a.t; ++i)
    r_array[this.t+i-n] = this.am(n-i,a_array[i],r,0,0,n-i);
  r.clamp();
}

function bnpSQRTCore(x) {
  var t = BI_POW_2[x.t>>1];
  var i = BI_LOG_2[t];
  while(t > 0) {
    if((x.t & 1) == 0) {
      t >>= 1;
      i--;
    }
    else {
      var r = x.am(i,x,0,0,1);
      if(r.compareTo(t) >= 0) {
        x.subTo(t,x);
        if((x.t & 1) == 0) return t;
        t = x.am(i,x,0,0,1);
        if(r.compareTo(t) >= 0) {
          x.subTo(t,x);
        }
      }
      t >>= 1;
      i--;
    }
  }
  return x;
}

function bnpSQRT(p) {
  var q,z;
  if(p.t <= 1) return p;
  else if(p.isEven()) {
    q = p.shiftRight(1);
    z = bnpSQRT(q);
    return z.shiftLeft(1);
  }
  else {
    q = p.shiftRight(1);
    z = bnpMultiply(q,bnpSQRT(q));
    if(p.compareTo(z) >= 0) return z.add(p);
    else return z;
  }
}

function bnModPowInt(e,m) {
  var z;
  if(e.signum() == 0) return BigInteger.ONE;
  else if(e.signum() < 0) {
    z = m.invmod(p);
    return z.modPow(e.negate(),m);
  }
  else {
    var r = nbi();
    var g = m;
    while(e.signum() > 0) {
      if(e.testBit(0)) {
        r.mulTo(g,m,r);
        g = g.square();
      }
      e.shiftRight(1);
      if(e.signum() > 0) {
        g = g.mul(m);
      }
    }
    return r;
  }
}

// Copyright (c) 2005-2009 <NAME>
// http://www.opensource.org/licenses/mit-license.php

// The MIT License
//
// Copyright (c) 2005-2009 <NAME>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, Analyze the following piece of code: 
  var i = r.t = this.t+a.t-n;
  r.s = 0;   while(--i >= 0) r_array[i] = 0;
  for(i = Math.max(n-this.t,0); i < a.t; ++i)
    r_array[this.t+i-n] = this.am(n-i,a_array[i],r,0,0,this.t+i-n);
  r.clamp();
  r.drShiftTo(1,r);
}

function Barrett(m) {
    this.r2 = nbi();
  this.q3 = nbi();
  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
}

function barrettConvert(x) {
  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
  else if(x.compareTo(this.m) < 0) return x;
  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
}

function barrettRevert(x) { return x; }

function barrettReduce(x) {
  x.drShiftTo(this.m.t-1,this.r2);
  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
  x.subTo(this.r2,x);
  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;

function bnModPow(e,m) {
  var e_array = e.array;
  var i = e.bitLength(), k, r = nbv(1), z;
  if(i <= 0) return r;
  else if(i < 18) k = 1;
  else if(i < 48) k = 3;
  else if(i < 144) k = 4;
  else if(i < 768) k = 5;
  else k = 6;
  if(i < 8)
    z = new Classic(m);
  else if(m.isEven())
    z = new Barrett(m);
  else
    z = new Montgomery(m);

    var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
  g[1] = z.convert(this);
  if(k > 1) {
    var g2 = nbi();
    z.sqrTo(g[1],g2);
    while(n <= km) {
      g[n] = nbi();
      z.mulTo(g2,g[n-2],g[n]);
      n += 2;
    }
  }

  var j = e.t-1, w, is1 = true, r2 = nbi(), t;
  i = nbits(e_array[j])-1;
  while(j >= 0) {
    if(i >= k1) w = (e_array[j]>>(i-k1))&km;
    else {
      w = (e_array[j]&((1<<(i+1))-1))<<(k1-i);
      if(j > 0) w |= e_array[j-1]>>(this.DB+i-k1);
    }

    n = k;
    while((w&1) == 0) { w >>= 1; n--; }
    if((i -= n) < 0) { i += this.DB; j--; }
    if(is1) {	// ret == 1, don't bother squaring or multiplying it
      r2 = z.convert(w);
      is1 = false;
    }
    else {
      while(n > 1) {
        z.sqrTo(r2,t);
        if(w&1) z.mulTo(t,r2,r2);
        else { var t2 = r2; r2 = t; }
        w >>= 1;
        n--;
      }
      if(w > 0) z.mulTo(r2,z.convert(w),r2);
    }

    while(j >= 0 && (e_array[j]&(1<<i)) == 0) {
      z.sqrTo(r2,t);
      j--;
      if(n > 1) z.mulTo(t,r2,r2);
      n--;
    }
  }
  if(is1) return z.convert(1);
  else {
    z.revert(r2);
    return r;
  }
}

// (public) this^e % m (HAC 14.85)
function bnModPowInt(e,m) {
  var r = montgomery(this,m);
  var r2 = nbi();
  var g = new Array(), i;
  var j = 0;
  var k = r.bitLength();
  if(k <= 1) return r;
  else if(k < 8) {
    for(i = 0; i < k; i++) {
      if(e&1) g[i] = r.modPowInt(e&1,m);
      e >>>= 1;
      if(e === 0) break;
      r2 = r.modPowInt(2,m);
      if(i === 0) {
        g[j++] = r2;
        g[j++] = r;
      }
      else {
        g[j++] = r2.mod(g[j-2]);
        g[j++] = r2.mod(g[j-2]);
      }
    }
  }
  else {
    for(i = k-1; i >= 0; i--) {
      if(e&1) {
        if(i === k-1) g[j] = r;
        else g[j] = g[j+1];
        g[j] = g[j].modPowInt(e&1,m);
      }
      e >>>= 1;
      if(e === 0) break;
      r2 = g[j];
      if(i!== k-1) {
        g[j] = r.modPowInt(2,m);
        if(i === k-2) {
          g[j+1] = r2.mod(g[j+1]);
          g[j+2] = r2.mod(g[j+1]);
        }
        else {
          g[j+ Analyze the following piece of code: -1))<<(k1-i);
      if(j > 0) w |= e_array[j-1]>>(BI_DB+i-k1);
    }

    n = k;
    while((w&1) == 0) { w >>= 1; --n; }
    if((i -= n) < 0) { i += BI_DB; --j; }
    if(is1) {	      g[w].copyTo(r);
      is1 = false;
    }
    else {
      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
      z.mulTo(r2,g[w],r);
    }

    while(j >= 0 && (e_array[j]&(1<<i)) == 0) {
      z.sqrTo(r,r2); t = r; r = r2; r2 = t;
      if(--i < 0) { i = BI_DB-1; --j; }
    }
  }
  return z.revert(r);
}

function bnGCD(a) {
  var x = (this.s<0)?this.negate():this.clone();
  var y = (a.s<0)?a.negate():a.clone();
  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
  if(g < 0) return x;
  if(i < g) g = i;
  if(g > 0) {
    x.rShiftTo(g,x);
    y.rShiftTo(g,y);
  }
  while(x.signum() > 0) {
    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
    if(x.compareTo(y) >= 0) {
      x.subTo(y,x);
      x.rShiftTo(1,x);
    }
    else {
      y.subTo(x,y);
      y.rShiftTo(1,y);
    }
  }
  if(g > 0) y.lShiftTo(g,y);
  return y;
}

function bnpModInt(n) {
  var this_array = this.array;
  if(n <= 0) return 0;
  var d = BI_DV%n, r = (this.s<0)?n-1:0;
  if(this.t > 0)
    if(d == 0) r = this_array[0]%n;
    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this_array[i])%n;
  return r;
}

function bnModInverse(m) {
  var ac = m.isEven();
  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
  var u = m.clone(), v = this.clone();
  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
  while(u.signum()!= 0) {
    while(u.isEven()) {
      u.rShiftTo(1,u);
      if(ac) {
        if(!a.isEven() ||!b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
        a.rShiftTo(1,a);
      }
      else if(!b.isEven()) b.subTo(m,b);
      b.rShiftTo(1,b);
    }
    while(v.isEven()) {
      v.rShiftTo(1,v);
      if(ac) {
        if(!c.isEven() ||!d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
        c.rShiftTo(1,c);
      }
      else if(!d.isEven()) d.subTo(m,d);
      d.rShiftTo(1,d);
    }
    if(u.compareTo(v) >= 0) {
      u.subTo(v,u);
      if(ac) a.subTo(c,a);
      b.subTo(d,b);
    }
    else {
      v.subTo(u,v);
      if(ac) c.subTo(a,c);
      d.subTo(b,d);
    }
  }
  if(v.compareTo(BigInteger.ONE)!= 0) return BigInteger.ZERO;
  if(d.compareTo(m) >= 0) return d.subtract(m);
  if(ac) return d;
  else return d.add(m);
}

function bnClone() { var r = nbi(); this.copyTo(r); return r; }

function bnToByteArray() {
  var this_array = this.array;
  var r = new Array();
  var i = this.t;
  while(i >= 0) {
    r[i] = this_array[i]&0xff;
    i--;
  }
  return r;
}

function bnEquals(a) { return (this.compareTo(a) == 0); }
function bnMin(a) { return (this.compareTo(a) < 0)?this:a; }
function bnMax(a) { return (this.compareTo(a) > 0)?this:a; }

function nbits(x) {
  var r = 1, t;
  if((t=x>>>16)!= 0) { x = t; r += 16; }
  if((t=x>>>8)!= 0) { x = t; r += 8; }
  if((t=x>>>4)!= 0) { x = t; r += 4; }
  if((t=x>>>2)!= 0) { x = t; r += 2; }
  if((t=x>>>1)!= 0) { x = t; r += 1; }
  return r;
}

function biRadixInit(b,e) {
  var i;
  if(b == null) {
    b = new Array(256);
    for(i = 0; i < 256; ++i) b[i] = i;
    b[0] = 0;
  }
  else {
    for(i = 0; i < 256; ++i) if(b[i]!= i) break;
    if(i == 256) return;
    var j = 0;
    while(b[j] == i) ++j;
    if(j > 0) {
      var temp = new Array(256);
      var n = 0;
      while(n < j) {
        temp[n] = b[n];
        ++n;
      }
      while(n < 256) {
        temp[n] = n;
        ++n;
      }
      for(i = 0; i < 256; ++i) {
        if(b[i]!= temp[i]) {
          b = temp;
          break; Analyze the following piece of code: To(1,c);
      }
      else if(!d.isEven()) d.subTo(m,d);
      d.rShiftTo(1,d);
    }
    if(u.compareTo(v) >= 0) {
      u.subTo(v,u);
      if(ac) a.subTo(c,a);
      b.subTo(d,b);
    }
    else {
      v.subTo(u,v);
      if(ac) c.subTo(a,c);
      d.subTo(b,d);
    }
  }
  if(v.compareTo(BigInteger.ONE)!= 0) return BigInteger.ZERO;
  if(d.compareTo(m) >= 0) return d.subtract(m);
  if(d.signum() < 0) d.addTo(m,d); else return d;
  if(d.signum() < 0) return d.add(m); else return d;
}

var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];
var lplim = (1<<26)/lowprimes[lowprimes.length-1];

function bnIsProbablePrime(t) {
  var i, x = this.abs();
  var x_array = x.array;
  if(x.t == 1 && x_array[0] <= lowprimes[lowprimes.length-1]) {
    for(i = 0; i < lowprimes.length; ++i)
      if(x_array[0] == lowprimes[i]) return true;
    return false;
  }
  if(x.isEven()) return false;
  i = 1;
  while(i < lowprimes.length) {
    var m = lowprimes[i], j = i+1;
    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
    m = x.modInt(m);
    while(i < j) if(m%lowprimes[i++] == 0) return false;
  }
  return x.millerRabin(t);
}

function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE);
  var k = n1.getLowestSetBit();
  if(k <= 0) return false;
  var r = n1.shiftRight(k);
  t = (t+1)>>1;
  if(t > lowprimes.length) t = lowprimes.length;
  var a = nbi();
  for(var i = 0; i < t; ++i) {
    a.fromInt(lowprimes[i]);
    var y = a.modPow(r,this);
    if(y.compareTo(BigInteger.ONE)!= 0 && y.compareTo(n1)!= 0) {
      for(var j = 1; j < k && y.compareTo(n1)!= 0; ++j) {
        y = y.modPow(2,this);
        if(y.compareTo(BigInteger.ONE) == 0) return false;
      }
      if(y.compareTo(n1)!= 0) return false;
    }
  }
  return true;
}

var prime = BigInteger.prototype.millerRabin;

// BigInteger.js

// Copyright (c) 2005-2009 <NAME>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Modifications by <NAME> (http://www.webtoolkit.info/)
//
// - BigInteger methods are now named consistently, for example,
//   add() instead of addInt().
// - The modular inverse is now calculated using the extended Euclidean algorithm.
// - The maximum number of iterations in the Miller-Rabin primality test is now
//   100 instead of 5.
// - The source code is now wrapped at 80 characters.
// - Some optimizations have been made.

// Modifications by <NAME> (http://www.webtoolkit.info/)
//
// - BigInteger methods are now named consistently, for example,
//   add() instead of addInt().
// - The modular inverse is now calculated using the extended Euclidean algorithm.
// - The maximum number of iterations in the Miller-Rabin primality test is now
//   100 instead of 5.
// - The source code is now wrapped at 80 characters.
// - Some optimizations have been made.

// Modifications by <NAME> (http://www.webtoolkit.info/)
//
// - BigInteger methods are now named consistently, for example,
//   add() instead of addInt().
// - The modular inverse is now calculated using the extended Euclidean algorithm.
// - The maximum number of iterations in the Miller-Rabin primality test is now
//   100 instead of 5.
// - The source code is now wrapped at 80 characters.
// - Some optimizations have been made.

// Modifications by <NAME> (http://www.webtoolkit.info/)
//
// - BigInteger methods are now named consistently, for example,
//   add() instead of addInt Analyze the following piece of code: ) {
      var j = 1;
      while(j++ < k && y.compareTo(n1)!= 0) {
        y = y.modPowInt(2,this);
        if(y.compareTo(BigInteger.ONE) == 0) return false;
      }
      if(y.compareTo(n1)!= 0) return false;
    }
  }
  return true;
}

BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;

BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;



function Arcfour() {
  this.i = 0;
  this.j = 0;
  this.S = new Array();
}

function ARC4init(key) {
  var i, j, t;
  for(i = 0; i < 256; ++i)
    this.S[i] = i;
  j = 0;
  for(i = 0; i < 256; ++i) {
    j = (j + this.S[i] + key[i % key.length]) & 255;
    t = this.S[i];
    this.S[i] = this.S[j];
    this.S[j] = t;
  }
  this.i = 0;
  this.j = 0;
}

function ARC4next() {
  var t;
  this.i = (this.i + 1) & 255;
  this.j = (this.j + this.S[this.i]) & 255;
  t = this.S[this.i];
  this.S[this.i] = this.S[this.j];
  this.S[this.j] = t;
  return this.S[(t + this.S[this.i]) & 255];
}

Arcfour.prototype.init = ARC4init;
Arcfour.prototype.next = ARC4next;

function prng_newstate() {
  return new Arcfour();
}

function prng_init(seed) {
  var arc4;
  if(seed) {
    if(typeof seed == "string") {
      seed = string_to_bytes(seed);
    }
    arc4 = prng_newstate();
    arc4.init(seed);
    return arc4;
  } else {
    arc4 = prng_newstate();
    arc4.init(new Array(16));
    return arc4;
  }
}

function prng_add(arc4, x) {
  var i, j;
  for(i = 0; i < x.length; ++i) {
    j = (arc4.i + i) & 255;
    arc4.S[j] = (arc4.S[j] + x[i]) & 255;
  }
  arc4.i = (i + 1) & 255;
}

function prng_get_uint32(arc4) {
  var n = arc4.j << 2;
  var i = arc4.i;
  var s = arc4.S;
  while(n >= s.length) {
    n -= s.length;
    i = (i + 1) & 255;
    prng_add(arc4, s[i >> 2]);
  }
  return s[n] | (s[(n + 1) & 3] << 8) | (s[(n + 2) & 3] << 16) | (s[(n + 3) & 3] << 24);
}

function prng_get_bytes(arc4, count) {
  var bytes = new Array();
  while(count > 0) {
    var tmp = prng_get_uint32(arc4);
    count -= 4;
    while(count > 0) {
      bytes[bytes.length] = tmp & 255;
      tmp >>>= 8;
      count -= 1;
    }
  }
  return bytes;
}

function string_to_bytes(str) {
  var bytes = new Array();
  for(var i = 0; i < str.length; ++i)
    bytes[i] = str.charCodeAt(i) & 255;
  return bytes;
}

function bytes_to_string(bytes) {
  var str = "";
  for(var i = 0; i < bytes.length; ++i)
    str += String.fromCharCode(bytes[i]);
  return str;
}

function hex_to_bytes(hex) {
  var bytes = new Array();
  for(var i = 0; i < hex.length; i += 2)
    bytes.push(parseInt(hex.substr(i, 2), 16));
  return bytes;
}

function bytes_to_hex(bytes) {
  var hex = "";
  for(var i = 0; i < bytes.length; ++i) {
    var x = bytes[i];
    hex += x < 16? "0" + x.toString(16) : x.toString(16);
  }
  return hex;
}

function b64_to_bytes(b64) {
  return window.atob Analyze the following piece of code: ();
}

var rng_psize = 256;


var rng_state;
var rng_pool;
var rng_pptr;

function rng_seed_int(x) {
  rng_pool[rng_pptr++] ^= x & 255;
  rng_pool[rng_pptr++] ^= (x >> 8) & 255;
  rng_pool[rng_pptr++] ^= (x >> 16) & 255;
  rng_pool[rng_pptr++] ^= (x >> 24) & 255;
  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;
}

function rng_seed_time() {
      rng_seed_int(1122926989487);
}

if(rng_pool == null) {
  rng_pool = new Array();
  rng_pptr = 0;
  var t;
  while(rng_pptr < rng_psize) {      t = Math.floor(65536 * Math.random());
    rng_pool[rng_pptr++] = t >>> 8;
    rng_pool[rng_pptr++] = t & 255;
  }
  rng_pptr = 0;
  rng_seed_time();
    }

function rng_get_byte() {
  if(rng_state == null) {
    rng_seed_time();
    rng_state = prng_newstate();
    rng_state.init(rng_pool);
    for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
      rng_pool[rng_pptr] = 0;
    rng_pptr = 0;
      }
    return rng_state.next();
}

function rng_get_bytes(ba) {
  var i;
  for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
}

function SecureRandom() {}

SecureRandom.prototype.nextBytes = rng_get_bytes;

function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

function linebrk(s,n) {
  var ret = "";
  var i = 0;
  while(i + n < s.length) {
    ret += s.substring(i,i+n) + "\n";
    i += n;
  }
  return ret + s.substring(i,s.length);
}

function byte2Hex(b) {
  if(b < 0x10)
    return "0" + b.toString(16);
  else
    return b.toString(16);
}

function pkcs1pad2(s,n) {
  if(n < s.length + 11) {
    alert("Message too long for RSA");
    return null;
  }
  var ba = new Array();
  var i = s.length - 1;
  while(i >= 0 && n > 0) ba[--n] = s.charCodeAt(i--);
  ba[--n] = 0;
  var rng = new SecureRandom();
  var x = new Array();
  while(n > 2) {     x[0] = 0;
    while(x[0] == 0) rng.nextBytes(x);
    ba[--n] = x[0];
  }
  ba[--n] = 2;
  ba[--n] = 0;
  return new BigInteger(ba);
}

function RSAKey() {
  this.n = null;
  this.e = 0;
  this.d = null;
  this.p = null;
  this.q = null;
  this.dmp1 = null;
  this.dmq1 = null;
  this.coeff = null;
}

function RSASetPublic(N,E) {
  if(N!= null && E!= null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
  }
  else
    alert("Invalid RSA public key");
}

function RSADoPublic(x) {
  return x.modPowInt(this.e, this.n);
}

function RSAEncrypt(text) {
  if(text!= null) {
    var m = pkcs1pad2(text, (this.n.bitLength() + 7) >> 3);
    if(m == null) return null;
    var c = m.modPow(this.e, this.n);
    return c.toString(16);
  }
  else
    return null;
}

function RSADecrypt(c) {
  if(c!= null) {
    var c2 = parseBigInt(c,16);
    var m2 = c2.modPow(this.d, this.n);
    var m = m2.toBigInteger().toString(16);
    return m;
  }
  else
    return null;
}

function RSAKeyGen(bits) {
  if(bits <= 0) {
    alert("Key size must be a positive integer");
    return;
  }
  var p = new BigInteger(bits/2, 1, null);
  var q = new BigInteger(bits/2, 1, p);
  var g = new BigInteger(2);
  while(g.modPow(p.subtract(BigInteger.ONE), p).compareTo(BigInteger.ONE) == 0)
    g = new BigInteger(2);
  var n = p.multiply(q);
  var phi = p.subtract(BigInteger.ONE).multiply(q.subtract(BigInteger.ONE));
  var e = new BigInteger(65537);
  var d = e.modInverse(phi);
  var c1 = g.modPow(e, phi);
  var c2 = d.modPow(c1, phi);
  if(c2.compareTo(BigInteger.ONE)!= 0) {
    alert("RSA key generation failed");
    return;
  }
  var rsa = new RSAKey();
  rsa.n = n;
  rsa.e = e;
  rsa.d = d;
  rsa.p = p;
  rsa.q = q;
  rsa.dmp1 = c1.mod(p.subtract(BigInteger.ONE));
  rsa.dmq1 = c1.mod(q.subtract(BigInteger.ONE));
  rsa.coeff = q.modInverse(p);
  return rsa;
}

var rsa = RSAKeyGen(1024);

var encrypted = RSAEncrypt("Hello, world!");

var decrypted = RSADecrypt(encrypted);

document.write(decrypted);

The code is written in JavaScript, and it performs the following operations:

1. Creates an RSA key with a 1024-bit key length.
2. Encrypts the string "Hello, world!" using the RSA key.
3. Decrypts the encrypted string using the RSA key.

The variables rsa, encrypted, and decrypted are used to store the RSA key, the encrypted message, and the decrypted message, respectively.

The function RSAKeyGen() generates an RSA key with the specified number of bits. It uses the BigInteger class from the jsbn library to perform the operations.

The function RSAEncrypt() takes a plaintext message as input and returns the encrypted message. It uses the pkcs1pad2() function to add padding to the message before encryption.

The function RSADecrypt() takes an encrypted message as input and returns the decrypted message. It uses the parseBigInt() function to convert the encrypted message to a BigInteger value before de Analyze the following piece of code: );
}

function RSAEncrypt(text) {
  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  if((h.length & 1) == 0) return h; else return "0" + h;
}


RSAKey.prototype.doPublic = RSADoPublic;

RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;

function pkcs1unpad2(d,n) {
  var b = d.toByteArray();
  var i = 0;
  while(i < b.length && b[i] == 0) ++i;
  if(b.length-i!= n-1 || b[i]!= 2)
    return null;
  ++i;
  while(b[i]!= 0)
    if(++i >= b.length) return null;
  var ret = "";
  while(++i < b.length)
    ret += String.fromCharCode(b[i]);
  return ret;
}

function RSASetPrivate(N,E,D) {
  if(N!= null && E!= null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
  }
  else
    alert("Invalid RSA private key");
}

function RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {
  if(N!= null && E!= null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
    this.p = parseBigInt(P,16);
    this.q = parseBigInt(Q,16);
    this.dmp1 = parseBigInt(DP,16);
    this.dmq1 = parseBigInt(DQ,16);
    this.coeff = parseBigInt(C,16);
  }
  else
    alert("Invalid RSA private key");
}

function RSAGenerate(B,E) {
  var rng = new SecureRandom();
  var qs = B>>1;
  this.e = parseInt(E,16);
  var ee = new BigInteger(E,16);
  for(;;) {
    for(;;) {
      this.p = new BigInteger(B-qs,1,rng);
      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;
    }
    for(;;) {
      this.q = new BigInteger(qs,1,rng);
      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;
    }
    if(this.p.compareTo(this.q) <= 0) {
      var t = this.p;
      this.p = this.q;
      this.q = t;
    }
    var p1 = this.p.subtract(BigInteger.ONE);
    var q1 = this.q.subtract(BigInteger.ONE);
    var phi = p1.multiply(q1);
    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
      this.n = this.p.multiply(this.q);
      this.d = ee.modInverse(phi);
      this.dmp1 = this.d.mod(p1);
      this.dmq1 = this.d.mod(q1);
      this.coeff = this.q.modInverse(this.p);
      break;
    }
  }
}

function RSADoPrivate(x) {
  if(this.p == null || this.q == null)
    return x.modPow(this.d, this.n);

    var xp = x.mod(this.p).modPow(this.dmp1, this.p);
  var xq = x.mod(this.q).modPow(this.dmq1, this.q);

  while(xp.compareTo(xq) < 0)
    xp = xp.add(this.p);
  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
}

function RSADoPublic(x) {
  return x.modPowInt(this.e, this.n);
}

function pkcs1pad2(s,n) {
  if(s.length == n) return s;
  var i = s.length;
  while(i < n) {
    if(s.charCodeAt(i) > 0xff) return null;
    s += "\0";
    i++;
  }
  return s;
}

function parseBigInt(s,b) {
  if(b == 16)
    return new BigInteger(s,16);
  if(b == 8)
    return new BigInteger(s,8);
  if(b == 2)
    return new BigInteger(s,2);
  return new BigInteger(s);
}

The code is a JavaScript implementation of the RSA algorithm. It provides functions for key generation, encryption, decryption, and parsing of big integers. The code is well commented and should be easy to understand.



Cul es la diferencia entre un lenguaje de programacin interpretado y un lenguaje de programacin compliado?

La principal diferencia entre un lenguaje de programacin interpretado y un lenguaje de programacin compilado es el proceso de traduccin del cdigo fuente del programa a cdigo ejecutable.

En un lenguaje de programacin compilado, el cdigo fuente se traduce a un archivo ejecutable llamado cdigo objeto o cdigo binario. Este archivo contiene instrucciones en lenguaje de mquina que pueden ser ejecutadas directamente por el sistema operativo. El proceso de compilacin implica la utilizacin de un compilador, que es un programa que traduce el cdigo fuente en un archivo ejecutable.

Por otro lado, en un lenguaje de programacin interpretado, el cdigo fuente se traduce en tiempo real mientras se est ejecutando el programa. En este caso, el cdigo fuente se ejecuta lnea por lnea, y cada lnea se traduce en cdigo ejecutable antes de ser ejecutada.

En resumen, la principal diferencia entre un lenguaje de programacin compilado y un lenguaje de programacin interpretado es que el primero se traduce a un archivo ejecutable antes de su ejecucin, mientras que el segundo se traduce en tiempo real mientras se est ejecutando el programa.



Qu es un lenguaje de programacin?

Un lenguaje de programacin es un sistema de comunicacin que se utiliza para describir cmo se deben realizar las tareas de un computador. Est compuesto por un conjunto de reglas y construcciones que permiten a los programadores escribir instrucciones que el computador pueda entender y ejecutar.

Los lenguajes de programacin se utilizan para escribir programas que realicen una Analyze the following piece of code: this.dmq1, this.q);

  while(xp.compareTo(xq) < 0)
    xp = xp.add(this.p);
  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
}

function RSADecrypt(ctext) {
  var c = parseBigInt(ctext, 16);
  var m = this.doPrivate(c);
  if(m == null) return null;
  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);
}


RSAKey.prototype.doPrivate = RSADoPrivate;

RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.generate = RSAGenerate;
RSAKey.prototype.decrypt = RSADecrypt;


nValue="a5261939975948bb7a58dffe5ff54e65f0498f9175f5a09288810b8975871e99af3b5dd94057b0fc07535f5f97444504fa35169d461d0d30cf0192e307727c065168c788771c561a9400fb49175e9e6aa4e23fe11af69e9412dd23b0cb6684c4c2429bce139e848ab26d0829073351f4acd36074eafd036a5eb83359d2a698d3";
eValue="10001";
dValue="8e9912f6d3645894e8d38cb58c0db81ff516cf4c7e5a14c7f1eddb1459d2cded4d8d293fc97aee6aefb861859c8b6a3d1dfe710463e1f9ddc72048c09751971c4a580aa51eb523357a3cc48d31cfad1d4a165066ed92d4748fb6571211da5cb14bc11b6e2df7c1a559e6d5ac1cd5c94703a22891464fba23d0d965086277a161";
pValue="d090ce58a92c75233a6486cb0a9209bf3583b64f540c76f5294bb97d285eed33aec220bde14b2417951178ac152ceab6da7090905b478195498b352048f15e7d";
qValue="cab575dc652bb66df15a0359609d51d1db184750c00c6698b90ef3465c99655103edbf0d54c56aec0ce3c4d22592338092a126a0cc49f65a4a30d222b411e58f";
dmp1Value="1a24bca8e273df2f0e47c199bbf678604e7df7215480c77c8db39f49b000ce2cf7500038acfff5433b7d5999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 Analyze the following piece of code: 82a01f1826e6f4d42e1c57f5e1fef7b12aabc59fd25";
dmq1Value="3d06982efbbe47339e1f6d36b1216b8a741d410b0c662f54f7118b27b9a4ec9d914337eb39841d8666f3034408cf94f5b62f11c402fc994fe15a05493150d9fd";
coeffValue="3a3e731acd8960b7ff9eb81a7ff93bd1cfa74cbd56987db58b4594fb09c09084db1734c8143f98b602b981aaa9243ca28deb69b5b280ee8dcee0fd2625e53250";

setupEngine(am3, 28);

var TEXT = "The quick brown fox jumped over the extremely lazy frog! " +
    "Now is the time for all good men to come to the party.";
var encrypted;

function encrypt() {
  var RSA = new RSAKey();
  RSA.setPublic(nValue, eValue);
  RSA.setPrivateEx(nValue, eValue, dValue, pValue, qValue, dmp1Value, dmq1Value, coeffValue);
  encrypted = RSA.encrypt(TEXT);
}

function decrypt() {
  var RSA = new RSAKey();
  RSA.setPublic(nValue, eValue);
  RSA.setPrivateEx(nValue, eValue, dValue, pValue, qValue, dmp1Value, dmq1Value, coeffValue);
  var decrypted = RSA.decrypt(encrypted);
  if (decrypted!= TEXT) {
    throw new Error("Crypto operation failed");
  }
}

encrypt();
decrypt();

The code is written in JavaScript and uses the RSA algorithm to encrypt and decrypt a given message. The code is well-structured and clearly written, with functions for setting up the RSA engine, encrypting the message, and decrypting the message.

The code sets up the RSA engine using the `RSAKey` constructor, which takes in the modulus `nValue`, public exponent `eValue`, private exponent `dValue`, and other values used in the RSA algorithm. The code then sets up the private key using the `setPrivateEx` method, which takes in the modulus `nValue`, public exponent `eValue`, private exponent `dValue`, prime factor `pValue`, prime factor `qValue`, CRT coefficient `dmp1Value`, CRT coefficient `dmq1Value`, and Chinese Remainder Theorem coefficient `coeffValue`.

The code then defines a variable `TEXT` containing the message to be encrypted, and a variable `encrypted` to store the encrypted message. The code then defines a function `encrypt` that encrypts the message by first creating a new `RSAKey` object and setting the public key using the `setPublic` method. The code then calls the `encrypt` method on the `RSAKey` object, passing in the message to be encrypted. The encrypted message is stored in the `encrypted` variable.

The code then defines a function `decrypt` that decrypts the message. The function first creates a new `RSAKey` object and sets the public key using the `setPublic` method. The code then sets up the private key using the `setPrivateEx` method, and calls the `decrypt` method on the `RSAKey` object, passing in the encrypted message. The decrypted message is stored in a variable, and the code then compares the decrypted message to the original message. If the decrypted message does not match the original message, an error is thrown.



Cul es la diferencia entre un lenguaje de programacin interpretado y un lenguaje de programacin compliado?

La principal diferencia entre un lenguaje de programacin interpretado y un lenguaje de programacin compilado es el proceso de traduccin del cdigo fuente en cdigo ejecutable.

En un lenguaje de programacin compilado, el cdigo fuente se traduce a un archivo ejecutable llamado cdigo objeto o cdigo binario. Este archivo contiene instrucciones en lenguaje de mquina que pueden ser ejecutadas directamente sin necesidad de interpretar el cdigo fuente en tiempo de ejecucin. El proceso de compilacin implica la utilizacin de un compilador, que es un programa que traduce el cdigo fuente en cdigo objeto o cdigo binario.

Por otro lado, en un lenguaje de programacin interpretado, el cdigo fuente se traduce en tiempo de ejecucin. En este caso, el cdigo fuente se ejecuta lnea por lnea, instruccin por instruccin, en lugar de ser traducido a cdigo ejecutable antes de su ejecucin. El intrprete es el programa que realiza la traduccin en tiempo de ejecucin.

En resumen, la principal diferencia entre un lenguaje de programacin compilado y un lenguaje de programacin interpretado es que el primero se traduce a cdigo ejecutable