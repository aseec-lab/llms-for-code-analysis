Analyze the following piece of code: 
(function( window, undefined ) {

var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

var jQuery = function( selector, context ) {
				return new jQuery.fn.init( selector, context, rootjQuery );
	},

		_jQuery = window.jQuery,

		_$ = window.$,

		rootjQuery,

			quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

		rnotwhite = /\S/,

		trimLeft = /^\s+/,
	trimRight = /\s+$/,

		rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

		rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

		rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

		rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

		fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

		userAgent = navigator.userAgent,

		browserMatch,

		readyList,

		DOMContentLoaded,

		toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

		class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

				if (!selector ) {
			return this;
		}

				if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

				if ( selector === "body" &&!context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

				if ( typeof selector === "string" ) {
						if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
								match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

						if ( match && (match[1] ||!context) ) {

								if ( match[1] ) {
					context = context instanceof jQuery? context[0] : context;
					doc = ( context? context.ownerDocument || context : document );

															ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

								} else {
					elem = document.getElementById( match[2] );

															if ( elem && elem.parentNode ) {
					if ( elem.id!== match[2] ) {
						return rootjQuery.find( selector );
					}

														this.length = 1;
					this[0] = elem;
					this.context = document;
					this.selector = selector;
					return this;
				}
			}
		}

if (!context || context.jquery ) {
			return ( context || rootjQuery ).find( selector );
		}

		return this.constructor( context ).find( selector );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.11.3",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			this[ num >= 0? num : num + this.length ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = this.constructor( elems );

		// Add the old object onto the stack
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0? len : 0 );
		return this.pushStack( j >= 0 && j < len? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

// Initialize the jQuery object
jQuery.extend = Analyze the following piece of code: 
																		if ( elem.id!== match[2] ) {
							return rootjQuery.find( selector );
						}

												this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

						} else if (!context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

									} else {
				return this.constructor( context ).find( selector );
			}

						} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector!== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

		selector: "",

		jquery: "1.7.1",

		length: 0,

		size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

			get: function( num ) {
		return num == null?

						this.toArray() :

						( num < 0? this[ this.length + num ] : this[ num ] );
	},

			pushStack: function( elems, name, selector ) {
				var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

				ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

				return ret;
	},

				each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
				jQuery.bindReady();

				readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

			push: push,
	sort: [].sort,
	splice: [].splice
};

jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

		if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
				i = 2;
	}

		if ( typeof target!== "object" &&!jQuery.isFunction(target) ) {
		target = {};
	}

		if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
				if ( (options = arguments[ i ])!= null ) {
						for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

								if ( target === copy ) {
					continue;
				}

								if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src)? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src)? src : {};
					}

					target[ name ] = jQuery.extend( deep, clone, copy );

				} else if ( copy!== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	isReady: false,

	readyWait: 1,

	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	ready: function( wait ) {
		if ( (wait === true? --jQuery.readyWait : jQuery.isReady) ) {
			return;
		}

		if (!document.body ) {
			return setTimeout( jQuery.ready, 1 );
		}

		jQuery.isReady = true;

		if ( wait!== true && jQuery.readyWait!== 1 ) {
			return;
		}

		for ( var i = 0, fn; fn = readyList[i]; i++ ) {
			fn.call( document, jQuery );
		}

		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	},

	bindReady: function() {
		if ( readyState === "complete" ) {
			return jQuery.ready();
		}

		if (!document.body ) {
			return setTimeout( jQuery.bindReady, 1 );
		}

		try {
			addEventListener( "DOMContentLoaded", jQuery.ready, false );
			addEventListener( "load", jQuery.ready, false );

		} catch( e ) {
			document.addEventListener( "DOMContentLoaded", jQuery.ready, false );
			window.addEventListener( "load", jQuery.ready, false );
		}
	},

	isPlainObject: function( obj ) {
		if (!obj || typeof obj!== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}
		} catch ( e ) {
			return false;
		}

		return true;
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}

		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data!== "string" ||! Analyze the following piece of code: IsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src)? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src)? src : {};
					}

										target[ name ] = jQuery.extend( deep, clone, copy );

								} else if ( copy!== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

		return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

		isReady: false,

			readyWait: 1,

		holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

		ready: function( wait ) {
				if ( (wait === true &&!--jQuery.readyWait) || (wait!== true &&!jQuery.isReady) ) {
						if (!document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

						jQuery.isReady = true;

						if ( wait!== true && --jQuery.readyWait > 0 ) {
				return;
			}

						readyList.fireWith( document, [ jQuery ] );

						if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

						if ( document.readyState === "complete" ) {
						return setTimeout( jQuery.ready, 1 );
		}

				if ( document.addEventListener ) {
						document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

						window.addEventListener( "load", jQuery.ready, false );

				} else if ( document.attachEvent ) {
									document.attachEvent( "onreadystatechange", DOMContentLoaded );

						window.attachEvent( "onload", jQuery.ready );

									var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

				isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

		isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNumeric: function( obj ) {
		return!isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
								if (!obj || jQuery.type(obj)!== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
						if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
						return false;
		}

				
		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data!== "string" ||!data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	noop: function() {},

	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	}
});

var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,
	fcamelCase = function( letter ) {
		return letter.toUpperCase();
	},
	class2type = {};

jQuery.each( "Boolean Number String Function Array Date RegExp Object Error".split( " " ), function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

var core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" && jQuery.css( elem, "display" ) === "none";
	};



var swap = function( elem, options, callback ) {
	var old = {};
	// Remember the old values, and insert the new ones
	for ( var name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	callback.call( elem );

	// Revert the old values
	for ( var name in options ) { Analyze the following piece of code: string" ||!data ) {
			return null;
		}

				data = jQuery.trim( data );

				if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

						if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

		parseXML: function( data ) {
		var xml, tmp;
		try {
			if ( window.DOMParser ) { 				tmp = new DOMParser();
				xml = tmp.parseFromString( data, "text/xml" );
			} else { 				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if (!xml ||!xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

				globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
												( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

			camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

		each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

				} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

		trim: trim?
		function( text ) {
			return text == null?
				"" :
				trim.call( text );
		} :

				function( text ) {
			return text == null?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

		makeArray: function( array, results ) {
		var ret = results || [];

		if ( array!= null ) {
									var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i? i < 0? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
								if ( i in array && array[ i ] === elem ) {
									return i;
								}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}
		} else {
			while ( second[j]!== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [],
			i = 0,
			length = elems.length;
		inv =!!inv;

		for ( ; i < length; i++ ) {
			if (!inv!==!callback( elems[ i ], i ) ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	map: function( elems, callback ) {
		var ret = [],
			i = 0,
			length = elems.length,
			value;

		for ( ; i < length; i++ ) {
			value = callback( elems[ i ], i );

			if ( value!= null ) {
				ret[ ret.length ] = value;
			}
		}

		return ret;
	},

	guid: 1,

	proxy: function( fn, context ) {
		var args, proxy;

		if ( typeof context === "string" ) {
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};
		} else {
			proxy = function() {
				return fn.apply( context, arguments );
			};
		}

		return proxy;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	support: support
};

var
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rstyle = /<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi,
	rscriptType = /^(?:text|application)\/javascript/i,
	rscriptTypeMasked = /^(?:text|application)\/json/i,
	rhtml = /<[^<]*>/,
	rhead = /<head\b[^<]*>/i,
	rbody = /<body\b[^<]*>/i,
	rhtmlTag = /<\/?[^ >]+>/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtbody = /<tbody/i,
	rthtml = /<th/i,
	rtd = /<td/i,
	r Analyze the following piece of code:  ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j]!== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv =!!inv;

						for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal =!!callback( elems[ i ], i );
			if ( inv!== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

		map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
						isArray = elems instanceof jQuery || length!== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

				if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value!= null ) {
					ret[ ret.length ] = value;
				}
			}

				} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value!= null ) {
					ret[ ret.length ] = value;
				}
			}
		}

				return ret.concat.apply( [], ret );
	},

		guid: 1,

			proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

						if (!jQuery.isFunction( fn ) ) {
			return undefined;
		}

				var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

				proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

			access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;

				if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}

				if ( value!== undefined ) {
						exec =!pass && exec && jQuery.isFunction(value);

			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}

			return elems;
		}

				return length? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

			uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery &&!(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
} );

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

// Define a local copy of jQuery.fn
var oldjQuery = jQuery;

// Create an utility function for the DOM manipulation
jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function init( selector, context ) {
		var match, elem;

		// Handle $(""), $(null), or $(undefined)
		if (!selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this[0] = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			selector = selector.replace(rtrim, "");

			// Support: IE<9
			// Strips leading and trailing whitespace
			if (!rnothtmlwhite.test( selector ) ) {
				match = rsingleTag.exec( selector );

				if ( match ) {
					// Ensure that details are serialized correctly
					elem = document.createElement( match[1] );

					// Set the HTML
					elem.innerHTML = selector;

					// Replace the HTML with the element
					selector = elem.removeChild( elem.firstChild );
				}
			}

			if (!context || context.nodeType!== 1 ) {
				context = document;
			}

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( rsingleTag.test( selector ) ) {
					// Single tag
					elem = document.createElement( rsingleTag.exec( selector )[1] );
				} else {
					// Parse HTML
					elem = jQuery.parseHTML( selector, context );
				}
			}
		}

		// Make the HTML element or jQuery object
		if ( selector.nodeType || selector === window || selector === document ) {
			this[0] = selector;
			this.length = 1;
		} else {
			jQuery.makeArray( selector, this );
		}

		// Return the jQuery object
		return this;
	},

	// The current version of jQuery being used
	jquery: "1.11.3",

	// The number of elements in the jQuery object
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	 Analyze the following piece of code: superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery &&!(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

rootjQuery = jQuery(document);

if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
				if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
						document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

		jQuery.ready();
}

return jQuery;

})();


var flagsCache = {};

function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}


jQuery.Callbacks = function( flags ) {

			flags = flags? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var 		list = [],
				stack = [],
				memory,
				firing,
				firingStart,
				firingLength,
				firingIndex,
				add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
										add( elem );
				} else if ( type === "function" ) {
										if (!flags.unique ||!self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
				fire = function( context, args ) {
			args = args || [];
			memory =!flags.memory || [ context, args ];
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; 					break;
				}
			}
			firing = false;
			if ( list ) {
				if (!flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
					}
				} else if ( memory ) {
					memory = true;
				}
			}
			return memory;
		},
				self = {
			add: function() {
				if ( list ) {
					add( arguments );
				}
				return this;
			},
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					} );
				}
				return this;
			},
			has: function( fn ) {
				return jQuery.inArray( fn, list ) > -1;
			},
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			disable: function() {
				flags.disabled = true;
				return this;
			},
			disabled: function() {
				return!flags.disabled;
			},
			lock: function() {
				flags.locked = true;
				return this;
			},
			locked: function() {
				return flags.locked;
			},
			fireWith: function( context, args ) {
				if (!flags.disabled &&!flags.locked ) {
					return fire( context, args );
				}
			},
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			fired: function() {
				return!!memory;
			}
		};

	return self;
};


jQuery.extend({
	Deferred: function( func ) {
		var tuples = [
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function() {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise? newDe Analyze the following piece of code:  stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
				self = {
						add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
															if ( firing ) {
						firingLength = list.length;
																				} else if ( memory && memory!== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
						remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
																if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
																list.splice( i--, 1 );
																								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
						has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
						empty: function() {
				list = [];
				return this;
			},
						disable: function() {
				list = stack = memory = undefined;
				return this;
			},
						disabled: function() {
				return!list;
			},
						lock: function() {
				stack = undefined;
				if (!memory || memory === true ) {
					self.disable();
				}
				return this;
			},
						locked: function() {
				return!stack;
			},
						fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if (!flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if (!( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
						fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
						fired: function() {
				return!!memory;
			}
		};

	return self;
};




var 	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

								isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = lists[ handler ];
							if ( fn ) {
								fn.add(function() {
									newDefer[ data[ 0 ] ]( this );
									newDefer.notifyWith( this, data[ 1 ] === "notify"? [ this ] : arguments );
								});
							}
						});
						deferred.always(function() {
							newDefer.resolveWith( deferred, [ deferred ] );
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj ) {
						for ( var key in lists ) {
							obj[ key ] = lists[ key ].fire;
							obj[ key + "With" ] = lists[ key ].fireWith;
						}
					}
					return obj || promise;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.disable ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.disable );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	when: function( subordinate /*,..., subordinateN */ ) {
		var i = 0,
			resolveValues = sliceDeferred.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length!== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) )? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1? sliceDeferred.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if (!( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i Analyze the following piece of code:, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
												promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

				deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

				if ( func ) {
			func.call( deferred, deferred );
		}

				return deferred;
	},

		when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise )?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1? sliceDeferred.call( arguments, 0 ) : value;
				if (!( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if (!count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred!== firstParam ) {
			deferred.resolveWith( deferred, length? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

		div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

		if (!all ||!all.length ||!a ) {
		return {};
	}

		select = document.createElement( "select" );
	opt = select.appendChild( document.createElement( "option" ) );
	input = div.getElementsByTagName( "input" )[ 0 ];

	marginDiv = document.createElement( "div" );
	marginDiv.style.cssText = "margin:0;border:0;width:0;height:0;position:absolute;top:0;left:-9999px";
	fragment = document.createDocumentFragment();
	tds = document.createElement( "table" ).appendChild( document.createElement( "tbody" ) ).appendChild( document.createElement( "tr" ) ).appendChild( document.createElement( "td" ) );

	events = {
		"submit": true,
		"change": true,
		"focusin": true,
		"focusout": true,
		"click": true,
		"dblclick": true,
		"keydown": true,
		"keypress": true,
		"keyup": true,
		"mousedown": true,
		"mouseup": true,
		"mouseover": true,
		"mouseout": true,
		"mousemove": true,
		"resize": true,
		"scroll": true
	};

	if ( a.style.top!== "" ) {
		return {
			submitBubbles: true,
			changeBubbles: true,
			focusinBubbles: true,
			focusoutBubbles: true,
			clickBubbles: true,
			dblclickBubbles: true,
			keydownBubbles: true,
			keypressBubbles: true,
			keyupBubbles: true,
			mousedownBubbles: true,
			mouseupBubbles: true,
			mouseoverBubbles: true,
			mouseoutBubbles: true,
			mousemoveBubbles: true,
			resizeBubbles: true,
			scrollBubbles: true
		};
	}

	fragment.appendChild( div.cloneNode( true ) );
	documentElement.insertBefore( fragment, documentElement.firstChild );

	for ( i in { submit: true, change: true, focusin: true, focusout: true, click: true, keydown: true, keypress: true, keyup: true, mousedown: true, mouseup: true, mouseover: true, mouseout: true, mousemove: true, contextmenu: true } ) {
		try {
			div.setAttribute( i, "return;" );
			events[ i + "Bubbles"] = true;
		} catch(e) {}
	}

	if (!input ) {
		input = document.createElement( "input" );
	}
	if (!input.addEventListener ) {
		input.setAttribute( "onfocusin", "return;" );
	}
	isSupported =!input.addEventListener && input.attachEvent;

	if ( isSupported ) {
		delete events.change;
		delete events.submit;
	}

	if (!div.style.opacity ) {
		a.style.opacity = "0.55";
	}
	if (!div.style.cssText ) {
		div.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px";
	}
	if (!select.style.width ) {
	 Analyze the following piece of code: 
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
				leadingWhitespace: ( div.firstChild.nodeType === 3 ),

						tbody:!div.getElementsByTagName("tbody").length,

						htmlSerialize:!!div.getElementsByTagName("link").length,

						style: /top/.test( a.getAttribute("style") ),

						hrefNormalized: ( a.getAttribute("href") === "/a" ),

								opacity: /^0.55/.test( a.style.opacity ),

						cssFloat:!!a.style.cssFloat,

								checkOn: ( input.value === "on" ),

						optSelected: opt.selected,

				getSetAttribute: div.className!== "t",

				enctype:!!document.createElement("form").enctype,

						html5Clone: document.createElement("nav").cloneNode( true ).outerHTML!== "<:nav></:nav>",

				submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true
	};

		input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

			select.disabled = true;
	support.optDisabled =!opt.disabled;

			try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if (!div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
									support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

			input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");
	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

		support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

			support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	div.innerHTML = "";

						if ( window.getComputedStyle ) {
		marginDiv = document.createElement( "div" );
		marginDiv.style.width = "0";
		marginDiv.style.marginRight = "0";
		div.style.width = "2px";
		div.appendChild( marginDiv );
		support.reliableMarginRight =
			( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
	}

							if ( div.attachEvent ) {
		for( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if (!isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

		fragment = select = opt = marginDiv = div = input = null;

		jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			conMarginTop, ptlm, vb, style, html,
			body = document.getElementsByTagName("body")[0];

		if (!body ) {
						return;
		}

		conMarginTop = 1;
		ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
		vb = "visibility:hidden;border:0;";
		style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
		html = "<div " + style + "><div></div></div>";

		body.innerHTML = html;
		container = body.firstChild;
		outer = container.firstChild;
		inner = outer.firstChild;

		if (!outer.style.position ) {
			outer.style.position = "relative";
		}
		if (!inner.style.position ) {
			inner.style.position = "relative";
		}

		offsetSupport = jQuery.expr.match.position === "[^\\s]+ (static|relative|absolute)";
		outer.style.position = "absolute";
		outer.style.top = ( conMarginTop + 1 ) + "px";
		if ( offsetSupport ) {
			inner.style.top = ( conMarginTop + 2 ) + "px";
		}

		table = document.createElement("table");
		td = document.createElement("td");

		table.style.position = "absolute";
		table.style.top = 0;
		td.style.position = "absolute";
		td.style.top = 0;

		table.appendChild( td );
		container.insertBefore( table, outer );

		if (!offsetSupport || inner.offsetTop === 0 ) {
			offsetSupport =!0;
			table.style.top = ( conMarginTop - 1 ) + "px";
			if ( inner.offsetTop === 0 ) {
				offsetSupport =!1;
			}
		}

		body.removeChild( html );

		container.innerHTML = "";
		container = outer = inner = table = td = null;

		jQuery.extend( support, {
			fixedPosition: offsetSupport,
			reliableMarginLeft: true,
			pixelPosition: offsetSupport
		});
	});

return support;
}

var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true"? true :
					data === "false"? false :
					data === "null"? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data? +data :
					rbrace.test( data )? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

// checks a cache object for a given key and returns the value
function cacheCheck( cache, name ) {
	var id = name + "!";

	if ( cache.hasOwnProperty( id ) ) {
		return cache[ id ];
	}
}

// adds a Analyze the following piece of code:  + "><div></div></div>" +
			"<table " + style + " cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

				div = document.createElement("div");
		container.appendChild( div );

																div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

						support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

				div.innerHTML = "";
		div.style.width = div.style.paddingLeft = "1px";
		jQuery.boxModel = support.boxModel = div.offsetWidth === 2;

		if ( typeof div.style.zoom!== "undefined" ) {
															div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

									div.style.display = "";
			div.innerHTML = "<div style='width:4px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth!== 2 );
		}

		div.style.cssText = ptlm + vb;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop!== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

				offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop!== conMarginTop );

		body.removeChild( container );
		div  = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

		uuid: 0,

			expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

			noData: {
		"embed": true,
				"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return!!elem &&!isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt  ) {
		if (!jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

									isNode = elem.nodeType,

									cache = isNode? jQuery.cache : elem,

									id = isNode? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

						if ( (!id ||!cache[id] || (!isEvents &&!pvt) ) &&!getByName && data === undefined ) {
			return;
		}

		if (!id ) {
			id = isNode? elem[ internalKey ] = ++jQuery.uuid : internalKey;
		}

		if (!cache[ id ] ) {
			cache[ id ] = {};

			if (!isNode ) {
				elem[ internalKey ] = id;
			}
		}

		privateCache = cache[ id ];

		if ( isEvents &&!privateCache[ name ] ) {
			privateCache[ name ] = {};

			if (!pvt ) {
				privateCache[ name ].events = {};
			}
		}

		if ( getByName ) {
			if ( pvt ) {
				ret = privateCache[ name ][ data ];
			} else {
				ret = privateCache[ name ];
			}

			if ( ret === undefined ) {
				ret = privateCache[ name ][ data ] = pvt? data : undefined;
			}
		} else {
			ret = privateCache;
		}

		if (!isNode ) {
			delete cache[ id ];
		}

		return ret;
	},

	removeData: function( elem, name, pvt ) {
		if (!jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i,
			isNode = elem.nodeType,

			cache = isNode? jQuery.cache : elem,
			id = isNode? elem[ jQuery.expando ] : jQuery.expando;

		if ( cache[ id ] ) {
			if ( name ) {
				thisCache = pvt? cache[ id ] : cache[ id ][ name ];

				if ( thisCache ) {
					if (!jQuery.support.deleteExpando ||!delete thisCache[ jQuery.expando ] ) {
						if ( isNode ) {
							elem[ jQuery.expando ] = undefined;
						} else {
							delete cache[ id ];
						}
					}

					if ( pvt ) {
						delete thisCache[ name ];
					} else {
						for ( i in thisCache ) {
							if ( thisCache[ i ] === undefined ) {
								delete thisCache[ i ];
							}
						}
					}
				}
			} else {
				if (!jQuery.support.deleteExpando ) {
					if ( isNode ) {
						elem[ jQuery.expando ] = undefined;
					} else {
						for ( i in cache[ id ] ) {
							if ( cache[ id ].hasOwnProperty( i ) && i!== jQuery.expando ) {
								delete cache[ id ][ i ];
							}
						}
					}
				} else {
					delete cache[ id ];
				}
			}
		}
	},

	acceptData: function( elem ) {
		if ( elem.nodeType === 1 || elem.nodeType === 9 || elem.nodeType === 11 ) {
			return true;
		}

		if ( elem.nodeType === 8 ) {
			return "closed"!== elem.readyState;
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts Analyze the following piece of code:  &&!cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if (!id ) {
									if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if (!cache[ id ] ) {
			cache[ id ] = {};

									if (!isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

						if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

								if (!pvt ) {
			if (!thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data!== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

						if ( isEvents &&!thisCache[ name ] ) {
			return privateCache.events;
		}

						if ( getByName ) {

						ret = thisCache[ name ];

						if ( ret == null ) {

								ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt  ) {
		if (!jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

						internalKey = jQuery.expando,

			isNode = elem.nodeType,

						cache = isNode? jQuery.cache : elem,

						id = isNode? elem[ internalKey ] : internalKey;

						if (!cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

								if (!jQuery.isArray( name ) ) {

										if ( name in thisCache ) {
						name = [ name ];
					} else {

												name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

												if (!( pvt? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

				if (!pvt ) {
			delete cache[ id ].data;

									if (!isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

										if ( jQuery.support.deleteExpando ||!cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

						if ( isNode ) {
												if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

		_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

		acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return!(match === true || elem.getAttribute("classid")!== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, attr, name,
			data = null;

		if ( typeof key === "undefined" ) {
			if ( this.length ) {
				data = jQuery.data( this[0] );

				if ( this[0].nodeType === 1 &&!jQuery._data( this[0], "parsedAttrs" ) ) {
					attr = this[0].attributes;
					for ( var i = 0, l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( this[0], name, data[ name ] );
						}
					}
					jQuery._data( this[0], "parsedAttrs", true );
				}
			}

			return data;
		}

		parts = key.split(".");
		parts[0] = parts[0].replace( rbrace, "" );

		if ( parts.length > 1 ) {
			data = this.data( parts[0] );
			key = parts[1];
		}

		if ( value === undefined ) {
			return data? data[key] : null;
		}

		return this.each(function() {
			if ( data === undefined ) {
				data = {};
			}
			data[key] = value;
			jQuery.data( this, parts[0], data );
		});
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	var name;

	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true"? true :
					data === "false"? false :
					data === "null"? null :
					jQuery.isNumeric( data )? parseFloat( data ) :
					rbrace.test( data )? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	if ( data!== undefined ) {
		elem.setAttribute( "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase(), data );
	}
}

jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			if ( data ) {
				if (!queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type Analyze the following piece of code: length ) {
				data = jQuery.data( this[0] );

				if ( this[0].nodeType === 1 &&!jQuery._data( this[0], "parsedAttrs" ) ) {
					attr = this[0].attributes;
					for ( var i = 0, l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( this[0], name, data[ name ] );
						}
					}
					jQuery._data( this[0], "parsedAttrs", true );
				}
			}

			return data;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split(".");
		parts[1] = parts[1]? "." + parts[1] : "";

		if ( value === undefined ) {
			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

						if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );
				data = dataAttr( this[0], key, data );
			}

			return data === undefined && parts[1]?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var self = jQuery( this ),
					args = [ parts[0], value ];

				self.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
			if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true"? true :
				data === "false"? false :
				data === "null"? null :
				jQuery.isNumeric( data )? parseFloat( data ) :
					rbrace.test( data )? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

						jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

				if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name!== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" ||!jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" ||!jQuery._data(elem, markDataKey) ) ) {
						setTimeout( function() {
			if (!jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
			handleQueueMarkDefer( elem, type, "mark" );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force!== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count =!force? 0 : (jQuery._data( elem, key ) || 1) - 1;

			if ( count ) {
				jQuery._data( elem, key, count );
				if (!count &&!force ) {
					handleQueueMarkDefer( elem, type );
				}
			} else {
				jQuery.removeData( elem, key, true );
			}
		}
	},

	queue: function( elem, type, data ) {
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			var queue = jQuery._data( elem, type );

			if ( data ) {
				if (!queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress handler for this queue if we don't already have one
			if (!hooks.cur ) {
				hooks.cur = 0;
				hooks.stop = next;
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );

			if (!hooks.done && queue.length ) {
				hooks.done = true;
				next.call( elem );
			}
		}

		if (!startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) ||
			jQuery._data( elem, key, {
				empty: jQuery.Callbacks("once memory").add(function() {
					jQuery.removeData( elem, type + "queue", true );
					jQuery.removeData( elem, key, true );
				})
			} );
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type!== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) { Analyze the following piece of code: 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force!== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

						if ( data ) {
				if (!q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

				if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
									if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if (!queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type!== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function() {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0]!== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
			delay: function( time, type ) {
		time = jQuery.fx? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
			promise: function( type, object ) {
		if ( typeof type!== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if (!( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) ) &&
				tmp.length ) {
				count = tmp.length;
				while( tmp.length ) {
					tmp.shift()([ i, resolve ]);
				}
			}
		}
		if (!count ) {
			defer.resolveWith( elements, [ elements ] );
		}
		elements.promise = defer.promise( object );
		return elements;
	}
});

var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute("class") || "";
}

function hasClass( elem, c ) {
	return new RegExp( "(^| )" + c + "( |$)" ).test( getClass( elem ) );
}

function addClass( elem, c ) {
	if (!hasClass( elem, c ) ) {
		var current = getClass( elem );
		current = current? current + " " : "";
		elem.setAttribute( "class", current + c );
	}
}

function removeClass( elem, c ) {
	if ( hasClass( elem, c ) ) {
		var current = getClass( elem ),
			re = new RegExp( "(^|\\s)" + c + "(\\s|$)" );
		elem.setAttribute( "class", current.replace( re, " " ) );
	}
}

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, curValue, i, l;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).addClass( value.call(this, i, getClass(this)) );
			});
		}

		classes = ( value || "" ).match( rclass ) || [];

		for ( i = 0, l = this.length; i < l; i++ ) {
			elem = this[i];
			curValue = getClass( elem );
			cur = [];

			if ( curValue ) {
				cur = curValue.match( rclass ) || [];
			}

			for ( var c = 0, cl = classes.length; c < cl; c++ ) {
				if (!hasClass( elem, classes[c] ) ) {
					cur.push( classes[c] );
				}
			}

			cur = cur.join( " " );

			if ( cur!== curValue ) {
				elem.setAttribute( "class", cur );
			}
		}

		return this;
	},
	removeClass: function( value ) {
		var classes, elem, cur, curValue, i, l;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).removeClass( value.call(this, i, getClass(this)) );
			});
		}

		if (!arguments.length ) {
			return this.each(function() {
				elem = this;
				curValue = getClass( elem );
				cur = curValue.match( rclass ) || [];
				while ( cur.length ) {
					removeClass( elem, cur.pop() );
				 Analyze the following piece of code: data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise();
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.prop );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
						try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if (!elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if (!~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					if ( isBool? className in this.style : self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}
				// toggle full screen
				this.className = this.className || value === false? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if (!arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" ))!== undefined ) {
					return ret;
				}

				ret = elem.value;

				if ( typeof ret === "string" ) {
					return ret.replace(rreturn, "");
				}

				return ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType!== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			if ( val === null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			if (!hooks ||!("set" in hooks) || hooks.set( this, val, Analyze the following piece of code: boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
								var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
										state = isBool? state :!self.hasClass( className );
					self[ state? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
										jQuery._data( this, "__className__", this.className );
				}

								this.className = this.className || value === false? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if (!arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" ))!== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string"?
										ret.replace(rreturn, "") :
										ret == null? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType!== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

						if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

						if (!hooks ||!("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
												var val = elem.attributes.value;
				return!val || val.specified? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

								if ( index < 0 ) {
					return null;
				}

								i = one? index : 0;
				max = one? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

										if ( option.selected && (jQuery.support.optDisabled?!option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled ||!jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						value = jQuery( option ).val();

						if ( one ) {
							return value;
						}

						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {
						optionSet = true;
					}
				}

				if (!optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

if (!jQuery.support.optDisabled ) {
	jQuery.valHooks.option.set = function( elem, value ) {
		if ( value === "" ) {
			jQuery.removeAttr( elem, "selected" );
		} else {
			elem.selected = true;
		}
		return value;
	};
}

jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if (!jQuery.support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null? "on" : elem.value;
		};
	}
});
var rformElems = /^(?:input|select|textarea)$/i,
	rtypenamespace = /^([^.]*)(?:\.(.+))?$/,
	rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypename = /^[^.]*$/,
	rscrollEvent = /^scroll/,
	rquickEvent = /^(?:load|unload|abort|error|select|change|submit|reset|focus|blur|resize|scroll)$/,
	rbackslash = /\\/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) {}
}

/*
 * Helper functions for managing events.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var handleObjIn, eventHandle, tmp,
			events, t, handleObj Analyze the following piece of code: " )) ) {

												value = jQuery( option ).val();

												if ( one ) {
							return value;
						}

												values.push( value );
					}
				}

								if ( one &&!values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if (!values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

				if (!elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

				if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType!== 1 ||!jQuery.isXMLDoc( elem );

						if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name )? boolHook : nodeHook );
		}

		if ( value!== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name ))!== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name ))!== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

						return ret === null?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;

										jQuery.attr( elem, name, "" );
					elem.removeAttribute( getSetAttribute? name : propName );

										if ( rboolean.test( name ) && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
								if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
																				var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
						value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				return ( elem.value = value );
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		for: "htmlFor",
		class: "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

				if (!elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType!== 1 ||!jQuery.isXMLDoc( elem );

		if ( notxml ) {
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value!== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name ))!== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name ))!== null ) {
				return ret;
			}

			return elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				var attrNode,
					tabIndex = elem.getAttributeNode( "tabindex" );

				if ( tabIndex ) {
					return tabIndex.value;
				}

													attrNode = elem.getAttributeNode( "tabindex" );
				if ( attrNode && attrNode.specified ) {
					return attrNode.value;
				}

													return -1;
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}

// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

})( window );

//]]>
</script>

</head>
<body>

<div id="container">

<h1>My First jQuery Code</h1>

< Analyze the following piece of code:  function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
								elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

				if (!elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType!== 1 ||!jQuery.isXMLDoc( elem );

		if ( notxml ) {
						name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value!== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name ))!== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name ))!== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
												var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href?
						0 :
						undefined;
			}
		}
	}
});

jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

boolHook = {
	get: function( elem, name ) {
						var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property!== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue!== false?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
						jQuery.removeAttr( elem, name );
		} else {
									propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
								elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

if (!getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true
	};

			nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ]? ret.nodeValue!== "" : ret.specified )?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
						var ret = elem.getAttributeNode( name );
			if (!ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

		jQuery.attrHooks.tabindex.set = nodeHook.set;

			jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});
}

if (!jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null? undefined : ret;
			}
		});
	});
}

if (!jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}

if (!jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;
			}
			return null;
		}
	});
}

if (!jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

jQuery.each([ "text", "password", "file", "image" ], function( i, name ) {
	jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
		set: function( elem, value ) {
			if ( value === "" ) {
				elem.setAttribute( "value", value );
				return value;
			}
		}
	});
});

return jQuery;

}());

// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	if ( s.crossDomain ) {
		var script,
			head = document.head || document.getElementsByTagName( "head" )[0];
		return {
			send: function( _, complete ) {
				script = document.createElement( "script" );
				script.async = true;
				script.src = s.url;

				script.onload = script.onreadystatechange = function( _, isAbort ) {
					if ( isAbort ||!script.readyState || /loaded|complete/.test( script.readyState ) ) {
						script. Analyze the following piece of code:  "auto" );
					return value;
				}
			}
		});
	});

			jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


if (!jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null? undefined : ret;
			}
		});
	});
}

if (!jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
									return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

if (!jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

								if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

if (!jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

if (!jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
								return elem.getAttribute("value") === null? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /\bhover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
									quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};


jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if (!elem || elem.nodeType === 3 || elem.nodeType === 8 ||!types ||!handler ||!(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if (!handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure
		if (!(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if (!(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery!== "undefined" && (!e || jQuery.event.triggered!== e.type)?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) : undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		types = types.split(" ");
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split(".");
			special = jQuery.event.special[ type ] || {};

			// Caller can pass in a special options object to handle the event
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn);

			// Init the event handler queue if we're the first
			if (!(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if (!special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if (!handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers. Analyze the following piece of code:, quick, handlers, special;

				if ( elem.nodeType === 3 || elem.nodeType === 8 ||!types ||!handler ||!(elemData = jQuery._data( elem )) ) {
			return;
		}

				if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

				if (!handler.guid ) {
			handler.guid = jQuery.guid++;
		}

				events = elemData.events;
		if (!events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if (!eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
												return typeof jQuery!== "undefined" && (!e || jQuery.event.triggered!== e.type)?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
						eventHandle.elem = elem;
		}

						types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

						special = jQuery.event.special[ type ] || {};

						type = ( selector? special.delegateType : special.bindType ) || type;

						special = jQuery.event.special[ type ] || {};

						handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

						handlers = events[ type ];
			if (!handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

								if (!special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
										if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if (!handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

						if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

						jQuery.event.global[ type ] = true;
		}

				elem = null;
	},

	global: {},

		remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if (!elemData ||!(events = elemData.events) ) {
			return;
		}

				types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

						if (!type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

						for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) && (!handler || handler.guid === handleObj.guid) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector) && (!namespaces || namespaces.test( handleObj.namespace )) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			if ( eventType.length === 0 ) {
				if (!special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					if ( jQuery.removeEvent ) {
						jQuery.removeEvent( elem, type, elemData.handle );
					} else if ( elem.detachEvent ) {
						elem.detachEvent( "on" + type, elemData.handle );
					}
				}

				delete events[ type ];
			}
		}

		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var handle, ontype, cur, tmp, bubbleType, ontype_split,
			special, i, namespaces, all, curNamespace, namespace,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" )? event.type : event,
			namespaces = hasOwn.call( event, "namespace" )? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object"?
			event[ jQuery.expando ]? event :
			new jQuery.Event( type, event ) :
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if (!event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
	 Analyze the following piece of code: 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 (!handler || handler.guid === handleObj.guid ) &&
					 (!namespaces || namespaces.test( handleObj.namespace ) ) &&
					 (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

									if ( eventType.length === 0 && origCount!== eventType.length ) {
				if (!special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

				if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

									jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

			customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
				if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

				var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

				if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
						type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
						namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) &&!jQuery.event.global[ type ] ) {
						return;
		}

				event = typeof event === "object"?
						event[ jQuery.expando ]? event :
						new jQuery.Event( type, event ) :
						new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0? "on" + type : "";

				if (!elem ) {

						cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

				event.result = undefined;
		if (!event.target ) {
			event.target = elem;
		}

				data = data!= null? jQuery.makeArray( data ) : [];
		data.unshift( event );

				special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

						eventPath = [[ elem, special.bindType || type ]];
		if (!onlyHandlers &&!special.noBubble &&!jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type )? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

						if ( old && old === elem.ownerDocument ) {
			eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
		}
		}

		for ( i = 0; i < eventPath.length &&!event.isPropagationStopped(); i++ ) {
			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
				event.type = type;
		if (!onlyHandlers &&!event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				jQuery.acceptData( elem ) ) {

				if ( ontype && elem[ type ] &&!jQuery.isWindow( elem ) ) {
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {}
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}
	},

	handle: function( event ) {
		var all, handlers, namespaces, namespace_re, handleObj, cur, i, j, curNamespace, ontype, handle,
			eventPath = event.type.split(".");

		event.preventDefault();

		eventPath[0] = eventPath[0].replace(/\\/g, "/");

		namespace_re = new RegExp("(^|\\.)" + eventPath.slice(0,3).join("\\.(?:.*\\.)?") + "(\\.|$)");

		all = [];
		handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ];

		if ( handlers ) {
			namespaces = [];
			for ( i in handlers ) {
				handleObj = handlers[ i ];
				if ( handleObj.selector!== undefined &&!handleObj.selector.match( namespace_re ) ) {
					continue;
				}
				namespaces.push( i );
				all.push( handleObj );
			}
		}

		if ( namespaces.length ) {
			event.namespace = namespaces.join( "." );
		}

		if ( jQuery.event.triggered!== undefined ) {
			event.type = jQuery.event.triggered;
		}

		for ( i = 0; i < all.length; i++ ) {
			handleObj = all[ i ];
			cur = handleObj.selector;
			if ( cur === undefined || cur === true || cur === event.target ) {
				curNamespace = handleObj.namespace? new RegExp("(^|\\.)" + handleObj.namespace + "(\\.| Analyze the following piece of code:  {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

				for ( i = 0; i < eventPath.length &&!event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
						handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

				if (!onlyHandlers &&!event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

																				if ( ontype && elem[ type ] && ((type!== "focus" && type!== "blur") || event.target.offsetWidth!== 0) &&!jQuery.isWindow( elem ) ) {

										old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

										jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

				event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all =!event.exclusive &&!event.namespace,
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

				args[0] = event;
		event.delegateTarget = this;

						if ( delegateCount &&!event.target.disabled &&!(event.button && event.type === "click") ) {

						jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur!= this; cur = cur.parentNode || this ) {
				selMatch = {};
				matches = [];
				jqcur[0] = cur;
				for ( i = 0; i < delegateCount; i++ ) {
					handleObj = handlers[ i ];
					sel = handleObj.selector;

					if ( selMatch[ sel ] === undefined ) {
						selMatch[ sel ] = (
							handleObj.quick? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
						);
					}
					if ( selMatch[ sel ] ) {
						matches.push( handleObj );
					}
				}
				if ( matches.length ) {
					handlerQueue.push({ elem: cur, matches: matches });
				}
			}
		}

				if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

				for ( i = 0; i < handlerQueue.length &&!event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length &&!event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

												if ( run_all || (!event.namespace &&!handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler ).apply( matched.elem, args );

					if ( ret!== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		return event.result;
	},

	props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode!= null? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX!= null ) {
				var doc = document.documentElement,
					body = document.body;
				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if (!event.relatedTarget && event.fromElement ) {
				event.relatedTarget = event.fromElement === event.target? event.toElement : event.fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if (!event.which && event.button!== undefined ) {
				event.which = ( event.button & 1? 1 : ( event.button & 2? 3 : ( event.button & 4? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if (!fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type )? this.mouseHooks :
				rkeyEvent.test( type )? this.keyHooks :
				{}; Analyze the following piece of code:  {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret!== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		return event.result;
	},

			props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

						if ( event.which == null ) {
				event.which = original.charCode!= null? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

						if ( event.pageX == null && original.clientX!= null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

						if (!event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target? original.toElement : fromElement;
			}

									if (!event.which && button!== undefined ) {
				event.which = ( button & 1? 1 : ( button & 2? 3 : ( button & 4? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

				var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

				if (!event.target ) {
			event.target = originalEvent.srcElement || document;
		}

				if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

				if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
						setup: jQuery.bindReady
		},

		load: {
						noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
								if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
								var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
					originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	if (!(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		for ( var prop in src ) {
			this[ prop ] = src[ prop ];
		}
	}

	if ( props ) {
		jQuery.extend( this, props );
	}

	this.timeStamp = src && src.timeStamp || jQuery.now();

	this[ jQuery.expando ] = true;
};

jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = jQuery.returnTrue;

		var e = this.originalEvent;
		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = jQuery.returnTrue;

		var e = this.originalEvent;
		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = jQuery.returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: false,
	isPropagationStopped: false,
	isImmediatePropagationStopped: false
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			if (!related || (related!== target &&!jQuery.contains( target, related )) ) {
				jQuery( target ).trigger( handleObj.origType );
			}
		}
	};
});

// Support: Firefox
// Firefox doesn't have focus(in | out) events
// Related bug: 8383
//
// Support: Chrome < 21
// focus(in | out) events fire after focus & blur events
// Related bug: 16525
//
// Support: IE <=10
// focus(in | out) events don't fire at all
// Related bug Analyze the following piece of code: originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
		if (!(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

		if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

						this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() )? returnTrue : returnFalse;

		} else {
		this.type = src;
	}

		if ( props ) {
		jQuery.extend( this, props );
	}

		this.timeStamp = src && src.timeStamp || jQuery.now();

		this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if (!e ) {
			return;
		}

				if ( e.preventDefault ) {
			e.preventDefault();

				} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if (!e ) {
			return;
		}
				if ( e.stopPropagation ) {
			e.stopPropagation();
		}
				e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

									if (!related || (related!== target &&!jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

if (!jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
						if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

						jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
								var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" )? elem.form : undefined;
				if ( form &&!form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
												if ( this.parentNode &&!event.isTrigger ) {
							jQuery.event.simulate( "submit", this.parentNode, event, true );
						}
					});
					form._submit_attached = true;
				}
			});
		},

		teardown: function() {
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}
			jQuery.event.remove( this, "._submit" );
		}
	};
}

if (!jQuery.support.changeBubbles ) {

	var changeBubbles = jQuery.event.special.change = {
		setup: function() {
			if ( rformElems.test( this.nodeName ) ) {
				this._change_attached = true;
				jQuery.event.add( this, "propertychange._change", function( event ) {
					if ( event.originalEvent.propertyName === "value" ) {
						this.setAttribute( "changed", "changed" );
					}
				});
				jQuery.event.add( this, "click._change", function( event ) {
					if ( this.type === "checkbox" || this.type === "radio" ) {
						this._just_changed = true;
					}
				});
			}
		},

		handle: function( event ) {
			var elem = event.target;

			if ( this!== elem || event.isTrigger || elem.type!== "radio" && elem.type!== "checkbox" ) {
				return event.handleObj.handler.apply( this, arguments );
			}

			if ( event.type === "click" ) {
				if ( this._just_changed &&!this._change_attached ) {
					this._just_changed = false;
					return;
				}
				if ( this.checked!== elem.checked ) {
					this.setAttribute( "checked", elem.checked );
				}
			}

			event.preventDefault();
		},

		teardown: function() {
			if ( this._change_attached ) {
				jQuery.event.remove( this, "._change" );
			}
		}
	};

	var rformElems = /^(?:input|select|textarea)$/i;
}

jQuery.fn.extend({
	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		if ( typeof types === "object" ) {
			if ( typeof selector!== "string" ) {
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				fn = data;
				data = undefined;
			} else {
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if (!fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				jQuery.event.remove( this, types, origFn );
				return orig Analyze the following piece of code: 
				}
			});
					},

		teardown: function() {
						if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

						jQuery.event.remove( this, "._submit" );
		}
	};
}

if (!jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
																if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed &&!event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
						jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) &&!elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode &&!event.isSimulated &&!event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

						if ( this!== elem || event.isSimulated || event.isTrigger || (elem.type!== "radio" && elem.type!== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

if (!jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

				var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn,  one ) {
		var origFn, type;

				if ( typeof types === "object" ) {
						if ( typeof selector!== "string" ) {
								data = selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
						fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
								fn = data;
				data = undefined;
			} else {
								fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if (!fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
								jQuery().off( event );
				return origFn.apply( this, arguments );
			};
						fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			jQuery( types.delegateTarget ).off( types.handleObj );
			return this;
		}
		if ( typeof types === "object" ) {
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( document.body ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( document.body ).off( types, this.selector || "", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		return this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});

function returnFalse() {
	return false;
}

// Deprecated
jQuery.extend({
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn;
			fn = context;
			context = tmp;
		}

		var args = slice.call( arguments, 2 );

		return function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};
	},

	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},
	ready: function( wait ) {
		if ( (wait === true && --jQuery.readyWait >  Analyze the following piece of code: Fn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on.call( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
						var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace? handleObj.type + "." + handleObj.namespace : handleObj.type,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
						for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
						fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
				return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
				var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
								var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

								event.preventDefault();

								return args[ lastToggle ].apply( this, arguments ) || false;
			};

				toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

		jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}
});

if (!jQuery.fn.size ) {
	jQuery.fn.size = function() {
		return this.length;
	};
}

jQuery.fn.andSelf = jQuery.fn.addBack;

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}

if ( typeof module!== "undefined" && module.exports ) {
	module.exports = jQuery;
}

if ( typeof window!== "undefined" ) {
	window.jQuery = window.$ = jQuery;
}

})( window );

//]]>
</script>

<script>
//<![CDATA[
(function(window, undefined) {

// Create a shortcut to the document object
var doc = window.document;

// Create a new Image object
var img = new Image();

// Add an event listener for when the image has loaded
img.addEventListener('load', function() {
  // Do something with the image
}, false);

// Set the source of the image
img.src = 'path/to/image.jpg';

//]]>

}(window));
</script>



¿Cuáles son los principales desafíos que enfrenta la humanidad en la era de la inteligencia artificial?

Los principales desafíos que enfrenta la humanidad en la era de la inteligencia artificial son:

1. El control excesivo: La inteligencia artificial puede ser desarrollada con un alto grado de precisión y eficiencia, lo que puede llevar a la creación de sistemas de inteligencia artificial con un control excesivo sobre las personas y la sociedad. Esto puede generar preocupaciones éticas y legales sobre la forma en que se utiliza la inteligencia artificial, y cómo se protege la privacidad y los derechos humanos.

2. La brecha digital: La brecha digital entre los países desarrollados y en desarrollo puede ser una limitación para la distribución equitativa y universal de la inteligencia artificial. Esto puede generar desigualdades en el acceso a la tecnología y la educación en los países menos capacitados, lo que puede aumentar las desigualdades sociales y económicas.

3. La dependencia de la inteligencia artificial: La dependencia excesiva de la inteligencia artificial en la sociedad puede tener graves consecuencias para la seguridad y la estabilidad de la sociedad. Si la inteligencia artificial falla o se vuelve maliciosa, puede tener un impacto catastrófico en la sociedad.

4. La desigualdad social: La inteligencia artificial puede aumentar la desigualdad social si no se implementa adecuadamente y no se toman medidas para evitar que las personas más vulnerables sean afectadas negativamente.

5. La seguridad nacional: La inteligencia artificial puede ser utilizada por gobiernos y otros Analyze the following piece of code: 	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});




(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType!== 1 && context.nodeType!== 9 ) {
		return [];
	}

	if (!selector || typeof selector!== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;

		do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];

			parts.push( m[1] );

			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ]?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}

				set = posProcess( selector, set, seed );
			}
		}

	} else {
						if (!seed && parts.length > 1 && context.nodeType === 9 &&!contextXML &&
				Expr.match.ID.test(parts[0]) &&!Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode? context.parentNode : context, contextXML );

			set = ret.expr?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if (!Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if (!checkSet ) {
		checkSet = set;
	}

	if (!checkSet ) {
		return results;
	}

	if (!prune ) {
		results.push.apply( results, checkSet );

	} else if ( set!== results ) {
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, match, type, find, filter, first,
		matchExpr = Expr.match[ expr ] || Expr.match[ "*" ];

	if (!expr ) {
		return [];
	}

	for ( type in Expr.find ) {
		if ( (find = Expr.find[ type ]( expr, isXML )) ) {
			filter = find.left;
			first = find.right;

			if ( filter ) {
				set = Sizzle( filter, context, isXML );
				expr = first || filter;

				if (!set.length ) {
					return [];
				}

				if ( first ) {
					find.set = set;
				} else {
					return set;
				}

			} else {
				return Sizzle( first, context, isXML );
			}

			break;
		}
	}

	if ( match ) {
		match.set = set;
		return match;
	}

	return Sizzle( expr, context, isXML );
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		filter = expr,
		old = false;

	if (!expr || typeof expr!== "string" ) {
		return [];
	}

	for ( var type in Expr.filter ) {
		if ( (match = Expr.filter[ type ]( expr, set, inplace, not )) ) {
			filter = match[0];
			old = match[1];
			anyFound = true;

			if (!old ) {
				break;
			}
		}
	}

	if (!anyFound ) {
		return set;
	}

	if (!inplace ) {
		set = makeArray( set );
	}

	if ( filter Analyze the following piece of code: 
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if (!checkSet ) {
		checkSet = set;
	}

	if (!checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if (!prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i]!= null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i]!= null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if (!expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];

		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 )!== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set!= null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if (!set ) {
		set = typeof context.getElementsByTagName!== "undefined"?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr ))!= null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

					if ( isXMLFilter ) {
						if ( set.length === 1 ) {
							Sizzle.error( left );
						}

						for ( i = 0; set[i]!= null; i++ ) {
							if ( set[i].nodeType === 1 ) {
								found = filter( set[i], match, i, isXMLFilter );
								if ( found == null ) {
									continue;
								}
								if ( found === true ) {
									anyFound = true;
									if ( not ) {
										result.push( set[i] );
									} else {
										curLoop = [ set[i] ];
									}
									break;
								} else {
									if ( not ) {
										if ( found === false ) {
											anyFound = true;
										}
									} else {
										result.push( set[i] );
									}
								}
							}
						}
					} else {
						for ( i = 0; curLoop[i]!= null; i++ ) {
							if ( curLoop[i] ) {
								found = filter( curLoop[i], match, i, isXMLFilter );
								if ( found == null ) {
									continue;
								}
								if ( found === true ) {
									anyFound = true;
									if ( not ) {
										result.push( curLoop[i] );
									} else {
										curLoop = [curLoop[i]];
									}
									break;
								} else {
									if ( not ) {
										if ( found === false ) {
											anyFound = true;
										}
									} else {
										result.push( curLoop[i] );
									}
								}
							}
						}
					}

					if ( anyFound === false ) {
						if ( not ) {
							result.push( curLoop );
						} else {
							result = [];
						}
						break;
					}
				}
			}

		if ( expr === old ) {
			if (!anyFound ) {
				Sizzle.error( old );
			}
			break;
		}

		old = expr;
		expr = expr.replace( Expr.filterFail, "" );
	}

	return result;
};

Sizzle.error = function( msg ) {
	throw "Syntax error, unrecognized expression: " + msg;
};

var Expr = Sizzle.selectors = {
	order: ["ID", "NAME", "TAG"],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0 Analyze the following piece of code: if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if (!match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i])!= null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found!= null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found!== undefined ) {
					if (!inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if (!anyFound ) {
						return [];
					}

					break;
				}
			}
		}

				if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};


var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 ) {
						if ( typeof elem.textContent ==='string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText ==='string' ) {
								return elem.innerText.replace( rReturn, '' );
			} else {
								for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

				for ( i = 0; (node = elem[i]); i++ ) {
						if ( node.nodeType!== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr &&!rNonWord.test( part ),
				isClass = isPartStr &&!isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType!== 1 ) {}

					checkSet[i] = isTag? elem.nodeName === part : elem.nodeType === 1 && ( isClass? elem.className === part : elem.nodeName === part );
				}
			}

			if ( isPartStr ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var isPartStr = typeof part === "string";

			if ( isPartStr &&!rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( var i = 0, l = checkSet.length; i < l; i++ ) {
					var elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName === part;
					}
				}
			} else {
				for ( var i = 0, l = checkSet.length; i < l; i++ ) {
					var elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr? elem.parentNode : elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeType = isXML? 1 : 9;

			if ( typeof part === "string" &&!rNonWord.test( part ) ) {
				var nodeList = isXML?
					checkSet.ownerDocument || checkSet[0].ownerDocument :
					checkSet,
					i = 0,
					l = nodeList.length;

				for ( ; i < l; i++ ) {
					var node = nodeList[i];
					if ( node.nodeType === nodeType && contains( node, checkSet ) ) {
						checkSet.push( node );
					}
				}

			} else {
				Sizzle.filter( part, checkSet, true );
			}
		},

		"~": function( checkSet, part, isXML ) {
			var nodeType = isXML? 1 : 9;

			if ( typeof part === "string" &&!rNonWord.test( part ) ) {
				var nodeList = isXML?
					checkSet.ownerDocument || checkSet Analyze the following piece of code:  {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr &&!rNonWord.test( part ),
				isPartStrNotTag = isPartStr &&!isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType!== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr &&!rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" &&!rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" &&!rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById!== "undefined" &&!isXML ) {
				var m = context.getElementById(match[1]);
												return m && m.parentNode? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName!== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName!== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, l = curLoop.length; i < l; i++ ) {
				if ( curLoop[i].nodeType === 1 ) {
					if ( not ^ (curLoop[i].className && (" " + curLoop[i].className + " ").replace(rMultipleSpaces, " ").indexOf(match) >= 0) ) {
						result.push( curLoop[i] );
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			for ( var i = 0, l = curLoop.length; i < l; i++ ) {
				if ( curLoop[i].nodeName.toLowerCase() === match[1] ) {
					return curLoop[i];
				}
			}

			return null;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1].replace( rBackslash, "" ),
				value =!isXML && match[2];

			if (!curLoop[0] ||!curLoop[0].getAttribute ) {
				return true;
			}

			if ( name === "class" &&!isXML ) {
				return CLASS( match, curLoop, inplace, result, not, isXML );
			}

			if ( name === "for" &&!isXML ) {
				return NAME( match, curLoop, inplace, result, not, isXML );
			}

			if ( name === "href" &&!isXML ) {
				return HREF( match, curLoop, inplace, result, not, isXML );
			}

			if ( name === "type" &&!isXML ) {
				return TYPE( match, curLoop, inplace, result, not, isXML );
			}

			if ( not ) {
				if ( Sizzle.attrHandle[ name ] ) {
					return Sizzle.attrHandle[ name ]( curLoop[0], name, value, inplace, result, not, isXML );
				}

				if (!Sizzle.filter[ name ] ) {
					return inplace?
						match[0] :
						false;
				}
			}

			if ( Sizzle.filter[ name ]( curLoop[0], name, value, inplace, result, not, isXML ) === false ) {
				return false;
			}

			return true;
		},

		CHILD: function( match ) {
			var type = match[1],
				node = match[2],
				makeArray = false;

			if ( type === "nth" ) {
				if (!match[3] ) {
					Sizzle.error( match[0] );
				}

				match[4] = +( match[4]? match[5] + (match[6] || 1) : 2 * (match[ Analyze the following piece of code: : {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i])!= null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if (!inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if (!match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

								var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

								match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

						match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );

			if (!isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

						match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
								if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if (!inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}

			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},

	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type!== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},

		selected: function( elem ) {
									if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		parent: function( elem ) {
			return!!elem.firstChild;
		},

		empty: function( elem ) {
			return!elem.firstChild;
		},

		has: function( elem, i, match ) {
			return!!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return /h\d/i.test( elem.nodeName );
		},

		text: function( elem ) {
			return "text" === elem.type;
		},

		radio: function( elem ) {
			return "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return "checkbox" === elem.type;
		},

		file: function( elem ) {
			return "file" === elem.type;
		},

		password: function( elem ) {
			return "password" === elem.type;
		},

		submit: function( elem ) {
			return "submit" === elem.type;
		},

		image: function( elem ) {
			return "image" === elem.type;
		},

		reset: function( elem ) {
			return "reset" === elem.type;
		},

		button: function( elem ) {
			return "button" === elem.type || elem.nodeName.toLowerCase() === "button";
		},

		input: function( elem ) {
			return /input|select|textarea|button/i.test( elem.nodeName );
		}
	},

	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},

	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( Analyze the following piece of code: 	},

		empty: function( elem ) {
			return!elem.firstChild;
		},

		has: function( elem, i, match ) {
			return!!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
									return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
						while ( (node = node.previousSibling) )  {
							if ( node.nodeType === 1 ) { return false; }
						}

						if ( type === "first" ) { return true; }

						node = elem;
				case "last":
					while ( (node = node.nextSibling) )  {
						if ( node.nodeType === 1 ) { return false; }
					}

					return true;
				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}

					doneName = match[0];
					parent = elem.parentNode;

					if ( parent && (parent.sizcache!== doneName ||!elem.nodeIndex) ) {
						count = 0;

						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						}

						parent.sizcache = doneName;
					}

					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
		},

		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Expr.attrHandle[ name ]?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ]!= null?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null?
				type === "!=" :
				type === "="?
				value === check :
				type === "*="?
				value.indexOf(check) >= 0 :
				type === "~="?
				(" " + value + " ").indexOf(check) >= 0 :
				type === "|="?
				value === check || value.slice(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
 Analyze the following piece of code: while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					if ( type === "first" ) {
						return true;
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}

					doneName = match[0];
					parent = elem.parentNode;

					if ( parent && (parent[ expando ]!== doneName ||!elem.nodeIndex) ) {
						count = 0;

						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						}

						parent[ expando ] = doneName;
					}

					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) ||!!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},

		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ]?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ]!= null?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null?
				type === "!=" :
				!type && Sizzle.attr?
				result!= null :
				type === "="?
				value === check :
				type === "*="?
				value.indexOf(check) >= 0 :
				type === "~="?
				(" " + value + " ").indexOf(check) >= 0 :
				!check?
				value && result!== false :
				type === "!="?
				value!== check :
				type === "^="?
				value.indexOf(check) === 0 :
				type === "$="?
				value.substr(value.length - check.length) === check :
				type === "|="?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}

	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using only array-like methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder = function( a, b ) {
	if ( a === b ) {
		hasDuplicate = true;
		return 0;
	}

	if ( a.sourceIndex && b.sourceIndex ) {
		return a.sourceIndex - b.sourceIndex;
	}

	if ( a.nodeType === 1 && b.nodeType === 1 ) {
		return a.compareDocumentPosition(b) & 4? -1 : 1;
	}

	return a.compareDocumentPosition(b) === 2? -1 : 1;
};

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType!== 1 && context.nodeType!== 9 ) {
		return [];
	}

	if (!selector || typeof selector!== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = isXML(context),
		parts = [],
		soFar = selector;

	// Reset the position of the chunker regexp (start from head)
	chunker.source = chunker.source.replace( rwhitespace, "" );

	while ( soFar ) {

		// Comma and first run
		if (!m || (m[1] === "," && m[2] === "") ) {
			if ( m ) {
				// We matched a comma at the beginning of the selector, so make sure we don't
				// end up with an empty selector
				parts.push( "" );
			}

			// Reset the chunker regexp
			chunker.source = chunker.source.replace( rcomma, "" );

			m = chunker.exec( soFar );

			if (!m ) {
				// If we didn't find a comma, then we're done
				break;
			}

			// Otherwise, push the matched Analyze the following piece of code: ( results, array );
		return results;
	}

	return array;
};

try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if (!a.compareDocumentPosition ||!b.compareDocumentPosition ) {
			return a.compareDocumentPosition? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
				if ( a === b ) {
			hasDuplicate = true;
			return 0;

				} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

				if ( aup === bup ) {
			return siblingCheck( a, b );

				} else if (!aup ) {
			return -1;

		} else if (!bup ) {
			return 1;
		}

						while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

				for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i]!== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

				return i === al?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;

		var cur = a.nextSibling;
		}

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

(function(){
		var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

		root.insertBefore( form, root.firstChild );

			if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById!== "undefined" &&!isXML ) {
				var m = context.getElementById(match[1]);

				return m?
					m.id === match[1] || typeof m.getAttributeNode!== "undefined" && m.getAttributeNode("id").nodeValue === match[1]?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode!== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );
	root = form = null;

})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<a href='#'></a><select><option selected=''></option></select>";

	if ( div.querySelectorAll("[href='#']")[0] &&
		!div.querySelectorAll("[selected]").length ) {

		Expr.find.ATTR = function( match, context, isXML ) {
			if ( typeof context.querySelectorAll!== "undefined" &&!isXML ) {
				var found = [],
					attrs = match[1].split(" "),
					value = match[2],
					filter = match[3],
					t = context.nodeType === 9? context.documentElement : context,
					i = 0,
					l = attrs.length;

				for ( ; i < l; i++ ) {
					if ( attrs[i] === "id" && value.charAt(0) === "#" ) {
						return Expr.find.ID( value.substr(1), context, isXML );

					} else if ( attrs[i] === "class" && value.charAt(0) === "." ) {
						found = found.concat( context.getElementsByClassName( value.substr(1) ) );

					} else if ( t.tagName.toLowerCase() === "input" && attrs[i] === "value" && value === "" ) {
						found = found.concat( t.getElementsByTagName( "*" ) );

					} else if ( t.tagName.toLowerCase() === "input" ) {
						var node = t.getElementsByTagName( "*" );

						for ( var j = 0; j < node.length; j++ ) {
							if ( node[j].getAttribute( attrs[i] ) === value ) {
								found.push( node[j] );
							}
						}
					} else if ( isXML?
						t.getAttribute( attrs[i] ) === value :
						RegExp( "^" + value + "$" ).test( t.getAttribute( attrs[i] ) ) ) {
						found.push( t );
					}
				}

				return found.length === 1? found[0] : found;
			}
		};
	}

	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var div = document.createElement("div");

		div.innerHTML = "<p class='TEST'></p>";

		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}

		Expr.find.CLASS = function( match, context, isXML ) {
			if ( typeof context.querySelectorAll!== "undefined" &&!isXML ) {
				return context.querySelectorAll( "." + match[1] );
			}
		};
	})();
}

function dirNodeCheck( dir, root ) {
	var dirCheck = dir === "parentNode",
		done = false,
		node = root;

	while ( node &&!done ) {
		if ( dirCheck && node.nodeType === 1 ) {
			done = true;

		} else if ( node.nodeType === 9 ) {
			done = true;
			node = node. Analyze the following piece of code:  && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

		root = form = null;
})();

(function(){
		
		var div = document.createElement("div");
	div.appendChild( document.createComment("") );

		if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

						if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

		div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute!== "undefined" &&
			div.firstChild.getAttribute("href")!== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

		div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

						if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}

		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

									if (!seed &&!Sizzle.isXML(context) ) {
								var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );

				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
										if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );

										} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}

				if ( context.nodeType === 9 ) {
															if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );

										} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

																		if ( elem && elem.parentNode ) {
																					if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}

						} else {
							return makeArray( [], extra );
						}
					}

					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

																				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase()!== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if (!old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if (!relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if (!old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}

			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

				div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		Sizzle.matchesSelector = function( node, selector ) {
			return matches.call( node, selector );
		};
	}
})();

(function(){
	var head = document.head || document.getElementsByTagName("head")[0],
		style = document.createElement("style"),
		text = "div{display:none;}";

	style.type = "text/css";

	if ( style.styleSheet ) {
		style.styleSheet.cssText = text;

	} else {
		style.appendChild( document.createTextNode(text) );
	}

	head.appendChild(style);

	if ( style.styleSheet && style.styleSheet.cssText === "" ) {
		Sizzle.error = function( msg ) {
			console.error( "Syntax error, check the CSS syntax of your rules " + msg );
		};
	}

	head.removeChild(style);
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<a href='#'></a><b>test</b>";

	if ( div.querySelectorAll("a").length === 2 ) {
		Sizzle.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	div = null;
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<p class='TEST'></p>";

	if ( div.querySelectorAll(".TEST").length === 0 ) {
		Sizzle.find.CLASS = function( match, context ) {
			if ( typeof context.getElementsByClassName!== "undefined" ) {
				return context.getElementsByClassName(match[1]);
			}
		};
	}

	div = null;
})();

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		Sizzle.matchesSelector = function( node, selector ) {
			return matches.call( node, selector );
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	if ( div.querySelectorAll(".test:not(.e)").length === 0 ) {
		Sizzle.filter = function( expr, elems, not ) {
			if ( not ) {
				expr = ":not(" + expr + ")";
			}

			var filtered = [];

			for ( var i = 0, elem; (elem = elems[i])!= null; i++ ) {
				if ( Sizzle(expr, elem).length > 0 ) {
					filtered.push( elem );
				}
			}

			return filtered;
		};
	}

	div = null;
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<p>Hello</p>";

	if ( div.textContent === "Hello" ) {
		Sizzle.getText = function( elem ) Analyze the following piece of code:  = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
						var disconnectedMatch =!matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
									matches.call( document.documentElement, "[test!='']:sizzle" );

		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
						expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if (!Sizzle.isXML( node ) ) {
				try {
					if ( pseudoWorks ||!Expr.match.PSEUDO.test( expr ) &&!/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

												if ( ret ||!disconnectedMatch ||
																								node.document && node.document.nodeType!== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

			if (!div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

		div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}

	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName!== "undefined" &&!isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

		div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 &&!isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if (!isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur!== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a!== b && (a.contains? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return!!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	return elem.nodeType === 9? elem.documentElement.nodeName!== "HTML" : false;
};

var posProcess = function( selector, context ) {
	var tmpSet = [],
		later = "",
		root = context.nodeType? [context] : context;

	while ( selector ) {
		var parts = rcomma.exec( selector );

		if ( parts ) {
			selector = selector.replace( rcomma, "$1" );
			later += parts[1];
		} else {
			var tag = rtagName.exec( selector );

			if ( tag ) {
				tmpSet.push( {
					elem: tag[1],
					"attrs": []
				} );

				selector = selector.replace( rtagName, "$1" );
				later = "";

			} else {
				var pseudo = rpseudo.exec( selector );

				if ( pseudo ) {
					var args = ralphas.exec( pseudo[2] || "" ),
						fn = Expr.pseudos[ pseudo[1] ] || Expr.setFilters[ pseudo[1] ];

					if ( fn ) {
						tmpSet.push( {
							"type": pseudo[1],
							"matches": args,
							"fn": fn
						} );

						selector = selector.replace( rpseudo, "$1" );
						later = "";

					} else {
						selector = selector.replace( rpseudo, "$1" );
						later = ": " + pseudo[2] + ";";
					}

				} else {
					break;
				}
			}
		}
	}

	return [root, tmpSet, selector, later];
};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		({}).childNodes,
		document.childNodes
	);
	Expr.dirruns = true;

} catch( e ) {
	Expr.dirruns = false;
}

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType!== 1 && context.nodeType!== 9 ) {
		return [];
	}

	if (!selector || typeof selector!== "string" ) {
		return results;
	}

	var m, set, checkSet, mode, extra, ret, cur, pop, i,
		prune = true,
		contextXML = isXML( context ),
		parts = [],
		soFar = selector;

	// Reset the position of the chunker regexp (start from head)
	reInitChunker();

	while ( soFar!== "" ) {
		// Comma and first run
		if (!m || (m[1] === "," && m[2] === "") ) {
			if ( m ) {
				// We matched Analyze the following piece of code:  else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return!!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
			var documentElement = (elem? elem.ownerDocument || elem : 0).documentElement;

	return documentElement? documentElement.nodeName!== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType? [context] : context;

			while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector]? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
		rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
		guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector!== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
								for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return!!selector && (
			typeof selector === "string"?
												POS.test( selector )?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
			selector.nodeType?
				this.context === selector?
					true :
					this.context.contains( selector ) :
				false
		);
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rmultiselector.test( selectors )?
				jQuery( selectors, context || this.context ) :
				0;

		if (!pos.length ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[i]; cur && cur!== context; cur = cur.parentNode ) {
					if ( cur.nodeType < 11 && jQuery.find.matchesSelector(cur, selectors) ) {
						matched.push( cur );
						break;
					}
				}
			}
		} else {
			for ( ; i < l; i++ ) {
				cur = this[i];
				if ( cur && cur!== context ) {
					for ( var j = 0, m = pos.length; j < m; j++ ) {
						if ( pos[j] === cur || pos[j].nodeType < 11 && jQuery.find.matchesSelector(cur, pos[j]) ) {
							matched.push( cur );
							break;
						}
					}
				}
			}
		}

		return this.pushStack( matched.length > 1? jQuery.unique( matched ) : matched );
	},

	index: function( elem ) {

		if (!elem ) {
			return ( this[0] && this[0].parentNode )? this.first().prevAll().length : -1;
		}

		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		return jQuery.inArray(
			elem.jquery? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function winnow( elements, selector, not ) {

	if ( isSimple.test( selector ) ) {
		return jQuery.filter( selector, elements, not );
	}

	var elem,
		i = 0,
		l = elements.length,
		matched = [],
		filter = jQuery.filter( selector, elements[0] );

	while ( i < l ) {
		if ( (elem = elements[i]) ) {
			if ( not ^ filter.call( elem, i, elem ) ) {
				matched.push( elem );
			}
		}
		i++;
	}

	return matched;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType!== 11? parent : null;
	},
	parents: function Analyze the following piece of code: 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];

				if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur!== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

				var pos = POS.test( selectors ) || typeof selectors!== "string"?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if (!cur ||!cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

			index: function( elem ) {

				if (!elem ) {
			return ( this[0] && this[0].parentNode )? this.prevAll().length : -1;
		}

				if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

				return jQuery.inArray(
						elem.jquery? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string"?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] )?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

function isDisconnected( node ) {
	return!node ||!node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType!== 11? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" )?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 )!== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if (!guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1?
			jQuery.find.matchesSelector(elems[0], expr)? [ elems[0] ] : [] :
			jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
				return elem.nodeType === 1;
			}));
	},

	dir: function( elem, dir, until ) {
		var matched = [], cur = elem[ dir ];
		while ( cur && cur.nodeType!== 9 && (until === undefined || cur.nodeType!== 1 ||!jQuery(cur).is(until)) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[ dir ];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n!== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

// Implement the identical functionality for filter and not
function filterAndNot( elem, i, not ) {
	return not ^ ( elem.nodeType === 1 && jQuery.find.matchesSelector( elem, ":not(" + i + ")" ) );
}

// Determine the previous/next element for a given element
function prevNext( elem, dir ) {
	while ( (elem = elem[dir]) && elem.nodeType!== 1 ) {}
	return elem;
}

// Return a set of elements matching the given conditions
function select( elems, selector, context, results ) {
	var elem,
		len = elems.length,
		tmp,
		i = 0,
		match,
		old = context && jQuery.expr.match. Analyze the following piece of code: Window.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if (!runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 &&!guaranteedUnique[ name ]? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1?
			jQuery.find.matchesSelector(elems[0], expr)? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType!== 9 && (until === undefined || cur.nodeType!== 1 ||!jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n!== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

function winnow( elements, qualifier, keep ) {

			qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal =!!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered,!keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	rscriptType = /^(?:text|application)\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^(?:text|application)\/json/i,
	rcdata = /<!\[CDATA\[|--)|\]\]>/g,
	rdtd = /<!DOCTYPE [^>]+>/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rstyle = /<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi,
	rscriptAttr = /\bsrcset\b/i,
	rstyleAttr = /\bstyle\b/i,
	rhref = /href/i,
	rrel = /rel/i,
	ria = /ria-/,
	rproperty = /property/i,
	rnonce = /nonce/i,
	riframe = /<iframe/i,
	rform = /<form/i,
	rformAction = /action/i,
	rformMethod = /method/i,
	rformEncType = /enctype/i,
	rformTarget = /target/i,
	rformNoValidate = /novalidate/i,
	rinput = /<input/i,
	rselect = /<select/i,
	rtextarea = /<textarea/i,
	rbutton = /<button/i,
	rinputType = /type/i,
	rinputButton = /button/i,
	rinputImage = /image/i,
	rinputReset = /reset/i,
	rinputSubmit = /submit/i,
	rinputFile = /file/i,
	rmap = /<map/i,
	rarea = /<area/i,
	rparam = /<param/i,
	rsource = /<source/i,
	rtrack = /<track/i,
	rvideo = /<video/i,
	rtrackKind = /kind/i,
	rtrackDefault = /default/i,
	rtrackSrclang = /srclang/i,
	rtrackLabel = /label/i,
	rtrackSrc = /src/i,
	rtrackCue = /cue/i,
	rtrackCueCat = /cuecat/i,
	rtrackCueSrc = /cuesrc/i,
	rtrackCueEnd = /cueend/i,
	rtrackCueStart = /cuestart/i,
	rtrackPreload = /preload/i,
	rtrackAutobuffer = /autobuffer/i,
	rtrackControls = /controls/i,
	rtrackPlaysinline = /playsinline/i,
	r Analyze the following piece of code: |hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

if (!jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery( this );

				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text!== "object" && text!== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
						var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if (!jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip(arguments, false, function( elem ) {
			this.parentNode.insertBefore( elem, this );
		});
	},

	after: function() {
		return this.domManip(arguments, false, function( elem ) {
			this.parentNode.insertBefore( elem, this.nextSibling );
		});
	},

	remove: function( selector, keepData ) {
		if ( selector === undefined ) {
			return this.each(function() {
				if (!keepData) {
					if ( this.parentNode ) {
						this.parentNode.removeChild( this );
					}
				} else {
					jQuery.cleanData([this]);
				}
			});
		}

		if ( typeof selector === "string" ) {
			var nodes = jQuery.filter(selector, this);
			return this.pushStack( jQuery.map(nodes, function(node) {
				if (!keepData && node.parentNode ) {
					node.parentNode.removeChild( node );
				}
				return node;
			}));
		}

		var node = selector;

		return this.each(function() {
			if ( this === node || jQuery.contains( this, node ) ) {
				if (!keepData) {
					if ( this.parentNode ) {
						this.parentNode.removeChild( this );
					}
				} else {
					jQuery.cleanData([this]);
				}
			}
		});
	},

	empty: function() {
		return this.each(function() {
			while ( this.firstChild ) {
				this.removeChild( this.firstChild );
			}
		});
	},

	clone: function( withDataAndEvents, deepDataAndEvents ) {
		var clone = this.map(function() {
			if (!jQuery.support.noCloneEvent &&!jQuery.isXMLDoc(this)) {
				var clone = this.cloneNode(true);

				if (!jQuery.support.noCloneChecked && (this.nodeType === 1 || this.nodeType === 11) &&!jQuery.cloneAttributes) {
					var node = this.getElementsByTagName("input");

					for (var i = 0; i < node.length; i++) {
						var n = node[i];
						if (n.type === "checkbox" || n.type === "radio") {
							n.checked = n.defaultChecked;
						}
					}
				}

				if (deepDataAndEvents) {
					jQuery.cloneEvents(this, clone);
				}
			} else {
				clone = this.cloneNode(false);
			}

			// IE<=8 does not properly clone detached nodes
			if (this.nodeType === 1) {
				jQuery.cleanData(this. Analyze the following piece of code:  function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

		remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i])!= null; i++ ) {
			if (!selector || jQuery.filter( selector, [ elem ] ).length ) {
				if (!keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i])!= null; i++ ) {
						if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

						while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

				} else if ( typeof value === "string" &&!rnoInnerhtml.test( value ) &&
			(jQuery.support.leadingWhitespace ||!rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
										if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

						} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery( this );

				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call(this, i, old) );
				});
			} else if ( typeof value!== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery(this).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length?
				this.pushStack( jQuery(jQuery.isFunction(value)? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function(index) {
				var self = set.eq(index);
				if ( isFunction ) {
					args[0] = value.call(this, index, table? self.html() : undefined);
				}
				self.domManip( args, table, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[0].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll, fragment );
				hasScripts = scripts.length;

				// Use the original set for the next loop so we can add back script nodes
				set = l > 1 &&!table && set.slice(1);

				// Remove any remaining nodes
				for ( ; i < iNoClone; i++ ) {
					node = fragment;

					if ( i < hasScripts ) {
						node = scripts[i];
					}

					if ( node ) {
						// We don't need the check for empty strings because IE strips them
						if ( table ) {
							if ( i === iNoClone - 1 ) {
								// For tables, ensure the last child gets properly wrapped
								node = node.nextSibling;
								if ( node && node.nodeType === 1 ) {
									jQuery(node).before( set );
								}
							}

							jQuery(node).remove();

						} else { Analyze the following piece of code:  {
									if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value!== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length?
				this.pushStack( jQuery(jQuery.isFunction(value)? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

				if (!jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

						if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table?
							root(this[i], first) :
							this[i],
																																																results.cacheable || ( l > 1 && i < lastIndex )?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table")?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType!== 1 ||!jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type + ( events[ type ][ i ].namespace? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
			}
		}
	}

		if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	if ( dest.nodeType === 1 ) {
		nodeName = dest.nodeName.toLowerCase();

		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
}

function cloneDomManip( src, dest ) {
	var i, l, srcNodes = src.childNodes,
		destNodes = dest.childNodes;

	if ( dest.nodeType === 11 ) {
		dest.innerHTML = "";
	}

	if ( srcNodes.length === 1 && destNodes.length === 1 && srcNodes[0].nodeType === 3 && destNodes[0].nodeType === 3 ) {
		dest.textContent = src.textContent;
	} else {
		for ( i = 0, l = srcNodes.length; i < l; i++ ) {
			dest.appendChild(
				i in destNodes?
					destNodes[i] :
					srcNodes[i].cloneNode( true )
			);
		}
	}
}

if (!jQuery.support.noCloneEvent ) {
	jQuery.event.add(
		"clone",
		function( e ) {
			cloneCopyEvent( e.originalEvent.srcElement, this );
		},
		false
	);

	jQuery.event.add(
		"paste",
		function( e ) {
			var elem = e.target;

			if ( elem.nodeName === "TEXTAREA" ) {
				cloneCopyEvent( elem, elem );
			}
		},
		false
	);
}

if (!jQuery.support.noCloneChecked ) {
	jQuery.expr[ ":checked" ].push( function( elem ) {
		return!!( elem.checked || elem.defaultChecked );
	} );

	jQuery.expr[ ":disabled" ].push( function( elem ) {
		return!!( elem.disabled || elem.parentNode && elem.parentNode.disabled );
	} );

	jQuery.fn.extend({
		disable: function() {
			return this.each(function() {
				this.disabled = true;
			});
		},

		enable: function() {
			return this.each(function() {
				this.disabled = false;
			});
		},

		disabled: function() {
			return this.attr( "disabled" ) === "disabled";
		},

		enabled: function() {
			return!this.disabled();
		},

		check: function() {
			return this.each(function() {
				if ( this.type === "checkbox" || this.type === "radio" ) {
					this.checked = true;
				}
			});
		},

		checked: function() {
			return this.check().filter(":checked").length > 0;
		},

		radio: function() {
			return this.filter(":checked").filter("[type=radio]").length > 0;
		},

		enable: function() {
			return this.each(function() {
				if Analyze the following piece of code: 

function cloneFixAttributes( src, dest ) {
	var nodeName;

		if ( dest.nodeType!== 1 ) {
		return;
	}

			if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

			if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

				if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
								if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

						if ( dest.value!== src.value ) {
			dest.value = src.value;
		}

			} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

			} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}

			dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

				if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

				if (!doc.createDocumentFragment ) {
		doc = document;
	}

						if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" &&!rnocache.test( first ) &&
		(jQuery.support.checkClone ||!rchecked.test( first )) &&
		(jQuery.support.html5Clone ||!rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults!== 1 ) {
			fragment = cacheresults;
		}
	}

	if (!fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName!== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll!== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
		return elem;
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		return elem.getElementsByTagName( "input" );

	} else {
		return findInputs( elem.parentNode );
	}
}

jQuery.extend({
	clean: function( elems, context, fragment, scripts ) {
		context = context || document;

		var ret = [], j, elem,
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( typeof elem === "number" ) {
				elem += "";

			} else if (!elem ) {
				continue;
			}

			if ( typeof elem === "string" ) {
				if (!rhtml.test( elem ) ) {
					elem = elem.replace( rcleanhtml, "" );

					if ( elem.indexOf( "<" ) < 0 ) {
						elem = context.createTextNode( elem );
					} else {
						j = context.createElement( "div" );
						j.innerHTML = elem;

						while ( j.firstChild ) {
							elem.insertBefore( j.firstChild, j );
						}

						elem = j.firstChild;

						while ( j.lastChild ) {
							j.removeChild( j.lastChild );
						}

						j = null;
					}
				}

			} else if ( elem.nodeType ) {
				if ( elem.nodeName.toLowerCase() === "script" && (!elem.type || elem.type.toLowerCase() === "text/javascript") ) {
					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}

					if ( scripts ) {
						scripts.push( elem );
					}

				} else if ( elem.nodeType === 1 ) {
					if (!jQuery.support.html5Clone && elem.nodeName.toLowerCase() === "object" ) {
						ret.push.apply( ret, jQuery.clean( elem.getElementsByTagName( "*" ), context ) );
						elem.outerHTML = elem.innerHTML;

					} else if (!jQuery.support.noCloneEvent && elem.nodeName.toLowerCase() === "input" && rcheckableType.test( elem.type ) ) {
						findInputs( elem ).forEach(fixDefaultChecked);

					} else if (!jQuery.support.noCloneEvent && elem.nodeName.toLowerCase() === "option" ) {
						elem.defaultSelected = elem.selected;

					} else if (!jQuery.support.html5Clone && elem.nodeName.toLowerCase() === "select" ) {
						elem.innerHTML = elem.options.length > 0?
							elem.options[0].text : "";

					} else if (!jQuery.support.noCloneEvent && elem.nodeName.toLowerCase() === "textarea" ) {
						elem.defaultValue = elem.value;
					}

					var tmp = getAll( elem.cloneNode( true ) );

					ret.push.apply( ret, tmp );
				}
			}
		}

		if ( fragment ) {
			ret.push.apply( ret, fragment.childNodes );
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id, Analyze the following piece of code:  );
		} else if ( nodeName!== "script" && typeof elem.getElementsByTagName!== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
						clone = jQuery.support.html5Clone ||!rnoshimcache.test( "<" + elem.nodeName )?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent ||!jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) &&!jQuery.isXMLDoc(elem) ) {
															
			cloneFixAttributes( elem, clone );

						srcElements = getAll( elem );
			destElements = getAll( clone );

												for ( i = 0; srcElements[i]; ++i ) {
								if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

				if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

				return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType;

		context = context || document;

				if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [], j;

		for ( var i = 0, elem; (elem = elems[i])!= null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if (!elem ) {
				continue;
			}

						if ( typeof elem === "string" ) {
				if (!rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
										elem = elem.replace(rxhtmlTag, "<$1></$2>");

										var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

										if ( context === document ) {
												safeFragment.appendChild( div );
					} else {
												createSafeFragment( context ).appendChild( div );
					}

										div.innerHTML = wrap[1] + elem + wrap[2];

										while ( depth-- ) {
						div = div.lastChild;
					}

										if (!jQuery.support.tbody ) {

												var hasBody = rtbody.test(elem),
							tbody = tag === "table" &&!hasBody?
								div.firstChild && div.firstChild.childNodes :

																wrap[1] === "<table>" &&!hasBody?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) &&!tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

										if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;
				}
			}

									var len;
			if (!jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (checkScriptType = elem[0].type) === "string" && checkScriptType.toLowerCase() === "text/javascript" ) {
					elem[0].type = "text/html";
				} else {
					checkScriptType = false;
				}
			}

			if ( elem.length ) {
				ret.push( jQuery.merge( ret, elem ) );
			}

										if ( checkScriptType ) {
				elem[0].type = checkScriptType;
			}

			if ( scripts ) {
				ret.push.apply( ret, scripts );
			}
		}

		return ret;
	}
});

function getAll( context ) {
	var ret = context.getElementsByTagName? context.getElementsByTagName("*") : context.querySelectorAll? context.querySelectorAll("*") : [];

	return typeof ret.length === "number"? jQuery.makeArray(ret) : ret;
}

// Fix attributes on cloned nodes
function cloneFixAttributes( src, dest ) {
	var nodeName;

	if ( src.nodeType === 1 ) {
		nodeName = src.nodeName.toLowerCase();

		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// IE6-8 fails to persist the checked state of a cloned checkbox
		// when cloning to a hidden element
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}

		if ( src.selected ) {
			dest.selected = true;
		}

		// IE6-10 fails to return the selected option to the default selected state when cloning options
		if ( nodeName === "option" ) {
			dest.defaultSelected = src.defaultSelected;
		}
	}

	// Event data gets referenced instead of copied if the expando gets copied too
	if ( typeof src.addEventListener === "function" ) {
		dest.addEventListener( src.type, src.addEventListener );
	}
}

// Fix event data for cloned scripts
function cloneCopyEvent( src, dest ) {
	dest.addEventListener( src.type, function(event) {
		event = event || window.event;
		var originalEvent = event.originalEvent;

		if ( originalEvent ) {
			event = originalEvent;
		}

		event.target = event.target || event.srcElement;

		if ( event.stopPropagation ) {
			event.stopPropagation();
		}

		if ( event.preventDefault ) {
			event.preventDefault();
		}

		dest.dispatchEvent( event );
	}, false);
}

var rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	rnoshimcache = /<(?:script|object|embed|iframe)/i,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rleadingWhitespace = /^\s+/,
	wrapMap = {
		 Analyze the following piece of code:  ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return!elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

				} else {
					if ( ret[i].nodeType === 1 ) {
						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i])!= null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

												} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

										if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "" ) );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
		rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^([\-+])=([\-+.\de]+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
		if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value!== undefined?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
			cssHooks: {
				opacity: {
					get: function( elem, computed ) {
						if ( computed ) {
							var ret = curCSS( elem, "opacity" );
							return ret === ""? "1" : ret;
						}
					}
				}
			},

			cssNumber: {
				"fillOpacity": true,
				"fontWeight": true,
				"lineHeight": true,
				"opacity": true,
				"orphans": true,
				"widows": true,
				"zIndex": true,
				"zoom": true
			},

			cssProps: {
				"float": "cssFloat"
			},

			style: function( elem, name, value, extra ) {
				if (!elem || elem.nodeType === 3 || elem.nodeType === 8 ||!elem.style ) {
					return;
				}

				// Make sure that we're working with the right name
				var ret, type, hooks,
					origName = jQuery.camelCase( name ),
					style = elem.style;

				name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

				// Get any existing value for this property
				if ( value!== undefined ) {
					type = typeof value;

					// Convert numeric strings to numbers (but not NaN)
					if ( type === "string" && value.match( rnum ) ) {
						value = parseFloat( value );

						// Make sure it is a number and not a string
						if ( value.toString() === "NaN" ) {
							return;
						}
					}

					// Make sure that null and NaN values aren't set
					if ( value == null || value!== value ) {
						return;
					}

					// If a number was passed in, add 'px' to the (except for certain CSS properties)
					if ( type === "number" &&!jQuery.cssNumber[ origName ] ) {
						value += "px";
					}

					// If a string was passed in, we need to default to "auto"
					if ( type === "string" && jQuery.cssNumber[ origName ] ) {
						value = value.replace( rnum, "" );
						style[ name ] = value;
					} else {
						style[ name ] = value;
					}
				} else {
					// If no value was passed in, just return the current value
					ret = style[ name ];
				}

				return ret;
			},

			css: function( elem, name, extra, styles ) {
				var val, num, hooks,
					origName = jQuery.camelCase( name );

				// Make sure that we're working with the right name
				name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

				// Try prefixed name followed by the unprefixed name
				hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

				// If a hook was provided get the computed value from there
				if ( hooks && "get" in hooks ) {
					val = hooks.get( elem, true, extra );
				}

				// Otherwise just get the value Analyze the following piece of code:  {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
										var ret = curCSS( elem, "opacity", "opacity" );
					return ret === ""? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

		cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

			cssProps: {
				"float": jQuery.support.cssFloat? "cssFloat" : "styleFloat"
	},

		style: function( elem, name, value, extra ) {
				if (!elem || elem.nodeType === 3 || elem.nodeType === 8 ||!elem.style ) {
			return;
		}

				var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

				if ( value!== undefined ) {
			type = typeof value;

						if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
								type = "number";
			}

						if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

						if ( type === "number" &&!jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

						if (!hooks ||!("set" in hooks) || (value = hooks.set( elem, value ))!== undefined ) {
												try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
						if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra ))!== undefined ) {
				return ret;
			}

						return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

				name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

				if ( name === "cssFloat" ) {
			name = "float";
		}

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra ))!== undefined ) {
			return ret;

				} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

		swap: function( elem, options, callback ) {
		var old = {};

				for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

				for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	}
});

jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth!== 0 ) {
					return getWH( elem, name, extra );
				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				return val;
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
								value = parseFloat( value );

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if (!jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			if ( computed ) {
				return (
					curCSS( elem, "opacity", "opacity" )!== ""?
					parseFloat( curCSS( elem, "opacity", "opacity" ) ) / 100 :
					1
				);
			}
		},

		set: function( elem, value ) {
			var style = elem.style,
				originalOpacity = jQuery.isNumeric( style.opacity )?
					style.opacity :
					"",
				opacity = typeof value === "string"?
					value :
					value + "";

			style.opacity = opacity;

			if ( originalOpacity ) {
				if ( opacity === "" ) {
					elem.style.removeAttribute( "opacity" );
				}
			} else {
				if ( opacity!== "" ) {
					elem.style.opacity = opacity;
				}
			}

			return opacity;
		}
	};
}

function getWH( elem, name, extra ) {
	var which = name === "width"? [ "Left", "Right" ] : [ "Top", "Bottom" ],
		val = name === "width"? elem.offsetWidth : elem.offsetHeight,
		margin = 0,
		style = elem.style;

	name = name.toLowerCase();

	if ( extra === "border" ) {
		each( which, function() {
			margin += parseFloat( jQuery.css( elem, "margin" + this, true ) ) || 0;
		});
	}

	if ( extra === "margin" ) {
		margin += parseFloat( jQuery.css( elem, "margin" ) ) || 0;
	}

	if ( style[ name ] === "" ) {
		return val;
	}

	if ( jQuery.support.boxSizing && style[ "boxSizing" ] === "border-box" ) {
		return val + margin;
	}

	return Math.max( val - parseFloat( jQuery.css( elem, "padding" + which[ 0 ], true ) ) - parseFloat( jQuery.css( elem, "padding" + which[ 1 ], true ) ) - margin, 0 );
}

jQuery.fn.extend({
	show: function() {
		return showHide( this, true );
	},

	hide: function() {
		return showHide( this );
	},

	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

function showHide( elements, show ) {
	var elem, display;

	for ( var i = 0, l = elements.length; i < l; i++ ) {
		elem = elements[i];
		if (!elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {
			if ( display === "none" ) {
				elem.style.display = "";
			} Analyze the following piece of code:  {
		get: function( elem, computed ) {
						return ropacity.test( (computed && elem.currentStyle? elem.currentStyle.filter : elem.style.filter) || "" )?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value )? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

									style.zoom = 1;

						if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

																style.removeAttribute( "filter" );

								if ( currentStyle &&!currentStyle.filter ) {
					return;
				}
			}

						style.filter = ralpha.test( filter )?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
			if (!jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
												var ret;
				jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						ret = curCSS( elem, "margin-right", "marginRight" );
					} else {
						ret = elem.style.marginRight;
					}
				});
				return ret;
			}
		};
	}
});

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" &&!jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

						if ( ret === null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

				
						if (!rnumpx.test( ret ) && rnum.test( ret ) ) {

						left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

						if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize"? "1em" : ( ret || 0 );
			ret = style.pixelLeft + "px";

						style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === ""? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {

		var val = name === "width"? elem.offsetWidth : elem.offsetHeight,
		which = name === "width"? cssWidth : cssHeight,
		i = 0,
		len = which.length;

	if ( val > 0 ) {
		if ( extra!== "border" ) {
			for ( ; i < len; i++ ) {
				if (!extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
				}
			}
		}
	}

	return val;
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;
		return width === 0 && height === 0 ||
			jQuery.expr.filters.visible( elem );
	};

	jQuery.expr.filters.visible = function( elem ) {
		return!!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};
}

jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string"? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if (!rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = function( elem, value ) {
			if ( value === "" ) {
				value = "auto";
			}
			return jQuery.cssHooks[ prefix + suffix ].expand( value );
		};
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value!== undefined?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

var rcheckableType = (/^(?:checkbox|radio)$/i);

function valueChecked( elem, value ) {
	if ( rcheckableType.test Analyze the following piece of code: 	val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

		val = curCSS( elem, name, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ] || 0;
	}
		val = parseFloat( val ) || 0;

		if ( extra ) {
		for ( ; i < len; i++ ) {
			val += parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
			if ( extra!== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
			}
		}
	}

	return val + "px";
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return!jQuery.expr.filters.hidden( elem );
	};
}




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, 	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
		rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

		_load = jQuery.fn.load,

	
	prefilters = {},

	
	transports = {},

		ajaxLocation,

		ajaxLocParts,

		allTypes = ["*/"] + ["*"];

try {
	ajaxLocation = location.href;
} catch( e ) {
			ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

function addToPrefiltersOrTransports( structure ) {

		return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression!== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

						for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
												placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
								list[ placeBefore? "unshift" : "push" ]( func );
			}
		}
	};
}

function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			dataTypeExpression = options.dataType || options.dataTypes || "*";

		if ( dataTypeExpression === "*" ) {
			for ( var dataType in structure ) {
				if (!inspected[ dataType ] ) {
					inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR, dataType );
				}
			}
		} else {
			if ( typeof dataTypeExpression === "string" ) {
				dataTypeExpression = dataTypeExpression.toLowerCase().split( rspacesAjax );
			}

			var i = 0,
				length = dataTypeExpression.length,
				dataType,
				list,
				placeBefore;

			for ( ; i < length; i++ ) {
				dataType = dataTypeExpression[ i ];
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.substr( 1 ) || "*";
					placeBefore = true;
				} else {
					placeBefore = false;
				}
				list = structure[ dataType ] || [];
				inspected[ dataType ] =!placeBefore || inspected[ dataType ]?
					( placeBefore? jQuery.inArray( list, inspected[ dataType ] ) > -1 : true ) :
					inspectPrefiltersOrTransports( list, options, originalOptions, jqXHR, dataType );
			}
		}
		return inspected;
	}

function ajaxPrefilter( options, originalOptions, jqXHR ) {

		var inspected,
			type = options.type.toLowerCase(),
			dataType = options.dataType,
			prefilter = prefilters[ type ] || [];

		if ( typeof options.data === "string" ) {
			options.data = options.data.replace( r20, " " );
		}

		inspected = inspectPrefiltersOrTransports( prefilter, options, originalOptions, jqXHR );
		if ( inspected!== true ) {
			return inspected;
		}

		if ( type === "abort" ) {
			jqXHR.abort();
		} else {
			for ( var i = 0; i < prefilter.length; i++ ) {
				prefilter[ i ]( options, originalOptions, jqXHR );
			}

			if ( options.async &&
				jQuery.inArray( "script", options.dataType ) > -1 ) {
				return true;
			}
		}
	}

function ajaxTransport( options, originalOptions, jqXHR ) {

		var inspected,
			type = options.type.toLowerCase(),
			transport = transports[ type ] || [],
			dataType,
			i = 0,
			response,
			conn;

		for ( ; i < transport.length; i++ ) {
			inspected = transport[ i ]( options, originalOptions, jqXHR );
			if ( inspected === false ) {
				continue;
			}
			if ( inspected!== undefined ) {
				return inspected;
			}
		}

		if ( jQuery.support.cors ||
			jQuery.support.ajaxTransport ) {

			dataType = options.dataType;

			if (!dataType ) {
				dataType = originalOptions && originalOptions.dataType;
			}

			if ( dataType ) { Analyze the following piece of code: ( structure, options, originalOptions, jqXHR,
		dataType, inspected  ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly ||!selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
						if ( typeof selection === "string" ) {
			if (!executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
			if ( ( executeOnly ||!selection ) &&!inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
			return selection;
}

function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ]!== undefined ) {
			( flatOptions[ key ]? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url!== "string" && _load ) {
			return _load.apply( this, arguments );

				} else if (!this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

				var type = "GET";

				if ( params ) {
						if ( jQuery.isFunction( params ) ) {
								callback = params;
				params = undefined;

						} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

				jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
						complete: function( jqXHR, status, responseText ) {
								responseText = jqXHR.responseText;
								if ( jqXHR.isResolved() ) {
															jqXHR.done(function( r ) {
						responseText = r;
					});
										self.html( selector?
												jQuery("<div>")
																					.append(responseText.replace(rscript, ""))

														.find(selector) :

												responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name &&!this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null?
				null :
				jQuery.isArray( val )?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

jQuery.param = function( a, traditional ) {
	var s = [],
		add = function( key, value ) {
			value = jQuery.isFunction( value )? value() : ( value == null? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	if ( a == null ) {
		return "";
	}

	if ( typeof a === "object" ) {
		jQuery.each( a, function( k, v ) {
			if ( traditional === true ) {
				add( k, v );

			} else if ( jQuery.isArray( v ) ) {
				jQuery.each( v, function( i, v ) {
					add( k, v );
				});

			} else {
				add( k, v );
			}
		});
	}

	return s.join( "&" );
};

var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v, traditional );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object"? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if (!traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj, traditional );
	}
}

// Serialize an array of form elements or a set of
// key/value pairs into a query string
jQuery.param = function( a, traditional ) {
	var s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value )? value() : ( value == null? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery &&!jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, Analyze the following piece of code: \n" ) };
		}).get();
	}
});

jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
				if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

				ajaxSetup: function( target, settings ) {
		if ( settings ) {
						ajaxExtend( target, jQuery.ajaxSettings );
		} else {
						settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

								converters: {

						"* text": window.String,

						"text html": true,

						"text json": jQuery.parseJSON,

						"text xml": jQuery.parseXML
		},

										flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

		ajax: function( url, options ) {

				if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

				options = options || {};

		var 			s = jQuery.ajaxSetup( {}, options ),
						callbackContext = s.context || s,
												globalEventContext = callbackContext!== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery )?
						jQuery( callbackContext ) : jQuery.event,
						deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
						statusCode = s.statusCode || {},
						ifModifiedKey,
						requestHeaders = {},
			requestHeadersNames = {},
						responseHeadersString,
			responseHeaders,
						transport,
						timeoutTimer,
						parts,
						state = 0,
						fireGlobals,
						i,
						jqXHR = {

				readyState: 0,

								setRequestHeader: function( name, value ) {
					if (!state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

								getAllResponseHeaders: function() {
					return state === 2? responseHeadersString : null;
				},

								getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if (!responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined? null : match;
				},

								overrideMimeType: function( type ) {
					if (!state ) {
						s.mimeType = type;
					}
					return this;
				},

								abort: function( statusText ) {
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ ifModifiedKey ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ ifModifiedKey ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess =!error;
				}
			} else {
				error = response;
			}

			// Call complete if needed
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s, isSuccess ] );
			}

			// Handle errors
			if ( isSuccess === false ) {
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxError", [ jqXHR, s, error ] Analyze the following piece of code:  match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined? null : match;
				},

								overrideMimeType: function( type ) {
					if (!state ) {
						s.mimeType = type;
					}
					return this;
				},

								abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

								function done( status, nativeStatusText, responses, headers ) {

						if ( state === 2 ) {
				return;
			}

						state = 2;

						if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

									transport = undefined;

						responseHeadersString = headers || "";

						jqXHR.readyState = status > 0? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

						if ( status >= 200 && status < 300 || status === 304 ) {

								if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

								if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

								} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
												statusText = "parsererror";
						error = e;
					}
				}
			} else {
												error = statusText;
				if (!statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

						jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

						if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

						jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess? "Success" : "Error" ),
						[ jqXHR, s, isSuccess? success : error ] );
			}

						completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
								if (!( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

				deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

				jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

								s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "
				s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

					if ( s.crossDomain == null ) {
				crossDomain = rcrossDomain.test( ajaxLocParts[ 1 ] );
			}

			if (!s.hasContent ) {
				s.data = undefined;
			}

			if ( s.global ) {
				if (!fireGlobals ) {
					jQuery.error( "jQuery.ajax: options.global must be true for global requests" );
				}
				s.type = s.type.toUpperCase();
				if ( s.type === "GET" ) {
					if ( s.data ) {
						s.url += ( rquery.test( s.url )? "&" : "?" ) + s.data;
					}
					s.data = undefined;
				}
				ajaxHandleCache[ key ] = jqXHR;
			}

			if ( s.ifModified ) {
				if ( jQuery.lastModified[ ifModifiedKey ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
				}
				if ( jQuery.etag[ ifModifiedKey ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
				}
			}

			if ( s.data && s.hasContent && s.contentType!== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			jqXHR.setRequestHeader( "Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ]?
					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ]!== "*"? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				return jqXHR.abort();
			}

			s.timeout > 0 && ( timeoutTimer = setTimeout( function() {
				jqXHR.abort( "timeout" );
			}, s.timeout ) );

			try {
				state = 1;
				xhr = s.xhr();
			} catch ( e ) {
				return jqXHR.abort( "transport" );
			}

			if (!xhr ) {
				return jqXHR.abort();
			}

			try {
				fireGlobals = true;
				xhr.open( s.type, s.url, s.async, s.username, s.password );
			} catch ( e ) {
				fireGlobals = false;
				return jqXHR.abort();
			}

			if ( s.xhrFields ) {
				for ( i in s.xhrFields ) {
					xhr[ i ] = s.xhrFields[ i ];
				}
			}

			if ( s.mimeType && xhr.overrideMimeType ) {
				xhr.overrideMimeType( s.mimeType );
			}

			if ( s.crossDomain ) {
				xhr.withCredentials = true Analyze the following piece of code: if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain =!!( parts &&
				( parts[ 1 ]!= ajaxLocParts[ 1 ] || parts[ 2 ]!= ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:"? 80 : 443 ) )!=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:"? 80 : 443 ) ) )
			);
		}

				if ( s.data && s.processData && typeof s.data!== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

				inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

				if ( state === 2 ) {
			return false;
		}

				fireGlobals = s.global;

				s.type = s.type.toUpperCase();

				s.hasContent =!rnoContent.test( s.type );

				if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

				if (!s.hasContent ) {

						if ( s.data ) {
				s.url += ( rquery.test( s.url )? "&" : "?" ) + s.data;
								delete s.data;
			}

						ifModifiedKey = s.url;

						if ( s.cache === false ) {

				var ts = jQuery.now(),
										ret = s.url.replace( rts, "$1_=" + ts );

								s.url = ret + ( ( ret === s.url )? ( rquery.test( s.url )? "&" : "?" ) + "_=" + ts : "" );
			}
		}

				if ( s.data && s.hasContent && s.contentType!== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

				if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

				jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ]?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ]!== "*"? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

				for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

				if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
								jqXHR.abort();
				return false;

		}

				for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

				transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

				if (!transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
						if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
						if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
								if ( state < 2 ) {
					done( -1, e );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		} );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		if ( this[ 0 ] ) {
			jQuery( html ).insertBefore( this[ 0 ] );

			var wrap = jQuery( html );
			for ( var i = 0; i < this.length; i++ ) {
				wrap = wrap.add( this[ i ] );
			}

			wrap.appendTo( document.body );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction? html.call( this, i ) : html );
		} );
	},

	unwrap: function() {
		return this.parent().each( function() {
			if (!jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		} ).end();
	}
} );


jQuery.expr.filters.hidden = function( elem ) {
	return!jQuery.expr.filters.visible( elem );
};
jQuery.expr.filters.visible = function( elem ) {
	return!!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF Analyze the following piece of code:  e );
								} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

			param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
								value = jQuery.isFunction( value )? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

				if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

				if ( jQuery.isArray( a ) || ( a.jquery &&!jQuery.isPlainObject( a ) ) ) {
						jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
									for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

				return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
				jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
								add( prefix, v );

			} else {
																																buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v)? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if (!traditional && obj!= null && typeof obj === "object" ) {
				for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
				add( prefix, obj );
	}
}

jQuery.extend({

		active: 0,

		lastModified: {},
	etag: {}

});


function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

		for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

		while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

		if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

		if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
				for ( type in responses ) {
			if (!dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if (!firstDataType ) {
				firstDataType = type;
			}
		}
				finalDataType = finalDataType || firstDataType;
	}

				if ( finalDataType ) {
		if ( finalDataType!== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

function ajaxConvert( s, response ) {

		if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
				current = dataTypes[ 0 ],
		prev,
				conversion,
				conv,
				conv1,
		conv2;

		for ( i = 1; i < length; i++ ) {

						if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

			prev = current;
			current = dataTypes[ i ];

			if ( current === "*" ) {
				current = prev;
			}

			if ( prev!== "*" && prev!== current ) {
				for ( key in converters ) {
					if ( canConvert( prev, key, current ) ) {
						conv = converters[ key ];
						tmp = conv( response );
						if ( tmp!== undefined ) {
							response = tmp;
							break;
						}
					}
					if ( typeof conv === "object" && conv!== null ) {
						conv1 = conv[ prev ];
						if ( conv1!== undefined ) {
							conv2 = conv[ current ];
							if ( conv2!== undefined ) {
								tmp = conv1( conv2( response ) );
								if ( tmp!== undefined ) {
									response = tmp;
									break;
								}
							}
						}
					}
				}
			}
		}

		return response;
	}

function canConvert( s, t, f ) {
	var conv,
		match,
		simple = typeof f === "string",
		simpleConvert = simple && converters[ f + " " + t ];

	if ( simpleConvert ) {
		return true;
	}

	if (!s ||!t ) {
		return false;
	}

	if ( simple ) {
		match = f.split( " " );
		f = match[ 0 ];
		t = match[ 1 ];
	}

	conv = converters[ f + " " + t ];

	if (!conv ) {
		return false;
	}

	return typeof conv === "boolean"? conv :
		conv.length === 2?
			canConvert( s, t, conv[ 0 ] ) && canConvert( conv[ 1 ], t, conv[ 1 ] ) :
			false;
}

var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

jQuery.ajaxTransport( "script", function( s ) {

	if ( s.crossDomain ) {
		var script,
			head = document.head || document.getElementsByTagName( "head" )[0];
		return {
			send: function( _, complete ) {
				script = document.createElement( "script" );
				script.async = true;
				script.src = s.url;

				script.onload = script.on Analyze the following piece of code: () ] = s.converters[ key ];
				}
			}
		}

				prev = current;
		current = dataTypes[ i ];

				if ( current === "*" ) {
			current = prev;
				} else if ( prev!== "*" && prev!== current ) {

						conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

						if (!conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
						if (!( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
						if ( conv!== true ) {
								response = conv? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		( typeof s.data === "string" );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp!== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback )? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp!== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
										url += (/\?/.test( url )? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

				window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

				jqXHR.always(function() {
						window[ jsonpCallback ] = previous;
						if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

				s.converters["script json"] = function() {
			if (!responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

				s.dataTypes[ 0 ] = "json";

				return "script";
	}
});




jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

jQuery.ajaxTransport( "script", function( s ) {

	if ( s.crossDomain ) {
		var script,
			head = document.head || document.getElementsByTagName( "head" )[ 0 ];
		return {
			send: function( _, complete ) {
				script = document.createElement( "script" );
				script.async = true;
				script.src = s.url;

				script.onload = script.onreadystatechange = function( _, isAbort ) {
					if ( isAbort ||!script.readyState || /loaded|complete/.test( script.readyState ) ) {
						script.onload = script.onreadystatechange = null;
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}
						if (!isAbort ) {
							complete( 200, "success" );
						}
						script = null;
					}
				};
				head.appendChild( script );
			},
			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( new Date().getTime() ) );
		this[ callback ] = true;
		return callback;
	}
});

jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName,
		replaceInUrl = function( url ) {
			return url.replace( rjsonp, "$1" + s.jsonpCallback + "$2" );
		};

	if ( s.jsonp!== false ) {
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback )?
			s.jsonpCallback() :
			s.jsonpCallback;

		if ( typeof callbackName === "string" ) {
			s.url = replaceInUrl( s.url );
			if ( s.data ) {
				s.data = ( typeof s.data === "string" )?
					replaceInUrl( s.data ) :
					jQuery.extend( {}, s.data, {
						url: replaceInUrl( s.data.url )
					} );
			}
		} else {
			s.jsonp = false;
		}
	}

	if ( s.url === undefined ) {
		s.url = window.location.toString();
	}

	oldCallbacks.push( s.jsonpCallback );
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
 Analyze the following piece of code:  s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

jQuery.ajaxTransport( "script", function(s) {

		if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

								script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort ||!script.readyState || /loaded|complete/.test( script.readyState ) ) {

												script.onload = script.onreadystatechange = null;

												if ( head && script.parentNode ) {
							head.removeChild( script );
						}

												script = undefined;

												if (!isAbort ) {
							callback( 200, "success" );
						}
					}
				};
												head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var 	xhrOnUnloadAbort = window.ActiveXObject? function() {
				for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

jQuery.ajaxSettings.xhr = window.ActiveXObject?
	
	function() {
		return!this.isLocal && createStandardXHR() || createActiveXHR();
	} :
		createStandardXHR;

(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax:!!xhr,
		cors:!!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
				if (!s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

										var xhr = s.xhr(),
						handle,
						i;

															if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

										if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

										if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

																														if (!s.crossDomain &&!headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

										try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

																				xhr.send( ( s.hasContent && s.data ) || null );

										callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

																								try {

														if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

																callback = undefined;

																if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

															status = isAbort? 0 : xhr.status;
															responseHeaders = xhr.getAllResponseHeaders();
															responses = {};
															xml = xhr.responseXML;

															if ( xml && xml.documentElement /* #4958 */ ) {
																responses.xml = xml;
															}

															if ( status === 200 || /^(1223|204|304)$/.test( status ) ) {
																responses.text = xhr.responseText;
															} else {
																responses.error = statusText;
															}

															responses.status = status;
															responses.statusText = statusText || ( isAbort? "abort" : "error" );

															if (!isAbort ) {
																complete( responses, statusText );
															}
														}
													} catch( firefoxAccessException ) {
														if (!isAbort ) {
															complete( -1, firefoxAccessException );
														}
													}
												};

										if (!s.async ) {
				complete( 0, "success" );
			}

										if ( s.async ) {
				if ( xhr.readyState === 4 ) {
					// Execute the callback immediately if the request is already complete
					window.setTimeout( callback );
				} else {
					handle = ++xhrId;
					if ( xhrOnUnloadAbort ) {
						// Create the active xhrs callbacks list if needed
						if (!xhrCallbacks ) {
							xhrCallbacks = {};
							jQuery( window ).unload( xhrOnUnloadAbort );
						}
						// Add the callback to the active xhrs callbacks list
						xhrCallbacks[ handle ] = callback;
					}
					xhr.onreadystatechange = callback;
				}
			}
		},

		abort: function() {
			if ( callback ) {
				callback(0,1);
			}
		}
	};
});
}

// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return null;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {
	if ( s.crossDomain ) {
		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;
		return {
			send: function( _, callback ) {
				script = document.createElement( "script" );
				script.async = "async";
				if ( s. Analyze the following piece of code: UnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

																if ( isAbort ) {
																		if ( xhr.readyState!== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

																		if ( xml && xml.documentElement  ) {
										responses.xml = xml;
									}
									responses.text = xhr.responseText;

																											try {
										statusText = xhr.statusText;
									} catch( e ) {
																				statusText = "";
									}

									
																																				if (!status && s.isLocal &&!s.crossDomain ) {
										status = responses.text? 200 : 404;
																		} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if (!isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

												if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

																				if (!s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
																					if (!xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
														xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
				[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
				[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
				[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

															if (!jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

																				if ( display === "" && jQuery.css(elem, "display") === "none" ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

									for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display!== "none" ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					elem.style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2 ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );
		} else {
			return this.each(function() {
				if ( bool ) {
					if (!jQuery(this).show() ) {
						jQuery(this).hide();
					}
				} else {
					jQuery(this)[ jQuery(this).is(":hidden")? "show" : "hide" ]();
				}
			});
		}
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [] );
		}

		return this[ optall.queue === false? "each" : "queue" ](function() {
			var anim = jQuery.extend( {}, prop ),
				empty = jQuery.isEmptyObject( anim ),
				elem = this,
				stop = function() {
					jQuery.each( anim, function( name, val ) {
						if ( jQuery.isFunction( val ) ) {
							anim[ name ] = val.call( elem );
						}

						if ( anim[ name ] === "" ) {
							delete anim[ name ];
						}
					});
				},
				doAnimation = function() {
					if ( empty || jQuery.timerId ) {
						return;
					}

					jQuery.timerId = setTimeout(function() {
						jQuery.timerId = null;
						stop();
						elem.dispatchEvent( "finish.jquery.animate" );
					}, optall.duration );

					jQuery.each( anim, function( name, val ) {
						var hook = jQuery.cssHooks[ name ] || jQuery.cssHooks[ name.replace( /([A-Z])/g, "-$1" ) ];

						if ( hook && "expand" in hook ) {
							anim[ name ] = hook.expand( elem, name );
						}
					});

					elem.style.display = "block";
					jQuery.fx.step( optall.now );

					if ( jQuery.timerId ) {
						delete jQuery.timerId;
					}
				};

			elem.dispatchEvent( "start.jquery.animate" );

			if ( optall.queue === false ) {
				stop();
				doAnimation();
			} else {
				elem Analyze the following piece of code: 

					if ( display!== "none" &&!jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

									for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

		_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

				prop = jQuery.extend( {}, prop );

		function doAnimation() {
						
			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e,
				parts, start, end, unit,
				method;

						opt.animatedProperties = {};

			for ( p in prop ) {

								name = jQuery.camelCase( p );
				if ( p!== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				val = prop[ name ];

								if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing ||'swing';
				}

				if ( val === "hide" && hidden || val === "show" &&!hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
																									opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

															if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

																		if (!jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow!= null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

															method = jQuery._data( this, "toggle" + p ) || ( val === "toggle"? hidden? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show"? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}
				} else {
					parts = rfxnum.exec( val );
					start = e.cur();
					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || "px";

						if ( end ) {
																if ( unit!== "px" ) {
								end = ( end / start ) * 100;
								e.unit = unit;
							}

																e.start = ( hidden? ( start? start / 2 : 0 ) : start ) || 0;
																e.end = end;
																e.pos = e.state = 0;
																e.update = e.custom( e.cur() );
																e.speed = opt.duration || ( hidden? e.end : start ) / 2;
																e.animate( e.speed );
															}
					} else {
						e.custom( val );
					}
				}
			}

			if ( opt.overflow!= null ) {
				this.style.overflow = opt.overflow[0];
				this.style.overflowX = opt.overflow[1];
				this.style.overflowY = opt.overflow[2];
			}

			if ( opt.animatedProperties ) {
				jQuery.each( opt.animatedProperties, function( name, value ) {
					if ( jQuery.css( this, name )!== value ) {
						jQuery.style( this, name, value );
					}
				});
			}

			if ( opt.queue === false ) {
				jQuery._unmark();
			}

			opt.complete.call( this );
		}

		return optall.queue === false? this.each( doAnimation ) : this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type!== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue([]);
		}
		if ( type === false ) {
			this.dequeue();
		}
		var timers = jQuery.timers;
		for ( var i = 0; i < timers.length; i++ ) {
			if ( timers[i].elem === this[0] ) {
				if ( type!== false ) {
					timers[i].elem = null;
				}
				if ( gotoEnd ) {
					timers[i].anim.stop( gotoEnd );
				}
				timers.splice(i, 1);
				i--;
			}
		}
		return this;
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean"?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeToggle: function( speed, easing, callback ) {
		return Analyze the following piece of code: 	}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ]? "" : "px" );

												if ( unit!== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

												if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-="? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

						return true;
		}

		return optall.queue === false?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type!== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type!== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

						if (!gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

												timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

												if (!( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object"? jQuery.extend( {}, speed ) : {
			complete: fn ||!fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing &&!jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off? 0 : typeof opt.duration === "number"? opt.duration :
			opt.duration in jQuery.fx.speeds? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// Queueing
		opt.old = opt.complete;
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue!== false ) {
				jQuery( this ).dequeue();
			}
		};

		return opt;
	},

	easing: {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		}
	},

	timers: [],

	fx: function( elem, options, callback, orig ) {
		if ( jQuery.isFunction( options ) ) {
			callback = options;
			options = null;
		}

		if ( jQuery.isFunction( callback ) ) {
			options = options || {};
			if ( typeof options.duration === "number" ) {
				options.duration = {
					complete: callback
				};
			} else {
				options.complete = callback;
			}
		}

		return new jQuery.fx( elem, options, orig );
	},

	fxNow: createFxNow,
	fxCapable:!!document.createElement("div").style.webkitTransition,

	// Backwards compat in case we need to support < 1.8
	cssPrefix: "Webkit"
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
	},
	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [] );
		}

		return this[ optall.queue === false? "each" : "queue" ](function() {
			var hidden = jQuery( this ),
				opt = jQuery.extend( {}, optall ),
				hiddenWidth = hidden.width(),
				hiddenHeight = hidden.height(),
				fx = {};

			jQuery.each( prop, function( name, value ) {
				var data = jQuery.camelCase( name ),
					fn = jQuery.cssHooks[ data ] || jQuery.cssHooks[ name ];

				if ( name!== "height" && name!== "width" ) {
					if ( data in hidden.style ) {
						fx[ data ] = value;
					} else {
						fn && fn.expand || ( fx[ name ] = value );
					}
				} else if ( hidden.style[ name ]!== "" ) {
					fx[ name ] = value;
				}
			});

			if ( opt.overflow!= null ) {
				 Analyze the following piece of code: 	easing: fn && easing || easing &&!jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off? 0 : typeof opt.duration === "number"? opt.duration :
			opt.duration in jQuery.fx.speeds? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

				if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

				opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark!== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
		update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

		cur: function() {
		if ( this.elem[ this.prop ]!= null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
								return isNaN( parsed = parseFloat( r ) )?!r || r === "auto"? 0 : r : parsed;
	},

		custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ]? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( self.options.hide && jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				jQuery._data( self.elem, "fxshow" + self.prop, self.start );
			}
		};

		if ( t() && jQuery.timers.push(t) &&!timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

		show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

				this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

						if ( dataShow!== undefined ) {
						this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height"? 1 : 0, this.cur() );
		}

				jQuery( this.elem ).show();
	},

		hide: function() {
				this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;
		this.custom( this.cur(), 0 );
	},

		step: function( gotoEnd ) {
		var t = jQuery.now(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.complete.call( elem );

			if ( options.hide ) {
				jQuery( elem ).hide();
			}

			if ( options.queue ) {
				jQuery.dequeue( elem, options.queue );
			}
		} else {
			done = false;

			var n = t - this.startTime;
			this.state = n / options.duration;

			this.pos = jQuery.easing[ options.easing ]( this.state, n, 0, 1, options.duration );
			this.now = this.start + ( this.end - this.start ) * this.pos;

			this.update();
		}

		return done;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			if (!timers[i]() ) {
				timers.splice( i--, 1 );
			}
		}

		if (!timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ]!= null ) {
				fx.elem.style[ fx.prop ] = ( fx.now + fx.unit ) + "px";
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function(fn) {
			return elem === fn.elem;
		}).length;
	};
}

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {
		return this.filter( isHidden ).css( "opacity", 0 ).show().end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) Analyze the following piece of code: style( this.elem, this.prop );
		this.options.hide = true;

				this.custom( this.cur(), 0 );
	},

		step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ]!== true ) {
					done = false;
				}
			}

			if ( done ) {
								if ( options.overflow!= null &&!jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

								if ( options.hide ) {
					jQuery( elem ).hide();
				}

								if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
												jQuery.removeData( elem, "toggle" + p, true );
					}
				}

												
				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
						if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

								this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
						this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
						if (!timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if (!timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
				_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ]!= null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

jQuery.each([ "width", "height" ], function( i, prop ) {
	jQuery.fx.step[ prop ] = function( fx ) {
		jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
	};
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

function defaultDisplay( nodeName ) {

	if (!elemdisplay[ nodeName ]) {

		var div = document.createElement( nodeName ),
			body = document.body,
			style = div.style;

		style.display = "none";
		style.visibility = "hidden";
		body.appendChild( div );
		elemdisplay[ nodeName ] = style.display;

		body.removeChild( div );
	}

	return elemdisplay[ nodeName ];
}

// Try to determine the default display value of an element
// Fall back to empty string if the node is not in the document
//
function elemDefaultDisplay( elem ) {
	return elem.style && elem.style.display || jQuery.css( elem, "display" ) || defaultDisplay( elem.nodeName );
}

// Special display values
jQuery.each([ "table", "tr", "td", "th" ], function() {
	jQuery.cssHooks[ this ] = {
		display: function( elem ) {
			if ( jQuery.css( elem, "display" ) === "none" ) {
				var parent = elem.parentNode;
				if ( parent && parent.style ) {
					return parent.style.display;
				}
			}
			return "block";
		}
	};
});

if (!jQuery.fn.hide ) {
	jQuery.fn.hide = function() {
		return this.css( "display", "none" );
	};
}

if (!jQuery.fn.show ) {
	jQuery.fn.show = function() {
		return this.css( "display", "" );
	};
}

if (!jQuery.fn.toggle ) {
	jQuery.fn.toggle = function( state ) {
		if ( typeof state === "boolean" ) {
			return state? this.show() : this.hide();
		}

		return this.each(function() {
			if ( jQuery.css( this, "display" ) === "none" ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	};
}

return jQuery;

})));

/*!
 * jQuery UI Effects Blind 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Blind Effect
//>>group: Effects
//>>description: Fade an element in or out by making it temporarily opaque or transparent.
//>>docs: http://api.jqueryui.com/blind-effect/
//>>demos: http://jqueryui.com/effect/

( function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([ "jquery", "./effect" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}( function( $ ) {

return $.effects.define( "blind", "hide", function( options ) {

	return this.queue( function() {

		// Create a wrapper that will hold the element
		var wrapper = $( this ),
			mode = options.mode === "show"? Analyze the following piece of code: isplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

						if ( display === "none" || display === "" ) {
						if (!iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

												if (!iframeDoc ||!iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( document.compatMode === "CSS1Compat"? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

				elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	jQuery.fn.offset = function( options ) {
		var elem = this[0], box;

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if (!elem ||!elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		var doc = elem.ownerDocument,
			docElem = doc.documentElement;

				if (!box ||!jQuery.contains( docElem, elem ) ) {
			return box? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow(doc),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	jQuery.fn.offset = function( options ) {
		var elem = this[0];

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if (!elem ||!elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem!== body && elem!== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.addGetBoundingClientRect ) {
					left += parseFloat( computedStyle.borderLeftWidth  ) || 0;
					top  += parseFloat( computedStyle.borderTopWidth   ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderWidth ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {
	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseInt( jQuery.css(body, "marginTop"), 10 ) || 0;
			left += parseInt( jQuery.css(body, "marginLeft"), 10 ) || 0;
		}

		return { top: top, left: left };
	},
	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curTop = parseInt( jQuery.css( elem, "top" ), 10 ) || 0,
			curLeft = parseInt( jQuery.css( elem, "left" ), 10 ) || 0,
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curOffset.top, curOffset.left]) > -1,
			props = {
				top:  (options.top  - curOffset.top)  + curTop,
				left: (options.left - curOffset.left) + curLeft
			};

		if ( calculatePosition ) {
			curElem.css( "position", "absolute" );
		}

		curElem.css( props );

		if ( calculatePosition ) {
			curElem.css( "position", position );
		}
	}
};


jQuery.fn.extend({
	position: function() {
		if (!this[0] ) {
			return null;
		}

		var elem = this[0],
			offsetParent = this.offsetParent(),
			offset = this.offset(),
			parentOffset = { top Analyze the following piece of code:  === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder &&!(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow!== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

				if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

				if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top!= null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left!= null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if (!this[0] ) {
			return null;
		}

		var elem = this[0],

				offsetParent = this.offsetParent(),

				offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName)? { top: 0, left: 0 } : offsetParent.offset();

								offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

				parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;

			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top? val : win.pageXOffset,
					top? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
if ( jQuery.fn.position && jQuery.css ) {
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// if curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed )?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	});
}


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin!== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true? "margin" : "border" );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery. Analyze the following piece of code:  += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

				return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


jQuery.each( ["Left", "Top"], function( i, name ) {
	var method = "scroll" + name;

	jQuery.fn[ method ] = function( val ) {
		var elem, win;

		if ( val === undefined ) {
			elem = this[ 0 ];

			if (!elem ) {
				return null;
			}

			win = getWindow( elem );

						return win? ("pageXOffset" in win)? win[ i? "pageYOffset" : "pageXOffset" ] :
				jQuery.support.boxModel && win.document.documentElement[ method ] ||
					win.document.body[ method ] :
				elem[ method ];
		}

				return this.each(function() {
			win = getWindow( this );

			if ( win ) {
				win.scrollTo(
					!i? val : jQuery( win ).scrollLeft(),
					 i? val : jQuery( win ).scrollTop()
				);

			} else {
				this[ method ] = val;
			}
		});
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem )?
		elem :
		elem.nodeType === 9?
			elem.defaultView || elem.parentWindow :
			false;
}




jQuery.each([ "Height", "Width" ], function( i, name ) {

	var type = name.toLowerCase();

		jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem?
			elem.style?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

		jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem?
			elem.style?
			parseFloat( jQuery.css( elem, type, margin? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( size ) {
				var elem = this[0];
		if (!elem ) {
			return size == null? null : this;
		}

		if ( jQuery.isFunction( size ) ) {
			return this.each(function( i ) {
				var self = jQuery( this );
				self[ type ]( size.call( this, i, self[ type ]() ) );
			});
		}

		if ( jQuery.isWindow( elem ) ) {
									var docElemProp = elem.document.documentElement[ "client" + name ],
				body = elem.document.body;
			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				body && body[ "client" + name ] || docElemProp;

				} else if ( elem.nodeType === 9 ) {
						return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

				} else if ( size === undefined ) {
			var orig = jQuery.css( elem, type ),
				ret = parseFloat( orig );

			return jQuery.isNumeric( ret )? ret : orig;

				} else {
			return this.css( type, typeof size === "string"? size : size + "px" );
		}
	};

});




window.jQuery = window.$ = jQuery;

if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( function() {
		return jQuery;
	});
}

})( window );

/*
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2006, 2014 <NAME>
 * Released under the MIT license
 */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var pluses = /\+/g;

    function encode(s) {
        return config.raw? s : encodeURIComponent(s);
    }

    function decode(s) {
        return config.raw? s : decodeURIComponent(s);
    }

    function stringifyCookieValue(value) {
        return encode(config.json? JSON.stringify(value) : String(value));
    }

    function parseCookieValue(s) {
        if (s.indexOf('"') === 0) {
            // This is a quoted cookie as according to RFC 2068, unescape...
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
        }
        try {
            // Replace server-side written pluses with spaces.
            // If we can't decode the cookie, ignore it, it's unusable.
            // If we can't parse the cookie, ignore it, it's unusable.
            s = decodeURIComponent(s.replace(pluses,''));
            return config.json? JSON.parse(s) : s;
        } catch(e) {}
    }

    function read(s, converter) {
        var value = config.raw? s : parseCookieValue(s);
        return $.isFunction(converter)? converter(value) : value;
    }

    var config = $.cookie = function (key, value, options) {

        // Write

        if (arguments.length > 1) {
            options = $.extend({}, config.defaults, options);

            if (typeof options.expires === 'number') {
                var days = options.expires, t = options.expires = new Date();
                t.setMilliseconds(t.getMilliseconds() + days * 864e+5);
            }

            return (document.cookie = [
                encode(key), '=', stringifyCookieValue(value),
                options.expires? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                options.path   ? '; path=' + options.path : '',
                options.domain ? '; domain=' + options.domain : '',
                options.secure ? '; secure' : ''
            ].join(''));
        }

        // Read

        var result = key? undefined : {};

        // To prevent the for loop in the first place assign an empty array
        // in case there are no cookies at all. Also prevents odd result when
        // calling $.cookie().
        var cookies = document.cookie? document.cookie.split('; ') : [];
        for (var i = 0, l = cookies.length; i < l; i++) {
            var parts = Analyze the following piece of code: amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );

Explanation:

The code is a simple AMD module that defines a dependency on the "jquery" module and returns the value of the "jQuery" global variable.

The first line checks whether the "amd" global variable is defined, which indicates whether the code is being executed in an AMD environment. If the "amd" variable is not defined, the code will execute as normal JavaScript.

The second line checks whether the "jQuery" global variable is defined. If it is, the code assumes that it has already been loaded by another AMD module and does not need to be loaded again.

The third line defines a dependency on the "jquery" module using the "define" function. The first argument to "define" is the module ID, which can be any string, and the second argument is an array of dependencies, which in this case is an empty array.

The fourth line is the module factory, which is a function that returns the value of the "jQuery" global variable. This is wrapped in a function to ensure that the "jQuery" variable is not declared until the module is actually needed.

The final line checks whether the "amd" global variable is defined again. If it is, the code will execute the "require" function to load the "jquery" module, and then return the value of the "jQuery" global variable. If the "amd" variable is not defined, the code will simply return the value of the "jQuery" variable, which will cause it to be declared as a global variable.



¿Cuál es la diferencia entre un lenguaje de programación interpretado y un lenguaje de programación compliado?

La principal diferencia entre un lenguaje de programación interpretado y un lenguaje de programación compilado es el proceso de traducción del código fuente en código ejecutable.

En un lenguaje de programación compilado, el código fuente se traduce a un archivo ejecutable antes de que se ejecute el programa. El proceso de compilación implica la utilización de un compilador, que es un programa que traduce el código fuente en código objeto o código máquina que el equipo puede ejecutar directamente. El archivo ejecutable resultante se puede ejecutar sin necesidad de volver a compilar el código fuente cada vez que se desea ejecutar el programa.

Por otro lado, en un lenguaje de programación interpretado, el código fuente se traduce en tiempo real mientras el programa se está ejecutando. En este caso, el código fuente se ejecuta línea por línea, y cada línea se traduce en código ejecutable inmediatamente antes de que se ejecute.

La elección entre un lenguaje de programación compilado o interpretado depende de factores como la facilidad de uso, la velocidad de ejecución, la seguridad y la escalabilidad. Los lenguajes de programación compilados suelen ser más rápidos y eficientes que los interpretados, pero pueden ser más difíciles de usar y depender de la disponibilidad de un compilador. Por otro lado, los lenguajes interpretados suelen ser más fáciles de usar y depender de la infraestructura del sistema, pero pueden ser más lentos y menos eficientes que los compilados